var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
function makeMap(str, expectsLowerCase) {
  const map = Object.create(null);
  const list2 = str.split(",");
  for (let i = 0; i < list2.length; i++) {
    map[list2[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `HYDRATE_EVENTS`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const range$1 = 2;
function generateCodeFrame(source2, start2 = 0, end2 = source2.length) {
  let lines = source2.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
  lines = lines.filter((_2, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start2) {
      for (let j = i - range$1; j <= i + range$1 || end2 > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start2 - (count - (lineLength + newLineSeqLength));
          const length = Math.max(1, end2 > count ? lineLength - pad : end2 - start2);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end2 > count) {
            const length = Math.max(Math.min(end2 - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
function normalizeStyle(value) {
  if (isArray$b(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item2 = value[i];
      const normalized = isString$3(item2) ? parseStringStyle(item2) : normalizeStyle(item2);
      if (normalized) {
        for (const key2 in normalized) {
          res[key2] = normalized[key2];
        }
      }
    }
    return res;
  } else if (isString$3(value)) {
    return value;
  } else if (isObject$d(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item2) => {
    if (item2) {
      const tmp = item2.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString$3(styles)) {
    return ret;
  }
  for (const key2 in styles) {
    const value = styles[key2];
    const normalizedKey = key2.startsWith(`--`) ? key2 : hyphenate(key2);
    if (isString$3(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$3(value)) {
    res = value;
  } else if (isArray$b(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$d(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props2) {
  if (!props2)
    return null;
  let { class: klass, style } = props2;
  if (klass && !isString$3(klass)) {
    props2.class = normalizeClass(klass);
  }
  if (style) {
    props2.style = normalizeStyle(style);
  }
  return props2;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const escapeRE = /["'&<>]/;
function escapeHtml$1(string3) {
  const str = "" + string3;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index2;
  let lastIndex = 0;
  for (index2 = match.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str.slice(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escaped;
  }
  return lastIndex !== index2 ? html + str.slice(lastIndex, index2) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src2) {
  return src2.replace(commentStripRE, "");
}
function looseCompareArrays(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a2.length; i++) {
    equal = looseEqual(a2[i], b2[i]);
  }
  return equal;
}
function looseEqual(a2, b2) {
  if (a2 === b2)
    return true;
  let aValidType = isDate$2(a2);
  let bValidType = isDate$2(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
  }
  aValidType = isArray$b(a2);
  bValidType = isArray$b(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
  }
  aValidType = isObject$d(a2);
  bValidType = isObject$d(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key2 in a2) {
      const aHasKey = a2.hasOwnProperty(key2);
      const bHasKey = b2.hasOwnProperty(key2);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key2], b2[key2])) {
        return false;
      }
    }
  }
  return String(a2) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item2) => looseEqual(item2, val));
}
const toDisplayString$1 = (val) => {
  return val == null ? "" : isArray$b(val) || isObject$d(val) && (val.toString === objectToString$3 || !isFunction$6(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap$2(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key2, val2]) => {
        entries[`${key2} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet$2(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$d(val) && !isArray$b(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP$1 = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key2) => onRE.test(key2);
const isModelListener = (key2) => key2.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove$1 = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$d = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key2) => hasOwnProperty$d.call(val, key2);
const isArray$b = Array.isArray;
const isMap$2 = (val) => toTypeString$1(val) === "[object Map]";
const isSet$2 = (val) => toTypeString$1(val) === "[object Set]";
const isDate$2 = (val) => val instanceof Date;
const isFunction$6 = (val) => typeof val === "function";
const isString$3 = (val) => typeof val === "string";
const isSymbol$5 = (val) => typeof val === "symbol";
const isObject$d = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$d(val) && isFunction$6(val.then) && isFunction$6(val.catch);
};
const objectToString$3 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$3.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key2) => isString$3(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const cacheStringFunction = (fn3) => {
  const cache2 = Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn3(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key2, value) => {
  Object.defineProperty(obj, key2, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber$2 = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
var shared_esmBundler = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  EMPTY_ARR,
  EMPTY_OBJ,
  NO,
  NOOP: NOOP$1,
  PatchFlagNames,
  camelize,
  capitalize,
  def,
  escapeHtml: escapeHtml$1,
  escapeHtmlComment,
  extend: extend$1,
  generateCodeFrame,
  getGlobalThis: getGlobalThis$1,
  hasChanged,
  hasOwn: hasOwn$1,
  hyphenate,
  includeBooleanAttr,
  invokeArrayFns,
  isArray: isArray$b,
  isBooleanAttr,
  isDate: isDate$2,
  isFunction: isFunction$6,
  isGloballyWhitelisted,
  isHTMLTag,
  isIntegerKey,
  isKnownHtmlAttr,
  isKnownSvgAttr,
  isMap: isMap$2,
  isModelListener,
  isNoUnitNumericStyleProp,
  isObject: isObject$d,
  isOn,
  isPlainObject: isPlainObject$2,
  isPromise: isPromise$1,
  isReservedProp,
  isSSRSafeAttrName,
  isSVGTag,
  isSet: isSet$2,
  isSpecialBooleanAttr,
  isString: isString$3,
  isSymbol: isSymbol$5,
  isVoidTag,
  looseEqual,
  looseIndexOf,
  makeMap,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  objectToString: objectToString$3,
  parseStringStyle,
  propsToAttrMap,
  remove: remove$1,
  slotFlagsText,
  stringifyStyle,
  toDisplayString: toDisplayString$1,
  toHandlerKey,
  toNumber: toNumber$2,
  toRawType,
  toTypeString: toTypeString$1
});
let activeEffectScope;
const effectScopeStack = [];
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn3) {
    if (this.active) {
      try {
        this.on();
        return fn3();
      } finally {
        this.off();
      }
    }
  }
  on() {
    if (this.active) {
      effectScopeStack.push(this);
      activeEffectScope = this;
    }
  }
  off() {
    if (this.active) {
      effectScopeStack.pop();
      activeEffectScope = effectScopeStack[effectScopeStack.length - 1];
    }
  }
  stop(fromParent) {
    if (this.active) {
      this.effects.forEach((e) => e.stop());
      this.cleanups.forEach((cleanup) => cleanup());
      if (this.scopes) {
        this.scopes.forEach((e) => e.stop(true));
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope) {
  scope = scope || activeEffectScope;
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn3) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn3);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
const effectStack = [];
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn3, scheduler = null, scope) {
    this.fn = fn3;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    if (!effectStack.includes(this)) {
      try {
        effectStack.push(activeEffect = this);
        enableTracking();
        trackOpBit = 1 << ++effectTrackDepth;
        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this);
        } else {
          cleanupEffect(this);
        }
        return this.fn();
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this);
        }
        trackOpBit = 1 << --effectTrackDepth;
        resetTracking();
        effectStack.pop();
        const n = effectStack.length;
        activeEffect = n > 0 ? effectStack[n - 1] : void 0;
      }
    }
  }
  stop() {
    if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect$6(fn3, options) {
  if (fn3.effect) {
    fn3 = fn3.effect.fn;
  }
  const _effect = new ReactiveEffect(fn3);
  if (options) {
    extend$1(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop$2(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target2, type4, key2) {
  if (!isTracking()) {
    return;
  }
  let depsMap = targetMap.get(target2);
  if (!depsMap) {
    targetMap.set(target2, depsMap = new Map());
  }
  let dep = depsMap.get(key2);
  if (!dep) {
    depsMap.set(key2, dep = createDep());
  }
  trackEffects(dep);
}
function isTracking() {
  return shouldTrack && activeEffect !== void 0;
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger$4(target2, type4, key2, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target2);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type4 === "clear") {
    deps = [...depsMap.values()];
  } else if (key2 === "length" && isArray$b(target2)) {
    depsMap.forEach((dep, key3) => {
      if (key3 === "length" || key3 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key2 !== void 0) {
      deps.push(depsMap.get(key2));
    }
    switch (type4) {
      case "add":
        if (!isArray$b(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$2(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key2)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$b(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$2(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$2(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect2 of isArray$b(dep) ? dep : [...dep]) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
      if (effect2.scheduler) {
        effect2.scheduler();
      } else {
        effect2.run();
      }
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key2) => Symbol[key2]).filter(isSymbol$5));
const get$3 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l2 = this.length; i < l2; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key2](...args);
      if (res === -1 || res === false) {
        return arr[key2](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key2].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get3(target2, key2, receiver) {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target2)) {
      return target2;
    }
    const targetIsArray = isArray$b(target2);
    if (!isReadonly2 && targetIsArray && hasOwn$1(arrayInstrumentations, key2)) {
      return Reflect.get(arrayInstrumentations, key2, receiver);
    }
    const res = Reflect.get(target2, key2, receiver);
    if (isSymbol$5(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
      return res;
    }
    if (!isReadonly2) {
      track(target2, "get", key2);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key2);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject$d(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target2, key2, value, receiver) {
    let oldValue = target2[key2];
    if (!shallow && !isReadonly(value)) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);
      if (!isArray$b(target2) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$b(target2) && isIntegerKey(key2) ? Number(key2) < target2.length : hasOwn$1(target2, key2);
    const result3 = Reflect.set(target2, key2, value, receiver);
    if (target2 === toRaw(receiver)) {
      if (!hadKey) {
        trigger$4(target2, "add", key2, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$4(target2, "set", key2, value);
      }
    }
    return result3;
  };
}
function deleteProperty(target2, key2) {
  const hadKey = hasOwn$1(target2, key2);
  target2[key2];
  const result3 = Reflect.deleteProperty(target2, key2);
  if (result3 && hadKey) {
    trigger$4(target2, "delete", key2, void 0);
  }
  return result3;
}
function has(target2, key2) {
  const result3 = Reflect.has(target2, key2);
  if (!isSymbol$5(key2) || !builtInSymbols.has(key2)) {
    track(target2, "has", key2);
  }
  return result3;
}
function ownKeys(target2) {
  track(target2, "iterate", isArray$b(target2) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target2);
}
const mutableHandlers = {
  get: get$3,
  set: set$1,
  deleteProperty,
  has,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target2, key2) {
    return true;
  },
  deleteProperty(target2, key2) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$1({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend$1({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1$1(target2, key2, isReadonly2 = false, isShallow = false) {
  target2 = target2["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key2);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
  if (has2.call(rawTarget, key2)) {
    return wrap(target2.get(key2));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target2.get(rawKey));
  } else if (target2 !== rawTarget) {
    target2.get(key2);
  }
}
function has$1(key2, isReadonly2 = false) {
  const target2 = this["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key2);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key2 === rawKey ? target2.has(key2) : target2.has(key2) || target2.has(rawKey);
}
function size(target2, isReadonly2 = false) {
  target2 = target2["__v_raw"];
  !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
  return Reflect.get(target2, "size", target2);
}
function add(value) {
  value = toRaw(value);
  const target2 = toRaw(this);
  const proto = getProto(target2);
  const hadKey = proto.has.call(target2, value);
  if (!hadKey) {
    target2.add(value);
    trigger$4(target2, "add", value, value);
  }
  return this;
}
function set$1$1(key2, value) {
  value = toRaw(value);
  const target2 = toRaw(this);
  const { has: has2, get: get3 } = getProto(target2);
  let hadKey = has2.call(target2, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target2, key2);
  }
  const oldValue = get3.call(target2, key2);
  target2.set(key2, value);
  if (!hadKey) {
    trigger$4(target2, "add", key2, value);
  } else if (hasChanged(value, oldValue)) {
    trigger$4(target2, "set", key2, value);
  }
  return this;
}
function deleteEntry(key2) {
  const target2 = toRaw(this);
  const { has: has2, get: get3 } = getProto(target2);
  let hadKey = has2.call(target2, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target2, key2);
  }
  get3 ? get3.call(target2, key2) : void 0;
  const result3 = target2.delete(key2);
  if (hadKey) {
    trigger$4(target2, "delete", key2, void 0);
  }
  return result3;
}
function clear() {
  const target2 = toRaw(this);
  const hadItems = target2.size !== 0;
  const result3 = target2.clear();
  if (hadItems) {
    trigger$4(target2, "clear", void 0, void 0);
  }
  return result3;
}
function createForEach(isReadonly2, isShallow) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target2 = observed["__v_raw"];
    const rawTarget = toRaw(target2);
    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target2.forEach((value, key2) => {
      return callback.call(thisArg, wrap(value), wrap(key2), observed);
    });
  };
}
function createIterableMethod(method4, isReadonly2, isShallow) {
  return function(...args) {
    const target2 = this["__v_raw"];
    const rawTarget = toRaw(target2);
    const targetIsMap = isMap$2(rawTarget);
    const isPair = method4 === "entries" || method4 === Symbol.iterator && targetIsMap;
    const isKeyOnly = method4 === "keys" && targetIsMap;
    const innerIterator = target2[method4](...args);
    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type4) {
  return function(...args) {
    return type4 === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key2) {
      return get$1$1(this, key2);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key2) {
      return get$1$1(this, key2, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key2) {
      return get$1$1(this, key2, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key2) {
      return get$1$1(this, key2, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method4) => {
    mutableInstrumentations2[method4] = createIterableMethod(method4, false, false);
    readonlyInstrumentations2[method4] = createIterableMethod(method4, true, false);
    shallowInstrumentations2[method4] = createIterableMethod(method4, false, true);
    shallowReadonlyInstrumentations2[method4] = createIterableMethod(method4, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target2, key2, receiver) => {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw") {
      return target2;
    }
    return Reflect.get(hasOwn$1(instrumentations, key2) && key2 in target2 ? instrumentations : target2, key2, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target2) {
  if (target2 && target2["__v_isReadonly"]) {
    return target2;
  }
  return createReactiveObject(target2, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target2) {
  return createReactiveObject(target2, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target2) {
  return createReactiveObject(target2, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target2) {
  return createReactiveObject(target2, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$d(target2)) {
    return target2;
  }
  if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
    return target2;
  }
  const existingProxy = proxyMap.get(target2);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target2);
  if (targetType === 0) {
    return target2;
  }
  const proxy = new Proxy(target2, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target2, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive$1 = (value) => isObject$d(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$d(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (isTracking()) {
    ref2 = toRaw(ref2);
    if (!ref2.dep) {
      ref2.dep = createDep();
    }
    {
      trackEffects(ref2.dep);
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, _shallow) {
    this._shallow = _shallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = _shallow ? value : toRaw(value);
    this._value = _shallow ? value : toReactive$1(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this._shallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this._shallow ? newVal : toReactive$1(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target2, key2, receiver) => unref(Reflect.get(target2, key2, receiver)),
  set: (target2, key2, value, receiver) => {
    const oldValue = target2[key2];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target2, key2, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get3, set: set2 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get3;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs$1(object4) {
  const ret = isArray$b(object4) ? new Array(object4.length) : {};
  for (const key2 in object4) {
    ret[key2] = toRef(object4, key2);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object4, key2, defaultValue) {
  const val = object4[key2];
  return isRef(val) ? val : new ObjectRefImpl(object4, key2, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2) {
    this._setter = _setter;
    this.dep = void 0;
    this._dirty = true;
    this.__v_isRef = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed(getterOrOptions, debugOptions) {
  let getter;
  let setter;
  const onlyGetter = isFunction$6(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP$1;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);
  return cRef;
}
Promise.resolve();
let devtools$1;
let buffer = [];
function setDevtoolsHook(hook, target2) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target2.__VUE_DEVTOOLS_HOOK_REPLAY__ = target2.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target2);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target2.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
function emit$1(instance, event, ...rawArgs) {
  const props2 = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props2) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number4, trim: trim2 } = props2[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a2) => a2.trim());
    } else if (number4) {
      args = rawArgs.map(toNumber$2);
    }
  }
  let handlerName;
  let handler = props2[handlerName = toHandlerKey(event)] || props2[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props2[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props2[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$6(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache2.set(comp, null);
    return null;
  }
  if (isArray$b(raw)) {
    raw.forEach((key2) => normalized[key2] = null);
  } else {
    extend$1(normalized, raw);
  }
  cache2.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key2) {
  if (!options || !isOn(key2)) {
    return false;
  }
  key2 = key2.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$1(options, hyphenate(key2)) || hasOwn$1(options, key2);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev2 = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev2;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn3, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn3;
  if (fn3._n) {
    return fn3;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn3(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode: vnode2, proxy, withProxy, props: props2, propsOptions: [propsOptions], slots, attrs, emit, render: render2, renderCache, data: data2, setupState, ctx, inheritAttrs } = instance;
  let result3;
  let fallthroughAttrs;
  const prev2 = setCurrentRenderingInstance(instance);
  try {
    if (vnode2.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result3 = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props2, setupState, data2, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render3 = Component;
      if (false)
        ;
      result3 = normalizeVNode(render3.length > 1 ? render3(props2, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render3(props2, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result3 = createVNode(Comment);
  }
  let root2 = result3;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode2.dirs) {
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode2.dirs) : vnode2.dirs;
  }
  if (vnode2.transition) {
    root2.transition = vnode2.transition;
  }
  {
    result3 = root2;
  }
  setCurrentRenderingInstance(prev2);
  return result3;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key2 in attrs) {
    if (key2 === "class" || key2 === "style" || isOn(key2)) {
      (res || (res = {}))[key2] = attrs[key2];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props2) => {
  const res = {};
  for (const key2 in attrs) {
    if (!isModelListener(key2) || !(key2.slice(9) in props2)) {
      res[key2] = attrs[key2];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component: component2 } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component2.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key2 = dynamicProps[i];
        if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key2 = nextKeys[i];
    if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode: vnode2, parent }, el) {
  while (parent && parent.subTree === vnode2) {
    (vnode2 = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type4) => type4.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  __isSuspense: true,
  process(n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container2, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent$1(vnode2, name) {
  const eventListener = vnode2.props && vnode2.props[name];
  if (isFunction$6(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const { p: patch, o: { createElement } } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode2.suspense = createSuspenseBoundary(vnode2, parentSuspense, parentComponent, container2, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch(null, suspense.pendingBranch = vnode2.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent$1(vnode2, "onPending");
    triggerEvent$1(vnode2, "onFallback");
    patch(null, vnode2.ssFallback, container2, anchor, parentComponent, null, isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode2.ssFallback);
  } else {
    suspense.resolve();
  }
}
function patchSuspense(n1, n2, container2, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container2, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container2, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container2, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(activeBranch, newBranch, container2, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent$1(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode2, parent, parentComponent, container2, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const { p: patch, m: move, um: unmount, n: next2, o: { parentNode, remove: remove2 } } = rendererInternals;
  const timeout = toNumber$2(vnode2.props && vnode2.props.timeout);
  const suspense = {
    vnode: vnode2,
    parent,
    parentComponent,
    isSVG,
    container: container2,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false) {
      const { vnode: vnode3, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container3 } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container3, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next2(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container3, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent2 = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent2) {
        if (parent2.pendingBranch) {
          parent2.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent2 = parent2.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      triggerEvent$1(vnode3, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode3, activeBranch, parentComponent: parentComponent2, container: container3, isSVG: isSVG2 } = suspense;
      triggerEvent$1(vnode3, "onFallback");
      const anchor2 = next2(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(null, fallbackVNode, container3, anchor2, parentComponent2, null, isSVG2, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(activeBranch, parentComponent2, null, true);
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container3, anchor2, type4) {
      suspense.activeBranch && move(suspense.activeBranch, container3, anchor2, type4);
      suspense.container = container3;
    },
    next() {
      return suspense.activeBranch && next2(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode3 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode3.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode3, parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next2(instance.subTree), suspense, isSVG, optimized);
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode3.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node3, vnode2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode2.suspense = createSuspenseBoundary(vnode2, parentSuspense, parentComponent, node3.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
  const result3 = hydrateNode(node3, suspense.pendingBranch = vnode2.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve();
  }
  return result3;
}
function normalizeSuspenseChildren(vnode2) {
  const { shapeFlag, children } = vnode2;
  const isSlotChildren = shapeFlag & 32;
  vnode2.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode2.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s2) {
  let block;
  if (isFunction$6(s2)) {
    const trackBlock = isBlockTreeEnabled && s2._c;
    if (trackBlock) {
      s2._d = false;
      openBlock();
    }
    s2 = s2();
    if (trackBlock) {
      s2._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray$b(s2)) {
    const singleChild = filterSingleRoot(s2);
    s2 = singleChild;
  }
  s2 = normalizeVNode(s2);
  if (block && !s2.dynamicChildren) {
    s2.dynamicChildren = block.filter((c2) => c2 !== s2);
  }
  return s2;
}
function queueEffectWithSuspense(fn3, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$b(fn3)) {
      suspense.effects.push(...fn3);
    } else {
      suspense.effects.push(fn3);
    }
  } else {
    queuePostFlushCb(fn3);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode: vnode2, parentComponent } = suspense;
  const el = vnode2.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode2) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function provide(key2, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key2] = value;
  }
}
function inject(key2, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key2 in provides) {
      return provides[key2];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$6(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const rawProps = toRaw(props2);
      const { mode } = rawProps;
      const child = children[0];
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key2 = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key2;
        } else if (key2 !== prevTransitionKey) {
          prevTransitionKey = key2;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode2) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode2.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = Object.create(null);
    leavingVNodes.set(vnode2.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode2, props2, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props2;
  const key2 = String(vnode2.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode2);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key2];
      if (leavingVNode && isSameVNodeType(vnode2, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        hook(el, done);
        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key3 = String(vnode2.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key3] === vnode2) {
          delete leavingVNodesCache[key3];
        }
      };
      leavingVNodesCache[key3] = vnode2;
      if (onLeave) {
        onLeave(el, done);
        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    clone(vnode3) {
      return resolveTransitionHooks(vnode3, props2, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode2) {
  if (isKeepAlive(vnode2)) {
    vnode2 = cloneVNode(vnode2);
    vnode2.children = null;
    return vnode2;
  }
}
function getKeepAliveChild(vnode2) {
  return isKeepAlive(vnode2) ? vnode2.children ? vnode2.children[0] : void 0 : vnode2;
}
function setTransitionHooks(vnode2, hooks) {
  if (vnode2.shapeFlag & 6 && vnode2.component) {
    setTransitionHooks(vnode2.component.subTree, hooks);
  } else if (vnode2.shapeFlag & 128) {
    vnode2.ssContent.transition = hooks.clone(vnode2.ssContent);
    vnode2.ssFallback.transition = hooks.clone(vnode2.ssFallback);
  } else {
    vnode2.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } else if (keepComment || child.type !== Comment) {
      ret.push(child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$6(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source2) {
  if (isFunction$6(source2)) {
    source2 = { loader: source2 };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    suspensible = true,
    onError: userOnError
  } = source2;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error2 = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error2.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error2.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error2.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error2.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error2.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, { vnode: { ref: ref2, props: props2, children } }) {
  const vnode2 = createVNode(comp, props2, children);
  vnode2.ref = ref2;
  return vnode2;
}
const isKeepAlive = (vnode2) => vnode2.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return slots.default;
    }
    const cache2 = new Map();
    const keys2 = new Set();
    let current2 = null;
    const parentSuspense = instance.suspense;
    const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode2, container2, anchor, isSVG, optimized) => {
      const instance2 = vnode2.component;
      move(vnode2, container2, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode2, container2, anchor, instance2, parentSuspense, isSVG, vnode2.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode2.props && vnode2.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode2);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode2) => {
      const instance2 = vnode2.component;
      move(vnode2, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode2.props && vnode2.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode2);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode2) {
      resetShapeFlag(vnode2);
      _unmount(vnode2, instance, parentSuspense);
    }
    function pruneCache(filter2) {
      cache2.forEach((vnode2, key2) => {
        const name = getComponentName(vnode2.type);
        if (name && (!filter2 || !filter2(name))) {
          pruneCacheEntry(key2);
        }
      });
    }
    function pruneCacheEntry(key2) {
      const cached = cache2.get(key2);
      if (!current2 || cached.type !== current2.type) {
        unmount(cached);
      } else if (current2) {
        resetShapeFlag(current2);
      }
      cache2.delete(key2);
      keys2.delete(key2);
    }
    watch$1(() => [props2.include, props2.exclude], ([include, exclude]) => {
      include && pruneCache((name) => matches(include, name));
      exclude && pruneCache((name) => !matches(exclude, name));
    }, { flush: "post", deep: true });
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache2.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode2 = getInnerChild(subTree);
        if (cached.type === vnode2.type) {
          resetShapeFlag(vnode2);
          const da = vnode2.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current2 = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current2 = null;
        return rawVNode;
      }
      let vnode2 = getInnerChild(rawVNode);
      const comp = vnode2.type;
      const name = getComponentName(isAsyncWrapper(vnode2) ? vnode2.type.__asyncResolved || {} : comp);
      const { include, exclude, max: max2 } = props2;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current2 = vnode2;
        return rawVNode;
      }
      const key2 = vnode2.key == null ? comp : vnode2.key;
      const cachedVNode = cache2.get(key2);
      if (vnode2.el) {
        vnode2 = cloneVNode(vnode2);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode2;
        }
      }
      pendingCacheKey = key2;
      if (cachedVNode) {
        vnode2.el = cachedVNode.el;
        vnode2.component = cachedVNode.component;
        if (vnode2.transition) {
          setTransitionHooks(vnode2, vnode2.transition);
        }
        vnode2.shapeFlag |= 512;
        keys2.delete(key2);
        keys2.add(key2);
      } else {
        keys2.add(key2);
        if (max2 && keys2.size > parseInt(max2, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode2.shapeFlag |= 256;
      current2 = vnode2;
      return rawVNode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern4, name) {
  if (isArray$b(pattern4)) {
    return pattern4.some((p2) => matches(p2, name));
  } else if (isString$3(pattern4)) {
    return pattern4.split(",").indexOf(name) > -1;
  } else if (pattern4.test) {
    return pattern4.test(name);
  }
  return false;
}
function onActivated(hook, target2) {
  registerKeepAliveHook(hook, "a", target2);
}
function onDeactivated(hook, target2) {
  registerKeepAliveHook(hook, "da", target2);
}
function registerKeepAliveHook(hook, type4, target2 = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current2 = target2;
    while (current2) {
      if (current2.isDeactivated) {
        return;
      }
      current2 = current2.parent;
    }
    return hook();
  });
  injectHook(type4, wrappedHook, target2);
  if (target2) {
    let current2 = target2.parent;
    while (current2 && current2.parent) {
      if (isKeepAlive(current2.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type4, target2, current2);
      }
      current2 = current2.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type4, target2, keepAliveRoot) {
  const injected = injectHook(type4, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove$1(keepAliveRoot[type4], injected);
  }, target2);
}
function resetShapeFlag(vnode2) {
  let shapeFlag = vnode2.shapeFlag;
  if (shapeFlag & 256) {
    shapeFlag -= 256;
  }
  if (shapeFlag & 512) {
    shapeFlag -= 512;
  }
  vnode2.shapeFlag = shapeFlag;
}
function getInnerChild(vnode2) {
  return vnode2.shapeFlag & 128 ? vnode2.ssContent : vnode2;
}
function injectHook(type4, hook, target2 = currentInstance, prepend = false) {
  if (target2) {
    const hooks = target2[type4] || (target2[type4] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target2.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target2);
      const res = callWithAsyncErrorHandling(hook, target2, type4, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target2 = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target2);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target2 = currentInstance) {
  injectHook("ec", hook, target2);
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components: components2,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key2 in methods) {
      const methodHandler = methods[key2];
      if (isFunction$6(methodHandler)) {
        {
          ctx[key2] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data2 = dataOptions.call(publicThis, publicThis);
    if (!isObject$d(data2))
      ;
    else {
      instance.data = reactive(data2);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key2 in computedOptions) {
      const opt = computedOptions[key2];
      const get3 = isFunction$6(opt) ? opt.bind(publicThis, publicThis) : isFunction$6(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP$1;
      const set2 = !isFunction$6(opt) && isFunction$6(opt.set) ? opt.set.bind(publicThis) : NOOP$1;
      const c2 = computed({
        get: get3,
        set: set2
      });
      Object.defineProperty(ctx, key2, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key2 in watchOptions) {
      createWatcher(watchOptions[key2], ctx, publicThis, key2);
    }
  }
  if (provideOptions) {
    const provides = isFunction$6(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key2) => {
      provide(key2, provides[key2]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register3, hook) {
    if (isArray$b(hook)) {
      hook.forEach((_hook) => register3(_hook.bind(publicThis)));
    } else if (hook) {
      register3(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$b(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key2) => {
        Object.defineProperty(exposed, key2, {
          get: () => publicThis[key2],
          set: (val) => publicThis[key2] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP$1) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components2)
    instance.components = components2;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP$1, unwrapRef = false) {
  if (isArray$b(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key2 in injectOptions) {
    const opt = injectOptions[key2];
    let injected;
    if (isObject$d(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key2, opt.default, true);
      } else {
        injected = inject(opt.from || key2);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key2] = injected;
      }
    } else {
      ctx[key2] = injected;
    }
  }
}
function callHook$1(hook, instance, type4) {
  callWithAsyncErrorHandling(isArray$b(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type4);
}
function createWatcher(raw, ctx, publicThis, key2) {
  const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
  if (isString$3(raw)) {
    const handler = ctx[raw];
    if (isFunction$6(handler)) {
      watch$1(getter, handler);
    }
  } else if (isFunction$6(raw)) {
    watch$1(getter, raw.bind(publicThis));
  } else if (isObject$d(raw)) {
    if (isArray$b(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key2));
    } else {
      const handler = isFunction$6(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$6(handler)) {
        watch$1(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  cache2.set(base, resolved);
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions$1(to, m2, strats, true));
  }
  for (const key2 in from) {
    if (asMixin && key2 === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
      to[key2] = strat ? strat(to[key2], from[key2]) : from[key2];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(isFunction$6(to) ? to.call(this, this) : to, isFunction$6(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$b(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(extend$1(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$1(Object.create(null), to);
  for (const key2 in from) {
    merged[key2] = mergeAsArray(to[key2], from[key2]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props2 = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = Object.create(null);
  setFullProps(instance, rawProps, props2, attrs);
  for (const key2 in instance.propsOptions[0]) {
    if (!(key2 in props2)) {
      props2[key2] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props2 : shallowReactive(props2);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props2;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props: props2, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props2);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key2 = propsToUpdate[i];
        const value = rawProps[key2];
        if (options) {
          if (hasOwn$1(attrs, key2)) {
            if (value !== attrs[key2]) {
              attrs[key2] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key2);
            props2[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key2]) {
            attrs[key2] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props2, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key2 in rawCurrentProps) {
      if (!rawProps || !hasOwn$1(rawProps, key2) && ((kebabKey = hyphenate(key2)) === key2 || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key2] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props2[key2] = resolvePropValue(options, rawCurrentProps, key2, void 0, instance, true);
          }
        } else {
          delete props2[key2];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key2 in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key2)) {
          delete attrs[key2];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$4(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props2, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key2 in rawProps) {
      if (isReservedProp(key2)) {
        continue;
      }
      const value = rawProps[key2];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key2))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props2[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key2)) {
        if (!(key2 in attrs) || value !== attrs[key2]) {
          attrs[key2] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props2);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key2 = needCastKeys[i];
      props2[key2] = resolvePropValue(options, rawCurrentProps, key2, castValues[key2], instance, !hasOwn$1(castValues, key2));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props2, key2, value, instance, isAbsent) {
  const opt = options[key2];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$6(defaultValue)) {
        const { propsDefaults } = instance;
        if (key2 in propsDefaults) {
          value = propsDefaults[key2];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key2] = defaultValue.call(null, props2);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key2))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$6(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props2, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props2);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache2.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$b(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key2 in raw) {
      const normalizedKey = camelize(key2);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key2];
        const prop = normalized[normalizedKey] = isArray$b(opt) || isFunction$6(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache2.set(comp, res);
  return res;
}
function validatePropName(key2) {
  if (key2[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type4, expectedTypes) {
  if (isArray$b(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type4));
  } else if (isFunction$6(expectedTypes)) {
    return isSameType(expectedTypes, type4) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
const normalizeSlotValue = (value) => isArray$b(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key2, rawSlot, ctx) => {
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key2 in rawSlots) {
    if (isInternalKey(key2))
      continue;
    const value = rawSlots[key2];
    if (isFunction$6(value)) {
      slots[key2] = normalizeSlot$1(key2, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key2] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type4 = children._;
    if (type4) {
      instance.slots = toRaw(children);
      def(children, "_", type4);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode: vnode2, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode2.shapeFlag & 32) {
    const type4 = children._;
    if (type4) {
      if (optimized && type4 === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type4 === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key2 in slots) {
      if (!isInternalKey(key2) && !(key2 in deletionComparisonTarget)) {
        delete slots[key2];
      }
    }
  }
};
function withDirectives(vnode2, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode2;
  }
  const instance = internalInstance.proxy;
  const bindings = vnode2.dirs || (vnode2.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (isFunction$6(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode2;
}
function invokeDirectiveHook(vnode2, prevVNode, instance, name) {
  const bindings = vnode2.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode2.el,
        binding,
        vnode2,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (rootProps != null && !isObject$d(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$4,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2))
          ;
        else if (plugin2 && isFunction$6(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options);
        } else if (isFunction$6(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component2) {
        if (!component2) {
          return context.components[name];
        }
        context.components[name] = component2;
        return app;
      },
      directive(name, directive2) {
        if (!directive2) {
          return context.directives[name];
        }
        context.directives[name] = directive2;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode2 = createVNode(rootComponent, rootProps);
          vnode2.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode2, rootContainer);
          } else {
            render2(vnode2, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode2.component) || vnode2.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key2, value) {
        context.provides[key2] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode2, isUnmount = false) {
  if (isArray$b(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$b(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode2, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode2) && !isUnmount) {
    return;
  }
  const refValue = vnode2.shapeFlag & 4 ? getExposeProxy(vnode2.component) || vnode2.component.proxy : vnode2.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$3(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$1(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$6(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$3(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$b(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$b(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn$1(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (isRef(ref2)) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container2) => /svg/.test(container2.namespaceURI) && container2.tagName !== "foreignObject";
const isComment$2 = (node3) => node3.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, nextSibling, parentNode, remove: remove2, insert, createComment } } = rendererInternals;
  const hydrate2 = (vnode2, container2) => {
    if (!container2.hasChildNodes()) {
      patch(null, vnode2, container2);
      flushPostFlushCbs();
      return;
    }
    hasMismatch = false;
    hydrateNode(container2.firstChild, vnode2, null, null, null);
    flushPostFlushCbs();
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node3, vnode2, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment$2(node3) && node3.data === "[";
    const onMismatch = () => handleMismatch(node3, vnode2, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const { type: type4, ref: ref2, shapeFlag } = vnode2;
    const domType = node3.nodeType;
    vnode2.el = node3;
    let nextNode = null;
    switch (type4) {
      case Text:
        if (domType !== 3) {
          nextNode = onMismatch();
        } else {
          if (node3.data !== vnode2.children) {
            hasMismatch = true;
            node3.data = vnode2.children;
          }
          nextNode = nextSibling(node3);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node3);
        }
        break;
      case Static:
        if (domType !== 1) {
          nextNode = onMismatch();
        } else {
          nextNode = node3;
          const needToAdoptContent = !vnode2.children.length;
          for (let i = 0; i < vnode2.staticCount; i++) {
            if (needToAdoptContent)
              vnode2.children += nextNode.outerHTML;
            if (i === vnode2.staticCount - 1) {
              vnode2.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return nextNode;
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node3, vnode2, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode2.type.toLowerCase() !== node3.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node3, vnode2, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode2.slotScopeIds = slotScopeIds;
          const container2 = parentNode(node3);
          mountComponent(vnode2, container2, null, parentComponent, parentSuspense, isSVGContainer(container2), optimized);
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node3) : nextSibling(node3);
          if (isAsyncWrapper(vnode2)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container2.lastChild;
            } else {
              subTree = node3.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node3;
            vnode2.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode2.type.hydrate(node3, vnode2, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode2.type.hydrate(node3, vnode2, parentComponent, parentSuspense, isSVGContainer(parentNode(node3)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode2);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode2, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode2.dynamicChildren;
    const { type: type4, props: props2, patchFlag, shapeFlag, dirs } = vnode2;
    const forcePatchValue = type4 === "input" && dirs || type4 === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode2, null, parentComponent, "created");
      }
      if (props2) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key2 in props2) {
            if (forcePatchValue && key2.endsWith("value") || isOn(key2) && !isReservedProp(key2)) {
              patchProp2(el, key2, null, props2[key2], false, void 0, parentComponent);
            }
          }
        } else if (props2.onClick) {
          patchProp2(el, "onClick", null, props2.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props2 && props2.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode2);
      }
      if (dirs) {
        invokeDirectiveHook(vnode2, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props2 && props2.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode2);
          dirs && invokeDirectiveHook(vnode2, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && !(props2 && (props2.innerHTML || props2.textContent))) {
        let next2 = hydrateChildren(el.firstChild, vnode2, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        while (next2) {
          hasMismatch = true;
          const cur = next2;
          next2 = next2.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode2.children) {
          hasMismatch = true;
          el.textContent = vnode2.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node3, parentVNode, container2, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l2 = children.length;
    for (let i = 0; i < l2; i++) {
      const vnode2 = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node3) {
        node3 = hydrateNode(node3, vnode2, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode2.type === Text && !vnode2.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(null, vnode2, container2, null, parentComponent, parentSuspense, isSVGContainer(container2), slotScopeIds);
      }
    }
    return node3;
  };
  const hydrateFragment = (node3, vnode2, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container2 = parentNode(node3);
    const next2 = hydrateChildren(nextSibling(node3), vnode2, container2, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next2 && isComment$2(next2) && next2.data === "]") {
      return nextSibling(vnode2.anchor = next2);
    } else {
      hasMismatch = true;
      insert(vnode2.anchor = createComment(`]`), container2, next2);
      return next2;
    }
  };
  const handleMismatch = (node3, vnode2, parentComponent, parentSuspense, slotScopeIds, isFragment2) => {
    hasMismatch = true;
    vnode2.el = null;
    if (isFragment2) {
      const end2 = locateClosingAsyncAnchor(node3);
      while (true) {
        const next3 = nextSibling(node3);
        if (next3 && next3 !== end2) {
          remove2(next3);
        } else {
          break;
        }
      }
    }
    const next2 = nextSibling(node3);
    const container2 = parentNode(node3);
    remove2(node3);
    patch(null, vnode2, container2, next2, parentComponent, parentSuspense, isSVGContainer(container2), slotScopeIds);
    return next2;
  };
  const locateClosingAsyncAnchor = (node3) => {
    let match = 0;
    while (node3) {
      node3 = nextSibling(node3);
      if (node3 && isComment$2(node3)) {
        if (node3.data === "[")
          match++;
        if (node3.data === "]") {
          if (match === 0) {
            return nextSibling(node3);
          } else {
            match--;
          }
        }
      }
    }
    return node3;
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target2 = getGlobalThis$1();
  target2.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP$1, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container2, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type: type4, ref: ref2, shapeFlag } = n2;
    switch (type4) {
      case Text:
        processText(n1, n2, container2, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container2, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container2, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type4.process(n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type4.process(n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container2, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container2, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container2, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container2, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container2, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container2, anchor, isSVG);
  };
  const moveStaticNode = ({ el, anchor }, container2, nextSibling) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostInsert(el, container2, nextSibling);
      el = next2;
    }
    hostInsert(anchor, container2, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostRemove(el);
      el = next2;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type: type4, props: props2, shapeFlag, transition, patchFlag, dirs } = vnode2;
    if (vnode2.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el = vnode2.el = hostCloneNode(vnode2.el);
    } else {
      el = vnode2.el = hostCreateElement(vnode2.type, isSVG, props2 && props2.is, props2);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode2.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode2.children, el, null, parentComponent, parentSuspense, isSVG && type4 !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode2, null, parentComponent, "created");
      }
      if (props2) {
        for (const key2 in props2) {
          if (key2 !== "value" && !isReservedProp(key2)) {
            hostPatchProp(el, key2, null, props2[key2], isSVG, vnode2.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props2) {
          hostPatchProp(el, "value", null, props2.value);
        }
        if (vnodeHook = props2.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode2);
        }
      }
      setScopeId(el, vnode2, vnode2.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode2, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container2, anchor);
    if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode2);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode2, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode2, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode2 === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key2 = propsToUpdate[i];
            const prev2 = oldProps[key2];
            const next2 = newProps[key2];
            if (next2 !== prev2 || key2 === "value") {
              hostPatchProp(el, key2, prev2, next2, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container2 = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container2, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode2, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key2 in newProps) {
        if (isReservedProp(key2))
          continue;
        const next2 = newProps[key2];
        const prev2 = oldProps[key2];
        if (next2 !== prev2 && key2 !== "value") {
          hostPatchProp(el, key2, prev2, next2, isSVG, vnode2.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key2 in oldProps) {
          if (!isReservedProp(key2) && !(key2 in newProps)) {
            hostPatchProp(el, key2, oldProps[key2], null, isSVG, vnode2.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container2, anchor);
      hostInsert(fragmentEndAnchor, container2, anchor);
      mountChildren(n2.children, container2, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container2, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container2, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container2, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container2, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container2, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container2, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container2, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container2, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props: props2 } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container2, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container2 = anchor = null;
      } else {
        let { next: next2, bu, u: u2, parent, vnode: vnode2 } = instance;
        let originNext = next2;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next2) {
          next2.el = vnode2.el;
          updateComponentPreRender(instance, next2, optimized);
        } else {
          next2 = vnode2;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next2, vnode2);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        next2.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next2, vnode2), parentSuspense);
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
    const update3 = instance.update = effect2.run.bind(effect2);
    update3.id = instance.uid;
    toggleRecurse(instance, true);
    update3();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container2, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container2, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container2, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container2, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container2, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container2, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container2, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container2, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode2, container2, anchor, moveType, parentSuspense = null) => {
    const { el, type: type4, transition, children, shapeFlag } = vnode2;
    if (shapeFlag & 6) {
      move(vnode2.component.subTree, container2, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode2.suspense.move(container2, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type4.move(vnode2, container2, anchor, internals);
      return;
    }
    if (type4 === Fragment) {
      hostInsert(el, container2, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container2, anchor, moveType);
      }
      hostInsert(vnode2.anchor, container2, anchor);
      return;
    }
    if (type4 === Static) {
      moveStaticNode(vnode2, container2, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container2, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container2, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container2, anchor);
    }
  };
  const unmount = (vnode2, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type: type4, props: props2, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode2;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode2, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode2);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode2);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode2);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode2.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode2.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode2, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode2.type.remove(vnode2, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type4 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type4 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode2);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode2);
        shouldInvokeDirs && invokeDirectiveHook(vnode2, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode2) => {
    const { type: type4, el, anchor, transition } = vnode2;
    if (type4 === Fragment) {
      removeFragment(el, anchor);
      return;
    }
    if (type4 === Static) {
      removeStaticNode(vnode2);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode2.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode2.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end2) => {
    let next2;
    while (cur !== end2) {
      next2 = hostNextSibling(cur);
      hostRemove(cur);
      cur = next2;
    }
    hostRemove(end2);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update3, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update3) {
      update3.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode2) => {
    if (vnode2.shapeFlag & 6) {
      return getNextHostNode(vnode2.component.subTree);
    }
    if (vnode2.shapeFlag & 128) {
      return vnode2.suspense.next();
    }
    return hostNextSibling(vnode2.anchor || vnode2.el);
  };
  const render2 = (vnode2, container2, isSVG) => {
    if (vnode2 == null) {
      if (container2._vnode) {
        unmount(container2._vnode, null, null, true);
      }
    } else {
      patch(container2._vnode || null, vnode2, container2, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container2._vnode = vnode2;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update: update3 }, allowed) {
  effect2.allowRecurse = update3.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$b(ch1) && isArray$b(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result3 = [0];
  let i, j, u2, v2, c2;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result3[result3.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result3.push(i);
        continue;
      }
      u2 = 0;
      v2 = result3.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result3[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result3[u2]]) {
        if (u2 > 0) {
          p2[i] = result3[u2 - 1];
        }
        result3[u2] = i;
      }
    }
  }
  u2 = result3.length;
  v2 = result3[u2 - 1];
  while (u2-- > 0) {
    result3[u2] = v2;
    v2 = p2[v2];
  }
  return result3;
}
const isTeleport = (type4) => type4.__isTeleport;
const isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
const isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
const resolveTarget = (props2, select2) => {
  const targetSelector = props2 && props2.to;
  if (isString$3(targetSelector)) {
    if (!select2) {
      return null;
    } else {
      const target2 = select2(targetSelector);
      return target2;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container2, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container2, anchor);
      insert(mainAnchor, container2, anchor);
      const target2 = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target2) {
        insert(targetAnchor, target2);
        isSVG = isSVG || isTargetSVG(target2);
      }
      const mount = (container3, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container3, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container2, mainAnchor);
      } else if (target2) {
        mount(target2, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target2 = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container2 : target2;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target2);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container2, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target2, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode2, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target: target2, props: props2 } = vnode2;
    if (target2) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props2)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode2, container2, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode2.targetAnchor, container2, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props: props2 } = vnode2;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container2, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props2)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container2, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container2, parentAnchor);
  }
}
function hydrateTeleport(node3, vnode2, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target2 = vnode2.target = resolveTarget(vnode2.props, querySelector);
  if (target2) {
    const targetNode = target2._lpa || target2.firstChild;
    if (vnode2.shapeFlag & 16) {
      if (isTeleportDisabled(vnode2.props)) {
        vnode2.anchor = hydrateChildren(nextSibling(node3), vnode2, parentNode(node3), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode2.targetAnchor = targetNode;
      } else {
        vnode2.anchor = nextSibling(node3);
        vnode2.targetAnchor = hydrateChildren(targetNode, vnode2, target2, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
      target2._lpa = vnode2.targetAnchor && nextSibling(vnode2.targetAnchor);
    }
  }
  return vnode2.anchor && nextSibling(vnode2.anchor);
}
const Teleport = TeleportImpl;
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component2) {
  if (isString$3(component2)) {
    return resolveAsset(COMPONENTS, component2, false) || component2;
  } else {
    return component2 || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type4, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type4 === COMPONENTS) {
      const selfName = getComponentName(Component);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type4] || Component[type4], name) || resolve(instance.appContext[type4], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode2) {
  vnode2.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode2);
  }
  return vnode2;
}
function createElementBlock(type4, props2, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type4, props2, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type4, props2, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type4, props2, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$3(ref2) || isRef(ref2) || isFunction$6(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type4, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type4 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode2 = {
    __v_isVNode: true,
    __v_skip: true,
    type: type4,
    props: props2,
    key: props2 && normalizeKey(props2),
    ref: props2 && normalizeRef(props2),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode2, children);
    if (shapeFlag & 128) {
      type4.normalize(vnode2);
    }
  } else if (children) {
    vnode2.shapeFlag |= isString$3(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode2.patchFlag > 0 || shapeFlag & 6) && vnode2.patchFlag !== 32) {
    currentBlock.push(vnode2);
  }
  return vnode2;
}
const createVNode = _createVNode;
function _createVNode(type4, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type4 || type4 === NULL_DYNAMIC_COMPONENT) {
    type4 = Comment;
  }
  if (isVNode(type4)) {
    const cloned = cloneVNode(type4, props2, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }
  if (isClassComponent(type4)) {
    type4 = type4.__vccOpts;
  }
  if (props2) {
    props2 = guardReactiveProps(props2);
    let { class: klass, style } = props2;
    if (klass && !isString$3(klass)) {
      props2.class = normalizeClass(klass);
    }
    if (isObject$d(style)) {
      if (isProxy(style) && !isArray$b(style)) {
        style = extend$1({}, style);
      }
      props2.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$3(type4) ? 1 : isSuspense(type4) ? 128 : isTeleport(type4) ? 64 : isObject$d(type4) ? 4 : isFunction$6(type4) ? 2 : 0;
  return createBaseVNode(type4, props2, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props2) {
  if (!props2)
    return null;
  return isProxy(props2) || InternalObjectKey in props2 ? extend$1({}, props2) : props2;
}
function cloneVNode(vnode2, extraProps, mergeRef = false) {
  const { props: props2, ref: ref2, patchFlag, children } = vnode2;
  const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode2.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$b(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode2.scopeId,
    slotScopeIds: vnode2.slotScopeIds,
    children,
    target: vnode2.target,
    targetAnchor: vnode2.targetAnchor,
    staticCount: vnode2.staticCount,
    shapeFlag: vnode2.shapeFlag,
    patchFlag: extraProps && vnode2.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode2.dynamicProps,
    dynamicChildren: vnode2.dynamicChildren,
    appContext: vnode2.appContext,
    dirs: vnode2.dirs,
    transition: vnode2.transition,
    component: vnode2.component,
    suspense: vnode2.suspense,
    ssContent: vnode2.ssContent && cloneVNode(vnode2.ssContent),
    ssFallback: vnode2.ssFallback && cloneVNode(vnode2.ssFallback),
    el: vnode2.el,
    anchor: vnode2.anchor
  };
  return cloned;
}
function createTextVNode(text = " ", flag2 = 0) {
  return createVNode(Text, null, text, flag2);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode2 = createVNode(Static, null, content);
  vnode2.staticCount = numberOfNodes;
  return vnode2;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$b(child)) {
    return createVNode(Fragment, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode2, children) {
  let type4 = 0;
  const { shapeFlag } = vnode2;
  if (children == null) {
    children = null;
  } else if (isArray$b(children)) {
    type4 = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode2, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type4 = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode2.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$6(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type4 = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type4 = 16;
      children = [createTextVNode(children)];
    } else {
      type4 = 8;
    }
  }
  vnode2.children = children;
  vnode2.shapeFlag |= type4;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key2 in toMerge) {
      if (key2 === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key2 === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key2)) {
        const existing = ret[key2];
        const incoming = toMerge[key2];
        if (existing !== incoming && !(isArray$b(existing) && existing.includes(incoming))) {
          ret[key2] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key2 !== "") {
        ret[key2] = toMerge[key2];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode2, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode2,
    prevVNode
  ]);
}
function renderList(source2, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray$b(source2) || isString$3(source2)) {
    ret = new Array(source2.length);
    for (let i = 0, l2 = source2.length; i < l2; i++) {
      ret[i] = renderItem(source2[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source2 === "number") {
    ret = new Array(source2);
    for (let i = 0; i < source2; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$d(source2)) {
    if (source2[Symbol.iterator]) {
      ret = Array.from(source2, (item2, i) => renderItem(item2, i, void 0, cached && cached[i]));
    } else {
      const keys2 = Object.keys(source2);
      ret = new Array(keys2.length);
      for (let i = 0, l2 = keys2.length; i < l2; i++) {
        const key2 = keys2[i];
        ret[i] = renderItem(source2[key2], key2, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray$b(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props2 = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE) {
    return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props2));
  const rendered = createBlock(Fragment, { key: props2.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj) {
  const ret = {};
  for (const key2 in obj) {
    ret[toHandlerKey(key2)] = obj[key2];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = extend$1(Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => i.props,
  $attrs: (i) => i.attrs,
  $slots: (i) => i.slots,
  $refs: (i) => i.refs,
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => () => queueJob(i.update),
  $nextTick: (i) => nextTick.bind(i.proxy),
  $watch: (i) => instanceWatch.bind(i)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key2) {
    const { ctx, setupState, data: data2, props: props2, accessCache, type: type4, appContext } = instance;
    let normalizedProps;
    if (key2[0] !== "$") {
      const n = accessCache[key2];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key2];
          case 2:
            return data2[key2];
          case 4:
            return ctx[key2];
          case 3:
            return props2[key2];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn$1(setupState, key2)) {
        accessCache[key2] = 1;
        return setupState[key2];
      } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key2)) {
        accessCache[key2] = 2;
        return data2[key2];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key2)) {
        accessCache[key2] = 3;
        return props2[key2];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) {
        accessCache[key2] = 4;
        return ctx[key2];
      } else if (shouldCacheAccess) {
        accessCache[key2] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key2];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key2 === "$attrs") {
        track(instance, "get", key2);
      }
      return publicGetter(instance);
    } else if ((cssModule = type4.__cssModules) && (cssModule = cssModule[key2])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) {
      accessCache[key2] = 4;
      return ctx[key2];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key2)) {
      {
        return globalProperties[key2];
      }
    } else
      ;
  },
  set({ _: instance }, key2, value) {
    const { data: data2, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn$1(setupState, key2)) {
      setupState[key2] = value;
    } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key2)) {
      data2[key2] = value;
    } else if (hasOwn$1(instance.props, key2)) {
      return false;
    }
    if (key2[0] === "$" && key2.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key2] = value;
      }
    }
    return true;
  },
  has({ _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions } }, key2) {
    let normalizedProps;
    return !!accessCache[key2] || data2 !== EMPTY_OBJ && hasOwn$1(data2, key2) || setupState !== EMPTY_OBJ && hasOwn$1(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key2) || hasOwn$1(ctx, key2) || hasOwn$1(publicPropertiesMap, key2) || hasOwn$1(appContext.config.globalProperties, key2);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$1({}, PublicInstanceProxyHandlers, {
  get(target2, key2) {
    if (key2 === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target2, key2, target2);
  },
  has(_2, key2) {
    const has2 = key2[0] !== "_" && !isGloballyWhitelisted(key2);
    return has2;
  }
});
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode2, parent, suspense) {
  const type4 = vnode2.type;
  const appContext = (parent ? parent.appContext : vnode2.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode: vnode2,
    type: type4,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type4, appContext),
    emitsOptions: normalizeEmitsOptions(type4, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type4.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode2.ce) {
    vnode2.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props: props2, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props2, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$6(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$d(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template2 = Component.template;
      if (template2) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(extend$1({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$1(template2, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP$1;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target2, key2) {
      track(instance, "get", "$attrs");
      return target2[key2];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target2, key2) {
        if (key2 in target2) {
          return target2[key2];
        } else if (key2 in publicPropertiesMap) {
          return publicPropertiesMap[key2](instance);
        }
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component) {
  return isFunction$6(Component) ? Component.displayName || Component.name : Component.name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key2 in registry) {
        if (registry[key2] === Component) {
          return key2;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$6(value) && "__vccOpts" in value;
}
const stack = [];
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode: vnode2 }) => `at <${formatComponentName(instance, vnode2.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode: vnode2, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode2.component ? vnode2.component.parent == null : false;
  const open2 = ` at <${formatComponentName(vnode2.component, vnode2.type, isRoot)}`;
  const close2 = `>` + postfix;
  return vnode2.props ? [open2, ...formatProps(vnode2.props), close2] : [open2 + close2];
}
function formatProps(props2) {
  const res = [];
  const keys2 = Object.keys(props2);
  keys2.slice(0, 3).forEach((key2) => {
    res.push(...formatProp(key2, props2[key2]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key2, value, raw) {
  if (isString$3(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key2}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key2}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key2, toRaw(value.value), true);
    return raw ? value : [`${key2}=Ref<`, value, `>`];
  } else if (isFunction$6(value)) {
    return [`${key2}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key2}=`, value];
  }
}
function callWithErrorHandling(fn3, instance, type4, args) {
  let res;
  try {
    res = args ? fn3(...args) : fn3();
  } catch (err) {
    handleError(err, instance, type4);
  }
  return res;
}
function callWithAsyncErrorHandling(fn3, instance, type4, args) {
  if (isFunction$6(fn3)) {
    const res = callWithErrorHandling(fn3, instance, type4, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type4);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn3.length; i++) {
    values.push(callWithAsyncErrorHandling(fn3[i], instance, type4, args));
  }
  return values;
}
function handleError(err, instance, type4, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type4;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type4, contextVNode, throwInDev);
}
function logError(err, type4, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
function nextTick(fn3) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn3 ? p2.then(this ? fn3.bind(this) : fn3) : p2;
}
function findInsertionIndex(id) {
  let start2 = flushIndex + 1;
  let end2 = queue.length;
  while (start2 < end2) {
    const middle = start2 + end2 >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start2 = middle + 1 : end2 = middle;
  }
  return start2;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index2) {
  if (!isArray$b(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen);
  queue.sort((a2, b2) => getId(a2) - getId(b2));
  const check2 = NOOP$1;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "post" });
}
function watchSyncEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "sync" });
}
const INITIAL_WATCHER_VALUE = {};
function watch$1(source2, cb, options) {
  return doWatch(source2, cb, options);
}
function doWatch(source2, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source2)) {
    getter = () => source2.value;
    forceTrigger = !!source2._shallow;
  } else if (isReactive(source2)) {
    getter = () => source2;
    deep = true;
  } else if (isArray$b(source2)) {
    isMultiSource = true;
    forceTrigger = source2.some(isReactive);
    getter = () => source2.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$6(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction$6(source2)) {
    if (cb) {
      getter = () => callWithErrorHandling(source2, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source2, instance, 3, [onInvalidate]);
      };
    }
  } else {
    getter = NOOP$1;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onInvalidate = (fn3) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn3, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onInvalidate = NOOP$1;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onInvalidate
      ]);
    }
    return NOOP$1;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onInvalidate
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        job();
      }
    };
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
  } else {
    effect2.run();
  }
  return () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove$1(instance.scope.effects, effect2);
    }
  };
}
function instanceWatch(source2, value, options) {
  const publicThis = this.proxy;
  const getter = isString$3(source2) ? source2.includes(".") ? createPathGetter(publicThis, source2) : () => publicThis[source2] : source2.bind(publicThis, publicThis);
  let cb;
  if (isFunction$6(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$d(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$b(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet$2(value) || isMap$2(value)) {
    value.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject$2(value)) {
    for (const key2 in value) {
      traverse(value[key2], seen);
    }
  }
  return value;
}
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function withDefaults(props2, defaults2) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs$2() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function mergeDefaults(raw, defaults2) {
  const props2 = isArray$b(raw) ? raw.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw;
  for (const key2 in defaults2) {
    const opt = props2[key2];
    if (opt) {
      if (isArray$b(opt) || isFunction$6(opt)) {
        props2[key2] = { type: opt, default: defaults2[key2] };
      } else {
        opt.default = defaults2[key2];
      }
    } else if (opt === null) {
      props2[key2] = { default: defaults2[key2] };
    } else
      ;
  }
  return props2;
}
function createPropsRestProxy(props2, excludedKeys) {
  const ret = {};
  for (const key2 in props2) {
    if (!excludedKeys.includes(key2)) {
      Object.defineProperty(ret, key2, {
        enumerable: true,
        get: () => props2[key2]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise$1(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function h$1(type4, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$d(propsOrChildren) && !isArray$b(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type4, null, [propsOrChildren]);
      }
      return createVNode(type4, propsOrChildren);
    } else {
      return createVNode(type4, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type4, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      warn$1(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo2, render2, cache2, index2) {
  const cached = cache2[index2];
  if (cached && isMemoSame(cached, memo2)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo2.slice();
  return cache2[index2] = ret;
}
function isMemoSame(cached, memo2) {
  const prev2 = cached.memo;
  if (prev2.length != memo2.length) {
    return false;
  }
  for (let i = 0; i < prev2.length; i++) {
    if (prev2[i] !== memo2[i]) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version$4 = "3.2.26";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const staticTemplateCache = new Map();
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag3, isSVG, is, props2) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag3) : doc.createElement(tag3, is ? { is } : void 0);
    if (tag3 === "select" && props2 && props2.multiple != null) {
      el.setAttribute("multiple", props2.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node3, text) => {
    node3.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node3) => node3.parentNode,
  nextSibling: (node3) => node3.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  cloneNode(el) {
    const cloned = el.cloneNode(true);
    if (`_value` in el) {
      cloned._value = el._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    let template2 = staticTemplateCache.get(content);
    if (!template2) {
      const t = doc.createElement("template");
      t.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      template2 = t.content;
      if (isSVG) {
        const wrapper = template2.firstChild;
        while (wrapper.firstChild) {
          template2.appendChild(wrapper.firstChild);
        }
        template2.removeChild(wrapper);
      }
      staticTemplateCache.set(content, template2);
    }
    parent.insertBefore(template2.cloneNode(true), anchor);
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev2, next2) {
  const style = el.style;
  const isCssString = isString$3(next2);
  if (next2 && !isCssString) {
    for (const key2 in next2) {
      setStyle$1(style, key2, next2[key2]);
    }
    if (prev2 && !isString$3(prev2)) {
      for (const key2 in prev2) {
        if (next2[key2] == null) {
          setStyle$1(style, key2, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev2 !== next2) {
        style.cssText = next2;
      }
    } else if (prev2) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle$1(style, name, val) {
  if (isArray$b(val)) {
    val.forEach((v2) => setStyle$1(style, name, v2));
  } else {
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key2, value, isSVG, instance) {
  if (isSVG && key2.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
    } else {
      el.setAttributeNS(xlinkNS, key2, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key2);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key2);
    } else {
      el.setAttribute(key2, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key2, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key2 === "innerHTML" || key2 === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key2] = value == null ? "" : value;
    return;
  }
  if (key2 === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key2);
    }
    return;
  }
  if (value === "" || value == null) {
    const type4 = typeof el[key2];
    if (type4 === "boolean") {
      el[key2] = includeBooleanAttr(value);
      return;
    } else if (value == null && type4 === "string") {
      el[key2] = "";
      el.removeAttribute(key2);
      return;
    } else if (type4 === "number") {
      try {
        el[key2] = 0;
      } catch (_a) {
      }
      el.removeAttribute(key2);
      return;
    }
  }
  try {
    el[key2] = value;
  } catch (e) {
  }
}
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== "undefined") {
  if (_getNow() > document.createEvent("Event").timeStamp) {
    _getNow = () => performance.now();
  }
  const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
let cachedNow = 0;
const p$1 = Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p$1.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    const timeStamp = e.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$b(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn3) => (e2) => !e2._stopped && fn3(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key2, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key2 === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key2 === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key2)) {
    if (!isModelListener(key2)) {
      patchEvent(el, key2, prevValue, nextValue, parentComponent);
    }
  } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
    patchDOMProp(el, key2, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key2 === "true-value") {
      el._trueValue = nextValue;
    } else if (key2 === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key2, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key2, value, isSVG) {
  if (isSVG) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      return true;
    }
    if (key2 in el && nativeOnRE.test(key2) && isFunction$6(value)) {
      return true;
    }
    return false;
  }
  if (key2 === "spellcheck" || key2 === "draggable") {
    return false;
  }
  if (key2 === "form") {
    return false;
  }
  if (key2 === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key2 === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key2) && isString$3(value)) {
    return false;
  }
  return key2 in el;
}
function defineCustomElement(options, hydate) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydate);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (options) => {
  return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      this._resolveDef();
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render$28(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  _resolveDef() {
    if (this._resolved) {
      return;
    }
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    new MutationObserver((mutations) => {
      for (const m2 of mutations) {
        this._setAttr(m2.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve2 = (def2) => {
      const { props: props2, styles } = def2;
      const hasOptions = !isArray$b(props2);
      const rawKeys = props2 ? hasOptions ? Object.keys(props2) : props2 : [];
      let numberProps;
      if (hasOptions) {
        for (const key2 in this._props) {
          const opt = props2[key2];
          if (opt === Number || opt && opt.type === Number) {
            this._props[key2] = toNumber$2(this._props[key2]);
            (numberProps || (numberProps = Object.create(null)))[key2] = true;
          }
        }
      }
      this._numberProps = numberProps;
      for (const key2 of Object.keys(this)) {
        if (key2[0] !== "_") {
          this._setProp(key2, this[key2], true, false);
        }
      }
      for (const key2 of rawKeys.map(camelize)) {
        Object.defineProperty(this, key2, {
          get() {
            return this._getProp(key2);
          },
          set(val) {
            this._setProp(key2, val);
          }
        });
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then(resolve2);
    } else {
      resolve2(this._def);
    }
  }
  _setAttr(key2) {
    let value = this.getAttribute(key2);
    if (this._numberProps && this._numberProps[key2]) {
      value = toNumber$2(value);
    }
    this._setProp(camelize(key2), value, false);
  }
  _getProp(key2) {
    return this._props[key2];
  }
  _setProp(key2, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key2]) {
      this._props[key2] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key2), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key2), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key2));
        }
      }
    }
  }
  _update() {
    render$28(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode2 = createVNode(this._def, extend$1({}, this._props));
    if (!this._instance) {
      vnode2.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        instance.emit = (event, ...args) => {
          this.dispatchEvent(new CustomEvent(event, {
            detail: args
          }));
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            break;
          }
        }
      };
    }
    return vnode2;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s2 = document.createElement("style");
        s2.textContent = css;
        this.shadowRoot.appendChild(s2);
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode2, vars) {
  if (vnode2.shapeFlag & 128) {
    const suspense = vnode2.suspense;
    vnode2 = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode2.component) {
    vnode2 = vnode2.component.subTree;
  }
  if (vnode2.shapeFlag & 1 && vnode2.el) {
    setVarsOnNode(vnode2.el, vars);
  } else if (vnode2.type === Fragment) {
    vnode2.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode2.type === Static) {
    let { el, anchor } = vnode2;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key2 in vars) {
      style.setProperty(`--${key2}`, vars[key2]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props2, { slots }) => h$1(BaseTransition, resolveTransitionProps(props2), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$b(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$b(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key2 in rawProps) {
    if (!(key2 in DOMTransitionPropsValidators)) {
      baseProps[key2] = rawProps[key2];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name = "v", type: type4, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type4, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type4, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$d(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber$2(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el._vtc || (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type: type4, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type4) {
    return resolve2();
  }
  const endEvent = type4 + "end";
  let ended = 0;
  const end2 = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end2();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end2();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type4 = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type4 = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type4 = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type4 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type4 ? type4 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type4 === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
  return {
    type: type4,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
}
function toMs(s2) {
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props2);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag3 = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag3, null, children);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s2 = c2.el.style;
    s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
    s2.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root2, moveClass) {
  const clone = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
  clone.style.display = "none";
  const container2 = root2.nodeType === 1 ? root2 : root2.parentNode;
  container2.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container2.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode2) => {
  const fn3 = vnode2.props["onUpdate:modelValue"];
  return isArray$b(fn3) ? (value) => invokeArrayFns(fn3, value) : fn3;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target2 = e.target;
  if (target2.composing) {
    target2.composing = false;
    trigger$3(target2, "input");
  }
}
function trigger$3(el, type4) {
  const e = document.createEvent("HTMLEvents");
  e.initEvent(type4, true, true);
  el.dispatchEvent(e);
}
const vModelText = {
  created(el, { modifiers: { lazy, trim: trim2, number: number4 } }, vnode2) {
    el._assign = getModelAssigner(vnode2);
    const castToNumber = number4 || vnode2.props && vnode2.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim2) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = toNumber$2(domValue);
      }
      el._assign(domValue);
    });
    if (trim2) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number: number4 } }, vnode2) {
    el._assign = getModelAssigner(vnode2);
    if (el.composing)
      return;
    if (document.activeElement === el) {
      if (lazy) {
        return;
      }
      if (trim2 && el.value.trim() === value) {
        return;
      }
      if ((number4 || el.type === "number") && toNumber$2(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el, _2, vnode2) {
    el._assign = getModelAssigner(vnode2);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue$3(el);
      const checked2 = el.checked;
      const assign2 = el._assign;
      if (isArray$b(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found = index2 !== -1;
        if (checked2 && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked2 && found) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet$2(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked2) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked2));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el, binding, vnode2) {
    el._assign = getModelAssigner(vnode2);
    setChecked(el, binding, vnode2);
  }
};
function setChecked(el, { value, oldValue }, vnode2) {
  el._modelValue = value;
  if (isArray$b(value)) {
    el.checked = looseIndexOf(value, vnode2.props.value) > -1;
  } else if (isSet$2(value)) {
    el.checked = value.has(vnode2.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode2) {
    el.checked = looseEqual(value, vnode2.props.value);
    el._assign = getModelAssigner(vnode2);
    addEventListener(el, "change", () => {
      el._assign(getValue$3(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode2) {
    el._assign = getModelAssigner(vnode2);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode2.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el, { value, modifiers: { number: number4 } }, vnode2) {
    const isSetModel = isSet$2(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map((o2) => number4 ? toNumber$2(getValue$3(o2)) : getValue$3(o2));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode2);
  },
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode2) {
    el._assign = getModelAssigner(vnode2);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$b(value) && !isSet$2(value)) {
    return;
  }
  for (let i = 0, l2 = el.options.length; i < l2; i++) {
    const option2 = el.options[i];
    const optionValue = getValue$3(option2);
    if (isMultiple) {
      if (isArray$b(value)) {
        option2.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option2.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue$3(option2), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue$3(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked2) {
  const key2 = checked2 ? "_trueValue" : "_falseValue";
  return key2 in el ? el[key2] : checked2;
}
const vModelDynamic = {
  created(el, binding, vnode2) {
    callModelHook(el, binding, vnode2, null, "created");
  },
  mounted(el, binding, vnode2) {
    callModelHook(el, binding, vnode2, null, "mounted");
  },
  beforeUpdate(el, binding, vnode2, prevVNode) {
    callModelHook(el, binding, vnode2, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode2, prevVNode) {
    callModelHook(el, binding, vnode2, prevVNode, "updated");
  }
};
function callModelHook(el, binding, vnode2, prevVNode, hook) {
  let modelToUse;
  switch (el.tagName) {
    case "SELECT":
      modelToUse = vModelSelect;
      break;
    case "TEXTAREA":
      modelToUse = vModelText;
      break;
    default:
      switch (vnode2.props && vnode2.props.type) {
        case "checkbox":
          modelToUse = vModelCheckbox;
          break;
        case "radio":
          modelToUse = vModelRadio;
          break;
        default:
          modelToUse = vModelText;
      }
  }
  const fn3 = modelToUse[hook];
  fn3 && fn3(el, binding, vnode2, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode2) => {
    if (vnode2.props && looseEqual(vnode2.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode2) => {
    if (isArray$b(value)) {
      if (vnode2.props && looseIndexOf(value, vnode2.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet$2(value)) {
      if (vnode2.props && value.has(vnode2.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn3, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn3(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn3, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn3(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const rendererOptions = extend$1({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render$28 = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container2 = normalizeContainer(containerOrSelector);
    if (!container2)
      return;
    const component2 = app._component;
    if (!isFunction$6(component2) && !component2.render && !component2.template) {
      component2.template = container2.innerHTML;
    }
    container2.innerHTML = "";
    const proxy = mount(container2, false, container2 instanceof SVGElement);
    if (container2 instanceof Element) {
      container2.removeAttribute("v-cloak");
      container2.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container2 = normalizeContainer(containerOrSelector);
    if (container2) {
      return mount(container2, true, container2 instanceof SVGElement);
    }
  };
  return app;
};
function normalizeContainer(container2) {
  if (isString$3(container2)) {
    const res = document.querySelector(container2);
    return res;
  }
  return container2;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const compile = () => {
};
var vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  compile,
  EffectScope,
  ReactiveEffect,
  computed,
  customRef,
  effect: effect$6,
  effectScope,
  getCurrentScope,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  markRaw,
  onScopeDispose,
  proxyRefs,
  reactive,
  readonly,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  stop: stop$2,
  toRaw,
  toRef,
  toRefs: toRefs$1,
  triggerRef,
  unref,
  camelize,
  capitalize,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  toDisplayString: toDisplayString$1,
  toHandlerKey,
  BaseTransition,
  Comment,
  Fragment,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  cloneVNode,
  compatUtils,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  defineEmits,
  defineExpose,
  defineProps,
  get devtools() {
    return devtools$1;
  },
  getCurrentInstance,
  getTransitionRawChildren,
  guardReactiveProps,
  h: h$1,
  handleError,
  initCustomFormatter,
  inject,
  isMemoSame,
  isRuntimeOnly,
  isVNode,
  mergeDefaults,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  queuePostFlushCb,
  registerRuntimeCompiler,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  ssrContextKey,
  ssrUtils,
  toHandlers,
  transformVNodeArgs,
  useAttrs: useAttrs$2,
  useSSRContext,
  useSlots,
  useTransitionState,
  version: version$4,
  warn: warn$1,
  watch: watch$1,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withMemo,
  withScopeId,
  Transition,
  TransitionGroup,
  VueElement,
  createApp,
  createSSRApp,
  defineCustomElement,
  defineSSRCustomElement,
  hydrate,
  initDirectivesForSSR,
  render: render$28,
  useCssModule,
  useCssVars,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  withKeys,
  withModifiers
});
const version$3 = "1.0.21";
const generateId = () => Math.floor(Math.random() * 1e4);
const isBool = (val) => typeof val === "boolean";
const isHTMLElement$2 = (val) => toRawType(val).startsWith("HTML");
const isNumber$3 = (val) => typeof val === "number";
function addUnit(value) {
  if (isString$3(value)) {
    return value;
  } else if (isNumber$3(value)) {
    return `${value}px`;
  }
  return "";
}
function useGlobalConfig$2() {
  const vm = getCurrentInstance();
  if ("$HKUST" in vm.proxy) {
    return vm.proxy.$HKUST;
  }
  return {};
}
const NOOP = () => {
};
function withInstall$2(main2, extra) {
  main2.install = (app) => {
    for (const comp of [main2, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key2, comp] of Object.entries(extra)) {
      main2[key2] = comp;
    }
  }
  return main2;
}
const withNoopInstall$1 = (component2) => {
  component2.install = NOOP;
  return component2;
};
function mitt(n) {
  return { all: n = n || new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace"
};
const triggerEvent = function(elm, name, ...opts) {
  let eventName;
  if (name.includes("mouse") || name.includes("click")) {
    eventName = "MouseEvents";
  } else if (name.includes("key")) {
    eventName = "KeyboardEvent";
  } else {
    eventName = "HTMLEvents";
  }
  const evt = document.createEvent(eventName);
  evt.initEvent(name, ...opts);
  elm.dispatchEvent(evt);
  return elm;
};
class SubMenu {
  constructor(parent, domNode) {
    this.parent = parent;
    this.domNode = domNode;
    this.subIndex = 0;
    this.subIndex = 0;
    this.init();
  }
  init() {
    this.subMenuItems = this.domNode.querySelectorAll("li");
    this.addListeners();
  }
  gotoSubIndex(idx) {
    if (!this.subMenuItems)
      return;
    if (idx === this.subMenuItems.length) {
      idx = 0;
    } else if (idx < 0) {
      idx = this.subMenuItems.length - 1;
    }
    this.subMenuItems[idx].focus();
    this.subIndex = idx;
  }
  addListeners() {
    if (!this.subMenuItems)
      return;
    const parentNode = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, (el) => {
      el.addEventListener("keydown", (event) => {
        let prevDef = false;
        switch (event.code) {
          case EVENT_CODE.down: {
            this.gotoSubIndex(this.subIndex + 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.up: {
            this.gotoSubIndex(this.subIndex - 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.tab: {
            triggerEvent(parentNode, "mouseleave");
            break;
          }
          case EVENT_CODE.enter:
          case EVENT_CODE.space: {
            prevDef = true;
            event.currentTarget.click();
            break;
          }
        }
        if (prevDef) {
          event.preventDefault();
          event.stopPropagation();
        }
        return;
      });
    });
  }
}
class MenuItem {
  constructor(domNode) {
    this.domNode = domNode;
    this.submenu = null;
    this.submenu = null;
    this.init();
  }
  init() {
    this.domNode.setAttribute("tabindex", "0");
    const menuChild = this.domNode.querySelector(".hkust-menu");
    if (menuChild) {
      this.submenu = new SubMenu(this, menuChild);
    }
    this.addListeners();
  }
  addListeners() {
    this.domNode.addEventListener("keydown", (event) => {
      let prevDef = false;
      switch (event.code) {
        case EVENT_CODE.down: {
          triggerEvent(event.currentTarget, "mouseenter");
          this.submenu && this.submenu.gotoSubIndex(0);
          prevDef = true;
          break;
        }
        case EVENT_CODE.up: {
          triggerEvent(event.currentTarget, "mouseenter");
          this.submenu && this.submenu.subMenuItems && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
          prevDef = true;
          break;
        }
        case EVENT_CODE.tab: {
          triggerEvent(event.currentTarget, "mouseleave");
          break;
        }
        case EVENT_CODE.enter:
        case EVENT_CODE.space: {
          prevDef = true;
          event.currentTarget.click();
          break;
        }
      }
      if (prevDef) {
        event.preventDefault();
      }
    });
  }
}
class Menu {
  constructor(domNode) {
    this.domNode = domNode;
    this.init();
  }
  init() {
    const menuChildren = this.domNode.childNodes;
    [].filter.call(menuChildren, (child) => child.nodeType === 1).forEach((child) => {
      new MenuItem(child);
    });
  }
}
var script$j = defineComponent({
  name: "HkustMenu",
  componentName: "HkustMenu",
  props: {
    mode: {
      type: String,
      default: "vertical"
    },
    defaultActive: {
      type: String,
      default: ""
    },
    router: Boolean,
    defaultOpeneds: {
      type: Array
    },
    collapse: Boolean,
    textColor: { type: String },
    activeTextColor: { type: String },
    backgroundColor: { type: String },
    hoverBackgroundColor: { type: String },
    uniqueOpened: Boolean,
    menuTrigger: {
      type: String,
      default: "hover"
    },
    offset: {
      type: Number,
      default: 2
    },
    placement: String,
    showTimeout: Number,
    hideTimeout: Number,
    collapseTransition: {
      type: Boolean,
      default: true
    }
  },
  emits: ["close", "open", "select"],
  setup(props2, ctx) {
    const openedMenus = ref(props2.defaultOpeneds && !props2.collapse ? props2.defaultOpeneds.slice(0) : []);
    const instance = getCurrentInstance();
    const activeIndex = ref(props2.defaultActive);
    const items = ref({});
    const submenus = ref({});
    const rootMenuEmitter = mitt();
    const router = instance.appContext.config.globalProperties.$router;
    const isMenuPopup = computed(() => {
      return props2.mode === "horizontal" || props2.mode === "vertical" && props2.collapse;
    });
    const openMenu = (index2, indexPath) => {
      if (openedMenus.value.includes(index2))
        return;
      if (props2.uniqueOpened) {
        openedMenus.value = openedMenus.value.filter((i) => {
          return (isRef(indexPath) ? indexPath.value : indexPath).indexOf(i) !== -1;
        });
      }
      openedMenus.value.push(index2);
    };
    const closeMenu = (index2) => {
      const i = openedMenus.value.indexOf(index2);
      if (i !== -1) {
        openedMenus.value.splice(i, 1);
      }
    };
    const open2 = (index2) => {
      const { indexPath } = submenus.value[index2.toString()];
      indexPath.forEach((i) => openMenu(i, indexPath));
    };
    const close2 = (index2) => {
      closeMenu(index2);
    };
    const initializeMenu = () => {
      const index2 = activeIndex.value;
      const activeItem = items.value[index2];
      if (!activeItem || props2.mode === "horizontal" || props2.collapse)
        return;
      const indexPath = activeItem.indexPath;
      indexPath.forEach((index22) => {
        const submenu2 = submenus.value[index22];
        submenu2 && openMenu(index22, submenu2 == null ? void 0 : submenu2.indexPath);
      });
    };
    const handleSubmenuClick = (submenu2) => {
      const { index: index2, indexPath } = submenu2;
      const isOpened = openedMenus.value.includes(index2);
      if (isOpened) {
        closeMenu(index2);
        ctx.emit("close", index2, indexPath.value);
      } else {
        openMenu(index2, indexPath);
        ctx.emit("open", index2, indexPath.value);
      }
    };
    const handleItemClick = (item2) => {
      const { index: index2, indexPath } = item2;
      const hasIndex = item2.index !== null;
      const oldActiveIndex = activeIndex.value;
      if (hasIndex) {
        activeIndex.value = item2.index;
      }
      ctx.emit("select", index2, indexPath.value, item2);
      if (props2.mode === "horizontal" || props2.collapse) {
        openedMenus.value = [];
      }
      if (props2.router && router && hasIndex) {
        const route = item2.route || item2.index;
        try {
          router == null ? void 0 : router.push(route, () => null, (error2) => {
            activeIndex.value = oldActiveIndex;
            if (error2) {
              if (error2.name === "NavigationDuplicated")
                return;
              console.error(error2);
            }
          });
        } catch (e) {
          console.error(e);
        }
      }
    };
    const addMenuItem = (item2) => {
      items.value[item2.index] = item2;
    };
    const removeMenuItem = (item2) => {
      delete items.value[item2.index];
    };
    const addSubMenu = (item2) => {
      submenus.value[item2.index] = item2;
    };
    const removeSubMenu = (item2) => {
      delete submenus.value[item2.index];
    };
    provide("rootMenu", {
      props: props2,
      openedMenus,
      items,
      submenus,
      activeIndex,
      isMenuPopup,
      methods: {
        addMenuItem,
        removeMenuItem,
        addSubMenu,
        removeSubMenu,
        openMenu,
        closeMenu
      },
      rootMenuEmit: rootMenuEmitter.emit,
      rootMenuOn: rootMenuEmitter.on
    });
    provide(`submenu:${instance.uid}`, {
      addSubMenu: () => null,
      removeSubMenu: () => null,
      handleMouseleave: () => null,
      addMenuItem: () => null,
      removeMenuItem: () => null
    });
    onMounted(() => {
      initializeMenu();
      rootMenuEmitter.on("menuItem:item-click", handleItemClick);
      rootMenuEmitter.on("submenu:submenu-click", handleSubmenuClick);
      if (props2.mode === "horizontal") {
        new Menu(instance == null ? void 0 : instance.vnode.el);
      }
    });
    return {
      props: props2,
      open: open2,
      close: close2
    };
  }
});
function render$27(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", {
    key: +_ctx.props.collapse,
    role: "menubar",
    style: normalizeStyle({ backgroundColor: _ctx.props.backgroundColor || "" }),
    class: normalizeClass({
      "hkust-menu": true,
      "hkust-menu--horizontal": _ctx.mode === "horizontal",
      "hkust-menu--collapse": _ctx.props.collapse
    })
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
script$j.render = render$27;
script$j.__file = "packages/components/menu/src/index.vue";
function useMenu$1(instance, currentIndex) {
  const rootMenu = inject("rootMenu");
  const indexPath = computed(() => {
    let parent = instance.parent;
    const path = [currentIndex];
    while (parent.type.name !== "HkustMenu") {
      if (parent.props.index) {
        path.unshift(parent.props.index);
      }
      parent = parent.parent;
    }
    return path;
  });
  const parentMenu = computed(() => {
    let parent = instance.parent;
    while (parent && ["HkustMenu", "HkustSubmenu"].indexOf(parent.type.name) === -1) {
      parent = parent.parent;
    }
    return parent;
  });
  const paddingStyle = computed(() => {
    let parent = instance.parent;
    if (rootMenu.props.mode !== "vertical")
      return {};
    let padding = 20;
    if (rootMenu.props.collapse) {
      padding = 20;
    } else {
      while (parent && parent.type.name !== "HkustMenu") {
        if (parent.type.name === "HkustSubmenu") {
          padding += 20;
        }
        parent = parent.parent;
      }
    }
    return { paddingLeft: `${padding}px` };
  });
  return {
    indexPath,
    parentMenu,
    paddingStyle
  };
}
var script$i = defineComponent({
  name: "HkustMenuItem",
  componentName: "HkustMenuItem",
  props: {
    disabled: Boolean,
    index: {
      type: String,
      default: ""
    },
    route: {
      type: [String, Object],
      default: ""
    }
  },
  emits: ["click"],
  setup(props2, { emit }) {
    const instance = getCurrentInstance();
    const { parentMenu, paddingStyle, indexPath } = useMenu$1(instance, props2.index);
    const rootMenu = inject("rootMenu");
    const subMenu2 = inject(`submenu:${parentMenu.value.uid}`);
    const active = computed(() => {
      return props2.index === rootMenu.activeIndex.value;
    });
    const hoverBackgroundColor = computed(() => {
      return rootMenu.props.hoverBackgroundColor;
    });
    const backgroundColor = computed(() => {
      return rootMenu.props.backgroundColor || "";
    });
    const activeTextColor = computed(() => {
      return rootMenu.props.activeTextColor || "";
    });
    const textColor = computed(() => {
      return rootMenu.props.textColor || "";
    });
    const itemStyle = computed(() => {
      const style = {
        color: active.value ? activeTextColor.value : textColor.value
      };
      return style;
    });
    const mode = computed(() => {
      return rootMenu.props.mode;
    });
    const onMouseEnter = () => {
      if (mode.value === "horizontal" && !rootMenu.props.hoverBackgroundColor)
        return;
      instance.vnode.el.style.backgroundColor = hoverBackgroundColor.value;
    };
    const onMouseLeave = () => {
      if (mode.value === "horizontal" && !rootMenu.props.backgroundColor)
        return;
      instance.vnode.el.style.backgroundColor = backgroundColor.value;
    };
    const handleClick = () => {
      if (!props2.disabled) {
        rootMenu.rootMenuEmit("menuItem:item-click", {
          index: props2.index,
          indexPath,
          route: props2.route
        });
        emit("click", {
          index: props2.index,
          indexPath: indexPath.value
        });
      }
    };
    onMounted(() => {
      subMenu2 && subMenu2.addMenuItem({
        index: props2.index,
        indexPath,
        active
      });
      rootMenu.methods.addMenuItem({
        index: props2.index,
        indexPath,
        active
      });
    });
    onBeforeUnmount(() => {
      subMenu2 && subMenu2.removeMenuItem({
        index: props2.index,
        indexPath,
        active
      });
      rootMenu.methods.removeMenuItem({
        index: props2.index,
        indexPath,
        active
      });
    });
    return {
      active,
      itemStyle,
      paddingStyle,
      backgroundColor,
      handleClick,
      onMouseEnter,
      onMouseLeave
    };
  }
});
function render$26(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["hkust-menu-item", {
      "is-active": _ctx.active,
      "is-disabled": _ctx.disabled
    }]),
    role: "menuitem",
    tabindex: "-1",
    style: normalizeStyle([_ctx.paddingStyle, _ctx.itemStyle, { backgroundColor: _ctx.backgroundColor }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
    onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    renderSlot(_ctx.$slots, "default"),
    renderSlot(_ctx.$slots, "title")
  ], 38);
}
script$i.render = render$26;
script$i.__file = "packages/components/menu/src/menuItem.vue";
var isServer$9 = typeof window === "undefined";
const trim$1 = function(s2) {
  return (s2 || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
};
const on$1 = function(element, event, handler, useCapture = false) {
  if (element && event && handler) {
    element.addEventListener(event, handler, useCapture);
  }
};
function hasClass$1(el, cls) {
  if (!el || !cls)
    return false;
  if (cls.indexOf(" ") !== -1)
    throw new Error("className should not contain space.");
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return ` ${el.className} `.indexOf(` ${cls} `) > -1;
  }
}
function addClass$1(el, cls) {
  if (!el)
    return;
  let curClass = el.className;
  const classes = (cls || "").split(" ");
  for (let i = 0, j = classes.length; i < j; i++) {
    const clsName = classes[i];
    if (!clsName)
      continue;
    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass$1(el, clsName)) {
      curClass += ` ${clsName}`;
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
}
function removeClass$1(el, cls) {
  if (!el || !cls)
    return;
  const classes = cls.split(" ");
  let curClass = ` ${el.className} `;
  for (let i = 0, j = classes.length; i < j; i++) {
    const clsName = classes[i];
    if (!clsName)
      continue;
    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass$1(el, clsName)) {
      curClass = curClass.replace(` ${clsName} `, " ");
    }
  }
  if (!el.classList) {
    el.className = trim$1(curClass);
  }
}
const stop$1 = (e) => e.stopPropagation();
const nodeList = new Map();
let startClick;
if (!isServer$9) {
  on$1(document, "mousedown", (e) => startClick = e);
  on$1(document, "mouseup", (e) => {
    for (const { documentHandler } of nodeList.values()) {
      documentHandler(e, startClick);
    }
  });
}
function createDocumentHandler(el, binding) {
  let excludes = [];
  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else {
    excludes.push(binding.arg);
  }
  return function(mouseup, mousedown) {
    const popperRef = binding.instance.popperRef;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    const isSelf = el === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some((item2) => item2 == null ? void 0 : item2.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }
    binding.value(mouseup, mousedown);
  };
}
const ClickOutside = {
  beforeMount(el, binding) {
    nodeList.set(el, {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  updated(el, binding) {
    nodeList.set(el, {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  unmounted(el) {
    nodeList.delete(el);
  }
};
var Effect;
(function(Effect2) {
  Effect2["DARK"] = "dark";
  Effect2["LIGHT"] = "light";
})(Effect || (Effect = {}));
const DEFAULT_TRIGGER$1 = "hover";
const DEFAULT_FALLBACK_PLACEMENTS$1 = [];
var defaultProps = {
  arrowOffset: {
    type: Number,
    default: 5
  },
  appendToBody: {
    type: Boolean,
    default: true
  },
  autoClose: {
    type: Number,
    default: 0
  },
  boundariesPadding: {
    type: Number,
    default: 0
  },
  content: {
    type: String,
    default: ""
  },
  class: {
    type: String,
    default: ""
  },
  style: {
    type: Object,
    default: () => ({})
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  cutoff: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  effect: {
    type: String,
    default: Effect.DARK
  },
  enterable: {
    type: Boolean,
    default: true
  },
  manualMode: {
    type: Boolean,
    default: false
  },
  showAfter: {
    type: Number,
    default: 0
  },
  offset: {
    type: Number,
    default: 0
  },
  placement: {
    type: String,
    default: "bottom"
  },
  popperClass: {
    type: String,
    default: ""
  },
  pure: {
    type: Boolean,
    default: false
  },
  popperOptions: {
    type: Object,
    default: () => null
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  strategy: {
    type: String,
    default: "fixed"
  },
  transition: {
    type: String,
    default: "hkust-fade-in-linear"
  },
  trigger: {
    type: [String, Array],
    default: DEFAULT_TRIGGER$1
  },
  visible: {
    type: Boolean,
    default: false
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  fallbackPlacements: {
    type: Array,
    default: DEFAULT_FALLBACK_PLACEMENTS$1
  },
  teleportTarget: String
};
var top$2 = "top";
var bottom$2 = "bottom";
var right$2 = "right";
var left$1 = "left";
var auto$1 = "auto";
var basePlacements$1 = [top$2, bottom$2, right$2, left$1];
var start$1 = "start";
var end$1 = "end";
var clippingParents$1 = "clippingParents";
var viewport$1 = "viewport";
var popper$5 = "popper";
var reference$1 = "reference";
var variationPlacements$1 = /* @__PURE__ */ basePlacements$1.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start$1, placement + "-" + end$1]);
}, []);
var placements$1 = /* @__PURE__ */ [].concat(basePlacements$1, [auto$1]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start$1, placement + "-" + end$1]);
}, []);
var beforeRead$1 = "beforeRead";
var read$1 = "read";
var afterRead$1 = "afterRead";
var beforeMain$1 = "beforeMain";
var main$3 = "main";
var afterMain$1 = "afterMain";
var beforeWrite$1 = "beforeWrite";
var write$1 = "write";
var afterWrite$1 = "afterWrite";
var modifierPhases$1 = [beforeRead$1, read$1, afterRead$1, beforeMain$1, main$3, afterMain$1, beforeWrite$1, write$1, afterWrite$1];
function getNodeName$1(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow$1(node3) {
  if (node3 == null) {
    return window;
  }
  if (node3.toString() !== "[object Window]") {
    var ownerDocument = node3.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node3;
}
function isElement$1(node3) {
  var OwnElement = getWindow$1(node3).Element;
  return node3 instanceof OwnElement || node3 instanceof Element;
}
function isHTMLElement$1(node3) {
  var OwnElement = getWindow$1(node3).HTMLElement;
  return node3 instanceof OwnElement || node3 instanceof HTMLElement;
}
function isShadowRoot$1(node3) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow$1(node3).ShadowRoot;
  return node3 instanceof OwnElement || node3 instanceof ShadowRoot;
}
function applyStyles$2(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$5(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$3 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles$2,
  effect: effect$5,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max$1 = Math.max;
var min$1 = Math.min;
var round$1 = Math.round;
function getBoundingClientRect$1(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement$1(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round$1(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round$1(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getLayoutRect$1(element) {
  var clientRect = getBoundingClientRect$1(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains$1(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].indexOf(getNodeName$1(element)) >= 0;
}
function getDocumentElement$1(element) {
  return ((isElement$1(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode$1(element) {
  if (getNodeName$1(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot$1(element) ? element.host : null) || getDocumentElement$1(element);
}
function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock$1(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle$2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode$1(element);
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
    var css = getComputedStyle$2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent$1(element) {
  var window2 = getWindow$1(element);
  var offsetParent = getTrueOffsetParent$1(element);
  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock$1(element) || window2;
}
function getMainAxisFromPlacement$1(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within$1(min2, value, max2) {
  return max$1(min2, min$1(value, max2));
}
function withinMaxClamp$1(min2, value, max2) {
  var v2 = within$1(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject$1() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject$1(paddingObject) {
  return Object.assign({}, getFreshSideObject$1(), paddingObject);
}
function expandToHashMap$1(value, keys2) {
  return keys2.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject$1 = function toPaddingObject(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject$1(typeof padding !== "number" ? padding : expandToHashMap$1(padding, basePlacements$1));
};
function arrow$5(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement$1(basePlacement);
  var isVertical = [left$1, right$2].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject$1(options.padding, state);
  var arrowRect = getLayoutRect$1(arrowElement);
  var minProp = axis === "y" ? top$2 : left$1;
  var maxProp = axis === "y" ? bottom$2 : right$2;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent$1(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within$1(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$4(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains$1(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$6 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow$5,
  effect: effect$4,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation$1(placement) {
  return placement.split("-")[1];
}
var unsetSides$1 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR$1(_ref) {
  var x2 = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x2 * dpr) / dpr || 0,
    y: round$1(y * dpr) / dpr || 0
  };
}
function mapToStyles$1(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y
  }) : {
    x: x2,
    y
  };
  x2 = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left$1;
  var sideY = top$2;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent$1(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow$1(popper2)) {
      offsetParent = getDocumentElement$1(popper2);
      if (getComputedStyle$2(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top$2 || (placement === left$1 || placement === right$2) && variation === end$1) {
      sideY = bottom$2;
      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left$1 || (placement === top$2 || placement === bottom$2) && variation === end$1) {
      sideX = right$2;
      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides$1);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR$1({
    x: x2,
    y
  }) : {
    x: x2,
    y
  };
  x2 = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y + "px)" : "translate3d(" + x2 + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles$2(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation$1(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles$1(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles$1(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$3 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles$2,
  data: {}
};
var passive$1 = {
  passive: true
};
function effect$3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize2 = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow$1(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive$1);
    });
  }
  if (resize2) {
    window2.addEventListener("resize", instance.update, passive$1);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive$1);
      });
    }
    if (resize2) {
      window2.removeEventListener("resize", instance.update, passive$1);
    }
  };
}
var eventListeners$1 = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect$3,
  data: {}
};
var hash$3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$3[matched];
  });
}
var hash$2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement$1(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash$2[matched];
  });
}
function getWindowScroll$1(node3) {
  var win = getWindow$1(node3);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll$1(element).scrollLeft;
}
function getViewportRect$1(element) {
  var win = getWindow$1(element);
  var html = getDocumentElement$1(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX$1(element),
    y
  };
}
function getDocumentRect$1(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement$1(element);
  var winScroll = getWindowScroll$1(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX$1(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$2(body || html).direction === "rtl") {
    x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function isScrollParent$1(element) {
  var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent$1(node3) {
  if (["html", "body", "#document"].indexOf(getNodeName$1(node3)) >= 0) {
    return node3.ownerDocument.body;
  }
  if (isHTMLElement$1(node3) && isScrollParent$1(node3)) {
    return node3;
  }
  return getScrollParent$1(getParentNode$1(node3));
}
function listScrollParents$1(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent$1(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow$1(scrollParent);
  var target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent$1(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target2);
  return isBody ? updatedList : updatedList.concat(listScrollParents$1(getParentNode$1(target2)));
}
function rectToClientRect$1(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect$1(element) {
  var rect = getBoundingClientRect$1(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType$1(element, clippingParent) {
  return clippingParent === viewport$1 ? rectToClientRect$1(getViewportRect$1(element)) : isElement$1(clippingParent) ? getInnerBoundingClientRect$1(clippingParent) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
}
function getClippingParents$1(element) {
  var clippingParents2 = listScrollParents$1(getParentNode$1(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
  });
}
function getClippingRect$1(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents$1(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType$1(element, clippingParent);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType$1(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets$1(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation$1(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top$2:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom$2:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right$2:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left$1:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement$1(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start$1:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end$1:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow$1(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents$1 : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport$1 : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper$5 : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject$1(typeof padding !== "number" ? padding : expandToHashMap$1(padding, basePlacements$1));
  var altContext = elementContext === popper$5 ? reference$1 : popper$5;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect$1(isElement$1(element) ? element : element.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
  var popperOffsets2 = computeOffsets$1({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper$5 ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper$5 && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right$2, bottom$2].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top$2, bottom$2].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement$1(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements$1 : _options$allowedAutoP;
  var variation = getVariation$1(placement);
  var placements2 = variation ? flipVariations ? variationPlacements$1 : variationPlacements$1.filter(function(placement2) {
    return getVariation$1(placement2) === variation;
  }) : basePlacements$1;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow$1(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements$1(placement) {
  if (getBasePlacement$1(placement) === auto$1) {
    return [];
  }
  var oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeVariationPlacement$1(placement), oppositePlacement, getOppositeVariationPlacement$1(oppositePlacement)];
}
function flip$2(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement$1(preferredPlacement)] : getExpandedFallbackPlacements$1(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto$1 ? computeAutoPlacement$1(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation$1(placement) === start$1;
    var isVertical = [top$2, bottom$2].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow$1(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right$2 : left$1 : isStartVariation ? bottom$2 : top$2;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement$1(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement$1(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$3 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip$2,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets$1(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped$1(overflow) {
  return [top$2, right$2, bottom$2, left$1].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide$2(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow$1(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow$1(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets$1(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets$1(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped$1(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped$1(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$3 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide$2
};
function distanceAndSkiddingToXY$1(placement, rects, offset2) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left$1, top$2].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left$1, right$2].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset$2(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements$1.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY$1(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state.placement], x2 = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data2;
}
var offset$3 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset$2
};
function popperOffsets$2(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets$1({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$3 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets$2,
  data: {}
};
function getAltAxis$1(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow$2(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow$1(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation$1(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement$1(basePlacement);
  var altAxis = getAltAxis$1(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top$2 : left$1;
    var altSide = mainAxis === "y" ? bottom$2 : right$2;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect$1(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject$1();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within$1(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent$1(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within$1(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top$2 : left$1;
    var _altSide = mainAxis === "x" ? bottom$2 : right$2;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top$2, left$1].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp$1(_tetherMin, _offset, _tetherMax) : within$1(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data2;
}
var preventOverflow$3 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow$2,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll$1(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll$1(node3) {
  if (node3 === getWindow$1(node3) || !isHTMLElement$1(node3)) {
    return getWindowScroll$1(node3);
  } else {
    return getHTMLElementScroll$1(node3);
  }
}
function isElementScaled$1(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect$1(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled$1(offsetParent);
  var documentElement = getDocumentElement$1(offsetParent);
  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect$1(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order$1(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result3 = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result3.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result3;
}
function orderModifiers$1(modifiers) {
  var orderedModifiers = order$1(modifiers);
  return modifierPhases$1.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$6(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName$1(modifiers) {
  var merged = modifiers.reduce(function(merged2, current2) {
    var existing = merged2[current2.name];
    merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
      options: Object.assign({}, existing.options, current2.options),
      data: Object.assign({}, existing.data, current2.data)
    }) : current2;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS$1 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator$1(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS$1, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents$1(reference2) : reference2.contextElement ? listScrollParents$1(reference2.contextElement) : [],
          popper: listScrollParents$1(popper2)
        };
        var orderedModifiers = orderModifiers$1(mergeByName$1([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements$1(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect$1(reference3, getOffsetParent$1(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect$1(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce$6(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements$1(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers$3 = [eventListeners$1, popperOffsets$3, computeStyles$3, applyStyles$3, offset$3, flip$3, preventOverflow$3, arrow$6, hide$3];
var createPopper$3 = /* @__PURE__ */ popperGenerator$1({
  defaultModifiers: defaultModifiers$3
});
let $ELEMENT$1 = {};
const getConfig$1 = (key2) => {
  return $ELEMENT$1[key2];
};
const onTouchMove = (e) => {
  e.preventDefault();
  e.stopPropagation();
};
const onModalClick = () => {
  PopupManager == null ? void 0 : PopupManager.doOnModalClick();
};
let hasModal = false;
let zIndex;
const getModal = function() {
  if (isServer$9)
    return;
  let modalDom = PopupManager.modalDom;
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement("div");
    PopupManager.modalDom = modalDom;
    on$1(modalDom, "touchmove", onTouchMove);
    on$1(modalDom, "click", onModalClick);
  }
  return modalDom;
};
const instances = {};
const PopupManager = {
  modalFade: true,
  modalDom: void 0,
  zIndex,
  getInstance(id) {
    return instances[id];
  },
  register(id, instance) {
    if (id && instance) {
      instances[id] = instance;
    }
  },
  deregister(id) {
    if (id) {
      instances[id] = null;
      delete instances[id];
    }
  },
  nextZIndex() {
    return ++PopupManager.zIndex;
  },
  modalStack: [],
  doOnModalClick() {
    const topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem)
      return;
    const instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal.value) {
      instance.close();
    }
  },
  openModal(id, zIndex2, dom2, modalClass, modalFade) {
    if (isServer$9)
      return;
    if (!id || zIndex2 === void 0)
      return;
    this.modalFade = modalFade;
    const modalStack2 = this.modalStack;
    for (let i = 0, j = modalStack2.length; i < j; i++) {
      const item2 = modalStack2[i];
      if (item2.id === id) {
        return;
      }
    }
    const modalDom = getModal();
    addClass$1(modalDom, "v-modal");
    if (this.modalFade && !hasModal) {
      addClass$1(modalDom, "v-modal-enter");
    }
    if (modalClass) {
      const classArr = modalClass.trim().split(/\s+/);
      classArr.forEach((item2) => addClass$1(modalDom, item2));
    }
    setTimeout(() => {
      removeClass$1(modalDom, "v-modal-enter");
    }, 200);
    if (dom2 && dom2.parentNode && dom2.parentNode.nodeType !== 11) {
      dom2.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }
    if (zIndex2) {
      modalDom.style.zIndex = String(zIndex2);
    }
    modalDom.tabIndex = 0;
    modalDom.style.display = "";
    this.modalStack.push({ id, zIndex: zIndex2, modalClass });
  },
  closeModal(id) {
    const modalStack2 = this.modalStack;
    const modalDom = getModal();
    if (modalStack2.length > 0) {
      const topItem = modalStack2[modalStack2.length - 1];
      if (topItem.id === id) {
        if (topItem.modalClass) {
          const classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach((item2) => removeClass$1(modalDom, item2));
        }
        modalStack2.pop();
        if (modalStack2.length > 0) {
          modalDom.style.zIndex = String(modalStack2[modalStack2.length - 1].zIndex);
        }
      } else {
        for (let i = modalStack2.length - 1; i >= 0; i--) {
          if (modalStack2[i].id === id) {
            modalStack2.splice(i, 1);
            break;
          }
        }
      }
    }
    if (modalStack2.length === 0) {
      if (this.modalFade) {
        addClass$1(modalDom, "v-modal-leave");
      }
      setTimeout(() => {
        if (modalStack2.length === 0) {
          if (modalDom.parentNode)
            modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = "none";
          PopupManager.modalDom = void 0;
        }
        removeClass$1(modalDom, "v-modal-leave");
      }, 200);
    }
  }
};
Object.defineProperty(PopupManager, "zIndex", {
  configurable: true,
  get() {
    if (zIndex === void 0) {
      zIndex = getConfig$1("zIndex") || 2e3;
    }
    return zIndex;
  },
  set(value) {
    zIndex = value;
  }
});
const getTopPopup = function() {
  if (isServer$9)
    return;
  if (PopupManager.modalStack.length > 0) {
    const topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup)
      return;
    const instance = PopupManager.getInstance(topPopup.id);
    return instance;
  }
};
if (!isServer$9) {
  on$1(window, "keydown", function(event) {
    if (event.code === EVENT_CODE.esc) {
      const topPopup = getTopPopup();
      if (topPopup && topPopup.closeOnPressEscape.value) {
        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction("cancel") : topPopup.close();
      }
    }
  });
}
function buildModifier(props2, externalModifiers = []) {
  const { arrow: arrow2, arrowOffset, offset: offset2, gpuAcceleration, fallbackPlacements } = props2;
  const modifiers = [
    {
      name: "offset",
      options: {
        offset: [0, offset2 != null ? offset2 : 8]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration,
        adaptive: gpuAcceleration
      }
    }
  ];
  if (arrow2) {
    modifiers.push({
      name: "arrow",
      options: {
        element: arrow2,
        padding: arrowOffset != null ? arrowOffset : 5
      }
    });
  }
  modifiers.push(...externalModifiers);
  return modifiers;
}
function usePopperOptions$2(props2, state) {
  return computed(() => {
    var _a;
    return __spreadProps(__spreadValues({
      placement: props2.placement
    }, props2.popperOptions), {
      modifiers: buildModifier({
        arrow: state.arrow.value,
        arrowOffset: props2.arrowOffset,
        offset: props2.offset,
        gpuAcceleration: props2.gpuAcceleration,
        fallbackPlacements: props2.fallbackPlacements
      }, (_a = props2.popperOptions) == null ? void 0 : _a.modifiers)
    });
  });
}
const UPDATE_VISIBLE_EVENT = "update:visible";
function usePopper$2(props2, { emit }) {
  const arrowRef = ref(null);
  const triggerRef2 = ref();
  const popperRef = ref(null);
  const popperId = `hkust-popper-${generateId()}`;
  let popperInstance = null;
  let showTimer = null;
  let hideTimer = null;
  let triggerFocused = false;
  const isManualMode = () => props2.manualMode || props2.trigger === "manual";
  const popperStyle = ref({
    zIndex: PopupManager.nextZIndex()
  });
  const popperOptions2 = usePopperOptions$2(props2, {
    arrow: arrowRef
  });
  const state = reactive({
    visible: !!props2.visible
  });
  const visibility = computed({
    get() {
      if (props2.disabled) {
        return false;
      } else {
        return isBool(props2.visible) ? props2.visible : state.visible;
      }
    },
    set(val) {
      if (isManualMode())
        return;
      isBool(props2.visible) ? emit(UPDATE_VISIBLE_EVENT, val) : state.visible = val;
    }
  });
  const teleportTarget = computed(() => {
    var _a;
    return (_a = props2.teleportTarget) != null ? _a : "body";
  });
  function _show() {
    if (props2.autoClose > 0) {
      hideTimer = window.setTimeout(() => {
        _hide();
      }, props2.autoClose);
    }
    visibility.value = true;
  }
  function _hide() {
    visibility.value = false;
  }
  function clearTimers() {
    showTimer && clearTimeout(showTimer);
    hideTimer && clearTimeout(hideTimer);
  }
  const show = () => {
    if (isManualMode() || props2.disabled)
      return;
    clearTimers();
    if (props2.showAfter === 0) {
      _show();
    } else {
      showTimer = window.setTimeout(() => {
        _show();
      }, props2.showAfter);
    }
  };
  const hide2 = () => {
    if (isManualMode())
      return;
    clearTimers();
    if (props2.hideAfter > 0) {
      hideTimer = window.setTimeout(() => {
        close2();
      }, props2.hideAfter);
    } else {
      close2();
    }
  };
  const close2 = () => {
    _hide();
    if (props2.disabled) {
      doDestroy(true);
    }
  };
  function onPopperMouseEnter() {
    if (props2.enterable && props2.trigger !== "click") {
      hideTimer && clearTimeout(hideTimer);
    }
  }
  function onPopperMouseLeave() {
    const { trigger: trigger2 } = props2;
    const shouldPrevent = isString$3(trigger2) && (trigger2 === "click" || trigger2 === "focus") || trigger2.length === 1 && (trigger2[0] === "click" || trigger2[0] === "focus");
    if (shouldPrevent)
      return;
    hide2();
  }
  function initializePopper() {
    if (!unref(visibility)) {
      return;
    }
    const unwrappedTrigger = unref(triggerRef2);
    const _trigger = isHTMLElement$2(unwrappedTrigger) ? unwrappedTrigger : unwrappedTrigger.$el;
    popperInstance = createPopper$3(_trigger, unref(popperRef), unref(popperOptions2));
    popperInstance.update();
  }
  function doDestroy(forceDestroy) {
    if (!popperInstance || unref(visibility) && !forceDestroy)
      return;
    detachPopper();
  }
  function detachPopper() {
    var _a;
    (_a = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a.call(popperInstance);
    popperInstance = null;
  }
  const events = {};
  function update3() {
    if (!unref(visibility)) {
      return;
    }
    if (popperInstance) {
      popperInstance.update();
    } else {
      initializePopper();
    }
  }
  function onVisibilityChange(toState) {
    if (toState) {
      popperStyle.value.zIndex = PopupManager.nextZIndex();
      initializePopper();
    }
  }
  if (!isManualMode()) {
    const toggleState = () => {
      if (unref(visibility)) {
        hide2();
      } else {
        show();
      }
    };
    const popperEventsHandler = (e) => {
      e.stopPropagation();
      switch (e.type) {
        case "click": {
          if (triggerFocused) {
            triggerFocused = false;
          } else {
            toggleState();
          }
          break;
        }
        case "mouseenter": {
          show();
          break;
        }
        case "mouseleave": {
          hide2();
          break;
        }
        case "focus": {
          triggerFocused = true;
          show();
          break;
        }
        case "blur": {
          triggerFocused = false;
          hide2();
          break;
        }
      }
    };
    const triggerEventsMap = {
      click: ["onClick"],
      hover: ["onMouseenter", "onMouseleave"],
      focus: ["onFocus", "onBlur"]
    };
    const mapEvents = (t) => {
      (triggerEventsMap && triggerEventsMap[t]).forEach((event) => {
        events[event] = popperEventsHandler;
      });
    };
    if (isArray$b(props2.trigger)) {
      Object.values(props2.trigger).forEach(mapEvents);
    } else {
      mapEvents(props2.trigger);
    }
  }
  watch$1(popperOptions2, (val) => {
    if (!popperInstance)
      return;
    popperInstance.setOptions(val);
    popperInstance.update();
  });
  watch$1(visibility, onVisibilityChange);
  return {
    update: update3,
    doDestroy,
    show,
    hide: hide2,
    onPopperMouseEnter,
    onPopperMouseLeave,
    onAfterEnter: () => {
      emit("after-enter");
    },
    onAfterLeave: () => {
      detachPopper();
      emit("after-leave");
    },
    onBeforeEnter: () => {
      emit("before-enter");
    },
    onBeforeLeave: () => {
      emit("before-leave");
    },
    initializePopper,
    isManualMode,
    arrowRef,
    events,
    popperId,
    popperInstance,
    popperRef,
    popperStyle,
    triggerRef: triggerRef2,
    visibility,
    teleportTarget
  };
}
function renderPopper(props2, children) {
  const {
    effect: effect2,
    name,
    stopPopperMouseEvent,
    popperClass,
    popperStyle,
    popperRef,
    pure,
    popperId,
    visibility,
    onMouseenter,
    onMouseleave,
    onAfterEnter,
    onAfterLeave,
    onBeforeEnter,
    onBeforeLeave
  } = props2;
  const kls = [
    popperClass,
    "hkust-popper",
    `is-${effect2}`,
    pure ? "is-pure" : ""
  ];
  const mouseUpAndDown = stopPopperMouseEvent ? stop$1 : NOOP$1;
  return h$1(Transition, {
    name,
    onAfterEnter,
    onAfterLeave,
    onBeforeEnter,
    onBeforeLeave
  }, {
    default: withCtx(() => [
      withDirectives(h$1("div", {
        "aria-hidden": String(!visibility),
        class: kls,
        style: popperStyle != null ? popperStyle : {},
        id: popperId,
        ref: popperRef != null ? popperRef : "popperRef",
        role: "tooltip",
        onMouseenter,
        onMouseleave,
        onClick: stop$1,
        onMousedown: mouseUpAndDown,
        onMouseup: mouseUpAndDown
      }, children), [[vShow, visibility]])
    ])
  });
}
class HkustUIError extends Error {
  constructor(m2) {
    super(m2);
    this.name = "HkustUIError";
  }
}
var throwError$1 = (scope, m2) => {
  throw new HkustUIError(`[${scope}] ${m2}`);
};
const TEMPLATE$1 = "template";
const isFragment$1 = (node3) => node3.type === Fragment;
const isComment$1 = (node3) => node3.type === Comment;
const isTemplate$1 = (node3) => node3.type === TEMPLATE$1;
function getChildren$1(node3, depth) {
  if (isComment$1(node3))
    return;
  if (isFragment$1(node3) || isTemplate$1(node3)) {
    return depth > 0 ? getFirstValidNode$1(node3.children, depth - 1) : void 0;
  }
  return node3;
}
const getFirstValidNode$1 = (nodes, maxDepth = 3) => {
  if (Array.isArray(nodes)) {
    return getChildren$1(nodes[0], maxDepth);
  } else {
    return getChildren$1(nodes, maxDepth);
  }
};
function renderTrigger(trigger2, extraProps) {
  const firstElement = getFirstValidNode$1(trigger2, 1);
  if (!firstElement)
    throwError$1("renderTrigger", "trigger expects single rooted node");
  return cloneVNode(firstElement, extraProps, true);
}
function renderArrow(showArrow) {
  return showArrow ? h$1("div", {
    ref: "arrowRef",
    class: "hkust-popper__arrow",
    "data-popper-arrow": ""
  }) : h$1(Comment, null, "");
}
var script$h = defineComponent({
  name: "HkustPopper",
  props: defaultProps,
  setup(props2, ctx) {
    const popperState = usePopper$2(props2, ctx);
    const forceDestroy = () => popperState.doDestroy(true);
    onMounted(popperState.initializePopper);
    onBeforeUnmount(forceDestroy);
    onActivated(popperState.initializePopper);
    onDeactivated(forceDestroy);
    return popperState;
  },
  render() {
    var _a;
    const {
      $slots,
      appendToBody,
      class: kls,
      style,
      effect: effect2,
      hide: hide2,
      onPopperMouseEnter,
      onPopperMouseLeave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave,
      popperClass,
      popperId,
      popperStyle,
      pure,
      showArrow,
      transition,
      visibility,
      stopPopperMouseEvent,
      teleportTarget
    } = this;
    const isManual = this.isManualMode();
    const arrow2 = renderArrow(showArrow);
    const _t = (_a = $slots.trigger) == null ? void 0 : _a.call($slots);
    const triggerProps = __spreadValues({
      "aria-describedby": popperId,
      class: kls,
      style,
      ref: "triggerRef"
    }, this.events);
    const trigger2 = isManual ? renderTrigger(_t, triggerProps) : withDirectives(renderTrigger(_t, triggerProps), [[ClickOutside, hide2]]);
    const popper2 = renderPopper({
      effect: effect2,
      name: transition,
      popperClass,
      popperId,
      popperStyle,
      pure,
      stopPopperMouseEvent,
      onMouseenter: onPopperMouseEnter,
      onMouseleave: onPopperMouseLeave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave,
      visibility
    }, [
      renderSlot($slots, "default", {}, () => {
        return [toDisplayString$1(this.content)];
      }),
      arrow2
    ]);
    return h$1(Fragment, null, [
      trigger2,
      h$1(Teleport, {
        to: teleportTarget,
        disabled: !appendToBody
      }, [popper2])
    ]);
  }
});
script$h.__file = "packages/components/popper/src/index.vue";
const _Popper = withInstall$2(script$h);
var script$g = defineComponent({
  name: "HkustSubmenu",
  componentName: "HkustSubmenu",
  props: {
    index: {
      type: String,
      required: true
    },
    backgroundColor: String,
    popperClass: String,
    popperAppendToBody: {
      type: Boolean,
      default: void 0
    },
    showIcon: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    offset: Number,
    placement: String,
    showTimeout: Number,
    hideTimeout: Number,
    submenuTeleport: String
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const { paddingStyle, indexPath, parentMenu } = useMenu$1(instance, props2.index);
    const rootMenu = inject("rootMenu");
    const parentSubMenu = inject(`submenu:${parentMenu.value.uid}`);
    const state = reactive({
      items: {},
      submenus: {},
      currentPlacement: "",
      mouseInChild: false
    });
    const subMenuEmitter = mitt();
    const popperVnode = ref();
    const verticalTitleRef = ref();
    const mode = computed(() => {
      return rootMenu.props.mode;
    });
    const placement = computed(() => {
      return props2.placement || rootMenu.props.placement || "bottom-start";
    });
    const active = computed(() => {
      const items = state.items;
      const submenus = state.submenus;
      if (Object.keys(items).some((index2) => items[index2].active))
        return true;
      if (Object.keys(submenus).some((index2) => submenus[index2].active))
        return true;
      return false;
    });
    const opened = computed(() => {
      return rootMenu.openedMenus.value.includes(props2.index);
    });
    const isFirstLevel = computed(() => {
      let isFirstLevel2 = true;
      let parent = instance.parent;
      while (parent && parent.type.name !== "HkustMenu") {
        if (["HkustSubmenu", "HkustMenuItemGroup"].includes(parent.type.name)) {
          isFirstLevel2 = false;
          break;
        } else {
          parent = parent.parent;
        }
      }
      return isFirstLevel2;
    });
    const titleIcon = computed(() => {
      return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? "hkust-icon-arrow-down-bold" : "hkust-icon-arrow-right-bold";
    });
    const titleStyle = computed(() => {
      if (mode.value !== "horizontal") {
        return {
          color: rootMenu.props.textColor || ""
        };
      }
      return {
        borderBottomColor: active.value ? rootMenu.props.activeTextColor || "" : "transparent",
        color: active.value ? rootMenu.props.activeTextColor : rootMenu.props.textColor
      };
    });
    const appendToBody = computed(() => {
      return props2.popperAppendToBody === void 0 ? isFirstLevel.value : Boolean(props2.popperAppendToBody);
    });
    const menuTransitionName = computed(() => {
      return rootMenu.props.collapse ? "hkust-zoom-in-left" : "hkust-zoom-in-top";
    });
    const showTimeout = computed(() => {
      return props2.showTimeout || rootMenu.props.showTimeout;
    });
    const hideTimeout = computed(() => {
      return props2.hideTimeout || rootMenu.props.hideTimeout;
    });
    const submenuOffset = computed(() => {
      return props2.offset || rootMenu.props.offset;
    });
    const submenuBackgroundColor = computed(() => {
      return props2.backgroundColor || rootMenu.props.backgroundColor;
    });
    const handleMouseenter = (ev) => {
      if (!("ActiveXObject" in window) && ev.type === "focus" && !ev.relatedTarget) {
        return;
      }
      if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props2.disabled) {
        return;
      }
      subMenuEmitter.emit("submenu:mouse-enter-child");
      setTimeout(() => {
        rootMenu.methods.openMenu(props2.index, indexPath);
      }, showTimeout.value);
      if (appendToBody.value) {
        parentMenu.value.vnode.el.dispatchEvent(new MouseEvent("mouseenter"));
      }
    };
    const handleMouseleave = (deepDispatch = false) => {
      if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") {
        return;
      }
      subMenuEmitter.emit("submenu:mouse-leave-child");
      setTimeout(() => {
        !state.mouseInChild && rootMenu.methods.closeMenu(props2.index);
      }, hideTimeout.value);
      if (appendToBody.value && deepDispatch) {
        if (instance.parent.type.name === "HkustSubmenu") {
          parentSubMenu.handleMouseleave(true);
        }
      }
    };
    const handleClick = () => {
      if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props2.disabled) {
        return;
      }
      rootMenu.rootMenuEmit("submenu:submenu-click", {
        index: props2.index,
        indexPath
      });
    };
    const handleTitleMouseenter = () => {
      if (mode.value === "horizontal" && !rootMenu.props.hoverBackgroundColor)
        return;
      const title = popperVnode.value ? popperVnode.value.triggerRef : verticalTitleRef.value;
      title && (title.style.backgroundColor = rootMenu.props.hoverBackgroundColor);
    };
    const handleTitleMouseleave = () => {
      if (mode.value === "horizontal" && !rootMenu.props.hoverBackgroundColor)
        return;
      const title = popperVnode.value ? popperVnode.value.triggerRef : verticalTitleRef.value;
      title && (title.style.backgroundColor = rootMenu.props.backgroundColor || "");
    };
    const addMenuItem = (item2) => {
      state.items[item2.index] = item2;
    };
    const removeMenuItem = (item2) => {
      delete state.items[item2.index];
    };
    const addSubMenu = (item2) => {
      state.submenus[item2.index] = item2;
    };
    const removeSubMenu = (item2) => {
      delete state.submenus[item2.index];
    };
    const updatePlacement = () => {
      state.currentPlacement = mode.value === "horizontal" && isFirstLevel.value ? placement.value : "right-start";
    };
    provide(`submenu:${instance.uid}`, {
      addSubMenu,
      removeSubMenu,
      handleMouseleave,
      addMenuItem,
      removeMenuItem
    });
    onBeforeMount(() => {
      subMenuEmitter.on("submenu:mouse-enter-child", () => {
        state.mouseInChild = true;
      });
      subMenuEmitter.on("submenu:mouse-leave-child", () => {
        state.mouseInChild = false;
      });
    });
    onMounted(() => {
      rootMenu.methods.addSubMenu({
        index: props2.index,
        indexPath,
        active
      });
      parentSubMenu && parentSubMenu.addSubMenu({
        index: props2.index,
        indexPath,
        active
      });
      updatePlacement();
    });
    onBeforeUnmount(() => {
      rootMenu.methods.removeSubMenu({
        index: props2.index,
        indexPath,
        active
      });
      parentSubMenu && parentSubMenu.removeSubMenu({
        index: props2.index,
        indexPath,
        active
      });
    });
    return {
      state,
      mode,
      rootMenu,
      submenuOffset,
      teleportTarget: props2.submenuTeleport,
      rootBackgroundColor: rootMenu.props.backgroundColor,
      submenuBackgroundColor,
      active,
      opened,
      appendToBody,
      titleIcon,
      titleStyle,
      paddingStyle,
      verticalTitleRef,
      addMenuItem,
      removeMenuItem,
      handleMouseenter,
      handleMouseleave,
      handleClick,
      handleTitleMouseenter,
      handleTitleMouseleave,
      isMenuPopup: rootMenu.isMenuPopup,
      menuTransitionName
    };
  },
  render() {
    var _a, _b, _c, _d, _e, _f;
    const title = [
      (_b = (_a = this.$slots).title) == null ? void 0 : _b.call(_a),
      this.$slots.icon ? (_d = (_c = this.$slots).icon) == null ? void 0 : _d.call(_c) : this.showIcon ? h$1("i", {
        class: ["hkust-submenu__icon-arrow", this.titleIcon]
      }) : null
    ];
    const submenuStyle = {
      backgroundColor: this.submenuBackgroundColor || ""
    };
    const child = this.isMenuPopup ? h$1(_Popper, {
      ref: "popperVNode",
      teleportTarget: this.teleportTarget,
      manualMode: true,
      visible: this.opened,
      "onUpdate:visible": (val) => this.opened = val,
      effect: "light",
      pure: true,
      offset: this.submenuOffset,
      showArrow: false,
      popperClass: this.popperClass,
      placement: this.state.currentPlacement,
      appendToBody: this.appendToBody,
      transition: this.menuTransitionName,
      gpuAcceleration: false
    }, {
      default: () => {
        var _a2, _b2;
        return h$1("div", {
          ref: "menu",
          class: [`hkust-menu--${this.mode}`, this.popperClass],
          onMouseenter: ($event) => this.handleMouseenter($event),
          onMouseleave: () => this.handleMouseleave(true),
          onFocus: ($event) => this.handleMouseenter($event)
        }, h$1("ul", {
          class: [
            "hkust-menu hkust-menu--popup",
            `hkust-menu--popup-${this.state.currentPlacement}`
          ],
          style: submenuStyle
        }, (_b2 = (_a2 = this.$slots).default) == null ? void 0 : _b2.call(_a2)));
      },
      trigger: () => h$1("div", {
        class: "hkust-submenu__title",
        style: [
          this.paddingStyle,
          this.titleStyle,
          { backgroundColor: this.rootBackgroundColor }
        ],
        onClick: this.handleClick,
        onMouseenter: this.handleTitleMouseenter,
        onMouseleave: this.handleTitleMouseleave
      }, title)
    }) : h$1(Fragment, {}, [
      h$1("div", {
        class: "hkust-submenu__title",
        style: [
          this.paddingStyle,
          this.titleStyle,
          { backgroundColor: this.rootBackgroundColor }
        ],
        ref: "verticalTitleRef",
        onClick: this.handleClick,
        onMouseenter: this.handleTitleMouseenter,
        onMouseleave: this.handleTitleMouseleave
      }, title),
      withDirectives(h$1("ul", {
        role: "menu",
        class: "hkust-menu hkust-menu--inline",
        style: submenuStyle
      }, [(_f = (_e = this.$slots).default) == null ? void 0 : _f.call(_e)]), [[vShow, this.opened]])
    ]);
    return h$1("li", {
      class: [
        "hkust-submenu",
        {
          "is-active": this.active,
          "is-opened": this.opened,
          "is-disabled": this.disabled
        }
      ],
      role: "menuitem",
      ariaHaspopup: true,
      onMouseenter: this.handleMouseenter,
      onMouseleave: () => this.handleMouseleave(true),
      onFocus: this.handleMouseenter
    }, [child]);
  }
});
script$g.__file = "packages/components/menu/src/submenu.vue";
const HkustMenu = withInstall$2(script$j, {
  MenuItem: script$i,
  Submenu: script$g
});
const HkustMenuItem = withNoopInstall$1(script$i);
const HkustSubmenu = withNoopInstall$1(script$g);
const useDropdown$2 = () => {
  const HKUST = useGlobalConfig$2();
  const hkustDropdown = inject("hkustDropdown", {});
  const _hkustDropdownSize = computed(() => hkustDropdown == null ? void 0 : hkustDropdown.dropdownSize);
  return {
    HKUST,
    hkustDropdown,
    _hkustDropdownSize
  };
};
const initDropdownDomEvent$1 = (dropdownChildren, triggerElm, _instance) => {
  const menuItems = ref(null);
  const menuItemsArray = ref(null);
  const dropdownElm = ref(null);
  if (!triggerElm || !dropdownElm.value) {
    return false;
  }
  const listId = ref(`dropdown-menu-${generateId()}`);
  dropdownElm.value = dropdownChildren == null ? void 0 : dropdownChildren.subTree.el;
  function removeTabindex() {
    var _a;
    triggerElm.setAttribute("tabindex", "-1");
    (_a = menuItemsArray.value) == null ? void 0 : _a.forEach((item2) => {
      item2.setAttribute("tabindex", "-1");
    });
  }
  function resetTabindex(ele) {
    removeTabindex();
    ele == null ? void 0 : ele.setAttribute("tabindex", "0");
  }
  function handleTriggerKeyDown(ev) {
    if (!menuItems.value) {
      return false;
    }
    const code2 = ev.code;
    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code2)) {
      removeTabindex();
      resetTabindex(menuItems.value[0]);
      menuItems.value[0].focus();
      ev.preventDefault();
      ev.stopPropagation();
    } else if (code2 === EVENT_CODE.enter) {
      _instance.handleClick();
    } else if ([EVENT_CODE.tab, EVENT_CODE.esc].includes(code2)) {
      _instance.hide();
    }
  }
  function handleItemKeyDown(ev) {
    if (!menuItemsArray.value || !menuItems.value) {
      return false;
    }
    const code2 = ev.code;
    const target2 = ev.target;
    const currentIndex = menuItemsArray.value.indexOf(target2);
    const max2 = menuItemsArray.value.length - 1;
    let nextIndex;
    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code2)) {
      if (code2 === EVENT_CODE.up) {
        nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
      } else {
        nextIndex = currentIndex < max2 ? currentIndex + 1 : max2;
      }
      removeTabindex();
      resetTabindex(menuItems.value[nextIndex]);
      menuItems.value[nextIndex].focus();
      ev.preventDefault();
      ev.stopPropagation();
    } else if (code2 === EVENT_CODE.enter) {
      triggerElmFocus();
      target2.click();
      if (_instance.props.hideOnClick) {
        _instance.hide();
      }
    } else if ([EVENT_CODE.tab, EVENT_CODE.esc].includes(code2)) {
      _instance.hide();
      triggerElmFocus();
    }
  }
  function initAria() {
    dropdownElm.value.setAttribute("id", listId.value);
    triggerElm.setAttribute("aria-haspopup", "list");
    triggerElm.setAttribute("aria-controls", listId.value);
    if (!_instance.props.splitButton) {
      triggerElm.setAttribute("role", "button");
      triggerElm.setAttribute("tabindex", _instance.props.tabindex);
      addClass$1(triggerElm, "hkust-dropdown-selfdefine");
    }
  }
  function initEvent() {
    on$1(triggerElm, "keydown", handleTriggerKeyDown);
    on$1(dropdownElm.value, "keydown", handleItemKeyDown, true);
  }
  function initDomOperation() {
    menuItems.value = dropdownElm.value.querySelectorAll("[tabindex='-1']");
    menuItemsArray.value = [].slice.call(menuItems.value);
    initEvent();
    initAria();
  }
  function triggerElmFocus() {
    triggerElm.focus();
  }
  initDomOperation();
};
var script$f = defineComponent({
  name: "HkustDropdown",
  components: {
    HkustPopper: _Popper
  },
  props: {
    trigger: {
      type: String,
      default: "hover"
    },
    type: String,
    size: {
      type: String,
      default: ""
    },
    splitButton: Boolean,
    hideOnClick: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      default: "bottom"
    },
    showTimeout: {
      type: Number,
      default: 150
    },
    hideTimeout: {
      type: Number,
      default: 150
    },
    tabindex: {
      type: [Number, String],
      default: 0
    },
    effect: {
      type: String,
      default: "light"
    },
    maxHeight: {
      type: [Number, String],
      default: ""
    },
    teleportTarget: String
  },
  emits: ["visible-change", "click", "command"],
  setup(props2, { emit }) {
    const _instance = getCurrentInstance();
    const { HKUST } = useDropdown$2();
    const timeout = ref(null);
    const visible = ref(false);
    const scrollbar3 = ref(null);
    const wrapStyle = computed(() => `max-height: ${addUnit(props2.maxHeight)}`);
    watch$1(() => visible.value, (val) => {
      if (val)
        triggerElmFocus();
      if (!val)
        triggerElmBlur();
      emit("visible-change", val);
    });
    const focusing = ref(false);
    watch$1(() => focusing.value, (val) => {
      const selfDefine = triggerElm.value;
      if (selfDefine) {
        if (val) {
          addClass$1(selfDefine, "focusing");
        } else {
          removeClass$1(selfDefine, "focusing");
        }
      }
    });
    const triggerVnode = ref(null);
    const triggerElm = computed(() => {
      var _a, _b, _c, _d;
      const _2 = (_c = (_b = (_a = triggerVnode.value) == null ? void 0 : _a.$refs.triggerRef) == null ? void 0 : _b.children[0]) != null ? _c : {};
      return !props2.splitButton ? _2 : (_d = _2.children) == null ? void 0 : _d[1];
    });
    function handleClick() {
      var _a;
      if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
        return;
      if (visible.value) {
        hide2();
      } else {
        show();
      }
    }
    function show() {
      var _a;
      if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
        return;
      timeout.value && clearTimeout(timeout.value);
      timeout.value = window.setTimeout(() => {
        visible.value = true;
      }, ["click", "contextmenu"].includes(props2.trigger) ? 0 : props2.showTimeout);
    }
    function hide2() {
      var _a;
      if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
        return;
      removeTabindex();
      if (props2.tabindex >= 0) {
        resetTabindex(triggerElm.value);
      }
      timeout.value && clearTimeout(timeout.value);
      timeout.value = window.setTimeout(() => {
        visible.value = false;
      }, ["click", "contextmenu"].includes(props2.trigger) ? 0 : props2.hideTimeout);
    }
    function removeTabindex() {
      var _a;
      (_a = triggerElm.value) == null ? void 0 : _a.setAttribute("tabindex", "-1");
    }
    function resetTabindex(ele) {
      removeTabindex();
      ele == null ? void 0 : ele.setAttribute("tabindex", "0");
    }
    function triggerElmFocus() {
      var _a, _b;
      (_b = (_a = triggerElm.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    }
    function triggerElmBlur() {
      var _a, _b;
      (_b = (_a = triggerElm.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
    }
    const dropdownSize = computed(() => props2.size || HKUST.size);
    function commandHandler(...args) {
      emit("command", ...args);
    }
    provide("hkustDropdown", {
      instance: _instance,
      dropdownSize,
      visible,
      handleClick,
      commandHandler,
      show,
      hide: hide2,
      trigger: computed(() => props2.trigger),
      hideOnClick: computed(() => props2.hideOnClick),
      triggerElm
    });
    onMounted(() => {
      if (!props2.splitButton) {
        on$1(triggerElm.value, "focus", () => {
          focusing.value = true;
        });
        on$1(triggerElm.value, "blur", () => {
          focusing.value = false;
        });
        on$1(triggerElm.value, "click", () => {
          focusing.value = false;
        });
      }
      if (props2.trigger === "hover") {
        on$1(triggerElm.value, "mouseenter", show);
        on$1(triggerElm.value, "mouseleave", hide2);
      } else if (props2.trigger === "click") {
        on$1(triggerElm.value, "click", handleClick);
      } else if (props2.trigger === "contextmenu") {
        on$1(triggerElm.value, "contextmenu", (e) => {
          e.preventDefault();
          handleClick();
        });
      }
      Object.assign(_instance, {
        handleClick,
        hide: hide2,
        resetTabindex
      });
    });
    const handlerMainButtonClick = (event) => {
      emit("click", event);
      hide2();
    };
    return {
      visible,
      scrollbar: scrollbar3,
      wrapStyle,
      dropdownSize,
      handlerMainButtonClick,
      triggerVnode
    };
  }
});
function render$25(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_hkust_popper = resolveComponent("hkust-popper");
  return openBlock(), createBlock(_component_hkust_popper, {
    ref: "triggerVnode",
    visible: _ctx.visible,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.visible = $event),
    placement: _ctx.placement,
    effect: _ctx.effect,
    pure: true,
    "manual-mode": true,
    trigger: _ctx.trigger,
    "popper-class": "hkust-dropdown__popper",
    "append-to-body": "",
    transition: "hkust-zoom-in-top",
    "stop-popper-mouse-event": false,
    "gpu-acceleration": false,
    "teleport-target": _ctx.teleportTarget
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "dropdown")
    ]),
    trigger: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass([
          "hkust-dropdown",
          _ctx.dropdownSize ? "hkust-dropdown--" + _ctx.dropdownSize : ""
        ])
      }, [
        !_ctx.splitButton ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["visible", "placement", "effect", "trigger", "teleport-target"]);
}
script$f.render = render$25;
script$f.__file = "packages/components/dropdown/src/dropdown.vue";
var script$e = defineComponent({
  name: "HkustDropdownItem",
  props: {
    command: {
      type: [Object, String, Number],
      default: () => ({})
    },
    disabled: Boolean,
    divided: Boolean,
    icon: String
  },
  setup(props2) {
    const { hkustDropdown } = useDropdown$2();
    const _instance = getCurrentInstance();
    function handleClick(e) {
      var _a, _b, _c;
      if (props2.disabled) {
        e.stopImmediatePropagation();
        return;
      }
      if ((_a = hkustDropdown.hideOnClick) == null ? void 0 : _a.value) {
        (_b = hkustDropdown.handleClick) == null ? void 0 : _b.call(hkustDropdown);
      }
      (_c = hkustDropdown.commandHandler) == null ? void 0 : _c.call(hkustDropdown, props2.command, _instance, e);
    }
    return {
      handleClick
    };
  }
});
const _hoisted_1$5V = ["aria-disabled", "tabindex"];
function render$24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["hkust-dropdown-menu__item", {
      "is-disabled": _ctx.disabled,
      "hkust-dropdown-menu__item--divided": _ctx.divided
    }]),
    "aria-disabled": _ctx.disabled,
    tabindex: _ctx.disabled ? void 0 : -1,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.icon ? (openBlock(), createElementBlock("i", {
      key: 0,
      class: normalizeClass(_ctx.icon)
    }, null, 2)) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_1$5V);
}
script$e.render = render$24;
script$e.__file = "packages/components/dropdown/src/dropdown-item.vue";
var script$d = defineComponent({
  name: "HkustDropdownMenu",
  directives: {},
  setup() {
    const { _hkustDropdownSize, hkustDropdown } = useDropdown$2();
    const size2 = _hkustDropdownSize.value;
    function show() {
      var _a;
      if (["click", "contextmenu"].includes(hkustDropdown.trigger.value))
        return;
      (_a = hkustDropdown.show) == null ? void 0 : _a.call(hkustDropdown);
    }
    function hide2() {
      if (["click", "contextmenu"].includes(hkustDropdown.trigger.value))
        return;
      _hide();
    }
    function _hide() {
      var _a;
      (_a = hkustDropdown.hide) == null ? void 0 : _a.call(hkustDropdown);
    }
    onMounted(() => {
      var _a;
      const dropdownMenu2 = getCurrentInstance();
      initDropdownDomEvent$1(dropdownMenu2, (_a = hkustDropdown.triggerElm) == null ? void 0 : _a.value, hkustDropdown.instance);
    });
    return {
      size: size2,
      show,
      hide: hide2,
      innerHide: _hide,
      triggerElm: hkustDropdown.triggerElm
    };
  }
});
function render$23(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", {
    class: normalizeClass([[_ctx.size && `hkust-dropdown-menu--${_ctx.size}`], "hkust-dropdown-menu"]),
    onMouseenter: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.show && _ctx.show(...args), ["stop"])),
    onMouseleave: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.hide && _ctx.hide(...args), ["stop"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34);
}
script$d.render = render$23;
script$d.__file = "packages/components/dropdown/src/dropdown-menu.vue";
const HkustDropdown = withInstall$2(script$f, {
  DropdownItem: script$e,
  DropdownMenu: script$d
});
const HkustDropdownItem = withNoopInstall$1(script$e);
const HkustDropdownMenu = withNoopInstall$1(script$d);
const iconProps$1 = {
  size: {
    type: Number
  },
  color: {
    type: String
  }
};
var script$c = defineComponent({
  name: "HkustIcon",
  inheritAttrs: false,
  props: iconProps$1,
  setup(props2) {
    return {
      style: computed(() => {
        if (!props2.size && !props2.color) {
          return {};
        }
        return __spreadValues(__spreadValues({}, props2.size ? { "--font-size": `${props2.size}px` } : {}), props2.color ? { "--color": props2.color } : {});
      })
    };
  }
});
function render$22(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("i", mergeProps({
    class: "hkust-icon",
    style: _ctx.style
  }, _ctx.$attrs), [
    renderSlot(_ctx.$slots, "default")
  ], 16);
}
script$c.render = render$22;
script$c.__file = "packages/components/icon/src/index.vue";
const HkustIcon = withInstall$2(script$c);
var defaultLocales$1 = {
  name: "en",
  hkust: {
    header: {
      contactUs: "Contact Us",
      hkustGz: "HKUST(GZ)",
      subHeadTitle: "More about HKUST",
      ustNews: "University News",
      department: "Academic Departments A-Z",
      lifeUst: "Life{'@'}HKUST",
      library: "Library",
      map: "Map & Directions",
      career: "Careers at HKUST",
      facultyProfiles: "Faculty Profiles",
      about: "About HKUST",
      searchBtnText: "SEARCH",
      searchPlaceholder: "Enter your search terms"
    },
    footer: {
      privacy: "Privacy",
      copyright: "Copyright \xA9 The Hong Kong University of Science and Technology (Guangzhou). All rights reserved.",
      record: "\u7CA4ICP\u590720065231\u53F7",
      follow: "Follow HKUST(GZ) on"
    }
  }
};
function isMessageFun(val) {
  return typeof val === "function";
}
const template = (value, options) => {
  if (!value || !options)
    return value;
  const val = isMessageFun(value) ? value(options) : typeof value === "string" ? value : value[options.index] || "";
  const slotReg = /\{\s*(\w+)\s*\}/g;
  return val.replace(slotReg, (_2, key2) => {
    return options[key2] || "";
  });
};
let cache$3;
const localeContextKey$1 = Symbol("localeContextKey");
const translate$2 = (pathsString, locale, options) => {
  const paths = pathsString.split(".");
  let value;
  let current2 = locale;
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    value = current2[path];
    if (i === paths.length - 1)
      return template(value, options);
    if (!value)
      return "";
    current2 = value;
  }
  return "";
};
const buildTranslator$1 = (locale) => (path, option2) => translate$2(path, unref(locale), option2);
const provideLocale$1 = () => {
  const vm = getCurrentInstance();
  const props2 = vm.props;
  const locale = computed(() => props2.locale || defaultLocales$1);
  const lang = computed(() => locale.value.name);
  const t = buildTranslator$1(locale);
  const provides = {
    locale,
    lang,
    t
  };
  cache$3 = provides;
  provide(localeContextKey$1, provides);
};
const localeProviderMaker$1 = (locale = defaultLocales$1) => {
  const lang = ref(locale.name);
  const localeRef = ref(locale);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator$1(localeRef)
  };
};
const useLocale$2 = () => {
  return inject(localeContextKey$1, cache$3 || localeProviderMaker$1(defaultLocales$1));
};
var script$b = defineComponent({
  name: "HkustOverlay",
  props: {
    overlayClass: {
      type: [String, Array],
      default: ""
    },
    zIndex: {
      type: Number,
      default: 2e3
    },
    vague: {
      type: Boolean,
      default: true
    },
    blur: {
      type: String,
      default: "2px"
    },
    mode: {
      type: String,
      default: "fixed"
    },
    backgroundColor: String
  },
  emits: ["click"],
  setup(props2, { emit }) {
    const overlayStyle = computed(() => {
      return {
        zIndex: props2.zIndex,
        backgroundColor: props2.backgroundColor || "",
        position: props2.mode,
        backdropFilter: `blur(${props2.vague ? props2.blur : "0"})`
      };
    });
    const handleClick = (ev) => {
      emit("click", ev);
    };
    return {
      props: props2,
      overlayStyle,
      handleClick
    };
  }
});
function render$21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["hkust-overlay", _ctx.props.overlayClass]),
    style: normalizeStyle(_ctx.overlayStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
script$b.render = render$21;
script$b.__file = "packages/components/overlay/src/index.vue";
const HkustOverlay = withInstall$2(script$b);
var script$a = defineComponent({
  name: "Close"
});
const _hoisted_1$5U = {
  t: "1640334424477",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  focusable: "true",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "1502",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  width: "200",
  height: "200"
};
const _hoisted_2$5v = /* @__PURE__ */ createBaseVNode("path", {
  d: "M517.08411984 479.11475483L301.90637831 263.93753776a26.85237631 26.85237631 0 1 0-37.98667221 37.95153335l215.17669262 215.19504873L263.91970607 732.27864411a26.85237631 26.85237631 0 1 0 37.96936504 37.96884057l215.19504878-215.17669264 215.19504866 215.17669264a26.85237631 26.85237631 0 1 0 37.9688406-37.95100889l-215.17669262-215.2123559 215.17669262-215.1772171a26.85237631 26.85237631 0 1 0-37.9688406-37.96936505L517.10195147 479.11475483z",
  fill: "#8a8a8a",
  "p-id": "1503"
}, null, -1);
const _hoisted_3$5g = [
  _hoisted_2$5v
];
function render$20(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5U, _hoisted_3$5g);
}
script$a.render = render$20;
script$a.__file = "packages/icons/src/close/close.vue";
const Close = withInstall$2(script$a);
const drawerEmits$1 = {
  open: () => true,
  opened: () => true,
  close: () => true,
  closed: () => true,
  "update:modelValue": (value) => typeof value === "boolean"
};
const useDrawer = (props2, { emit }) => {
  const visible = ref(false);
  function afterEnter() {
    emit("opened");
  }
  function beforeLeave() {
    emit("close");
  }
  function afterLeave() {
    emit("closed");
  }
  function open2() {
    if (isServer$9) {
      return;
    }
    visible.value = true;
  }
  function close2() {
    visible.value = false;
    emit("update:modelValue", false);
  }
  function hide2(shouldCancel) {
    if (shouldCancel)
      return;
    close2();
  }
  function handleClose() {
    if (props2.beforeClose) {
      props2.beforeClose(hide2);
    } else {
      close2();
    }
  }
  function onModalClick2() {
    if (props2.closeOnClickModal) {
      handleClose();
    }
  }
  watch$1(() => props2.modelValue, (val) => {
    if (val) {
      open2();
    } else {
      visible.value && close2();
    }
  });
  onMounted(() => {
    if (props2.modelValue) {
      open2();
    }
  });
  return {
    visible,
    afterEnter,
    beforeLeave,
    afterLeave,
    onModalClick: onModalClick2,
    handleClose
  };
};
var script$9 = defineComponent({
  name: "HkustDrawer",
  componentName: "HkustDrawer",
  components: {
    HkustOverlay,
    Close,
    HkustIcon
  },
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    direction: {
      type: String,
      default: "ttb",
      validator: (val) => {
        return ["ltr", "rtl", "ttb", "btt"].indexOf(val) !== -1;
      }
    },
    zIndex: {
      type: Number
    },
    size: {
      type: [String, Number],
      default: "30%"
    },
    withHeader: {
      type: Boolean,
      default: true
    },
    modalFade: {
      type: Boolean,
      default: true
    },
    modalClass: {
      type: [String, Array],
      default: ""
    },
    customClass: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    showClose: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    beforeClose: {
      type: Function
    },
    top: {
      type: String,
      default: "0"
    },
    mode: {
      type: String,
      default: "fixed"
    }
  },
  emits: drawerEmits$1,
  setup(props2, ctx) {
    const drawerRef = ref();
    const {
      visible,
      afterEnter,
      beforeLeave,
      afterLeave,
      handleClose,
      onModalClick: onModalClick2
    } = useDrawer(props2, ctx);
    return {
      visible,
      drawerRef,
      isHorizontal: computed(() => props2.direction === "rtl" || props2.direction === "ltr"),
      drawerSize: computed(() => typeof props2.size === "number" ? `${props2.size}px` : props2.size),
      afterEnter,
      beforeLeave,
      afterLeave,
      onModalClick: onModalClick2,
      handleClose
    };
  }
});
const _hoisted_1$5T = ["aria-label"];
const _hoisted_2$5u = {
  key: 0,
  id: "hkust-drawer__title",
  class: "hkust-drawer__header"
};
const _hoisted_3$5f = ["title"];
const _hoisted_4$1Q = { class: "hkust-drawer__body" };
function render$1$(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_close = resolveComponent("close");
  const _component_hkust_icon = resolveComponent("hkust-icon");
  const _component_hkust_overlay = resolveComponent("hkust-overlay");
  return openBlock(), createElementBlock("div", null, [
    (openBlock(), createBlock(Teleport, {
      to: "body",
      disabled: !_ctx.appendToBody
    }, [
      createVNode(Transition, {
        name: "hkust-drawer-fade",
        onAfterEnter: _ctx.afterEnter,
        onAfterLeave: _ctx.afterLeave,
        onBeforeLeave: _ctx.beforeLeave
      }, {
        default: withCtx(() => [
          withDirectives(createVNode(_component_hkust_overlay, {
            "overlay-class": _ctx.modalClass,
            mode: _ctx.mode,
            vague: false,
            "z-index": _ctx.zIndex,
            style: normalizeStyle({ top: _ctx.top }),
            onClick: _ctx.onModalClick
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                ref: "drawerRef",
                "aria-modal": "true",
                "aria-labelledby": "hkust-drawer__title",
                "aria-label": _ctx.title,
                class: normalizeClass(["hkust-drawer", _ctx.direction, _ctx.visible && "open", _ctx.customClass]),
                style: normalizeStyle(_ctx.isHorizontal ? "width: " + _ctx.drawerSize : "height: " + _ctx.drawerSize),
                role: "dialog",
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["stop"]))
              }, [
                _ctx.withHeader ? (openBlock(), createElementBlock("header", _hoisted_2$5u, [
                  renderSlot(_ctx.$slots, "title", {}, () => [
                    createBaseVNode("span", { title: _ctx.title }, toDisplayString$1(_ctx.title), 9, _hoisted_3$5f)
                  ]),
                  _ctx.showClose ? (openBlock(), createBlock(_component_hkust_icon, {
                    key: 0,
                    class: "hkust-drawer__close-btn hkust-icon",
                    onClick: _ctx.handleClose
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_close)
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : createCommentVNode("v-if", true)
                ])) : createCommentVNode("v-if", true),
                createBaseVNode("section", _hoisted_4$1Q, [
                  renderSlot(_ctx.$slots, "default")
                ])
              ], 14, _hoisted_1$5T)
            ]),
            _: 3
          }, 8, ["overlay-class", "mode", "z-index", "style", "onClick"]), [
            [vShow, _ctx.visible]
          ])
        ]),
        _: 3
      }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["disabled"]))
  ]);
}
script$9.render = render$1$;
script$9.__file = "packages/components/drawer/src/index.vue";
const HkustDrawer = withInstall$2(script$9);
var script$8 = defineComponent({
  name: "Search"
});
const _hoisted_1$5S = {
  t: "1640334418195",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  focusable: "true",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "1371",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  width: "200",
  height: "200"
};
const _hoisted_2$5t = /* @__PURE__ */ createBaseVNode("path", {
  d: "M945.066667 898.133333l-189.866667-189.866666c55.466667-64 87.466667-149.333333 87.466667-241.066667 0-204.8-168.533333-373.333333-373.333334-373.333333S96 264.533333 96 469.333333 264.533333 842.666667 469.333333 842.666667c91.733333 0 174.933333-34.133333 241.066667-87.466667l189.866667 189.866667c6.4 6.4 14.933333 8.533333 23.466666 8.533333s17.066667-2.133333 23.466667-8.533333c8.533333-12.8 8.533333-34.133333-2.133333-46.933334zM469.333333 778.666667C298.666667 778.666667 160 640 160 469.333333S298.666667 160 469.333333 160 778.666667 298.666667 778.666667 469.333333 640 778.666667 469.333333 778.666667z",
  "p-id": "1372"
}, null, -1);
const _hoisted_3$5e = [
  _hoisted_2$5t
];
function render$1_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5S, _hoisted_3$5e);
}
script$8.render = render$1_;
script$8.__file = "packages/icons/src/search/search.vue";
const Search = withInstall$2(script$8);
var script$7 = defineComponent({
  name: "List"
});
const _hoisted_1$5R = {
  t: "1640334405619",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  focusable: "true",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "1240",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  width: "200",
  height: "200"
};
const _hoisted_2$5s = /* @__PURE__ */ createBaseVNode("path", {
  d: "M892.928 128q28.672 0 48.64 19.968t19.968 48.64l0 52.224q0 28.672-19.968 48.64t-48.64 19.968l-759.808 0q-28.672 0-48.64-19.968t-19.968-48.64l0-52.224q0-28.672 19.968-48.64t48.64-19.968l759.808 0zM892.928 448.512q28.672 0 48.64 19.968t19.968 48.64l0 52.224q0 28.672-19.968 48.64t-48.64 19.968l-759.808 0q-28.672 0-48.64-19.968t-19.968-48.64l0-52.224q0-28.672 19.968-48.64t48.64-19.968l759.808 0zM892.928 769.024q28.672 0 48.64 19.968t19.968 48.64l0 52.224q0 28.672-19.968 48.64t-48.64 19.968l-759.808 0q-28.672 0-48.64-19.968t-19.968-48.64l0-52.224q0-28.672 19.968-48.64t48.64-19.968l759.808 0z",
  "p-id": "1241"
}, null, -1);
const _hoisted_3$5d = [
  _hoisted_2$5s
];
function render$1Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5R, _hoisted_3$5d);
}
script$7.render = render$1Z;
script$7.__file = "packages/icons/src/list/list.vue";
const List = withInstall$2(script$7);
const modalStack$1 = [];
var useModal$2 = (instance, visibleRef) => {
  watch$1(() => visibleRef.value, (val) => {
    if (val) {
      modalStack$1.push(instance);
    } else {
      modalStack$1.splice(modalStack$1.findIndex((modal) => modal === instance), 1);
    }
  });
};
function closeModal$1(ev) {
  if (modalStack$1.length === 0)
    return;
  if (ev.code === EVENT_CODE.esc) {
    ev.stopPropagation();
    const topModal = modalStack$1[modalStack$1.length - 1];
    topModal.handleClose();
  }
}
if (!isServer$9) {
  on$1(document, "keydown", closeModal$1);
}
var script$6 = defineComponent({
  name: "HkustSearch",
  components: {
    HkustOverlay,
    Close,
    HkustIcon
  },
  props: {
    overlayClass: {
      type: String
    },
    zIndex: {
      type: Number,
      default: 2e3
    },
    backgroundColor: String,
    blur: {
      type: String,
      default: "2px"
    },
    showClose: {
      type: Boolean,
      default: true
    },
    confirmButtonText: {
      type: String,
      default: ""
    },
    inputPlaceholder: {
      type: String,
      default: ""
    },
    modelValue: {
      type: Boolean,
      default: false
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    teleportTarget: {
      type: String,
      validator: (val) => {
        return isServer$9 ? val !== "body" : typeof val === "string";
      }
    },
    beforeClose: {
      type: Function
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnpressEscape: {
      type: Boolean,
      default: true
    },
    closeDelay: Number,
    openDelay: Number,
    vague: {
      type: Boolean,
      default: true
    },
    modelKeyword: {
      type: String,
      default: ""
    }
  },
  emits: [
    "update:modelValue",
    "update:modelKeyword",
    "confirm",
    "input",
    "close",
    "open"
  ],
  setup(props2, { emit }) {
    const { t } = useLocale$2();
    const visible = ref(false);
    const closeTimer = ref();
    const openTimer = ref();
    const keyword = ref("");
    const target2 = computed(() => {
      var _a;
      return (_a = props2.teleportTarget) != null ? _a : "body";
    });
    watch$1(() => props2.modelValue, (newVal) => {
      if (newVal) {
        open2();
      } else {
        close2();
      }
    });
    watch$1(() => props2.modelKeyword, (newVal) => {
      keyword.value = newVal;
    });
    const handleConfirm = (ev) => {
      emit("confirm", ev);
    };
    const handleInput = (ev) => {
      emit("input", ev);
      emit("update:modelKeyword", keyword.value);
    };
    const open2 = () => {
      closeTimer.value && clearTimeout(closeTimer.value);
      openTimer.value && clearTimeout(openTimer.value);
      if (props2.openDelay) {
        openTimer.value = setTimeout(() => {
          openTimer.value = void 0;
          doOpen();
        }, props2.openDelay);
      } else {
        doOpen();
      }
    };
    const doOpen = () => {
      visible.value = true;
      emit("open");
    };
    const close2 = (shouldCancel = false) => {
      if (shouldCancel)
        return;
      closeTimer.value && clearTimeout(closeTimer.value);
      openTimer.value && clearTimeout(openTimer.value);
      if (props2.closeDelay) {
        closeTimer.value = setTimeout(() => {
          closeTimer.value = void 0;
          doClose();
        }, props2.closeDelay);
      } else {
        doClose();
      }
    };
    const doClose = () => {
      visible.value = false;
      emit("close");
      emit("update:modelValue", false);
    };
    const handleClose = () => {
      if (props2.beforeClose) {
        props2.beforeClose(close2);
      } else {
        close2();
      }
    };
    const handleModalClick = () => {
      if (props2.closeOnClickModal) {
        handleClose();
      }
    };
    const preventEvent = (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
    };
    if (props2.closeOnpressEscape) {
      useModal$2({
        handleClose
      }, visible);
    }
    onMounted(() => {
      if (props2.modelValue) {
        open2();
      }
    });
    return {
      visible,
      keyword,
      target: target2,
      t,
      open: open2,
      close: close2,
      handleConfirm,
      handleInput,
      handleClose,
      handleModalClick,
      preventEvent
    };
  }
});
const _hoisted_1$5Q = { class: "hkust-search" };
const _hoisted_2$5r = ["placeholder"];
function render$1Y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_close = resolveComponent("close");
  const _component_hkust_icon = resolveComponent("hkust-icon");
  const _component_hkust_overlay = resolveComponent("hkust-overlay");
  return openBlock(), createElementBlock("div", null, [
    (openBlock(), createBlock(Teleport, {
      to: _ctx.target,
      disabled: !_ctx.appendToBody
    }, [
      withDirectives(createVNode(_component_hkust_overlay, {
        vague: _ctx.vague,
        "background-color": "rgba(0,0,0,0.7)",
        onClick: _ctx.handleModalClick
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$5Q, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              createVNode(_component_hkust_icon, {
                class: "hkust-search__close-btn hkust-icon",
                onClick: _ctx.handleClose
              }, {
                default: withCtx(() => [
                  createVNode(_component_close)
                ]),
                _: 1
              }, 8, ["onClick"])
            ]),
            createBaseVNode("div", {
              class: "hkust-search__content",
              onClick: _cache[3] || (_cache[3] = (...args) => _ctx.preventEvent && _ctx.preventEvent(...args))
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.keyword = $event),
                  type: "text",
                  class: "hkust-search__input",
                  placeholder: _ctx.inputPlaceholder ? _ctx.inputPlaceholder : _ctx.t("hkust.header.searchPlaceholder"),
                  onInput: _cache[1] || (_cache[1] = (...args) => _ctx.handleInput && _ctx.handleInput(...args))
                }, null, 40, _hoisted_2$5r), [
                  [vModelText, _ctx.keyword]
                ]),
                createBaseVNode("button", {
                  type: "button",
                  class: "hkust-search__btn",
                  onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
                }, toDisplayString$1(_ctx.confirmButtonText ? _ctx.confirmButtonText : _ctx.t("hkust.header.searchBtnText")), 1)
              ])
            ])
          ])
        ]),
        _: 3
      }, 8, ["vague", "onClick"]), [
        [vShow, _ctx.visible]
      ])
    ], 8, ["to", "disabled"]))
  ]);
}
script$6.render = render$1Y;
script$6.__file = "packages/components/search/src/index.vue";
const HkustSearch = withInstall$2(script$6);
var script$5 = defineComponent({
  name: "ArrowDownBold"
});
const _hoisted_1$5P = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  focusable: "true",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M104.704 338.752a64 64 0 0190.496 0l316.8 316.8 316.8-316.8a64 64 0 0190.496 90.496L557.248 791.296a64 64 0 01-90.496 0L104.704 429.248a64 64 0 010-90.496z"
}, null, -1);
const _hoisted_3$5c = [
  _hoisted_2$5q
];
function render$1X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5P, _hoisted_3$5c);
}
script$5.render = render$1X;
script$5.__file = "packages/icons/src/arrow-down-bold/arrow-down-bold.vue";
const ArrowDownBold = withInstall$2(script$5);
var script$4 = defineComponent({
  name: "LangIcon"
});
const _hoisted_1$5O = {
  focusable: "true",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 18.212 18.217"
};
const _hoisted_2$5p = /* @__PURE__ */ createStaticVNode('<g opacity="0.7" transform="translate(0.065 -0.01)"><g transform="translate(-0.065 0.01)"><path fill="#ffffff" fill-rule="evenodd" d="M127.423,140.863s-.425-.22-.22,0a10.3,10.3,0,0,1,.687,1.015s.261.206.329.179.143-.248.143-.343S127.645,140.863,127.423,140.863Z" transform="translate(-118.037 -130.686)"></path><path fill="#ffffff" fill-rule="evenodd" d="M150.276,137.1c0-.014-.1-.324-.293-.147s-.567.549-.727.573c-.038.006-.165.132-.115.233s.22.178.286.278a.422.422,0,0,0,.329.183c.143.009.193-.109.252-.261s.293-.311.224-.434-.127-.229-.068-.279A.386.386,0,0,0,150.276,137.1Z" transform="translate(-138.445 -127.094)"></path><path fill="#ffffff" fill-rule="evenodd" d="M191.683,144.908c-.311-.137-.915-.358-.915-.358s-.22.22-.265.173-.339-.256-.393-.173.109.248.2.316.3.023.393.132a1.8,1.8,0,0,0,.385.4c.137.073.192.174.311.072s.173-.137.256-.1.246.183.411.256a.566.566,0,0,0,.347,0A2.932,2.932,0,0,0,191.683,144.908Z" transform="translate(-176.481 -134.182)"></path><path fill="#ffffff" fill-rule="evenodd" d="M187.685,54.164a.674.674,0,0,0,.463-.111c.125-.082-.3-.493-.463-.493C187.685,53.563,187.5,54.146,187.685,54.164Z" transform="translate(-174.162 -49.725)"></path><path fill="#ffffff" fill-rule="evenodd" d="M178.948,65.623a1.864,1.864,0,0,1,0,.3,1.013,1.013,0,0,1-.219.459c-.055.054-.583.418-.617.686s.13.3.473-.089.495-.254.632-.4S179.374,65.389,178.948,65.623Z" transform="translate(-165.348 -60.893)"></path><path fill="#ffffff" fill-rule="evenodd" d="M14.89,2.139c-.2-.171-.415-.333-.634-.486A9.095,9.095,0,0,0,1.075,4.717c-.112.2-.215.41-.312.622-.075.164-.143.332-.215.5C.461,6.07.38,6.3.311,6.54a9.1,9.1,0,0,0,14.068,9.954q.183-.133.358-.275a9.095,9.095,0,0,0,.148-14.078ZM1.552,4.771h0c.252.091.751.265.59.407s-.269.258-.412.2a1.092,1.092,0,0,0-.43-.139Q1.418,5,1.552,4.771ZM1.229,6.693.747,6.615c.056-.187.119-.37.186-.552a.449.449,0,0,0,.108-.014c.358-.1.47-.077.511,0S1.638,6.634,1.229,6.693Zm13.949,8.545a2.546,2.546,0,0,1,.225-.312,1.3,1.3,0,0,0,.256-1.547,3.335,3.335,0,0,1-.522-1.317c-.037-.155-.44-.448-.44-.347,0,0,.01.594-.082.65s-.613-.091-.622-.229a.4.4,0,0,1,.072-.3c.053-.054-.384-.247-.64-.065s-.182.228-.228.264-.092-.143-.22-.09a1.341,1.341,0,0,0-.44.329,1.273,1.273,0,0,1-.448.392c-.211.1-.375.019-.64.275s-.347.1-.3.466.32.874.2,1.059-.176.387.063.358.541-.193.816-.248.557-.286.731-.173.448.092.5.286a.7.7,0,0,1,.035.292s.12-.155.22-.147-.009-.082.1.211.027.42.173.5,0,.256.412.193a2.077,2.077,0,0,0,.306-.072A8.653,8.653,0,0,1,1.539,13.442c.048-.193.06-.442.259-.564.312-.193.716-.293.476-1.208s.238-.914.622-1.308.97-1.245.631-1.162-.6.3-.96-.175S1.176,6.968,1.542,7.163A3.263,3.263,0,0,1,2.777,9s.266.092.906-.384.979-.573.9-.788-.42-.522-.549-.376S3.5,7.444,3.3,7.162s-.179-.526.109-.349a2.372,2.372,0,0,0,1.317.6c.616,0,.892.082,1.154.508s.206-.027.274-.072.384,1.962.618,1.8.178-.9.425-1.07a10.371,10.371,0,0,1,.94-.638c.2-.082.3-.072.43.2s.206.638.507.425.225.42.243.568a1.7,1.7,0,0,0,.259.8c.241.405.261.481.46.542s-.192-.716-.35-.859S9.354,9,9.5,8.955s.562.358.632.481.528-.254.507-.493-.573-.551-.516-.68.191-.521.3-.348.083.385.138.339.12-.3.329-.411,1.235-.806.9-1.419-.384-.672-.238-.8,0-.175-.143-.17a.229.229,0,0,1-.179-.385c.165-.224.27-.072.274,0s.17.106.316.046.1.266.143.286a.662.662,0,0,1,.269.453c0,.21.22.072.335-.2s0-.449-.179-.5-.238-.128-.188-.215.152-.173.16-.246-.1-.092-.014-.165a.43.43,0,0,1,.286-.114c.16-.018.5-.563.407-1.1s-.091-1.3-.513-1.111-.384-.028-.4-.147.156-.246.165-.393a2.213,2.213,0,0,1,.12-.532,8.661,8.661,0,0,1,2.766,14.107Z" transform="translate(0.065 -0.01)"></path></g></g>', 1);
const _hoisted_3$5b = [
  _hoisted_2$5p
];
function render$1W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5O, _hoisted_3$5b);
}
script$4.render = render$1W;
script$4.__file = "packages/icons/src/lang-icon/lang-icon.vue";
const LangIcon = withInstall$2(script$4);
var script$3 = defineComponent({
  name: "HkustSubheader",
  componentName: "HkustSubheader",
  components: {
    HkustDropdown,
    HkustDropdownMenu,
    HkustDropdownItem,
    ArrowDownBold,
    Search,
    HkustIcon,
    LangIcon
  },
  props: {
    headerProps: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["fontSizeChange", "localesChange", "searchIconClick", "open"],
  setup(props2, { emit }) {
    const { t } = useLocale$2();
    const isOpen = ref(false);
    const toggleOpen = () => {
      isOpen.value = !isOpen.value;
      emit("open", isOpen.value);
    };
    const fontSize = ref(props2.headerProps.defaultFontSize);
    const changeTheme = (val) => {
      if (!isServer$9) {
        document.body.classList.remove(fontSize.value);
        document.body.classList.add(val);
      }
      fontSize.value = val;
      emit("fontSizeChange", val);
    };
    const changeLocale = (val) => {
      emit("localesChange", val);
    };
    const searchIconClick = () => {
      emit("searchIconClick");
    };
    watch$1(() => props2.headerProps.defaultFontSize, (newVal) => {
      props2.headerProps.useDefaultFontTheme && changeTheme(newVal);
    }, { immediate: true });
    return {
      isOpen,
      fontSize,
      t,
      toggleOpen,
      changeTheme,
      changeLocale,
      searchIconClick
    };
  }
});
const _hoisted_1$5N = { class: "hkust-subheader" };
const _hoisted_2$5o = { class: "hkust-subheader-drawer-wrap" };
const _hoisted_3$5a = { class: "hkust-subheader-drawer-wrap__about" };
const _hoisted_4$1P = { class: "hkust-subheader-drawer-link" };
const _hoisted_5$M = {
  href: "https://www.ust.hk/news",
  class: "hkust-subheader-drawer-link__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_6$n = {
  href: "https://www.ust.hk/academics/list",
  class: "hkust-subheader-drawer-link__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_7$g = {
  href: "https://www.ust.hk/lifehkust",
  class: "hkust-subheader-drawer-link__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_8$e = {
  href: "http://library.ust.hk/",
  class: "hkust-subheader-drawer-link__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_9$b = {
  href: "https://www.ust.hk/map-directions",
  class: "hkust-subheader-drawer-link__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_10$b = {
  href: "https://hkustcareers.ust.hk",
  class: "hkust-subheader-drawer-link__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_11$7 = {
  href: "https://facultyprofiles.ust.hk/",
  class: "hkust-subheader-drawer-link__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_12$6 = {
  href: "https://www.ust.hk/about",
  class: "hkust-subheader-drawer-link__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_13$5 = { class: "hkust-subheader-desktop" };
const _hoisted_14$4 = { class: "hkust-subheader-desktop-left" };
const _hoisted_15$4 = {
  href: "https://hkust-gz.edu.cn/contact-us",
  target: "_blank",
  rel: "noopener",
  class: "hkust-subheader-desktop-left__contact-us"
};
const _hoisted_16$4 = { class: "hkust-subheader-desktop-right" };
const _hoisted_17$3 = {
  key: 0,
  href: "https://hkust-gz.edu.cn/",
  class: "hkust-subheader-desktop-right__item",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_18$2 = {
  key: 1,
  class: "hkust-subheader-desktop-right__font hkust-subheader-desktop-right__item"
};
const _hoisted_19$2 = {
  key: 0,
  class: "hkust-subheader-desktop-right__item"
};
function render$1V(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_down_bold = resolveComponent("arrow-down-bold");
  const _component_hkust_icon = resolveComponent("hkust-icon");
  const _component_search = resolveComponent("search");
  const _component_lang_icon = resolveComponent("lang-icon");
  const _component_hkust_dropdown_item = resolveComponent("hkust-dropdown-item");
  const _component_hkust_dropdown_menu = resolveComponent("hkust-dropdown-menu");
  const _component_hkust_dropdown = resolveComponent("hkust-dropdown");
  return openBlock(), createElementBlock("div", _hoisted_1$5N, [
    createBaseVNode("div", {
      class: normalizeClass(["hkust-subheader-drawer", [_ctx.isOpen ? "is-open" : "is-close"]])
    }, [
      createBaseVNode("div", _hoisted_2$5o, [
        renderSlot(_ctx.$slots, "subcontent", {}, () => [
          createBaseVNode("div", _hoisted_3$5a, toDisplayString$1(_ctx.t("hkust.header.subHeadTitle")), 1),
          createBaseVNode("div", _hoisted_4$1P, [
            createBaseVNode("a", _hoisted_5$M, toDisplayString$1(_ctx.t("hkust.header.ustNews")), 1),
            createBaseVNode("a", _hoisted_6$n, toDisplayString$1(_ctx.t("hkust.header.department")), 1),
            createBaseVNode("a", _hoisted_7$g, toDisplayString$1(_ctx.t("hkust.header.lifeUst")), 1),
            createBaseVNode("a", _hoisted_8$e, toDisplayString$1(_ctx.t("hkust.header.library")), 1),
            createBaseVNode("a", _hoisted_9$b, toDisplayString$1(_ctx.t("hkust.header.map")), 1),
            createBaseVNode("a", _hoisted_10$b, toDisplayString$1(_ctx.t("hkust.header.career")), 1),
            createBaseVNode("a", _hoisted_11$7, toDisplayString$1(_ctx.t("hkust.header.facultyProfiles")), 1),
            createBaseVNode("a", _hoisted_12$6, toDisplayString$1(_ctx.t("hkust.header.about")), 1)
          ])
        ])
      ])
    ], 2),
    createBaseVNode("div", _hoisted_13$5, [
      createBaseVNode("div", _hoisted_14$4, [
        createBaseVNode("a", _hoisted_15$4, toDisplayString$1(_ctx.t("hkust.header.contactUs")), 1)
      ]),
      createBaseVNode("div", _hoisted_16$4, [
        _ctx.headerProps.showHkustLink ? (openBlock(), createElementBlock("a", _hoisted_17$3, toDisplayString$1(_ctx.t("hkust.header.hkustGz")), 1)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          class: "hkust-subheader-desktop-right__toggle hkust-subheader-desktop-right__item",
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleOpen && _ctx.toggleOpen(...args))
        }, [
          createVNode(_component_hkust_icon, {
            class: normalizeClass([
              "hkust-icon",
              "hkust-subheader-desktop-right__arrow",
              _ctx.isOpen ? "is-open" : ""
            ])
          }, {
            default: withCtx(() => [
              createVNode(_component_arrow_down_bold)
            ]),
            _: 1
          }, 8, ["class"])
        ]),
        _ctx.headerProps.showFontToggle ? (openBlock(), createElementBlock("div", _hoisted_18$2, [
          createBaseVNode("span", {
            class: "small-size",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.changeTheme("small"))
          }, "A"),
          createBaseVNode("span", {
            class: "normal-size",
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.changeTheme("medium"))
          }, "A"),
          createBaseVNode("span", {
            class: "large-size",
            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.changeTheme("large"))
          }, "A")
        ])) : createCommentVNode("v-if", true),
        createCommentVNode(" 'search-icon' only display at media max-width: 768px and showSearch: true "),
        _ctx.headerProps.showSearch ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: "hkust-subheader-desktop-right__item hkust-subheader-desktop-right__search-icon",
          onClick: _cache[4] || (_cache[4] = (...args) => _ctx.searchIconClick && _ctx.searchIconClick(...args))
        }, [
          createVNode(_component_hkust_icon, { class: "hkust-icon" }, {
            default: withCtx(() => [
              createVNode(_component_search)
            ]),
            _: 1
          })
        ])) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "locale", {}, () => [
          _ctx.headerProps.showLocale ? (openBlock(), createElementBlock("div", _hoisted_19$2, [
            createVNode(_component_hkust_dropdown, {
              "teleport-target": _ctx.headerProps.localesTeleport,
              onCommand: _ctx.changeLocale
            }, {
              dropdown: withCtx(() => [
                createVNode(_component_hkust_dropdown_menu, null, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.headerProps.locales, (item2) => {
                      return openBlock(), createBlock(_component_hkust_dropdown_item, {
                        key: item2.value,
                        command: item2.value,
                        divided: true
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString$1(item2.label), 1)
                        ]),
                        _: 2
                      }, 1032, ["command"]);
                    }), 128))
                  ]),
                  _: 1
                })
              ]),
              default: withCtx(() => [
                createBaseVNode("span", null, [
                  createVNode(_component_hkust_icon, {
                    style: { "margin-right": "8px" },
                    class: "hkust-icon"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_lang_icon)
                    ]),
                    _: 1
                  }),
                  createVNode(_component_hkust_icon, {
                    style: { "color": "#fff" },
                    class: "hkust-icon"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_arrow_down_bold)
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            }, 8, ["teleport-target", "onCommand"])
          ])) : createCommentVNode("v-if", true)
        ]),
        renderSlot(_ctx.$slots, "user")
      ])
    ])
  ]);
}
script$3.render = render$1V;
script$3.__file = "packages/components/header/src/sub-header.vue";
const defaultLocales = [
  {
    label: "Eng",
    value: "en"
  },
  {
    label: "\u7B80\u4F53",
    value: "zh-cn"
  },
  {
    label: "\u7E41\u9AD4",
    value: "zh-tw"
  }
];
var script$2 = defineComponent({
  name: "HkustHeader",
  componentName: "HkustHeader",
  components: {
    SubHeader: script$3,
    HkustSearch,
    HkustDrawer,
    Search,
    ListIcon: List,
    HkustIcon
  },
  props: {
    className: {
      type: [String, Object, Array],
      default: ""
    },
    showSubheader: {
      type: Boolean,
      default: true
    },
    showHkustLink: {
      type: Boolean,
      default: true
    },
    showFontToggle: {
      type: Boolean,
      default: true
    },
    showSearch: {
      type: Boolean,
      default: true
    },
    showLocale: {
      type: Boolean,
      default: true
    },
    defaultFontSize: {
      type: String,
      default: "medium"
    },
    useDefaultFontTheme: {
      type: Boolean,
      default: true
    },
    locales: {
      type: Array,
      default: () => defaultLocales
    },
    departmentName: {
      type: String,
      default: ""
    },
    searchTeleport: String,
    localesTeleport: String
  },
  emits: [
    "searchOpen",
    "localesChange",
    "fontSizeChange",
    "hadScroll",
    "drawerOpen",
    "subheaderOpen"
  ],
  setup(props2, { emit }) {
    const { t, lang } = useLocale$2();
    const hasScrolled = ref(false);
    const isOpenSearch = ref(false);
    const subHeaderRef = ref(null);
    const isOpenDrawer = ref(false);
    const searchIconClick = () => {
      isOpenSearch.value = true;
      emit("searchOpen", isOpenSearch.value);
    };
    const handleSearchClose = () => {
      emit("searchOpen", false);
    };
    const localesChange = (val) => {
      emit("localesChange", val);
    };
    const fontSizeChange = (val) => {
      emit("fontSizeChange", val);
    };
    function setBodyScroll() {
      if (isServer$9)
        return;
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
      document.body.style.overflow = isOpenDrawer.value ? "hidden" : "scroll";
    }
    const handleMenuIconClick = () => {
      isOpenDrawer.value = !isOpenDrawer.value;
      setBodyScroll();
      isOpenDrawer.value && emit("drawerOpen", true);
    };
    const handleDrawerClose = () => {
      setBodyScroll();
      emit("drawerOpen", false);
    };
    const changeLocale = (val) => {
      emit("localesChange", val);
    };
    const onSubheaderOpen = (val) => {
      emit("subheaderOpen", val);
    };
    function getScrollTop() {
      let scrollTop = 0;
      if (document.documentElement && document.documentElement.scrollTop) {
        scrollTop = document.documentElement.scrollTop;
      } else if (document.body) {
        scrollTop = document.body.scrollTop;
      }
      return scrollTop;
    }
    onMounted(() => {
      window.addEventListener("scroll", () => {
        hasScrolled.value = getScrollTop() === 0 ? false : true;
        emit("hadScroll", hasScrolled.value);
      });
    });
    return {
      lang,
      props: props2,
      subHeaderRef,
      hasScrolled,
      isOpenSearch,
      isOpenDrawer,
      t,
      searchIconClick,
      localesChange,
      fontSizeChange,
      handleMenuIconClick,
      handleDrawerClose,
      changeLocale,
      onSubheaderOpen,
      handleSearchClose
    };
  }
});
var img$8 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='utf-8'%3f%3e%3c!-- Generator: Adobe Illustrator 25.0.1%2c SVG Export Plug-In . SVG Version: 6.00 Build 0) --%3e%3csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 605.9 84.6' style='enable-background:new 0 0 605.9 84.6%3b' xml:space='preserve'%3e%3cstyle type='text/css'%3e .st0%7bfill:%23996600%3b%7d .st1%7bfill:%23003366%3b%7d%3c/style%3e%3cg%3e %3cg%3e %3cg%3e %3cpath class='st0' d='M42.3%2c84.2l-9.8-16.3c0%2c0-0.3-0.4-0.3-1l0-0.4v-0.8V36.6h-3.7v30.3v0.9c0.3%2c0.3%2c6.5%2c10.8%2c6.5%2c10.8H19.7 c0%2c0%2c6.2-10.5%2c6.5-10.8v-0.9V36.6h-3.7v29.1v0.8l0%2c0.4c0%2c0.6-0.3%2c1-0.3%2c1l-9.8%2c16.3H42.3z'/%3e %3c/g%3e %3cg%3e %3cpath class='st0' d='M39.3%2c15.4c0%2c0%2c1.8-7.6-4.7-12.6c0%2c0-2.6-2.4-7.6-2.4c-4.5%2c0-7.1%2c2.4-7.1%2c2.4c-6.1%2c4.2-4.5%2c12.6-4.5%2c12.6 H39.3z'/%3e %3cpath class='st0' d='M16.1%2c17.5h22.5c0.2-0.4%2c0.3-0.9%2c0.5-1.3H15.6C15.7%2c16.6%2c15.9%2c17.1%2c16.1%2c17.5z'/%3e %3cpath class='st0' d='M38.3%2c18.3H16.4c0.2%2c0.5%2c0.5%2c0.9%2c0.8%2c1.3h20.3C37.8%2c19.2%2c38%2c18.7%2c38.3%2c18.3z'/%3e %3cpath class='st0' d='M18.7%2c21.4H36c0.3-0.3%2c0.6-0.7%2c0.9-1.1H17.7C18%2c20.7%2c18.3%2c21.1%2c18.7%2c21.4z'/%3e %3cpath class='st0' d='M20.5%2c23h13.6c0.4-0.2%2c0.7-0.5%2c1-0.8H19.5C19.8%2c22.5%2c20.2%2c22.8%2c20.5%2c23z'/%3e %3cpath class='st0' d='M22.4%2c24.1c1.5%2c0.7%2c3.2%2c1.1%2c4.9%2c1.1c1.8%2c0%2c3.4-0.4%2c4.9-1.1H22.4z'/%3e %3c/g%3e %3cpath class='st1' d='M50.7%2c25.7H32.3c0%2c0-1.7%2c0-3.1%2c0.9c-1.1%2c0.7-1.8%2c2.4-1.8%2c2.5h0c0-0.1-0.8-1.8-1.8-2.5 c-1.4-0.9-3.1-0.9-3.1-0.9H4l-3.7%2c5.9h16.9c0%2c0%2c0.5%2c0%2c0.8%2c0.1c0.5%2c0.1%2c1.4%2c0.3%2c2.3%2c1c1.3%2c0.9%2c1.6%2c1.4%2c1.9%2c1.7 c0.2%2c0.2%2c0.6%2c0.7%2c0.6%2c0.7h4.1h0.5l0%2c0h1.4H32c0%2c0%2c0.4-0.5%2c0.6-0.7c0.3-0.3%2c0.7-0.8%2c1.9-1.7c0.9-0.7%2c1.8-0.9%2c2.3-1 c0.3-0.1%2c0.8-0.1%2c0.8-0.1h16.9L50.7%2c25.7z'/%3e %3cg%3e %3cg%3e %3cpath class='st1' d='M2.2%2c33.4v27.7c0%2c0%2c0%2c0.3%2c0%2c0.4c0%2c0.3%2c0%2c0.6%2c0%2c0.8c0.3%2c3%2c1.2%2c5.2%2c3%2c8c2.7%2c4.5%2c7.6%2c7.7%2c7.6%2c7.7l2.3-3.7 c0%2c0-3.1-1.7-5.7-5.5c-0.5-0.8-1-1.5-1.4-2.2c-0.3-0.7-0.6-1.2-0.8-1.8C7.2%2c64.4%2c7.1%2c64%2c7%2c63.6c-0.1-0.5-0.2-0.9-0.2-1.4 c0-0.2%2c0-0.9%2c0-0.9v-0.1V33.4H2.2z'/%3e %3cpath class='st1' d='M9.2%2c33.4v27.9c0%2c0%2c0%2c0.1%2c0%2c0.2c0%2c0.1%2c0%2c0.3%2c0%2c0.5c0%2c0.1%2c0%2c0.2%2c0%2c0.3c0.1%2c0.4%2c0.2%2c0.8%2c0.4%2c1.4 c0.3%2c0.9%2c0.9%2c2.1%2c1.7%2c3.4c2.1%2c3.3%2c5.1%2c4.9%2c5.1%2c4.9l2.3-3.6c0%2c0-0.8-0.4-1.7-1.3c-0.6-0.6-1.4-1.4-2-2.3c-0.6-0.9-1-1.9-1.2-2.6 c-0.2-0.6-0.2-1.1-0.2-1.4c0-0.3%2c0-0.4%2c0-0.4v-27H9.2z'/%3e %3c/g%3e %3cg%3e %3cpath class='st1' d='M52.6%2c33.4v27.7c0%2c0%2c0%2c0.3%2c0%2c0.4c0%2c0.3%2c0%2c0.6%2c0%2c0.8c-0.3%2c3-1.2%2c5.2-3%2c8c-2.7%2c4.5-7.6%2c7.7-7.6%2c7.7l-2.3-3.7 c0%2c0%2c3.1-1.7%2c5.7-5.5c0.5-0.8%2c1-1.5%2c1.4-2.2c0.3-0.7%2c0.6-1.2%2c0.8-1.8c0.1-0.4%2c0.3-0.8%2c0.3-1.2c0.1-0.5%2c0.2-0.9%2c0.2-1.4 c0-0.2%2c0-0.9%2c0-0.9v-0.1V33.4H52.6z'/%3e %3cpath class='st1' d='M45.5%2c33.4v27.9c0%2c0%2c0%2c0.1%2c0%2c0.2c0%2c0.1%2c0%2c0.3%2c0%2c0.5c0%2c0.1%2c0%2c0.2%2c0%2c0.3c-0.1%2c0.4-0.2%2c0.8-0.4%2c1.4 c-0.3%2c0.9-0.9%2c2.1-1.7%2c3.4c-2.1%2c3.3-5.1%2c4.9-5.1%2c4.9L36%2c68.4c0%2c0%2c0.8-0.4%2c1.7-1.3c0.6-0.6%2c1.4-1.4%2c2-2.3c0.6-0.9%2c1-1.9%2c1.2-2.6 c0.2-0.6%2c0.2-1.1%2c0.2-1.4c0-0.3%2c0-0.4%2c0-0.4v-27H45.5z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3cg%3e %3cg%3e %3cpath class='st1' d='M116.1%2c52.9v20.8h-4.5v-2.2H88.1v2.2h-4.5V53.2c-0.8%2c0.4-2.2%2c0.8-4.1%2c1.5l-2.3-4.3 c5.8-1.4%2c10.9-3.9%2c15.2-7.5H77.7v-4h19.7V35c-7.2%2c0.2-12.3%2c0.3-15.5%2c0.3l-1.6-4.4c1.8%2c0.1%2c4.1%2c0.1%2c6.7%2c0.1 c12.7%2c0%2c22.4-0.7%2c28.9-2.2l2.1%2c3.9c-4.3%2c0.9-9.7%2c1.6-16.2%2c2.2v4H122v4h-15.4c3.6%2c3.5%2c8.9%2c5.9%2c15.8%2c7.3l-2.1%2c4.4 c-0.6-0.3-1.3-0.5-2.1-0.8C117.4%2c53.6%2c116.7%2c53.3%2c116.1%2c52.9z M86.4%2c51.8h10.9V43C94.6%2c47%2c90.9%2c49.9%2c86.4%2c51.8z M111.6%2c55.9 H88.1v3.6h23.6V55.9z M88.1%2c67.5h23.6v-4.2H88.1V67.5z M101.8%2c43v8.9h11.8C108.8%2c49.9%2c104.8%2c47%2c101.8%2c43z'/%3e %3cpath class='st1' d='M148.7%2c58.9c-1.3%2c5.2-3.3%2c9.9-6.1%2c14.3l-3.8-3.9c2.8-4%2c4.7-8.2%2c5.7-12.8L148.7%2c58.9z M145.7%2c51.1 c-2.6-2.2-4.8-3.9-6.7-5.2l2.9-3.6c2.3%2c1.2%2c4.6%2c2.8%2c7.1%2c4.6L145.7%2c51.1z M150.4%2c34h6.4v-5h4.4v5h8.7v-5h4.3v5h7.9v3.8h-7.9v4.9 h8.6v4h-9.1c1.3%2c2.6%2c4.5%2c5.2%2c9.7%2c7.7l-2.1%2c4.3c-2.9-1.8-5.4-3.5-7.3-5.2v9.8h-15.4v3.1c0%2c1.1%2c0.6%2c1.7%2c1.7%2c1.7h14.2 c1.3%2c0%2c2.1-0.5%2c2.4-1.5c0.3-1%2c0.5-2.8%2c0.7-5.3l4.6%2c1.7c-0.5%2c4.4-1.2%2c7.1-2.1%2c8c-0.8%2c0.9-2.5%2c1.3-4.9%2c1.3h-15.5 c-2%2c0-3.5-0.4-4.3-1.1c-0.8-0.8-1.2-2.3-1.2-4.4V55.9c-0.8%2c0.7-2.3%2c1.7-4.4%2c3l-2.7-4c5.3-2.4%2c8.7-5.1%2c10.1-8.1h-7.7v-4h7.3V38 h-6.4v-2.6l-2.9%2c3.6c-2.6-2.4-5-4.3-7.1-5.6l3.2-3.5c2.7%2c1.7%2c5%2c3.3%2c6.9%2c4.7V34z M158.6%2c54.8v4.7h11v-4.7H158.6z M162.2%2c46.7 c-0.7%2c1.6-1.6%2c3.1-2.8%2c4.3h12.2c-1.1-1.2-2-2.6-2.9-4.3H162.2z M161.1%2c38v4.7h8.7V38H161.1z'/%3e %3cpath class='st1' d='M209%2c35.5c-1.7%2c0.3-4.2%2c0.6-7.4%2c0.8l-1-4c7.1-0.4%2c13.3-1.5%2c18.4-3.4l1.6%2c3.9c-2.3%2c0.8-4.7%2c1.5-7.2%2c2v6.8 h7.3v4.1h-7.3v0.4c3.6%2c3.3%2c6.3%2c6%2c8.1%2c7.9l-2.7%2c4.1c-1-1.3-1.9-2.6-2.9-3.6c-0.8-1-1.7-2.1-2.5-3.2v22.2l-4.4%2c0.2V54 c-1.2%2c3.1-3.4%2c6.6-6.5%2c10.7l-2.7-4.3c4-4.6%2c7-9.5%2c9-14.8h-8.8v-4.1h8.9V35.5z M220.1%2c63v-4.4l16-2.4V28.6h4.4v27l4.3-0.7v4.4 l-4.3%2c0.7v13.7h-4.4V60.5L220.1%2c63z M230.5%2c53.3c-3.3-2.7-6.2-4.9-8.7-6.4l2.8-3.2c2.4%2c1.2%2c5.3%2c3.2%2c8.9%2c5.9L230.5%2c53.3z M231.4%2c41.6c-3.5-2.8-6.4-4.9-8.6-6.3l2.9-3.2c2.1%2c1.2%2c5%2c3.1%2c8.8%2c5.8L231.4%2c41.6z'/%3e %3cpath class='st1' d='M279.1%2c42.8h-5.6v8.5c2.6-0.8%2c4.4-1.5%2c5.6-2.1v4.7c-1%2c0.5-2.9%2c1.3-5.6%2c2.2v11.7c0%2c2.3-0.3%2c3.8-1%2c4.5 c-0.7%2c0.8-2.2%2c1.1-4.6%2c1.1h-3.8l-1.1-4.8l4.2%2c0.1c1%2c0%2c1.6-0.5%2c1.6-1.6v-9.8c-2.7%2c0.7-4.8%2c1.2-6.4%2c1.6l-1.1-5.2 c2.8-0.3%2c5.3-0.8%2c7.6-1.4v-9.6h-7.1v-4.4h7.1v-9.8h4.7v9.8h5.6v-3.1h10.3v-6.8h4.7v6.8h11.3v4.4h-11.3v6.4h9.7v4 c-0.4%2c1.7-1.5%2c4-3.2%2c6.8c-1.7%2c2.8-3.4%2c5-5.2%2c6.6c3.2%2c2.6%2c6.8%2c4.5%2c10.8%2c5.6l-2.4%2c4.5c-4.2-1.4-8.2-3.7-11.9-7.1 c-5%2c3.9-9.9%2c6.3-14.5%2c7.2l-2.6-4.4c4.6-1%2c9.2-3.1%2c13.8-6.2c-2.5-2.5-4.9-5.9-7.2-10.2l4-1.6c2.2%2c3.9%2c4.4%2c6.9%2c6.6%2c9.1 c3.3-2.6%2c5.6-5.9%2c6.9-9.9h-19v-4.4h9.5v-6.4h-10.3L279.1%2c42.8z'/%3e %3cpath class='st1' d='M351.1%2c45.7c0.7%2c3.9%2c2.5%2c8%2c5.2%2c12.3c2.7%2c4.3%2c6.4%2c8%2c11.2%2c11.1l-3.7%2c4.4c-8.6-5.6-14.5-14.9-17.7-27.8h-0.8 c-2.1%2c11.5-8.6%2c20.8-19.3%2c27.9l-3.6-4.5c4.5-2.6%2c8.4-6%2c11.7-10.2c3.2-4.2%2c5.2-8.6%2c6-13.1h-16.5v-5.1h17.3 c0.4-2.9%2c0.6-6.9%2c0.6-12h5c0%2c5.5-0.1%2c9.5-0.4%2c12h20.3v5.1L351.1%2c45.7z'/%3e %3cpath class='st1' d='M419.4%2c54.6v3.5c-2.8%2c1.5-6.3%2c2.9-10.4%2c4.2h19.9v3.9H409v2c0%2c3.4-1.5%2c5.1-4.4%2c5.1h-7l-1.1-3.9l6.6%2c0.2 c1%2c0%2c1.4-0.5%2c1.4-1.4v-2h-20.8v-3.9h20.8v-2.1c2.2-0.4%2c5-1.1%2c8.4-2.1h-20.2v-3.5H419.4z M423.6%2c52.6H389v7h-4.3V48.8h2.4 l-0.5-18.4c4.1-0.1%2c7.7-0.6%2c10.5-1.4l2.1%2c3.5c-1.8%2c0.6-4.6%2c1-8.5%2c1.3l0.1%2c2.4h7.5v3.3H391l0%2c2.7h7.3v3.3h-7.2l0.1%2c3.2h30l0-3.2 h-6.7v-3.3h6.8l0.1-2.7h-6.9v-3.3h7l0-2.6h-7.6v-3.8h11.8l-0.5%2c18.9h2.5v10.8h-4.3V52.6z M407%2c35.3c-1.6%2c1-3.5%2c2-5.6%2c2.9 l-2.4-3.2c2.7-0.7%2c4.4-1.4%2c5.3-2c-0.8-0.6-1.9-1.4-3.3-2.2l2.6-2.3c1.2%2c0.8%2c2.5%2c1.7%2c3.8%2c2.6c1.4-0.9%2c2.3-1.8%2c2.9-2.6l2.4%2c2.2 c-0.7%2c1-1.6%2c1.8-2.8%2c2.6c0.6%2c0.6%2c1.5%2c1.4%2c2.5%2c2.5l-2.9%2c2.2C408.2%2c36.3%2c407.4%2c35.3%2c407%2c35.3z M407.3%2c45.2c-1.5%2c1-3.3%2c1.9-5.6%2c2.7 l-2.1-3.2c2.2-0.5%2c3.9-1.1%2c5-1.7c-0.6-0.5-1.7-1.2-3.2-2.3l2.5-2.1c0.6%2c0.4%2c1.2%2c0.8%2c1.7%2c1.1c0.6%2c0.4%2c1.3%2c0.9%2c2%2c1.5 c1-0.6%2c2.1-1.6%2c3.3-3l2.5%2c2.2c-1.2%2c1.2-2.3%2c2.1-3.3%2c2.9c0.9%2c0.8%2c1.8%2c1.6%2c2.7%2c2.5l-3.1%2c2.3C408.4%2c46.1%2c407.5%2c45.2%2c407.3%2c45.2z'/%3e %3c/g%3e %3c/g%3e %3cg%3e %3cg%3e %3cg%3e %3cpath class='st1' d='M462.9%2c28c-2.1%2c4-3.6%2c7.3-4.5%2c9.9c-1.5%2c4.3-2.2%2c8.8-2.2%2c13.4c0%2c7.5%2c2.2%2c15.2%2c6.7%2c23.2h-3.6 c-2.4-3.3-4.4-7-6.1-11.1c-1.5-4.1-2.3-8.2-2.3-12.2c0-5.5%2c1.4-11%2c4.2-16.3c1.5-2.8%2c2.9-5.1%2c4.2-6.8H462.9z'/%3e %3cpath class='st1' d='M482%2c34.4v8.9c0%2c13.6-1.6%2c23.6-4.7%2c30l-3.3-3.7c2.5-5.8%2c3.8-14.8%2c3.8-27.1V30.8h20.1 c-0.2-0.3-0.6-1.3-1.4-2.8l4.6-0.5c0.5%2c0.8%2c1.1%2c2%2c1.7%2c3.3h16.8v3.6H482z M495.4%2c66.8l2.7%2c3c-3.4%2c1.6-8.2%2c2.9-14.3%2c3.8l-2-3.8 C487.6%2c69.4%2c492.1%2c68.4%2c495.4%2c66.8z M505.5%2c66.8H486V50.9h13.2v-2.3h-15.7v-3.3h35.7v3.3h-15.9v2.3h13.1v15.9H505.5 c6.1%2c1.5%2c10.5%2c2.6%2c13.1%2c3.2l-2.3%2c3.6c-1.9-0.6-3.9-1.2-6.1-1.8c-2.5-0.7-4.8-1.4-6.9-2.1L505.5%2c66.8z M499.1%2c57.3v-3.2h-9v3.2 H499.1z M499.1%2c63.6v-3.3h-9v3.3H499.1z M512.3%2c57.3v-3.2h-9v3.2H512.3z M512.3%2c63.6v-3.3h-9v3.3H512.3z'/%3e %3cpath class='st1' d='M542.8%2c39.9c-0.4%2c4.9-1.3%2c9.8-2.9%2c14.9l-4.6-1.8c1.8-4%2c2.8-8.7%2c3-14L542.8%2c39.9z M540.2%2c72.7l-4.2-3.9 c2.9-2.1%2c5.2-4.8%2c6.8-8c1.6-3.3%2c2.4-8.3%2c2.4-15.1V28.7h4.8v20.5C550%2c59.3%2c546.7%2c67.2%2c540.2%2c72.7z M554.2%2c54.7 c-1-6.1-2.3-10.8-3.8-13.9l4.3-1.6c1.7%2c4.7%2c3.1%2c9.5%2c4.1%2c14.3L554.2%2c54.7z M559.7%2c29.1h4.6v43h-4.6V29.1z M569.5%2c54.3 c-0.5-4.3-1.9-8.9-4.2-13.8l4.2-1.6c2.2%2c5.1%2c3.8%2c9.7%2c4.8%2c14L569.5%2c54.3z M575.1%2c28.1h4.8v45.6h-4.8V28.1z'/%3e %3cpath class='st1' d='M605.1%2c51.3c0%2c5.5-1.4%2c10.9-4.2%2c16.3c-1.4%2c2.6-2.8%2c4.9-4.2%2c6.8h-3.6c2.1-4%2c3.6-7.3%2c4.6-9.8 c1.5-4.3%2c2.2-8.8%2c2.2-13.5c0-7.5-2.2-15.2-6.7-23.2h3.6c2.4%2c3.2%2c4.4%2c6.9%2c6%2c11.1C604.3%2c43.3%2c605.1%2c47.4%2c605.1%2c51.3z'/%3e %3c/g%3e %3cpath class='st1' d='M495.8%2c46.7v-4.6h11.1v4.6l4.4%2c0v-4.6h6.3v-3.3h-6.3v-3.2h-4.4v3.2h-11.1v-3.2h-4.4v3.2h-6.8v3.3h6.8v4.6 L495.8%2c46.7z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/g%3e%3c/svg%3e";
var img$7 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='utf-8'%3f%3e%3c!-- Generator: Adobe Illustrator 16.0.0%2c SVG Export Plug-In . SVG Version: 6.00 Build 0) --%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='1618px' height='324px' viewBox='468.5 118.5 1618 324' enable-background='new 468.5 118.5 1618 324' xml:space='preserve' %3e%3cpath fill='%23996600' d='M633.694%2c438.777l-36.895-61.93c0%2c0-1.317-1.317-1.317-3.953v-1.317v-3.294V258.259h-13.835v115.294v3.294 c1.317%2c1.317%2c24.376%2c40.847%2c24.376%2c40.847h-57.977c0%2c0%2c23.059-40.188%2c24.377-40.847v-3.294V258.259h-13.836v110.023v3.294v1.317 c0%2c2.636-1.317%2c3.953-1.317%2c3.953l-36.894%2c61.93H633.694z'/%3e%3cpath fill='%23996600' d='M621.835%2c177.882c0%2c0%2c7.247-28.988-17.788-48.094c0%2c0-9.882-9.224-28.988-9.224 c-17.129%2c0-27.012%2c9.224-27.012%2c9.224c-23.059%2c15.812-17.129%2c48.094-17.129%2c48.094H621.835z'/%3e%3cpath fill='%23996600' d='M534.212%2c185.788h85.647c0.658-1.317%2c1.317-3.294%2c1.976-5.271h-89.6 C532.895%2c182.494%2c533.553%2c183.812%2c534.212%2c185.788'/%3e%3cpath fill='%23996600' d='M617.883%2c188.423h-82.354c0.659%2c1.977%2c1.977%2c3.295%2c2.636%2c5.271h77.082 C616.564%2c191.718%2c617.224%2c190.4%2c617.883%2c188.423'/%3e%3cpath fill='%23996600' d='M544.094%2c200.282h65.883c1.317-1.317%2c2.635-2.636%2c3.294-3.953H540.8 C541.459%2c198.306%2c542.776%2c199.623%2c544.094%2c200.282'/%3e%3cpath fill='%23996600' d='M550.683%2c206.87h51.388c1.318-0.658%2c2.636-1.977%2c3.953-3.294h-59.294 C548.047%2c204.894%2c549.365%2c205.553%2c550.683%2c206.87'/%3e%3cpath fill='%23996600' d='M557.93%2c210.823c5.93%2c2.636%2c11.858%2c3.953%2c18.447%2c3.953c6.588%2c0%2c13.176-1.317%2c18.446-3.953H557.93 L557.93%2c210.823z'/%3e%3cpath fill='%23003366' d='M665.317%2c216.753h-69.835c0%2c0-6.588%2c0-11.859%2c3.294c-3.952%2c2.635-6.588%2c9.224-7.246%2c9.224l0%2c0 c0%2c0-3.295-6.589-7.248-9.224c-5.27-3.294-11.858-3.294-11.858-3.294h-69.177l-13.835%2c22.399h63.906c0%2c0%2c1.977%2c0%2c3.294%2c0 c1.977%2c0%2c5.271%2c1.318%2c8.564%2c3.953c4.612%2c3.294%2c5.93%2c5.271%2c7.247%2c6.589c0.659%2c0.658%2c1.977%2c2.635%2c1.977%2c2.635h15.812h1.977h5.271 h11.859c0%2c0%2c1.317-1.977%2c1.977-2.635c1.317-1.318%2c2.635-2.636%2c7.247-6.589c3.294-2.635%2c6.588-3.294%2c8.564-3.953 c1.317%2c0%2c3.294%2c0%2c3.294%2c0h63.906L665.317%2c216.753z'/%3e%3cpath fill='%23003366' d='M481.506%2c245.741v104.752v1.318c0%2c1.317%2c0%2c1.977%2c0%2c3.294c1.317%2c11.2%2c4.611%2c19.765%2c11.2%2c30.306 c10.541%2c17.13%2c28.988%2c28.988%2c28.988%2c28.988l8.564-13.835c0%2c0-11.858-6.589-21.741-21.083c-1.977-2.635-3.953-5.929-5.271-8.564 c-1.317-2.635-1.977-4.611-2.636-6.588c-0.658-1.317-0.658-3.294-1.317-4.612c-0.658-1.977-0.658-3.294-0.658-5.271 c0-0.658%2c0-3.294%2c0-3.294v-0.658V245.082h-17.13V245.741z'/%3e%3cpath fill='%23003366' d='M507.859%2c245.741v106.07v0.658c0%2c0.659%2c0%2c1.318%2c0%2c1.977c0%2c0.659%2c0%2c0.659%2c0%2c1.318 c0.658%2c1.317%2c0.658%2c3.294%2c1.317%2c5.271c1.317%2c3.294%2c3.294%2c7.905%2c6.588%2c12.518C523.671%2c386.071%2c534.871%2c392%2c534.871%2c392l8.564-13.836 c0%2c0-2.636-1.317-6.589-5.271c-2.635-1.977-5.271-5.271-7.247-8.564c-2.635-3.294-3.952-7.247-4.611-9.883 c-0.659-1.977-0.659-3.952-0.659-5.271c0-0.658%2c0-1.317%2c0-1.317V245.741H507.859z'/%3e%3cpath fill='%23003366' d='M672.564%2c245.741v104.752v1.318c0%2c1.317%2c0%2c1.977%2c0%2c3.294c-1.317%2c11.2-4.611%2c19.765-11.199%2c30.306 c-10.542%2c17.788-28.988%2c29.647-28.988%2c29.647l-8.565-13.836c0%2c0%2c11.859-6.588%2c21.741-21.082c1.977-2.635%2c3.953-5.93%2c5.271-8.564 c1.318-2.636%2c1.977-4.612%2c2.636-6.589c0.658-1.317%2c0.658-3.294%2c1.317-4.611c0.659-1.977%2c0.659-3.294%2c0.659-5.271 c0-0.659%2c0-3.294%2c0-3.294v-0.659V245.741H672.564L672.564%2c245.741z'/%3e%3cpath fill='%23003366' d='M645.553%2c245.741v106.07v0.658c0%2c0.659%2c0%2c1.318%2c0%2c1.977c0%2c0.659%2c0%2c0.659%2c0%2c1.318 c-0.658%2c1.317-0.658%2c3.294-1.317%2c5.271c-1.317%2c3.294-3.294%2c7.905-6.588%2c12.518C629.741%2c386.071%2c618.541%2c392%2c618.541%2c392 l-8.564-13.836c0%2c0%2c2.635-1.317%2c6.588-5.271c2.636-1.977%2c5.271-5.271%2c7.247-8.564c2.636-3.294%2c3.953-7.247%2c4.612-9.883 c0.658-1.977%2c0.658-3.952%2c0.658-5.271c0-0.658%2c0-1.317%2c0-1.317V245.741H645.553z'/%3e%3cg%3e %3cpath fill='%23003366' d='M753.6%2c437.458h-9.223v-64.564h-17.13v-8.564h43.482v8.564H753.6V437.458z'/%3e %3cpath fill='%23003366' d='M779.294%2c364.329h38.871v8.564h-30.306v20.424h28.988v8.564h-28.988v27.671h30.306v8.564h-38.871V364.329z' /%3e %3cpath fill='%23003366' d='M883.389%2c378.164c-5.271-4.611-12.518-7.247-19.106-7.247c-16.471%2c0-28.988%2c13.836-28.988%2c29.647 s12.518%2c29.646%2c28.329%2c29.646c7.248%2c0%2c13.836-2.635%2c19.106-7.247v10.542c-5.271%2c3.294-12.518%2c5.271-19.106%2c5.271 c-20.423%2c0-38.211-16.471-38.211-37.554c0-21.741%2c17.129-38.211%2c38.87-38.211c6.589%2c0%2c12.518%2c1.317%2c18.447%2c4.611v10.541H883.389z' /%3e %3cpath fill='%23003366' d='M938.07%2c393.976v-28.988h9.224v72.471h-9.224v-34.917h-34.917v34.917h-8.565v-72.471h9.224v28.988H938.07 L938.07%2c393.976z'/%3e %3cpath fill='%23003366' d='M960.471%2c361.035l54.683%2c57.317v-54.023h9.224v75.765l-54.683-57.317V436.8h-9.224V361.035z'/%3e %3cpath fill='%23003366' d='M1108.706%2c401.223c0%2c21.741-17.13%2c38.212-38.212%2c38.212s-38.212-16.471-38.212-38.212 c0-21.082%2c17.13-37.553%2c38.212-37.553C1091.576%2c363.012%2c1108.706%2c380.141%2c1108.706%2c401.223z M1099.482%2c401.223 c0-15.812-11.859-29.646-28.988-29.646s-28.988%2c13.177-28.988%2c29.646c0%2c16.471%2c13.177%2c29.647%2c28.988%2c29.647 C1086.306%2c430.211%2c1099.482%2c417.694%2c1099.482%2c401.223z'/%3e %3cpath fill='%23003366' d='M1127.812%2c428.894h22.4v8.564h-31.624v-72.471h9.224V428.894z'/%3e %3cpath fill='%23003366' d='M1227.953%2c401.223c0%2c21.741-17.129%2c38.212-38.212%2c38.212c-21.082%2c0-38.212-16.471-38.212-38.212 c0-21.082%2c17.13-37.553%2c38.212-37.553C1210.165%2c363.012%2c1227.953%2c380.141%2c1227.953%2c401.223z M1218.729%2c401.223 c0-15.812-11.858-29.646-28.988-29.646s-28.988%2c13.177-28.988%2c29.646c0%2c16.471%2c13.177%2c29.647%2c28.988%2c29.647 C1205.553%2c430.211%2c1218.729%2c417.694%2c1218.729%2c401.223z'/%3e %3cpath fill='%23003366' d='M1303.718%2c400.565v2.635c0%2c19.765-13.835%2c35.577-34.259%2c35.577s-36.895-17.789-36.895-37.554 c0-21.082%2c16.471-38.211%2c37.553-38.211c11.201%2c0%2c22.4%2c5.271%2c29.647%2c13.835l-6.588%2c5.93c-5.271-7.247-13.835-11.859-23.06-11.859 c-16.471%2c0-28.988%2c13.177-28.988%2c29.647c0%2c15.152%2c12.518%2c29.646%2c28.33%2c29.646c11.2%2c0%2c23.718-9.882%2c23.718-21.741h-19.106v-8.564 h29.647V400.565z'/%3e %3cpath fill='%23003366' d='M1306.354%2c364.329h10.541l17.788%2c30.965l17.788-30.965h10.541l-23.718%2c40.847V436.8h-9.224v-31.624 L1306.354%2c364.329z'/%3e%3c/g%3e%3cg%3e %3cpath fill='%23003366' d='M747.671%2c206.212h-9.224v-64.565h-17.13v-8.564H764.8v8.564h-17.129V206.212z'/%3e %3cpath fill='%23003366' d='M816.188%2c162.73v-28.988h9.224v72.471h-9.224v-34.918h-34.918v34.918h-9.224v-72.471h9.224v28.988H816.188 L816.188%2c162.73z'/%3e %3cpath fill='%23003366' d='M839.247%2c133.082h38.87v8.564h-30.306v20.424H876.8v8.564h-28.988v27.012h30.306v8.565h-38.87V133.082z'/%3e %3cpath fill='%23003366' d='M961.788%2c162.73v-28.988h9.224v72.471h-9.224v-34.918h-34.259v34.918h-9.224v-72.471h9.224v28.988H961.788 L961.788%2c162.73z'/%3e %3cpath fill='%23003366' d='M1056%2c169.318c0%2c21.741-17.129%2c38.212-38.212%2c38.212c-21.082%2c0-38.212-16.471-38.212-38.212 c0-21.082%2c17.13-37.553%2c38.212-37.553C1038.871%2c131.765%2c1056%2c148.894%2c1056%2c169.318z M1046.776%2c169.318 c0-15.812-11.858-29.647-28.988-29.647c-17.129%2c0-28.988%2c13.177-28.988%2c29.647s13.177%2c29.647%2c28.988%2c29.647 S1046.776%2c186.448%2c1046.776%2c169.318z'/%3e %3cpath fill='%23003366' d='M1065.224%2c129.788l54.683%2c57.317v-54.023h9.224v75.765l-55.342-57.317v54.023h-9.224v-75.765H1065.224z'/%3e %3cpath fill='%23003366' d='M1208.848%2c169.318v2.636c0%2c19.765-13.836%2c35.576-34.26%2c35.576c-20.423%2c0-36.894-17.788-36.894-37.553 c0-21.083%2c16.471-38.212%2c37.553-38.212c11.2%2c0%2c22.399%2c5.271%2c29.647%2c13.835l-6.589%2c5.93c-5.271-7.247-13.835-11.859-23.059-11.859 c-16.471%2c0-28.988%2c13.177-28.988%2c29.647c0%2c15.153%2c12.518%2c29.647%2c28.329%2c29.647c11.2%2c0%2c23.718-9.883%2c23.718-21.741H1179.2v-8.565 h29.647V169.318z'/%3e %3cpath fill='%23003366' d='M1287.247%2c133.082h11.858l-32.94%2c32.941l32.94%2c40.188h-12.518l-27.67-33.601l-3.953%2c3.294v30.307h-9.224 v-72.471h9.224v30.965L1287.247%2c133.082z'/%3e %3cpath fill='%23003366' d='M1377.506%2c169.318c0%2c21.741-17.129%2c38.212-38.212%2c38.212c-21.082%2c0-38.212-16.471-38.212-38.212 c0-21.082%2c17.13-37.553%2c38.212-37.553C1360.377%2c131.765%2c1377.506%2c148.894%2c1377.506%2c169.318z M1368.282%2c169.318 c0-15.812-11.858-29.647-28.988-29.647c-17.129%2c0-28.988%2c13.177-28.988%2c29.647s13.177%2c29.647%2c28.988%2c29.647 S1368.282%2c186.448%2c1368.282%2c169.318z'/%3e %3cpath fill='%23003366' d='M1386.07%2c129.788l54.683%2c57.317v-54.023h9.224v75.765l-54.683-57.317v54.023h-9.224V129.788z'/%3e %3cpath fill='%23003366' d='M1529.694%2c169.318v2.636c0%2c19.765-13.835%2c35.576-34.259%2c35.576s-36.895-17.788-36.895-37.553 c0-21.083%2c16.471-38.212%2c37.553-38.212c11.2%2c0%2c22.4%2c5.271%2c29.647%2c13.835l-6.589%2c5.93c-5.27-7.247-13.835-11.859-23.059-11.859 c-16.471%2c0-28.988%2c13.177-28.988%2c29.647c0%2c15.153%2c12.518%2c29.647%2c28.33%2c29.647c11.199%2c0%2c23.718-9.883%2c23.718-21.741h-19.106v-8.565 h29.647V169.318z'/%3e%3c/g%3e%3cg%3e %3cg%3e %3cpath fill='%23003366' d='M1497.412%2c400.565v2.635c0%2c19.765-13.836%2c35.577-34.259%2c35.577c-20.424%2c0-36.895-17.789-36.895-37.554 c0-21.082%2c17.13-38.211%2c37.553-38.211c11.2%2c0%2c22.4%2c5.271%2c29.647%2c13.835l-6.588%2c5.93c-5.271-7.247-13.836-11.859-23.06-11.859 c-16.47%2c0-28.987%2c13.177-28.987%2c29.647c0%2c15.152%2c12.518%2c29.646%2c28.329%2c29.646c11.2%2c0%2c23.718-9.882%2c23.718-21.741h-19.106v-8.564 h29.647V400.565z'/%3e %3cpath fill='%23003366' d='M1514.541%2c364.329v42.823c0%2c11.859%2c3.295%2c23.059%2c17.789%2c23.059c13.835%2c0%2c17.787-11.199%2c17.787-23.059 v-42.823h9.225v46.117c0%2c15.813-9.883%2c28.33-26.354%2c28.33s-26.354-12.518-26.354-28.33v-46.117H1514.541L1514.541%2c364.329z'/%3e %3cpath fill='%23003366' d='M1583.059%2c419.012l-8.564%2c18.446h-9.883l34.918-75.765l34.918%2c75.765h-9.883L1616%2c419.012H1583.059 L1583.059%2c419.012z M1599.529%2c381.458l-13.176%2c29.647h25.693L1599.529%2c381.458z'/%3e %3cpath fill='%23003366' d='M1640.377%2c361.035l54.682%2c57.317v-54.023h9.224v75.765l-54.683-57.317V436.8h-9.223V361.035z'/%3e %3cpath fill='%23003366' d='M1784.659%2c400.565v2.635c0%2c19.765-13.835%2c35.577-34.259%2c35.577s-36.895-17.789-36.895-37.554 c0-21.082%2c17.129-38.211%2c37.553-38.211c11.2%2c0%2c22.4%2c5.271%2c29.647%2c13.835l-6.589%2c5.93c-5.27-7.247-13.835-11.859-23.059-11.859 c-16.471%2c0-28.988%2c13.177-28.988%2c29.647c0%2c15.152%2c12.518%2c29.646%2c28.33%2c29.646c11.199%2c0%2c23.717-9.882%2c23.717-21.741h-19.105v-8.564 h29.647V400.565z'/%3e %3cpath fill='%23003366' d='M1840%2c428.894v8.564h-51.389l36.895-64.564h-31.623v-8.564h46.776l-36.895%2c64.564H1840L1840%2c428.894z'/%3e %3cpath fill='%23003366' d='M1891.389%2c393.976v-29.646h9.223v73.129h-9.223v-34.917h-34.918v34.917h-9.224v-73.129h9.224v29.646 H1891.389z'/%3e %3cpath fill='%23003366' d='M1985.6%2c401.223c0%2c21.741-17.129%2c38.212-38.211%2c38.212s-38.212-16.471-38.212-38.212 c0-21.082%2c17.13-38.211%2c38.212-38.211S1985.6%2c380.141%2c1985.6%2c401.223z M1976.377%2c401.223c0-15.812-11.859-29.646-28.988-29.646 c-17.13%2c0-28.988%2c13.177-28.988%2c29.646c0%2c16.471%2c13.176%2c29.647%2c28.988%2c29.647C1963.2%2c430.211%2c1976.377%2c417.694%2c1976.377%2c401.223z' /%3e %3cpath fill='%23003366' d='M2003.389%2c364.329v42.823c0%2c11.859%2c3.294%2c23.059%2c17.788%2c23.059c13.835%2c0%2c17.788-11.199%2c17.788-23.059 v-42.823h9.224v46.117c0%2c15.813-9.883%2c28.33-26.353%2c28.33c-16.471%2c0-26.354-12.518-26.354-28.33v-46.117H2003.389 L2003.389%2c364.329z'/%3e %3c/g%3e%3c/g%3e%3cg%3e %3cpath fill='%23003366' d='M1414.4%2c357.74c-3.953%2c7.247-6.589%2c13.836-8.565%2c18.447c-2.635%2c7.906-3.952%2c16.471-3.952%2c25.035 c0%2c13.836%2c3.952%2c28.33%2c12.518%2c42.824h-6.589c-4.611-5.93-7.905-13.177-11.2-20.424c-2.635-7.906-4.611-15.153-4.611-22.4 c0-9.882%2c2.635-20.423%2c7.906-30.306c2.635-5.271%2c5.271-9.224%2c7.905-12.518h6.589V357.74z'/%3e %3cpath fill='%23003366' d='M2086.4%2c401.223c0%2c9.883-2.636%2c20.424-7.906%2c30.307c-2.635%2c4.611-5.271%2c9.224-7.906%2c12.518H2064 c3.953-7.247%2c6.588-13.177%2c8.564-18.447c2.636-7.906%2c3.953-16.471%2c3.953-25.035c0-13.836-3.953-28.33-12.518-42.824h6.588 c4.612%2c5.93%2c7.906%2c12.519%2c11.2%2c20.424C2084.424%2c386.071%2c2086.4%2c393.976%2c2086.4%2c401.223z'/%3e%3c/g%3e%3cg%3e %3cpath fill='%23003366' d='M735.812%2c249.035v42.823c0%2c11.858%2c3.294%2c23.059%2c17.788%2c23.059c13.836%2c0%2c17.789-11.2%2c17.789-23.059v-42.823 h9.223v46.117c0%2c15.812-9.882%2c28.329-26.353%2c28.329s-26.353-12.518-26.353-28.329v-46.117H735.812z'/%3e %3cpath fill='%23003366' d='M793.788%2c245.741l54.683%2c57.317v-54.023h9.224V324.8l-54.683-57.317v54.023h-9.224V245.741z'/%3e %3cpath fill='%23003366' d='M884.047%2c321.506h-9.224v-72.471h9.224V321.506z'/%3e %3cpath fill='%23003366' d='M922.918%2c302.4l21.741-54.023h9.882L922.918%2c324.8l-31.624-76.424h9.883L922.918%2c302.4z'/%3e %3cpath fill='%23003366' d='M961.788%2c249.035h38.871v7.906h-30.306v20.423H1000v8.564h-28.988V313.6h30.306v8.564h-38.87v-73.129 H961.788z'/%3e %3cpath fill='%23003366' d='M1057.977%2c321.506h-11.2l-21.082-30.965h-3.953v30.965h-9.224v-72.471h11.2c6.588%2c0%2c13.177%2c0%2c19.105%2c3.294 c5.93%2c3.294%2c9.224%2c10.541%2c9.224%2c17.13c0%2c10.541-7.247%2c19.105-17.129%2c20.423L1057.977%2c321.506z M1021.741%2c283.294h2.636 c9.223%2c0%2c19.105-1.977%2c19.105-13.177s-10.541-13.176-19.765-13.176h-2.636v26.353H1021.741z'/%3e %3cpath fill='%23003366' d='M1099.482%2c262.87c-2.635-4.611-5.93-6.588-11.859-6.588c-5.929%2c0-11.858%2c3.953-11.858%2c10.541 c0%2c5.93%2c5.271%2c8.564%2c9.882%2c10.541l5.271%2c1.977c10.541%2c3.953%2c17.788%2c9.883%2c17.788%2c21.741c0%2c13.177-9.883%2c22.399-23.06%2c22.399 c-11.858%2c0-21.082-8.564-22.399-20.423l9.224-1.977c0%2c7.905%2c6.588%2c13.835%2c13.835%2c13.835c7.906%2c0%2c13.177-6.588%2c13.177-14.494 c0-7.905-6.588-11.199-12.518-13.835l-5.271-1.977c-8.565-3.294-15.812-8.564-15.812-18.447c0-11.858%2c10.541-19.105%2c21.082-19.105 c7.905%2c0%2c14.494%2c3.953%2c18.447%2c11.2L1099.482%2c262.87z'/%3e %3cpath fill='%23003366' d='M1130.447%2c321.506h-9.224v-72.471h9.224V321.506z'/%3e %3cpath fill='%23003366' d='M1166.683%2c321.506h-9.224v-64.564h-17.13v-8.565h43.482v8.565h-17.129V321.506z'/%3e %3cpath fill='%23003366' d='M1187.105%2c249.035h10.541L1215.436%2c280l17.788-30.965h10.541l-23.718%2c40.847v31.624h-9.223v-31.624 L1187.105%2c249.035z'/%3e %3cpath fill='%23003366' d='M1352.471%2c285.271c0%2c21.741-17.129%2c38.211-38.212%2c38.211c-21.082%2c0-38.212-16.47-38.212-38.211 c0-21.083%2c17.13-37.553%2c38.212-37.553C1335.342%2c247.718%2c1352.471%2c264.188%2c1352.471%2c285.271z M1343.247%2c285.271 c0-15.812-11.858-29.647-28.988-29.647s-28.988%2c13.177-28.988%2c29.647c0%2c16.47%2c13.177%2c29.646%2c28.988%2c29.646 S1343.247%2c301.74%2c1343.247%2c285.271z'/%3e %3cpath fill='%23003366' d='M1372.235%2c256.942v20.423h25.035v8.564h-25.035v35.577h-9.224v-72.471h34.918v7.906H1372.235z'/%3e %3cpath fill='%23003366' d='M1475.671%2c262.87c-2.636-4.611-5.93-6.588-11.859-6.588c-5.929%2c0-11.858%2c3.953-11.858%2c10.541 c0%2c5.93%2c5.271%2c8.564%2c9.882%2c10.541l5.271%2c1.977c10.541%2c3.953%2c17.789%2c9.883%2c17.789%2c21.741c0%2c13.177-10.541%2c22.399-23.06%2c22.399 c-11.858%2c0-21.082-8.564-22.399-20.423l9.223-1.977c0%2c7.905%2c6.589%2c13.835%2c13.836%2c13.835c7.906%2c0%2c13.177-6.588%2c13.177-14.494 c0-7.905-6.589-11.199-12.518-13.835l-5.271-1.977c-8.565-3.294-15.813-8.564-15.813-18.447c0-11.858%2c10.541-19.105%2c21.083-19.105 c7.905%2c0%2c14.493%2c3.953%2c18.446%2c11.2L1475.671%2c262.87z'/%3e %3cpath fill='%23003366' d='M1550.776%2c262.87c-5.271-4.611-12.518-7.247-19.105-7.247c-16.471%2c0-28.988%2c13.836-28.988%2c29.647 s12.518%2c29.646%2c28.329%2c29.646c7.247%2c0%2c13.836-2.635%2c19.105-7.247v10.541c-5.27%2c3.295-12.518%2c5.271-19.105%2c5.271 c-20.424%2c0-37.553-16.47-37.553-37.553c0-21.74%2c17.129-38.211%2c38.871-38.211c6.588%2c0%2c12.518%2c1.317%2c18.446%2c4.611V262.87z'/%3e %3cpath fill='%23003366' d='M1574.494%2c321.506h-9.224v-72.471h9.224V321.506z'/%3e %3cpath fill='%23003366' d='M1592.941%2c249.035h38.87v7.906h-30.306v20.423h28.988v8.564h-28.988V313.6h30.306v8.564h-38.87V249.035z'/%3e %3cpath fill='%23003366' d='M1646.307%2c245.741l54.682%2c57.317v-54.023h9.224V324.8l-54.683-57.317v54.023h-9.223V245.741z'/%3e %3cpath fill='%23003366' d='M1777.412%2c262.87c-5.271-4.611-12.518-7.247-19.105-7.247c-16.471%2c0-28.988%2c13.836-28.988%2c29.647 s12.518%2c29.646%2c28.329%2c29.646c7.247%2c0%2c13.835-2.635%2c19.105-7.247v10.541c-5.271%2c3.295-12.518%2c5.271-19.105%2c5.271 c-20.424%2c0-38.212-16.47-38.212-37.553c0-21.74%2c17.129-38.211%2c38.871-38.211c6.588%2c0%2c12.518%2c1.317%2c18.446%2c4.611v10.541H1777.412z' /%3e %3cpath fill='%23003366' d='M1790.588%2c249.035h38.871v7.906h-30.307v20.423h28.988v8.564h-28.988V313.6h30.307v8.564h-38.871V249.035z' /%3e%3c/g%3e%3cpath fill='%23003366' d='M1890.07%2c303.717l-8.564%2c18.447h-9.883l34.918-75.765l34.918%2c75.765h-9.883l-8.564-18.447H1890.07z M1906.541%2c266.164l-13.176%2c29.647h25.693L1906.541%2c266.164z'/%3e%3cpath fill='%23003366' d='M1949.365%2c245.741l54.682%2c57.317v-54.023h9.224V324.8l-54.683-57.317v54.023h-9.223V245.741z'/%3e%3cpath fill='%23003366' d='M2027.105%2c249.035h15.153c22.399%2c0%2c40.847%2c11.858%2c40.847%2c36.235c0%2c25.035-18.447%2c36.894-40.847%2c36.894 h-14.494v-73.129H2027.105z M2035.671%2c313.6h3.294c18.447%2c0%2c34.259-7.247%2c34.259-28.329c0-21.083-15.812-28.329-34.259-28.329 h-3.294V313.6z'/%3e%3c/svg%3e";
const _hoisted_1$5M = { class: "hkust-header-main" };
const _hoisted_2$5n = { class: "hkust-header-logo" };
const _hoisted_3$59 = {
  key: 0,
  href: "https://hkust-gz.edu.cn/zh-hans",
  class: "hkust-header-logo__gz-link"
};
const _hoisted_4$1O = /* @__PURE__ */ createBaseVNode("img", {
  src: img$8,
  class: "hkust-header-logo__gz-icon",
  target: "_bank",
  alt: "chinese logo"
}, null, -1);
const _hoisted_5$L = [
  _hoisted_4$1O
];
const _hoisted_6$m = {
  key: 1,
  href: "https://hkust-gz.edu.cn/",
  class: "hkust-header-logo__gz-link"
};
const _hoisted_7$f = /* @__PURE__ */ createBaseVNode("img", {
  src: img$7,
  class: "hkust-header-logo__gz-icon",
  target: "_bank",
  alt: "english logo"
}, null, -1);
const _hoisted_8$d = [
  _hoisted_7$f
];
const _hoisted_9$a = { class: "hkust-header-logo__department" };
const _hoisted_10$a = {
  key: 0,
  class: "hkust-header-logo__department-name"
};
const _hoisted_11$6 = { class: "hkust-header-right" };
const _hoisted_12$5 = { class: "hkust-header-menu" };
const _hoisted_13$4 = { class: "hkust-header-drawer__menu" };
const _hoisted_14$3 = { class: "hkust-header-drawer__toobar" };
const _hoisted_15$3 = {
  key: 0,
  href: "https://hkust-gz.edu.cn/",
  class: "hkust-header-drawer__hkustgz-link",
  target: "_blank",
  rel: "noreferrer"
};
const _hoisted_16$3 = {
  key: 0,
  class: "hkust-header-drawer__languages"
};
const _hoisted_17$2 = ["onClick"];
function render$1U(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_sub_header = resolveComponent("sub-header");
  const _component_search = resolveComponent("search");
  const _component_hkust_icon = resolveComponent("hkust-icon");
  const _component_list_icon = resolveComponent("list-icon");
  const _component_hkust_drawer = resolveComponent("hkust-drawer");
  const _component_hkust_search = resolveComponent("hkust-search");
  return openBlock(), createElementBlock("header", {
    class: normalizeClass([
      "hkust-header",
      _ctx.hasScrolled ? "is-scroll" : "",
      _ctx.isOpenDrawer ? "is-drawer-open" : "is-drawer-close"
    ])
  }, [
    _ctx.showSubheader ? (openBlock(), createBlock(_component_sub_header, {
      key: 0,
      ref: "subHeaderRef",
      "header-props": _ctx.props,
      onLocalesChange: _ctx.localesChange,
      onSearchIconClick: _ctx.searchIconClick,
      onFontSizeChange: _ctx.fontSizeChange,
      onOpen: _ctx.onSubheaderOpen
    }, {
      subcontent: withCtx(() => [
        renderSlot(_ctx.$slots, "subcontent")
      ]),
      locale: withCtx(() => [
        renderSlot(_ctx.$slots, "locale")
      ]),
      user: withCtx(() => [
        renderSlot(_ctx.$slots, "user")
      ]),
      _: 3
    }, 8, ["header-props", "onLocalesChange", "onSearchIconClick", "onFontSizeChange", "onOpen"])) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(["hkust-header-main-container", _ctx.className])
    }, [
      createBaseVNode("div", _hoisted_1$5M, [
        createBaseVNode("div", _hoisted_2$5n, [
          createBaseVNode("div", {
            class: normalizeClass(["hkust-header-logo__gz", { "is-scroll": _ctx.hasScrolled }])
          }, [
            renderSlot(_ctx.$slots, "hkustLogo", {}, () => [
              _ctx.lang === "zh-cn" ? (openBlock(), createElementBlock("a", _hoisted_3$59, _hoisted_5$L)) : (openBlock(), createElementBlock("a", _hoisted_6$m, _hoisted_8$d))
            ])
          ], 2),
          createBaseVNode("div", _hoisted_9$a, [
            renderSlot(_ctx.$slots, "departmentLogo", {}, () => [
              _ctx.departmentName !== "" ? (openBlock(), createElementBlock("div", _hoisted_10$a, [
                createBaseVNode("span", {
                  class: normalizeClass(["hkust-header-logo__department-text", { "is-scroll": _ctx.hasScrolled }])
                }, toDisplayString$1(_ctx.departmentName), 3)
              ])) : createCommentVNode("v-if", true)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_11$6, [
          createBaseVNode("div", _hoisted_12$5, [
            renderSlot(_ctx.$slots, "headerMenu")
          ]),
          _ctx.showSearch ? (openBlock(), createBlock(_component_hkust_icon, {
            key: 0,
            class: "hkust-header-right__search-icon hkust-icon",
            onClick: _ctx.searchIconClick
          }, {
            default: withCtx(() => [
              createVNode(_component_search)
            ]),
            _: 1
          }, 8, ["onClick"])) : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass([
              "hkust-header-right__menu-icon-wrap",
              _ctx.isOpenDrawer ? "is-open" : ""
            ])
          }, [
            createVNode(_component_hkust_icon, {
              class: "hkust-header-right__menu-icon",
              onClick: _ctx.handleMenuIconClick
            }, {
              default: withCtx(() => [
                createVNode(_component_list_icon)
              ]),
              _: 1
            }, 8, ["onClick"])
          ], 2)
        ])
      ])
    ], 2),
    withDirectives(createVNode(_component_hkust_drawer, {
      modelValue: _ctx.isOpenDrawer,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.isOpenDrawer = $event),
      "show-close": false,
      "append-to-body": false,
      size: "fit-content",
      "modal-class": [
        "hkust-header-drawer",
        _ctx.isOpenDrawer ? "hkust-header-drawer--open" : "hkust-header-drawer--close"
      ],
      mode: "relative",
      onClosed: _ctx.handleDrawerClose
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_13$4, [
          renderSlot(_ctx.$slots, "headerMenu")
        ]),
        createBaseVNode("div", _hoisted_14$3, [
          _ctx.showHkustLink ? (openBlock(), createElementBlock("a", _hoisted_15$3, toDisplayString$1(_ctx.t("hkust.header.hkustGz")), 1)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "locale", {}, () => [
            _ctx.showLocale ? (openBlock(), createElementBlock("ul", _hoisted_16$3, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.locales, (item2) => {
                return openBlock(), createElementBlock("li", {
                  key: item2.value,
                  class: "hkust-header-drawer__languages-item",
                  onClick: ($event) => _ctx.changeLocale(item2.value)
                }, toDisplayString$1(item2.label), 9, _hoisted_17$2);
              }), 128))
            ])) : createCommentVNode("v-if", true)
          ])
        ])
      ]),
      _: 3
    }, 8, ["modelValue", "modal-class", "onClosed"]), [
      [vShow, _ctx.isOpenDrawer]
    ]),
    createVNode(_component_hkust_search, {
      modelValue: _ctx.isOpenSearch,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.isOpenSearch = $event),
      "teleport-target": _ctx.searchTeleport,
      onClose: _ctx.handleSearchClose
    }, null, 8, ["modelValue", "teleport-target", "onClose"])
  ], 2);
}
script$2.render = render$1U;
script$2.__file = "packages/components/header/src/index.vue";
const HkustHeader = withInstall$2(script$2);
var script$1 = defineComponent({
  name: "HkustCollapseTransition",
  setup() {
    return {
      on: {
        beforeEnter(el) {
          addClass$1(el, "collapse-transition");
          if (!el.dataset)
            el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.style.height = "0";
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        },
        enter(el) {
          el.dataset.oldOverflow = el.style.overflow;
          if (el.scrollHeight !== 0) {
            el.style.height = `${el.scrollHeight}px`;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          } else {
            el.style.height = "";
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }
          el.style.overflow = "hidden";
        },
        afterEnter(el) {
          removeClass$1(el, "collapse-transition");
          el.style.height = "";
          el.style.overflow = el.dataset.oldOverflow;
        },
        beforeLeave(el) {
          if (!el.dataset)
            el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.dataset.oldOverflow = el.style.overflow;
          el.style.height = `${el.scrollHeight}px`;
          el.style.overflow = "hidden";
        },
        leave(el) {
          if (el.scrollHeight !== 0) {
            addClass$1(el, "collapse-transition");
            el.style.transitionProperty = "height";
            el.style.height = 0;
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          }
        },
        afterLeave(el) {
          removeClass$1(el, "collapse-transition");
          el.style.height = "";
          el.style.overflow = el.dataset.oldOverflow;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
      }
    };
  }
});
function render$1T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, toHandlers(_ctx.on), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
script$1.render = render$1T;
script$1.__file = "packages/components/collapse-transition/src/collapse-transition.vue";
script$1.install = (app) => {
  app.component(script$1.name, script$1);
};
const _CollapseTransition = script$1;
const HkustCollapseTransition = _CollapseTransition;
const defaultMenus = [
  {
    label: "hkust.footer.privacy",
    path: "https://dataprivacy.ust.hk/university-data-privacy-policy-statement/",
    target: "_bank"
  }
];
var script = defineComponent({
  name: "HkustFooter",
  componentName: "HkustFooter",
  props: {
    menus: {
      type: Array,
      default: () => defaultMenus,
      validator(value) {
        return value instanceof Array;
      }
    },
    showSocialMedia: {
      type: Boolean,
      default: true
    },
    socialMedias: {
      type: Array,
      validator(value) {
        return value instanceof Array;
      }
    }
  },
  setup() {
    const { t, lang } = useLocale$2();
    return {
      lang,
      t
    };
  }
});
var img$6 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='213px' height='44px' viewBox='0 0 213 44' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3ein_UST-GZ_white_tc_L1%3c/title%3e %3cg id='3.0' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cg id='%e9%87%87%e8%b4%ad%e9%a6%96%e9%a1%b5' transform='translate(-230.000000%2c -2085.000000)' fill='white' fill-rule='nonzero'%3e %3cg id='in_UST-GZ_white_tc_L1' transform='translate(230.000000%2c 2085.000000)'%3e %3cg id='%e7%bc%96%e7%bb%84' transform='translate(-0.000000%2c 0.000000)'%3e %3cpath d='M21.6471275%2c43.14 L16.6081287%2c34.7588081 C16.6081287%2c34.7588081 16.4538737%2c34.5531347 16.4538737%2c34.2446246 L16.4538737%2c34.0389511 L16.4538737%2c33.6276043 L16.4538737%2c18.6134446 L14.5513945%2c18.6134446 L14.5513945%2c34.1932062 L14.5513945%2c34.6559714 C14.7056496%2c34.8102265 17.8935876%2c40.2091538 17.8935876%2c40.2091538 L10.0265793%2c40.2091538 C10.0265793%2c40.2091538 13.2145173%2c34.8102265 13.3687723%2c34.6559714 L13.3687723%2c34.1932062 L13.3687723%2c18.6134446 L11.4148749%2c18.6134446 L11.4148749%2c33.5761859 L11.4148749%2c33.9875328 L11.4148749%2c34.1932062 C11.4148749%2c34.5017163 11.2606198%2c34.7073897 11.2606198%2c34.7073897 L6.22162098%2c43.0885816 L21.6471275%2c43.0885816 L21.6471275%2c43.14 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cg transform='translate(7.666769%2c -0.000000)' id='%e8%b7%af%e5%be%84'%3e %3cpath d='M12.4378082%2c7.71275328 C12.4378082%2c7.71275328 13.3633386%2c3.80495828 10.0211455%2c1.23404052 C10.0211455%2c1.23404052 8.68426829%2c2.28343367e-16 6.11335053%2c2.28343367e-16 C3.74810619%2c2.28343367e-16 2.41122896%2c1.23404052 2.41122896%2c1.23404052 C-0.725290708%2c3.39361144 0.0974029751%2c7.71275328 0.0974029751%2c7.71275328 L12.4378082%2c7.71275328 Z'%3e%3c/path%3e %3cpath d='M0.457331461%2c8.79253874 L12.0264614%2c8.79253874 C12.1292981%2c8.58686532 12.1807164%2c8.32977354 12.2835532%2c8.12410012 L0.251658041%2c8.12410012 C0.303076396%2c8.3811919 0.405913106%2c8.58686532 0.457331461%2c8.79253874 Z'%3e%3c/path%3e %3cpath d='M11.8722063%2c9.20388558 L0.663004882%2c9.20388558 C0.765841592%2c9.46097735 0.920096658%2c9.66665077 1.07435172%2c9.8723242 L11.5122778%2c9.8723242 C11.6151145%2c9.66665077 11.7693696%2c9.46097735 11.8722063%2c9.20388558 Z'%3e%3c/path%3e %3cpath d='M1.7942087%2c10.8492729 L10.7410025%2c10.8492729 C10.8952576%2c10.6950179 11.0495126%2c10.4893445 11.2037677%2c10.283671 L1.3314435%2c10.283671 C1.48569857%2c10.4893445 1.63995363%2c10.6950179 1.7942087%2c10.8492729 Z'%3e%3c/path%3e %3cpath d='M2.77115744%2c11.6719666 L9.76405375%2c11.6719666 C9.96972717%2c11.5691299 10.1239822%2c11.4148749 10.2782373%2c11.2606198 L2.25697389%2c11.2606198 C2.41122896%2c11.4148749 2.56548402%2c11.5177116 2.77115744%2c11.6719666 Z'%3e%3c/path%3e %3cpath d='M3.74810619%2c12.1861502 C4.51938152%2c12.5460787 5.39349356%2c12.7517521 6.2676056%2c12.7517521 C7.19313599%2c12.7517521 8.01582967%2c12.5460787 8.787105%2c12.1861502 L3.74810619%2c12.1861502 Z'%3e%3c/path%3e %3c/g%3e %3cpath d='M25.9662694%2c13.0602622 L16.4538737%2c13.0602622 C16.4538737%2c13.0602622 15.5797616%2c13.0602622 14.8599046%2c13.5230274 C14.2943027%2c13.8829559 13.9343743%2c14.7570679 13.9343743%2c14.8084863 L13.9343743%2c14.8084863 C13.9343743%2c14.7570679 13.5230274%2c13.8829559 13.0088439%2c13.5230274 C12.2889869%2c13.0602622 11.4148749%2c13.0602622 11.4148749%2c13.0602622 L1.90247914%2c13.0602622 L-4.56686735e-16%2c16.0939452 L8.68970203%2c16.0939452 C8.68970203%2c16.0939452 8.9467938%2c16.0939452 9.10104887%2c16.1453635 C9.35814064%2c16.1967819 9.82090584%2c16.2996186 10.283671%2c16.6595471 C10.9521097%2c17.1223123 11.1063647%2c17.3794041 11.2606198%2c17.5336591 C11.3634565%2c17.6364958 11.5691299%2c17.8935876 11.5691299%2c17.8935876 L13.6772825%2c17.8935876 L13.9343743%2c17.8935876 L13.9343743%2c17.8935876 L14.6542312%2c17.8935876 L16.2996186%2c17.8935876 C16.2996186%2c17.8935876 16.505292%2c17.6364958 16.6081287%2c17.5336591 C16.7623838%2c17.3794041 16.9680572%2c17.1223123 17.5850775%2c16.6595471 C18.0478427%2c16.2996186 18.5106079%2c16.1967819 18.7676996%2c16.1453635 C18.9219547%2c16.0939452 19.1790465%2c16.0939452 19.1790465%2c16.0939452 L27.8687485%2c16.0939452 L25.9662694%2c13.0602622 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cg transform='translate(0.976949%2c 17.019476)' id='%e8%b7%af%e5%be%84'%3e %3cg transform='translate(0.000000%2c 0.000000)'%3e %3cpath d='M-4.56686735e-16%2c0 L-4.56686735e-16%2c14.2428844 C-4.56686735e-16%2c14.2428844 -4.56686735e-16%2c14.3971395 -4.56686735e-16%2c14.4485578 C-4.56686735e-16%2c14.6028129 -4.56686735e-16%2c14.7570679 -4.56686735e-16%2c14.8599046 C0.154255066%2c16.4024553 0.617020262%2c17.5336591 1.54255066%2c18.9733731 C2.93084625%2c21.287199 5.45034565%2c22.9325864 5.45034565%2c22.9325864 L6.63296782%2c21.0301073 C6.63296782%2c21.0301073 5.03899881%2c20.1559952 3.70212157%2c18.2020977 C3.4450298%2c17.7907509 3.18793802%2c17.4308224 2.9822646%2c17.0708939 C2.82800954%2c16.7109654 2.67375447%2c16.4538737 2.57091776%2c16.1453635 C2.5194994%2c15.9396901 2.41666269%2c15.7340167 2.41666269%2c15.5283433 C2.36524434%2c15.2712515 2.31382598%2c15.0655781 2.31382598%2c14.8084863 C2.31382598%2c14.7056496 2.31382598%2c14.3457211 2.31382598%2c14.3457211 L2.31382598%2c14.2943027 L2.31382598%2c0 L-4.56686735e-16%2c0 Z'%3e%3c/path%3e %3cpath d='M3.59928486%2c0 L3.59928486%2c14.3457211 C3.59928486%2c14.3457211 3.59928486%2c14.3971395 3.59928486%2c14.4485578 C3.59928486%2c14.4999762 3.59928486%2c14.6028129 3.59928486%2c14.7056496 C3.59928486%2c14.7570679 3.59928486%2c14.8084863 3.59928486%2c14.8599046 C3.65070322%2c15.0655781 3.70212157%2c15.2712515 3.80495828%2c15.5797616 C3.95921335%2c16.0425268 4.26772348%2c16.6595471 4.67907032%2c17.3279857 C5.75885578%2c19.0247914 7.30140644%2c19.8474851 7.30140644%2c19.8474851 L8.48402861%2c17.9964243 C8.48402861%2c17.9964243 8.07268176%2c17.7907509 7.60991657%2c17.3279857 C7.30140644%2c17.0194756 6.89005959%2c16.6081287 6.58154946%2c16.1453635 C6.27303933%2c15.6825983 6.06736591%2c15.1684148 5.9645292%2c14.8084863 C5.86169249%2c14.4999762 5.86169249%2c14.2428844 5.86169249%2c14.0886293 C5.86169249%2c13.9343743 5.86169249%2c13.8829559 5.86169249%2c13.8829559 L5.86169249%2c0 L3.59928486%2c0 L3.59928486%2c0 Z'%3e%3c/path%3e %3c/g%3e %3cg transform='translate(17.430822%2c 0.000000)'%3e %3cpath d='M8.48402861%2c0 L8.48402861%2c14.2428844 C8.48402861%2c14.2428844 8.48402861%2c14.3971395 8.48402861%2c14.4485578 C8.48402861%2c14.6028129 8.48402861%2c14.7570679 8.48402861%2c14.8599046 C8.32977354%2c16.4024553 7.86700834%2c17.5336591 6.94147795%2c18.9733731 C5.55318236%2c21.287199 3.03368296%2c22.9325864 3.03368296%2c22.9325864 L1.85106079%2c21.0301073 C1.85106079%2c21.0301073 3.4450298%2c20.1559952 4.78190703%2c18.2020977 C5.03899881%2c17.7907509 5.29609058%2c17.4308224 5.501764%2c17.0708939 C5.65601907%2c16.7109654 5.81027414%2c16.4538737 5.91311085%2c16.1453635 C5.9645292%2c15.9396901 6.06736591%2c15.7340167 6.06736591%2c15.5283433 C6.11878427%2c15.2712515 6.17020262%2c15.0655781 6.17020262%2c14.8084863 C6.17020262%2c14.7056496 6.17020262%2c14.3457211 6.17020262%2c14.3457211 L6.17020262%2c14.2943027 L6.17020262%2c0 L8.48402861%2c0 Z'%3e%3c/path%3e %3cpath d='M4.88474374%2c0 L4.88474374%2c14.3457211 C4.88474374%2c14.3457211 4.88474374%2c14.3971395 4.88474374%2c14.4485578 C4.88474374%2c14.4999762 4.88474374%2c14.6028129 4.88474374%2c14.7056496 C4.88474374%2c14.7570679 4.88474374%2c14.8084863 4.88474374%2c14.8599046 C4.83332539%2c15.0655781 4.78190703%2c15.2712515 4.67907032%2c15.5797616 C4.52481526%2c16.0425268 4.21630513%2c16.6595471 3.80495828%2c17.3279857 C2.72517282%2c19.0247914 1.18262217%2c19.8474851 1.18262217%2c19.8474851 L0%2c17.9964243 C0%2c17.9964243 0.411346841%2c17.7907509 0.874112038%2c17.3279857 C1.18262217%2c17.0194756 1.59396901%2c16.6081287 1.90247914%2c16.1453635 C2.21098927%2c15.6825983 2.41666269%2c15.1684148 2.5194994%2c14.8084863 C2.62233611%2c14.4999762 2.62233611%2c14.2428844 2.62233611%2c14.0886293 C2.62233611%2c13.9343743 2.62233611%2c13.8829559 2.62233611%2c13.8829559 L2.62233611%2c0 L4.88474374%2c0 L4.88474374%2c0 Z'%3e%3c/path%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg id='%e7%bc%96%e7%bb%84' transform='translate(35.581502%2c 16.042527)'%3e %3cpath d='M17.4822408%2c11.3634565 L17.4822408%2c20.6701788 L15.4769249%2c20.6701788 L15.4769249%2c19.6418117 L4.88474374%2c19.6418117 L4.88474374%2c20.6701788 L2.87942789%2c20.6701788 L2.87942789%2c11.4148749 C2.5194994%2c11.5691299 1.90247914%2c11.7748033 1.0283671%2c12.0833135 L0%2c10.1808343 C2.62233611%2c9.56381406 4.88474374%2c8.43261025 6.83864124%2c6.78722288 L0.154255066%2c6.78722288 L0.154255066%2c4.98758045 L8.99821216%2c4.98758045 L8.99821216%2c3.23935638 C5.75885578%2c3.29077473 3.4450298%2c3.39361144 2.05673421%2c3.39361144 L1.33687723%2c1.38829559 C2.15957092%2c1.38829559 3.18793802%2c1.43971395 4.37056019%2c1.43971395 C10.0779976%2c1.43971395 14.4485578%2c1.07978546 17.3794041%2c0.411346841 L18.3049344%2c2.15957092 C16.3510369%2c2.57091776 13.9343743%2c2.87942789 11.0549464%2c3.13651967 L11.0549464%2c4.98758045 L20.1559952%2c4.98758045 L20.1559952%2c6.78722288 L13.2659356%2c6.78722288 C14.911323%2c8.3811919 17.2765673%2c9.46097735 20.3616687%2c10.0779976 L19.3847199%2c12.0318951 C19.0762098%2c11.87764 18.7676996%2c11.8262217 18.4077712%2c11.6719666 C18.099261%2c11.6205483 17.7907509%2c11.5177116 17.4822408%2c11.3634565 Z M4.16488677%2c10.8492729 L9.04963051%2c10.8492729 L9.04963051%2c6.89005959 C7.81558999%2c8.63828367 6.17020262%2c9.97516091 4.16488677%2c10.8492729 Z M15.5283433%2c12.6489154 L4.9361621%2c12.6489154 L4.9361621%2c14.2943027 L15.5283433%2c14.2943027 L15.5283433%2c12.6489154 L15.5283433%2c12.6489154 Z M4.9361621%2c17.8935876 L15.5283433%2c17.8935876 L15.5283433%2c15.9911085 L4.9361621%2c15.9911085 L4.9361621%2c17.8935876 Z M11.1063647%2c6.83864124 L11.1063647%2c10.7978546 L16.4024553%2c10.7978546 C14.191466%2c9.97516091 12.443242%2c8.63828367 11.1063647%2c6.83864124 Z' id='%e5%bd%a2%e7%8a%b6'%3e%3c/path%3e %3cpath d='M31.0566865%2c13.9857926 C30.4910846%2c16.2996186 29.5655542%2c18.4591895 28.3315137%2c20.3616687 L26.634708%2c18.6134446 C27.8687485%2c16.8138021 28.7428605%2c14.911323 29.2056257%2c12.8545888 L31.0566865%2c13.9857926 Z M29.7712277%2c10.5407628 C28.5886055%2c9.51239571 27.6116567%2c8.79253874 26.7375447%2c8.22693683 L28.0230036%2c6.63296782 C29.0513707%2c7.19856973 30.0797378%2c7.86700834 31.2109416%2c8.68970203 L29.7712277%2c10.5407628 Z M31.8279619%2c2.87942789 L34.7073897%2c2.87942789 L34.7073897%2c0.617020262 L36.7127056%2c0.617020262 L36.7127056%2c2.82800954 L40.6205006%2c2.82800954 L40.6205006%2c0.617020262 L42.5229797%2c0.617020262 L42.5229797%2c2.82800954 L46.0708462%2c2.82800954 L46.0708462%2c4.52481526 L42.4715614%2c4.52481526 L42.4715614%2c6.73580453 L46.327938%2c6.73580453 L46.327938%2c8.58686532 L42.2144696%2c8.58686532 C42.7800715%2c9.76948749 44.2712038%2c10.9006913 46.5336114%2c12.0318951 L45.608081%2c13.9343743 C44.2712038%2c13.1116806 43.1914184%2c12.3404052 42.3687247%2c11.5691299 L42.3687247%2c15.9911085 L35.4786651%2c15.9911085 L35.4786651%2c17.3794041 C35.4786651%2c17.8935876 35.6843385%2c18.1506794 36.2499404%2c18.1506794 L42.6258164%2c18.1506794 C43.2428367%2c18.1506794 43.6027652%2c17.945006 43.7056019%2c17.4822408 C43.8084386%2c17.0194756 43.9112753%2c16.2482002 44.014112%2c15.0655781 L46.0708462%2c15.8368534 C45.8651728%2c17.8421692 45.5566627%2c19.0247914 45.1453159%2c19.4361383 C44.7853874%2c19.8474851 44.0655304%2c20.0017402 42.9343266%2c20.0017402 L35.9928486%2c20.0017402 C35.0673182%2c20.0017402 34.450298%2c19.7960667 34.0903695%2c19.4875566 C33.730441%2c19.1276281 33.5761859%2c18.4591895 33.5761859%2c17.4822408 L33.5761859%2c12.6489154 C33.2162574%2c12.9574255 32.5478188%2c13.4201907 31.5708701%2c13.9857926 L30.3368296%2c12.1347318 C32.7020739%2c11.0549464 34.2446246%2c9.8723242 34.8616448%2c8.48402861 L31.416615%2c8.48402861 L31.416615%2c6.63296782 L34.7073897%2c6.63296782 L34.7073897%2c4.4733969 L31.8279619%2c4.4733969 L31.8279619%2c3.29077473 L30.4910846%2c4.9361621 C29.3084625%2c3.85637664 28.2800954%2c3.03368296 27.2517282%2c2.41666269 L28.6914422%2c0.822693683 C29.9254827%2c1.59396901 30.9024315%2c2.31382598 31.7765435%2c2.93084625 L31.8279619%2c2.87942789 L31.8279619%2c2.87942789 Z M35.4786651%2c12.1861502 L35.4786651%2c14.2943027 L40.4148272%2c14.2943027 L40.4148272%2c12.1861502 L35.4786651%2c12.1861502 Z M37.1240524%2c8.53544696 C36.8155423%2c9.25530393 36.4041955%2c9.92374255 35.8900119%2c10.4379261 L41.3917759%2c10.4379261 C40.9290107%2c9.92374255 40.4662455%2c9.25530393 40.0548987%2c8.53544696 L37.1240524%2c8.53544696 Z M36.6612872%2c4.67907032 L36.6612872%2c6.78722288 L40.5690822%2c6.78722288 L40.5690822%2c4.67907032 L36.6612872%2c4.67907032 Z' id='%e5%bd%a2%e7%8a%b6'%3e%3c/path%3e %3cpath d='M56.6116091%2c3.54786651 C55.8403337%2c3.70212157 54.7605483%2c3.80495828 53.269416%2c3.90779499 L52.8066508%2c2.05673421 C56.0460072%2c1.90247914 58.77118%2c1.38829559 61.085006%2c0.514183552 L61.8048629%2c2.26240763 C60.7764958%2c2.62233611 59.6967104%2c2.93084625 58.5655066%2c3.13651967 L58.5655066%2c6.17020262 L61.8048629%2c6.17020262 L61.8048629%2c8.02126341 L58.5655066%2c8.02126341 L58.5655066%2c8.22693683 C60.1594756%2c9.71806913 61.3935161%2c10.9006913 62.2162098%2c11.7748033 L60.9821692%2c13.6258641 C60.5708224%2c13.0088439 60.1080572%2c12.443242 59.6967104%2c11.9804768 C59.3367819%2c11.5177116 58.925435%2c11.0549464 58.5655066%2c10.5407628 L58.5655066%2c20.5159237 L56.5601907%2c20.5673421 L56.5601907%2c11.7748033 C55.9945888%2c13.1630989 55.01764%2c14.7570679 53.6293445%2c16.6081287 L52.3953039%2c14.7056496 C54.2463647%2c12.6489154 55.5318236%2c10.4379261 56.457354%2c8.07268176 L52.549559%2c8.07268176 L52.549559%2c6.22162098 L56.5601907%2c6.22162098 L56.6116091%2c3.54786651 L56.6116091%2c3.54786651 Z M61.5991895%2c15.8882718 L61.5991895%2c13.8829559 L68.7977592%2c12.8031704 L68.7977592%2c0.462765197 L70.8030751%2c0.462765197 L70.8030751%2c12.597497 L72.7055542%2c12.2889869 L72.7055542%2c14.2428844 L70.8030751%2c14.5513945 L70.8030751%2c20.7215971 L68.7977592%2c20.7215971 L68.7977592%2c14.7570679 L61.5991895%2c15.8882718 Z M66.2782598%2c11.5177116 C64.7871275%2c10.283671 63.5016687%2c9.30672229 62.3704648%2c8.63828367 L63.6045054%2c7.19856973 C64.6842908%2c7.76417163 66.0211681%2c8.63828367 67.5637187%2c9.82090584 L66.2782598%2c11.5177116 Z M66.6381883%2c6.27303933 C65.0442193%2c5.03899881 63.7587604%2c4.06205006 62.7818117%2c3.4450298 L64.0672706%2c2.00531585 C64.992801%2c2.5194994 66.2782598%2c3.39361144 67.9750656%2c4.62765197 L66.6381883%2c6.27303933 Z' id='%e5%bd%a2%e7%8a%b6'%3e%3c/path%3e %3cpath d='M90.5991418%2c8.12410012 C90.9590703%2c9.8723242 91.6789273%2c11.723385 92.9129678%2c13.6258641 C94.1470083%2c15.5283433 95.7923957%2c17.225149 97.9519666%2c18.6134446 L96.3065793%2c20.6187604 C92.4502026%2c18.099261 89.7764482%2c13.9343743 88.3881526%2c8.12410012 L88.0282241%2c8.12410012 C87.0512753%2c13.317354 84.1718474%2c17.4822408 79.3385221%2c20.6187604 L77.6931347%2c18.5620262 C79.7498689%2c17.3794041 81.498093%2c15.8882718 82.9378069%2c13.9857926 C84.3775209%2c12.0833135 85.3030513%2c10.129416 85.6115614%2c8.12410012 L78.2073182%2c8.12410012 L78.2073182%2c5.86169249 L86.0229082%2c5.86169249 C86.2285816%2c4.57623361 86.3314184%2c2.77659118 86.3314184%2c0.462765197 L88.593826%2c0.462765197 C88.593826%2c2.93084625 88.5424076%2c4.73048868 88.3881526%2c5.86169249 L97.4892014%2c5.86169249 L97.4892014%2c8.12410012 L90.5991418%2c8.12410012 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cg transform='translate(107.618617%2c -0.000000)'%3e %3cpath d='M5.39892729%2c0.257091776 C4.4733969%2c2.05673421 3.75353993%2c3.54786651 3.34219309%2c4.67907032 C2.67375447%2c6.58154946 2.36524434%2c8.58686532 2.36524434%2c10.6950179 C2.36524434%2c14.037211 3.34219309%2c17.4822408 5.34750894%2c21.0301073 L3.75353993%2c21.0301073 C2.67375447%2c19.5903933 1.74822408%2c17.945006 1.0283671%2c16.0939452 C0.359928486%2c14.2428844 -2.9227951e-14%2c12.443242 -2.9227951e-14%2c10.6435995 C-2.9227951e-14%2c8.17551847 0.617020262%2c5.75885578 1.90247914%2c3.34219309 C2.57091776%2c2.05673421 3.18793802%2c1.07978546 3.80495828%2c0.308510131 L5.39892729%2c0.308510131 L5.39892729%2c0.257091776 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cpath d='M13.9343743%2c3.13651967 L13.9343743%2c7.09573302 C13.9343743%2c13.2145173 13.2145173%2c17.6364958 11.8262217%2c20.4645054 L10.3350894%2c18.819118 C11.4662932%2c16.2482002 12.0318951%2c12.1861502 12.0318951%2c6.68438617 L12.0318951%2c1.4911323 L20.9786889%2c1.4911323 C20.8758522%2c1.33687723 20.6701788%2c0.874112038 20.3616687%2c0.257091776 L22.4184029%2c0 C22.6240763%2c0.359928486 22.9325864%2c0.874112038 23.1896782%2c1.4911323 L30.696758%2c1.4911323 L30.696758%2c3.13651967 L13.9343743%2c3.13651967 Z M19.9503218%2c17.5850775 L21.132944%2c18.9219547 C19.5903933%2c19.6418117 17.4822408%2c20.2074136 14.7056496%2c20.6187604 L13.7801192%2c18.9219547 C16.4024553%2c18.7676996 18.4591895%2c18.3049344 19.9503218%2c17.5850775 Z M24.4751371%2c17.5850775 L15.7340167%2c17.5850775 L15.7340167%2c10.4893445 L21.5957092%2c10.4893445 L21.5957092%2c9.46097735 L14.6028129%2c9.46097735 L14.6028129%2c7.96984505 L30.542503%2c7.96984505 L30.542503%2c9.46097735 L23.44677%2c9.46097735 L23.44677%2c10.4893445 L29.3084625%2c10.4893445 L29.3084625%2c17.5850775 L24.4751371%2c17.5850775 C27.2003099%2c18.2535161 29.1542074%2c18.7676996 30.3368296%2c19.0247914 L29.3084625%2c20.6187604 C28.4343504%2c20.3616687 27.5602384%2c20.1045769 26.5832896%2c19.7960667 C25.5035042%2c19.4875566 24.4751371%2c19.1790465 23.4981883%2c18.8705364 L24.4751371%2c17.5850775 Z M21.5957092%2c13.317354 L21.5957092%2c11.87764 L17.5850775%2c11.87764 L17.5850775%2c13.317354 L21.5957092%2c13.317354 Z M21.5957092%2c16.1453635 L21.5957092%2c14.6542312 L17.5850775%2c14.6542312 L17.5850775%2c16.1453635 L21.5957092%2c16.1453635 Z M27.4574017%2c13.317354 L27.4574017%2c11.87764 L23.44677%2c11.87764 L23.44677%2c13.317354 L27.4574017%2c13.317354 Z M27.4574017%2c16.1453635 L27.4574017%2c14.6542312 L23.44677%2c14.6542312 L23.44677%2c16.1453635 L27.4574017%2c16.1453635 Z' id='%e5%bd%a2%e7%8a%b6'%3e%3c/path%3e %3cpath d='M41.1346841%2c5.55318236 C40.9804291%2c7.71275328 40.5690822%2c9.92374255 39.8492253%2c12.1861502 L37.7924911%2c11.3634565 C38.5637664%2c9.56381406 39.0265316%2c7.50707986 39.1293683%2c5.09041716 L41.1346841%2c5.55318236 Z M39.952062%2c20.2588319 L38.1010012%2c18.5106079 C39.4378784%2c17.5850775 40.4148272%2c16.4024553 41.1346841%2c14.9627414 C41.8545411%2c13.5230274 42.2144696%2c11.2606198 42.2144696%2c8.22693683 L42.2144696%2c0.514183552 L44.3740405%2c0.514183552 L44.3740405%2c9.66665077 C44.3226222%2c14.2428844 42.8829082%2c17.7393325 39.952062%2c20.2588319 Z M46.173683%2c12.1861502 C45.7109178%2c9.46097735 45.1453159%2c7.35282479 44.4768772%2c5.9645292 L46.3793564%2c5.24467223 C47.1506317%2c7.35282479 47.767652%2c9.46097735 48.2304172%2c11.6719666 L46.173683%2c12.1861502 Z M48.641764%2c0.719856973 L50.6984982%2c0.719856973 L50.6984982%2c19.9503218 L48.641764%2c19.9503218 L48.641764%2c0.719856973 Z M53.0123242%2c11.9804768 C52.8066508%2c10.0779976 52.1382122%2c8.02126341 51.1098451%2c5.81027414 L53.0123242%2c5.09041716 C53.9892729%2c7.35282479 54.7091299%2c9.46097735 55.1718951%2c11.3634565 L53.0123242%2c11.9804768 Z M55.5318236%2c0.257091776 L57.6913945%2c0.257091776 L57.6913945%2c20.6701788 L55.5318236%2c20.6701788 L55.5318236%2c0.257091776 Z' id='%e5%bd%a2%e7%8a%b6'%3e%3c/path%3e %3cpath d='M68.9520143%2c10.6435995 C68.9520143%2c13.1116806 68.334994%2c15.5283433 67.0495352%2c17.945006 C66.4325149%2c19.1276281 65.8154946%2c20.1559952 65.147056%2c20.9786889 L63.6045054%2c20.9786889 C64.5814541%2c19.1790465 65.2498927%2c17.7393325 65.6612396%2c16.6081287 C66.3296782%2c14.7056496 66.6381883%2c12.7003337 66.6381883%2c10.5921812 C66.6381883%2c7.24998808 65.6612396%2c3.80495828 63.6559237%2c0.257091776 L65.2498927%2c0.257091776 C66.3296782%2c1.69680572 67.2037902%2c3.34219309 67.9236472%2c5.24467223 C68.5920858%2c7.09573302 68.9520143%2c8.89537545 68.9520143%2c10.6435995 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cpolygon id='%e8%b7%af%e5%be%84' points='20.1045769 8.63828367 20.1045769 6.58154946 25.040739 6.58154946 25.040739 8.63828367 26.9946365 8.63828367 26.9946365 6.58154946 29.822646 6.58154946 29.822646 5.09041716 26.9946365 5.09041716 26.9946365 3.65070322 25.040739 3.65070322 25.040739 5.09041716 20.1045769 5.09041716 20.1045769 3.65070322 18.1506794 3.65070322 18.1506794 5.09041716 15.1169964 5.09041716 15.1169964 6.58154946 18.1506794 6.58154946 18.1506794 8.63828367'%3e%3c/polygon%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";
var img$5 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='200px' height='44px' viewBox='0 0 200 44' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3ein_UST-GZ_white_en_L1%3c/title%3e %3cg id='%e9%a1%b5%e9%9d%a2-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cg id='NEW-STAFF-ORIENTATION3%e5%a4%87%e4%bb%bd-7' transform='translate(-230.000000%2c -1397.000000)' fill='white'%3e %3cg id='Footer' transform='translate(0.000000%2c 1377.000000)'%3e %3cg id='in_UST-GZ_white_en_L1' transform='translate(230.000000%2c 20.000000)'%3e %3cg id='%e7%bc%96%e7%bb%84' fill-rule='nonzero'%3e %3cpath d='M21.6598769%2c43.1417647 L16.6535846%2c34.8 C16.6535846%2c34.8 16.5003308%2c34.5952941 16.5003308%2c34.2882353 L16.5003308%2c34.0835294 L16.5003308%2c33.6741176 L16.5003308%2c18.7817647 L14.6102%2c18.7817647 L14.6102%2c34.2882353 L14.6102%2c34.7488235 C14.7634538%2c34.9023529 17.9307%2c40.2758824 17.9307%2c40.2758824 L10.0636692%2c40.2758824 C10.0636692%2c40.2758824 13.2309154%2c34.9023529 13.3841692%2c34.7488235 L13.3841692%2c34.2882353 L13.3841692%2c18.7817647 L11.4940385%2c18.7817647 L11.4940385%2c33.6741176 L11.4940385%2c34.0835294 L11.4940385%2c34.2882353 C11.4940385%2c34.5952941 11.3407846%2c34.8 11.3407846%2c34.8 L6.33449231%2c43.1417647 L21.6598769%2c43.1417647 L21.6598769%2c43.1417647 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cg transform='translate(7.662692%2c 0.000000)' id='%e8%b7%af%e5%be%84'%3e %3cpath d='M12.4135615%2c7.93235294 C12.4135615%2c7.93235294 13.3330846%2c4.04294118 10.0125846%2c1.48411765 C10.0125846%2c1.48411765 8.68438462%2c0.255882353 6.13015385%2c0.255882353 C3.83134615%2c0.255882353 2.50314615%2c1.48411765 2.50314615%2c1.48411765 C-0.613015385%2c3.63352941 0.204338462%2c7.93235294 0.204338462%2c7.93235294 L12.4135615%2c7.93235294 Z'%3e%3c/path%3e %3cpath d='M0.561930769%2c9.00705882 L12.0559692%2c9.00705882 C12.1581385%2c8.80235294 12.2092231%2c8.54647059 12.3113923%2c8.34176471 L0.306507692%2c8.34176471 C0.408676923%2c8.54647059 0.459761538%2c8.75117647 0.561930769%2c9.00705882 Z'%3e%3c/path%3e %3cpath d='M11.9027154%2c9.41647059 L0.766269231%2c9.41647059 C0.868438462%2c9.67235294 1.02169231%2c9.87705882 1.17494615%2c10.0817647 L11.5451231%2c10.0817647 C11.6472923%2c9.87705882 11.8005462%2c9.62117647 11.9027154%2c9.41647059 Z'%3e%3c/path%3e %3cpath d='M1.89013077%2c11.0029412 L10.7277692%2c11.0029412 C10.8810231%2c10.8494118 11.0342769%2c10.6447059 11.1875308%2c10.44 L1.43036923%2c10.44 C1.58362308%2c10.6447059 1.73687692%2c10.8494118 1.89013077%2c11.0029412 Z'%3e%3c/path%3e %3cpath d='M2.86073846%2c11.8217647 L9.80824615%2c11.8217647 C10.0125846%2c11.7194118 10.1658385%2c11.5658824 10.3190923%2c11.4123529 L2.29880769%2c11.4123529 C2.50314615%2c11.5658824 2.6564%2c11.7194118 2.86073846%2c11.8217647 Z'%3e%3c/path%3e %3cpath d='M3.78026154%2c12.3847059 C4.54653077%2c12.7429412 5.41496923%2c12.9476471 6.28340769%2c12.9476471 C7.20293077%2c12.9476471 8.02028462%2c12.7429412 8.78655385%2c12.3847059 L3.78026154%2c12.3847059 Z'%3e%3c/path%3e %3c/g%3e %3cpath d='M25.8999%2c13.2035294 L16.5003308%2c13.2035294 C16.5003308%2c13.2035294 15.6318923%2c13.2035294 14.9167077%2c13.6641176 C14.3547769%2c14.0223529 13.9971846%2c14.8923529 13.9971846%2c14.9435294 L13.9971846%2c14.9435294 C13.9971846%2c14.8923529 13.5885077%2c14.0223529 13.0776615%2c13.6641176 C12.3624769%2c13.2035294 11.4940385%2c13.2035294 11.4940385%2c13.2035294 L2.04338462%2c13.2035294 L0.153253846%2c16.2229412 L8.78655385%2c16.2229412 C8.78655385%2c16.2229412 9.04197692%2c16.2229412 9.19523077%2c16.2741176 C9.45065385%2c16.3252941 9.91041538%2c16.4276471 10.3701769%2c16.7858824 C11.0342769%2c17.2464706 11.1875308%2c17.5023529 11.3407846%2c17.6558824 C11.4429538%2c17.7582353 11.6472923%2c18.0141176 11.6472923%2c18.0141176 L13.7417615%2c18.0141176 L13.9971846%2c18.0141176 L13.9971846%2c18.0141176 L14.7123692%2c18.0141176 L16.3470769%2c18.0141176 C16.3470769%2c18.0141176 16.5514154%2c17.7582353 16.6535846%2c17.6558824 C16.8068385%2c17.5023529 17.0111769%2c17.2464706 17.6241923%2c16.7858824 C18.0839538%2c16.4276471 18.5437154%2c16.3252941 18.7991385%2c16.2741176 C18.9523923%2c16.2229412 19.2078154%2c16.2229412 19.2078154%2c16.2229412 L27.8411154%2c16.2229412 L25.8999%2c13.2035294 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cg transform='translate(1.021692%2c 16.888235)' id='%e8%b7%af%e5%be%84'%3e %3cg%3e %3cpath d='M0.102169231%2c0.255882353 L0.102169231%2c14.4317647 C0.102169231%2c14.4317647 0.102169231%2c14.5852941 0.102169231%2c14.6364706 C0.102169231%2c14.79 0.102169231%2c14.9435294 0.102169231%2c15.0458824 C0.255423077%2c16.5811765 0.715184615%2c17.7070588 1.63470769%2c19.14 C3.01399231%2c21.4429412 5.51713846%2c23.0805882 5.51713846%2c23.0805882 L6.69208462%2c21.1870588 C6.69208462%2c21.1870588 5.10846154%2c20.3170588 3.78026154%2c18.3723529 C3.52483846%2c17.9629412 3.26941538%2c17.6047059 3.06507692%2c17.2464706 C2.91182308%2c16.8882353 2.75856923%2c16.6323529 2.6564%2c16.3252941 C2.60531538%2c16.1205882 2.50314615%2c15.9158824 2.50314615%2c15.7111765 C2.45206154%2c15.4552941 2.40097692%2c15.2505882 2.40097692%2c14.9947059 C2.40097692%2c14.8923529 2.40097692%2c14.5341176 2.40097692%2c14.5341176 L2.40097692%2c14.4829412 L2.40097692%2c0.255882353 L0.102169231%2c0.255882353 Z'%3e%3c/path%3e %3cpath d='M3.67809231%2c0.255882353 L3.67809231%2c14.5341176 C3.67809231%2c14.5341176 3.67809231%2c14.5852941 3.67809231%2c14.6364706 C3.67809231%2c14.6876471 3.67809231%2c14.79 3.67809231%2c14.8923529 C3.67809231%2c14.9435294 3.67809231%2c14.9947059 3.67809231%2c15.0458824 C3.72917692%2c15.2505882 3.78026154%2c15.4552941 3.88243077%2c15.7623529 C4.03568462%2c16.2229412 4.34219231%2c16.8370588 4.75086923%2c17.5023529 C5.82364615%2c19.1911765 7.35618462%2c20.01 7.35618462%2c20.01 L8.53113077%2c18.1676471 C8.53113077%2c18.1676471 8.12245385%2c17.9629412 7.66269231%2c17.5023529 C7.35618462%2c17.1952941 6.94750769%2c16.7858824 6.641%2c16.3252941 C6.33449231%2c15.8647059 6.13015385%2c15.3529412 6.02798462%2c14.9947059 C5.92581538%2c14.6876471 5.92581538%2c14.4317647 5.92581538%2c14.2782353 C5.92581538%2c14.1247059 5.92581538%2c14.0735294 5.92581538%2c14.0735294 L5.92581538%2c0.255882353 L3.67809231%2c0.255882353 L3.67809231%2c0.255882353 Z'%3e%3c/path%3e %3c/g%3e %3cg transform='translate(17.368769%2c 0.000000)'%3e %3cpath d='M8.48004615%2c0.255882353 L8.48004615%2c14.4317647 C8.48004615%2c14.4317647 8.48004615%2c14.5852941 8.48004615%2c14.6364706 C8.48004615%2c14.79 8.48004615%2c14.9435294 8.48004615%2c15.0458824 C8.32679231%2c16.5811765 7.86703077%2c17.7070588 6.94750769%2c19.14 C5.56822308%2c21.4429412 3.06507692%2c23.0805882 3.06507692%2c23.0805882 L1.89013077%2c21.1870588 C1.89013077%2c21.1870588 3.47375385%2c20.3170588 4.80195385%2c18.3723529 C5.05737692%2c17.9629412 5.3128%2c17.6047059 5.51713846%2c17.2464706 C5.67039231%2c16.8882353 5.82364615%2c16.6323529 5.92581538%2c16.3252941 C5.9769%2c16.1205882 6.07906923%2c15.9158824 6.07906923%2c15.7111765 C6.13015385%2c15.4552941 6.18123846%2c15.2505882 6.18123846%2c14.9947059 C6.18123846%2c14.8923529 6.18123846%2c14.5341176 6.18123846%2c14.5341176 L6.18123846%2c14.4829412 L6.18123846%2c0.255882353 L8.48004615%2c0.255882353 Z'%3e%3c/path%3e %3cpath d='M4.85303846%2c0.255882353 L4.85303846%2c14.5341176 C4.85303846%2c14.5341176 4.85303846%2c14.5852941 4.85303846%2c14.6364706 C4.85303846%2c14.6876471 4.85303846%2c14.79 4.85303846%2c14.8923529 C4.85303846%2c14.9435294 4.85303846%2c14.9947059 4.85303846%2c15.0458824 C4.80195385%2c15.2505882 4.75086923%2c15.4552941 4.6487%2c15.7623529 C4.49544615%2c16.2229412 4.18893846%2c16.8370588 3.78026154%2c17.5023529 C2.70748462%2c19.1911765 1.17494615%2c20.01 1.17494615%2c20.01 L0%2c18.1676471 C0%2c18.1676471 0.408676923%2c17.9629412 0.868438462%2c17.5023529 C1.17494615%2c17.1952941 1.58362308%2c16.7858824 1.89013077%2c16.3252941 C2.19663846%2c15.8647059 2.40097692%2c15.3529412 2.50314615%2c14.9947059 C2.60531538%2c14.6876471 2.60531538%2c14.4317647 2.60531538%2c14.2782353 C2.60531538%2c14.1247059 2.60531538%2c14.0735294 2.60531538%2c14.0735294 L2.60531538%2c0.255882353 L4.85303846%2c0.255882353 Z'%3e%3c/path%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cpolygon id='%e8%b7%af%e5%be%84' points='47.4576077 24.9229412 47.4576077 17.5535294 49.9607538 17.5535294 49.9607538 35.7211765 47.4576077 35.7211765 47.4576077 27.0211765 37.9558692 27.0211765 37.9558692 35.7211765 35.5038077 35.7211765 35.5038077 17.5535294 37.9558692 17.5535294 37.9558692 24.8717647 47.4576077 24.8717647'%3e%3c/polygon%3e %3cpolygon id='%e8%b7%af%e5%be%84' points='69.9348385 17.5535294 73.1531692 17.5535294 64.2644462 25.7417647 73.3064231 35.7211765 69.9859231 35.7211765 62.5275692 27.2770588 61.5058769 28.1470588 61.5058769 35.7723529 59.0538154 35.7723529 59.0538154 17.5535294 61.5058769 17.5535294 61.5058769 25.4347059 69.9348385 17.5535294'%3e%3c/polygon%3e %3cpath d='M81.6843%2c17.5535294 L81.6843%2c28.2494118 C81.6843%2c31.1664706 82.6549077%2c33.93 86.4862538%2c33.93 C90.3176%2c33.93 91.2882077%2c31.2176471 91.2882077%2c28.2494118 L91.2882077%2c17.5535294 L93.7913538%2c17.5535294 L93.7913538%2c28.9658824 C93.7913538%2c32.9576471 91.0838692%2c35.9770588 86.5373385%2c35.9770588 C81.9908077%2c35.9770588 79.2833231%2c32.9576471 79.2833231%2c28.9658824 L79.2833231%2c17.5535294 L81.6843%2c17.5535294 L81.6843%2c17.5535294 L81.6843%2c17.5535294 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cpath d='M111.109038%2c21.0335294 C110.393854%2c19.9076471 109.423246%2c19.3447059 107.890708%2c19.3447059 C106.307085%2c19.3447059 104.570208%2c20.3170588 104.570208%2c21.9035294 C104.570208%2c23.3364706 106.102746%2c24.0529412 107.328777%2c24.5135294 L108.759146%2c25.0252941 C111.5688%2c26.0488235 113.714354%2c27.4305882 113.714354%2c30.45 C113.714354%2c33.7252941 110.9047%2c36.0794118 107.328777%2c36.0794118 C104.110446%2c36.0794118 101.556215%2c33.93 101.147538%2c31.0129412 L103.650685%2c30.5523529 C103.650685%2c32.5482353 105.336477%2c33.9811765 107.482031%2c33.9811765 C109.627585%2c33.9811765 111.160123%2c32.3435294 111.160123%2c30.45 C111.160123%2c28.5052941 109.474331%2c27.6864706 107.737454%2c27.0211765 L106.358169%2c26.5094118 C104.110446%2c25.6394118 102.067062%2c24.4623529 102.067062%2c21.9035294 C102.067062%2c18.9864706 104.9278%2c17.2464706 107.941792%2c17.2464706 C110.138431%2c17.2464706 111.977477%2c18.2188235 113.101338%2c19.9588235 L111.109038%2c21.0335294 L111.109038%2c21.0335294 L111.109038%2c21.0335294 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cpolygon id='%e8%b7%af%e5%be%84' points='128.222385 35.7723529 125.770323 35.7723529 125.770323 19.7029412 121.019454 19.7029412 121.019454 17.6558824 132.973254 17.6558824 132.973254 19.7029412 128.273469 19.7029412 128.222385 35.7723529 128.222385 35.7723529'%3e%3c/polygon%3e %3cpath d='M170.6737%2c26.6117647 L170.6737%2c27.3282353 C170.6737%2c32.2923529 167.148862%2c36.1817647 162.091485%2c36.1817647 C157.034108%2c36.1817647 152.947338%2c31.8317647 152.947338%2c26.7141176 C152.947338%2c21.4941176 157.136277%2c17.1952941 162.397992%2c17.1952941 C165.207646%2c17.1952941 167.966215%2c18.4747059 169.754177%2c20.7264706 L168.170554%2c22.2617647 C166.893438%2c20.4705882 164.6968%2c19.2935294 162.500162%2c19.2935294 C158.464477%2c19.2935294 155.297231%2c22.5688235 155.297231%2c26.7141176 C155.297231%2c30.5011765 158.413392%2c34.1858824 162.346908%2c34.1858824 C165.156562%2c34.1858824 168.170554%2c31.7805882 168.272723%2c28.8123529 L163.470769%2c28.8123529 L163.470769%2c26.7652941 L170.6737%2c26.7652941 L170.6737%2c26.6117647 L170.6737%2c26.6117647 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cpolygon id='%e8%b7%af%e5%be%84' points='188.348977 33.7252941 188.348977 35.7723529 175.526738 35.7723529 184.670885 19.7029412 176.803854 19.7029412 176.803854 17.6558824 188.348977 17.6558824 179.204831 33.7764706 188.348977 33.7764706'%3e%3c/polygon%3e %3cpath d='M147.838877%2c15.9670588 C146.868269%2c17.8094118 146.153085%2c19.3447059 145.744408%2c20.5217647 C145.080308%2c22.5176471 144.722715%2c24.5647059 144.722715%2c26.6629412 C144.722715%2c30.0917647 145.744408%2c33.6229412 147.838877%2c37.3076471 L146.102%2c37.3076471 C144.978138%2c35.8235294 144.058615%2c34.1347059 143.292346%2c32.19 C142.577162%2c30.2964706 142.219569%2c28.4029412 142.219569%2c26.5605882 C142.219569%2c24.0017647 142.883669%2c21.5452941 144.160785%2c19.0376471 C144.824885%2c17.7070588 145.488985%2c16.6835294 146.102%2c15.9158824 L147.736708%2c15.9158824 L147.736708%2c15.9670588 L147.838877%2c15.9670588 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3cpath d='M199.076746%2c26.7141176 C199.076746%2c29.2217647 198.412646%2c31.7294118 197.135531%2c34.2882353 C196.522515%2c35.5164706 195.858415%2c36.54 195.194315%2c37.41 L193.559608%2c37.41 C194.530215%2c35.5676471 195.2454%2c34.0835294 195.654077%2c32.9064706 C196.318177%2c30.9105882 196.675769%2c28.8635294 196.675769%2c26.7141176 C196.675769%2c23.2852941 195.654077%2c19.7541176 193.559608%2c16.0182353 L195.194315%2c16.0182353 C196.318177%2c17.5023529 197.2377%2c19.1911765 198.003969%2c21.1358824 C198.719154%2c23.0294118 199.076746%2c24.8717647 199.076746%2c26.7141176 L199.076746%2c26.7141176 Z' id='%e8%b7%af%e5%be%84'%3e%3c/path%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";
var img$4 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='32px' height='32px' viewBox='0 0 32 32' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3eFooter/Facebook%3c/title%3e %3cg id='Footer/Facebook' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cpath d='M16%2c1 C20.1442506%2c1 23.8904641%2c2.67758873 26.6061432%2c5.39359822 C29.3221253%2c8.10991064 31%2c11.8555561 31%2c15.9998485 C31%2c20.1444439 29.3221253%2c23.8903923 26.6061432%2c26.6064018 C23.8904641%2c29.3221083 20.1442506%2c31 16%2c31 C11.8554465%2c31 8.10953593%2c29.3221083 5.39355386%2c26.6064018 C2.67787471%2c23.8903923 1%2c20.1444439 1%2c15.9998485 C1%2c11.8555561 2.67787471%2c8.10991064 5.39355386%2c5.39359822 C8.10953593%2c2.67758873 11.8554465%2c1 16%2c1 Z M16%2c2.1707982 C12.1795711%2c2.1707982 8.72416091%2c3.72418842 6.22416091%2c6.22421366 C3.72416091%2c8.72423891 2.1710893%2c12.179381 2.1710893%2c15.9998485 C2.1710893%2c19.820619 3.72416091%2c23.2757611 6.22416091%2c25.7839653 C8.72416091%2c28.2842934 12.1795711%2c29.8288989 16%2c29.8288989 C19.8204289%2c29.8288989 23.2758391%2c28.2842934 25.7840179%2c25.7839653 C28.2840179%2c23.2757611 29.8289107%2c19.820619 29.8289107%2c15.9998485 C29.8289107%2c12.179381 28.2840179%2c8.72423891 25.7840179%2c6.22421366 C23.2758391%2c3.72418842 19.8204289%2c2.1707982 16%2c2.1707982 Z M19.5382285%2c8.35037108 L19.5382285%2c10.9752007 L17.8191567%2c10.9752007 C17.5365322%2c10.9752007 17.1460681%2c11.1163629 17.1460681%2c11.7058515 L17.1460681%2c11.7058515 L17.1460681%2c12.9351138 L19.5797286%2c12.9351138 L19.3970677%2c14.7956682 L19.297407%2c16.0000909 L17.0300497%2c16.0000909 L17.0300497%2c23.6576867 L13.9651036%2c23.6576867 L13.9651036%2c16.0000909 L12.4202108%2c16.0000909 L12.4202108%2c12.9351138 L13.948443%2c12.9351138 L13.948443%2c11.5565103 C13.948443%2c10.2936235 14.5382285%2c8.35037108 17.1712105%2c8.35037108 L17.1712105%2c8.35037108 L19.5382285%2c8.35037108 Z' id='%e5%bd%a2%e7%8a%b6%e7%bb%93%e5%90%88' fill='%23FEFEFE'%3e%3c/path%3e %3c/g%3e%3c/svg%3e";
var img$3 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='32px' height='32px' viewBox='0 0 32 32' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3eFooter/Linkedin%3c/title%3e %3cg id='Footer/Linkedin' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cpath d='M16.0004544%2c1 C20.1443602%2c1 23.8902329%2c2.67757179 26.6064905%2c5.39355386 C29.3224451%2c8.10953593 31%2c11.8554465 31%2c15.9996971 C31%2c20.1442506 29.3224451%2c23.8901612 26.6064905%2c26.6058403 C23.8902329%2c29.3221253 20.1443602%2c31 16.0004544%2c31 C11.8556398%2c31 8.10976706%2c29.3221253 5.39441825%2c26.6058403 C2.67785777%2c23.8901612 1%2c20.1442506 1%2c15.9996971 C1%2c11.8554465 2.67785777%2c8.10953593 5.39441825%2c5.39355386 C8.10976706%2c2.67757179 11.8556398%2c1 16.0004544%2c1 Z M16.0004544%2c2.1710893 C12.1788523%2c2.1710893 8.72438584%2c3.71598207 6.22410816%2c6.22416091 C3.71625756%2c8.72416091 2.17107748%2c12.1792681 2.17107748%2c15.9996971 C2.17107748%2c19.8204289 3.71625756%2c23.2758391 6.22410816%2c25.7755362 C8.72438584%2c28.283715 12.1788523%2c29.8286078 16.0004544%2c29.8286078 C19.8211477%2c29.8286078 23.2756142%2c28.283715 25.7758918%2c25.7755362 C28.2837424%2c23.2758391 29.8286196%2c19.8204289 29.8286196%2c15.9996971 C29.8286196%2c12.1792681 28.2837424%2c8.72416091 25.7758918%2c6.22416091 C23.2756142%2c3.71598207 19.8211477%2c2.1710893 16.0004544%2c2.1710893 Z M16.7061906%2c13.7407609 L16.7061906%2c14.9618321 L16.7476903%2c14.9618321 C17.1296687%2c14.2390646 18.0429637%2c13.7407609 19.3970031%2c13.7407609 C21.706443%2c13.7407609 22.4867575%2c14.8037077 22.6945586%2c16.5146008 C22.7439341%2c16.9135466 22.7690762%2c17.3452078 22.7690762%2c17.8104932 L22.7690762%2c17.8104932 L22.7690762%2c22.7686902 L20.0609974%2c22.7686902 L20.0604498%2c18.2522685 C20.0507354%2c17.2191563 19.8975853%2c15.9751 18.5006715%2c15.9751 C17.0545453%2c15.9751 16.8222079%2c17.112868 16.8222079%2c18.2924391 L16.8222079%2c18.2924391 L16.8222079%2c22.7686902 L14.1892525%2c22.7686902 L14.1892525%2c13.7407609 L16.7061906%2c13.7407609 Z M12.3868958%2c13.7407609 L12.3868958%2c22.7686902 L9.23110555%2c22.7686902 L9.23110555%2c13.7407609 L12.3868958%2c13.7407609 Z M10.8093036%2c9.23058282 C11.6814019%2c9.23058282 12.3868958%2c9.93668969 12.3868958%2c10.8087968 C12.3868958%2c11.6812068 11.6814019%2c12.3870108 10.8093036%2c12.3870108 C9.93720529%2c12.3870108 9.23110555%2c11.6812068 9.23110555%2c10.8087968 C9.23110555%2c9.93668969 9.93720529%2c9.23058282 10.8093036%2c9.23058282 Z' id='%e5%bd%a2%e7%8a%b6%e7%bb%93%e5%90%88' fill='%23FEFEFE'%3e%3c/path%3e %3c/g%3e%3c/svg%3e";
var img$2 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='32px' height='32px' viewBox='0 0 32 32' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3eFooter/Instagram%3c/title%3e %3cg id='Footer/Instagram' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cpath d='M16%2c1 C20.1445535%2c1 23.89834%2c2.67758873 26.6061432%2c5.39359822 C29.3221253%2c8.10991064 31%2c11.8555561 31%2c15.9998485 C31%2c20.1444439 29.3221253%2c23.8903923 26.6061432%2c26.6064018 C23.89834%2c29.3221083 20.1445535%2c31 16%2c31 C11.8636253%2c31 8.10983885%2c29.3221083 5.39355386%2c26.6064018 C2.67757179%2c23.8903923 1%2c20.1444439 1%2c15.9998485 C1%2c11.8555561 2.67757179%2c8.10991064 5.39355386%2c5.39359822 C8.10983885%2c2.67758873 11.8636253%2c1 16%2c1 Z M16%2c2.1707982 C12.1877499%2c2.1707982 8.72446383%2c3.72418842 6.22446383%2c6.22421366 C3.72416091%2c8.72423891 2.1710893%2c12.179381 2.1710893%2c15.9998485 C2.1710893%2c19.820619 3.72416091%2c23.2757611 6.22446383%2c25.7839653 C8.72446383%2c28.2842934 12.1877499%2c29.8288989 16%2c29.8288989 C19.8204289%2c29.8288989 23.2755362%2c28.2842934 25.7840179%2c25.7839653 C28.2840179%2c23.2757611 29.8289107%2c19.820619 29.8289107%2c15.9998485 C29.8289107%2c12.179381 28.2840179%2c8.72423891 25.7840179%2c6.22421366 C23.2755362%2c3.72418842 19.8204289%2c2.1707982 16%2c2.1707982 Z M19.9703441%2c8.48356642 C21.9302375%2c8.48356642 23.5248092%2c10.0778513 23.5248092%2c12.0383703 L23.5248092%2c12.0383703 L23.5248092%2c19.9701116 C23.5248092%2c21.9215429 21.9302375%2c23.5246125 19.9703441%2c23.5246125 L19.9703441%2c23.5246125 L12.03838%2c23.5246125 C10.0863625%2c23.5246125 8.4833091%2c21.9215429 8.4833091%2c19.9701116 L8.4833091%2c19.9701116 L8.4833091%2c12.0383703 C8.4833091%2c10.0778513 10.0863625%2c8.48356642 12.03838%2c8.48356642 L12.03838%2c8.48356642 Z M19.9703441%2c9.37234311 L12.03838%2c9.37234311 C10.5680056%2c9.37234311 9.37207682%2c10.567981 9.37207682%2c12.0383703 L9.37207682%2c12.0383703 L9.37207682%2c19.9701116 C9.37207682%2c21.439895 10.5680056%2c22.6361387 12.03838%2c22.6361387 L12.03838%2c22.6361387 L19.9703441%2c22.6361387 C21.4404156%2c22.6361387 22.6363444%2c21.439895 22.6363444%2c19.9701116 L22.6363444%2c19.9701116 L22.6363444%2c12.0383703 C22.6363444%2c10.567981 21.4404156%2c9.37234311 19.9703441%2c9.37234311 L19.9703441%2c9.37234311 Z M15.9999697%2c11.1495936 C18.6829335%2c11.1495936 20.8503272%2c13.325491 20.8503272%2c16 C20.8503272%2c18.6826879 18.6829335%2c20.8504064 15.9999697%2c20.8504064 C13.3254877%2c20.8504064 11.1496123%2c18.6826879 11.1496123%2c16 C11.1496123%2c13.325491 13.3254877%2c11.1495936 15.9999697%2c11.1495936 Z M15.9999697%2c12.1543899 C13.881952%2c12.1543899 12.1625772%2c13.8819609 12.1625772%2c16 C12.1625772%2c18.126218 13.881952%2c19.8456101 15.9999697%2c19.8456101 C18.1264692%2c19.8456101 19.845541%2c18.126218 19.845541%2c16 C19.845541%2c13.8819609 18.1264692%2c12.1543899 15.9999697%2c12.1543899 Z M20.7591482%2c10.493159 C21.1911123%2c10.493159 21.5397734%2c10.8421265 21.5397734%2c11.2737921 C21.5397734%2c11.7060635 21.1911123%2c12.0547281 20.7591482%2c12.0547281 C20.3271841%2c12.0547281 19.978523%2c11.7060635 19.978523%2c11.2737921 C19.978523%2c10.8421265 20.3271841%2c10.493159 20.7591482%2c10.493159 Z' id='%e5%bd%a2%e7%8a%b6%e7%bb%93%e5%90%88' fill='%23FEFEFE'%3e%3c/path%3e %3c/g%3e%3c/svg%3e";
var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='32px' height='32px' viewBox='0 0 32 32' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3eFooter/Youtube%3c/title%3e %3cg id='Footer/Youtube' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cpath d='M16%2c1 C20.1445535%2c1 23.8901612%2c2.68530819 26.6061432%2c5.39240072 C29.3218224%2c8.10766994 31%2c11.8607741 31%2c16.0042398 C31%2c20.1392259 29.3218224%2c23.8923301 26.6061432%2c26.6072964 C23.8901612%2c29.314389 20.1445535%2c31 16%2c31 C11.8551436%2c31 8.10953593%2c29.314389 5.39355386%2c26.6072964 C2.67787471%2c23.8923301 1%2c20.1392259 1%2c16.0042398 C1%2c11.8607741 2.67787471%2c8.10766994 5.39355386%2c5.39240072 C8.10953593%2c2.68530819 11.8551436%2c1 16%2c1 Z M16%2c2.17895863 C12.1792681%2c2.17895863 8.72416091%2c3.72314308 6.22385799%2c6.22278977 C3.71628499%2c8.72213361 2.1710893%2c12.1848136 2.1710893%2c16.0042398 C2.1710893%2c19.8151864 3.71628499%2c23.2781692 6.22385799%2c25.7775131 C8.72416091%2c28.2765541 12.1792681%2c29.8295209 16%2c29.8295209 C19.8204289%2c29.8295209 23.2755362%2c28.2765541 25.7758391%2c25.7775131 C28.283715%2c23.2781692 29.8283049%2c19.8151864 29.8283049%2c16.0042398 C29.8283049%2c12.1848136 28.283715%2c8.72213361 25.7758391%2c6.22278977 C23.2755362%2c3.72314308 19.8204289%2c2.17895863 16%2c2.17895863 Z M16.0896646%2c10.3829203 C16.6016617%2c10.3841747 19.4233555%2c10.3975541 21.3655943%2c10.5402677 C21.6560948%2c10.5820597 22.3125227%2c10.5905393 22.8935236%2c11.2213563 C23.3506301%2c11.7031758 23.5081486%2c12.8073328 23.5081486%2c12.8073328 C23.5081486%2c12.8073328 23.6574882%2c14.1025822 23.6574882%2c15.3814783 L23.6574882%2c15.3814783 L23.6574882%2c16.6019261 C23.6574882%2c17.8971755 23.5081486%2c19.1760716 23.5081486%2c19.1760716 C23.5081486%2c19.1760716 23.3506301%2c20.2805314 22.8935236%2c20.7702247 C22.3125227%2c21.4095213 21.6560948%2c21.4095213 21.3655943%2c21.4510105 C19.3563818%2c21.5912636 16.4060164%2c21.6146686 16.0450692%2c21.6170464 L15.9962326%2c21.6171391 C15.7541212%2c21.6145066 11.9823398%2c21.571756 10.8009512%2c21.4510105 C10.4519872%2c21.3846884 9.68771962%2c21.4095213 9.10641585%2c20.7702247 C8.64930934%2c20.2805314 8.49209378%2c19.1760716 8.49209378%2c19.1760716 C8.49209378%2c19.1760716 8.33366655%2c17.8971755 8.33366655%2c16.6019261 L8.33366655%2c16.6019261 L8.33366655%2c15.3814783 C8.33366655%2c14.1025822 8.49209378%2c12.8073328 8.49209378%2c12.8073328 C8.49209378%2c12.8073328 8.64930934%2c11.7031758 9.10641585%2c11.2213563 C9.68771962%2c10.5905393 10.3353629%2c10.5820597 10.642221%2c10.5402677 C12.5847343%2c10.3975541 15.3994879%2c10.3841747 15.9101813%2c10.3829203 Z M14.413274%2c13.5795764 L14.413274%2c18.063435 L18.5581304%2c15.8299853 L16.2907731%2c14.6010579 L14.413274%2c13.5795764 Z' id='%e5%bd%a2%e7%8a%b6%e7%bb%93%e5%90%88' fill='%23FEFEFE'%3e%3c/path%3e %3c/g%3e%3c/svg%3e";
var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='32px' height='32px' viewBox='0 0 32 32' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3eFooter/Wechat%3c/title%3e %3cg id='Footer/Wechat' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cpath d='M16.0003029%2c1 C20.1445535%2c1 23.8901612%2c2.67816069 26.6064461%2c5.39411533 C29.3224282%2c8.10976706 31%2c11.8556398 31%2c16.0001515 C31%2c20.1443602 29.3224282%2c23.8902329 26.6064461%2c26.6064905 C23.8901612%2c29.3221422 20.1445535%2c31 16.0003029%2c31 C11.8554465%2c31 8.10983885%2c29.3221422 5.3941597%2c26.6064905 C2.67757179%2c23.8902329 1%2c20.1443602 1%2c16.0001515 C1%2c11.8556398 2.67757179%2c8.10976706 5.3941597%2c5.39411533 C8.10983885%2c2.67816069 11.8554465%2c1 16.0003029%2c1 Z M16.0003029%2c2.17168331 C12.1789652%2c2.17168331 8.72446383%2c3.71656048 6.22416091%2c6.224714 C3.71628499%2c8.72468875 2.1710893%2c12.1794582 2.1710893%2c16.0001515 C2.1710893%2c19.8205418 3.71628499%2c23.2756142 6.22416091%2c25.7755889 C8.72446383%2c28.2840454 12.1789652%2c29.8286196 16.0003029%2c29.8286196 C19.8210348%2c29.8286196 23.2755362%2c28.2840454 25.7758391%2c25.7755889 C28.2840179%2c23.2756142 29.8289107%2c19.8205418 29.8289107%2c16.0001515 C29.8289107%2c12.1794582 28.2840179%2c8.72468875 25.7758391%2c6.224714 C23.2755362%2c3.71656048 19.8210348%2c2.17168331 16.0003029%2c2.17168331 Z M19.7504544%2c13.2526631 C23.0837877%2c13.2526631 25.7852296%2c15.4912205 25.7855325%2c18.2523097 C25.7855325%2c19.767501 24.9712832%2c21.1236609 23.6865988%2c22.0414996 L23.6865988%2c22.0414996 L24.1343148%2c23.8941406 L22.0986914%2c22.8605875 C21.3768327%2c23.1132203 20.5837877%2c23.253168 19.7504544%2c23.253168 C16.4177269%2c23.253168 13.7156791%2c21.0140049 13.7156791%2c18.2526127 C13.7156791%2c15.4912205 16.4177269%2c13.2526631 19.7504544%2c13.2526631 Z M13.5533745%2c8.06199703 C16.7737186%2c8.06169411 19.4815219%2c9.87525874 20.2733551%2c12.3364601 C20.1125045%2c12.3270697 19.951351%2c12.3210113 19.7877741%2c12.3210113 C15.9670423%2c12.3213143 12.8584757%2c14.9657805 12.8590815%2c18.215475 C12.8590815%2c18.6816644 12.9254211%2c19.1333138 13.0456804%2c19.5689086 C12.4489277%2c19.5325585 11.8724706%2c19.4338076 11.3266085%2c19.2814403 L11.3266085%2c19.2814403 L8.86083848%2c20.3928431 L9.37489398%2c18.4284257 C7.6900521%2c17.3766976 6.60075124%2c15.7064128 6.60044832%2c13.8243889 C6.6001454%2c10.6419419 9.71325579%2c8.06229995 13.5533745%2c8.06199703 Z M21.8751363%2c15.4651696 C21.3138253%2c15.4651696 20.8591421%2c15.9198481 20.8591421%2c16.4814564 C20.8591421%2c17.0424589 21.3138253%2c17.4971374 21.8751363%2c17.4971374 C22.4367503%2c17.4971374 22.8911305%2c17.0424589 22.8911305%2c16.4814564 C22.8911305%2c15.9198481 22.4367503%2c15.4651696 21.8751363%2c15.4651696 Z M17.953835%2c15.4651696 C17.3925239%2c15.4651696 16.9378408%2c15.9198481 16.9378408%2c16.4814564 C16.9378408%2c17.0424589 17.3925239%2c17.4971374 17.953835%2c17.4971374 C18.515146%2c17.4971374 18.9698292%2c17.0424589 18.9698292%2c16.4814564 C18.9698292%2c15.9198481 18.515146%2c15.4651696 17.953835%2c15.4651696 Z M11.2317945%2c10.9060856 C10.642009%2c10.9060856 10.1643039%2c11.3843917 10.1643039%2c11.9738684 C10.1643039%2c12.5636479 10.6423119%2c13.041954 11.2320974%2c13.041954 C11.821883%2c13.041954 12.2998909%2c12.5636479 12.2998909%2c11.9738684 C12.2998909%2c11.3840888 11.821883%2c10.9060856 11.2317945%2c10.9060856 Z M15.7768084%2c10.9057825 C15.1870229%2c10.9057825 14.7090149%2c11.3840888 14.7090149%2c11.9735654 C14.7090149%2c12.563345 15.1873258%2c13.0416511 15.7771114%2c13.0416511 C16.366291%2c13.0416511 16.8452078%2c12.5630421 16.8452078%2c11.9732625 C16.8452078%2c11.3837859 16.3659881%2c10.9054798 15.7768084%2c10.9057825 Z' id='%e5%bd%a2%e7%8a%b6%e7%bb%93%e5%90%88' fill='%23FEFEFE'%3e%3c/path%3e %3c/g%3e%3c/svg%3e";
const _hoisted_1$5L = { class: "hkust-footer" };
const _hoisted_2$5m = { class: "hkust-footer-main" };
const _hoisted_3$58 = { class: "hkust-footer-content" };
const _hoisted_4$1N = { class: "hkust-footer-logo" };
const _hoisted_5$K = {
  key: 0,
  src: img$6,
  alt: "footer logo"
};
const _hoisted_6$l = {
  key: 1,
  src: img$5,
  alt: "footer logo"
};
const _hoisted_7$e = { class: "hkust-footer-menus-copyright" };
const _hoisted_8$c = { class: "hkust-footer-menus" };
const _hoisted_9$9 = ["href"];
const _hoisted_10$9 = { class: "hkust-footer-copyright" };
const _hoisted_11$5 = {
  href: "https://beian.miit.gov.cn/#/Integrated/index",
  target: "_bank",
  class: "hkust-footer-copyright__link"
};
const _hoisted_12$4 = {
  key: 0,
  class: "hkust-footer-follow"
};
const _hoisted_13$3 = { class: "hkust-footer-follow__text" };
const _hoisted_14$2 = ["href", "target"];
const _hoisted_15$2 = ["src"];
const _hoisted_16$2 = /* @__PURE__ */ createStaticVNode('<a class="hkust-footer-follow__link" href="https://www.facebook.com/hkust/" target="_blank" rel="noreferrer"><img src="' + img$4 + '" alt="LinkedIn" class="hkust-footer-follow__icon"></a><a class="hkust-footer-follow__link" href="https://www.linkedin.com/school/hkust/" target="_blank" rel="noreferrer"><img src="' + img$3 + '" alt="LinkedIn" class="hkust-footer-follow__icon"></a><a class="hkust-footer-follow__link" href="https://www.instagram.com/hkust" target="_blank" rel="noreferrer"><img src="' + img$2 + '" alt="Instagram" class="hkust-footer-follow__icon"></a><a class="hkust-footer-follow__link" href="https://www.youtube.com/user/hkust" target="_blank" rel="noreferrer"><img src="' + img$1 + '" alt="Youtube" class="hkust-footer-follow__icon"></a><a class="hkust-footer-follow__link" href="https://www.ust.hk/sites/default/files/menu_icons/IMG_5246.JPG" target="_bank" rel="noreferrer"><img class="hkust-footer-follow__icon" src="' + img + '" alt="Wechat"></a>', 5);
const _hoisted_21$1 = { class: "hkust-footer-logo-mobile" };
const _hoisted_22$1 = {
  key: 0,
  src: img$6,
  alt: "footer logo"
};
const _hoisted_23$1 = {
  key: 1,
  src: img$5,
  alt: "footer logo"
};
const _hoisted_24$1 = { class: "hkust-footer-copyright-mobile" };
const _hoisted_25$1 = {
  href: "https://beian.miit.gov.cn/#/Integrated/index",
  target: "_bank",
  class: "hkust-footer-copyright-mobile__link"
};
function render$1S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("footer", _hoisted_1$5L, [
    createBaseVNode("div", _hoisted_2$5m, [
      createBaseVNode("div", _hoisted_3$58, [
        createBaseVNode("div", _hoisted_4$1N, [
          renderSlot(_ctx.$slots, "footerLogo", {}, () => [
            _ctx.lang === "zh-cn" ? (openBlock(), createElementBlock("img", _hoisted_5$K)) : (openBlock(), createElementBlock("img", _hoisted_6$l))
          ])
        ]),
        createBaseVNode("div", _hoisted_7$e, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("ul", _hoisted_8$c, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menus, (item2) => {
                return openBlock(), createElementBlock("li", {
                  key: item2.path,
                  class: "hkust-footer-menus__item"
                }, [
                  createBaseVNode("a", {
                    href: item2.path,
                    class: "hkust-footer-menus__link"
                  }, toDisplayString$1(_ctx.t(item2.label)), 9, _hoisted_9$9)
                ]);
              }), 128))
            ]),
            createBaseVNode("p", _hoisted_10$9, [
              createTextVNode(toDisplayString$1(_ctx.t("hkust.footer.copyright")) + " ", 1),
              createBaseVNode("a", _hoisted_11$5, toDisplayString$1(_ctx.t("hkust.footer.record")), 1)
            ])
          ])
        ])
      ]),
      _ctx.showSocialMedia ? (openBlock(), createElementBlock("div", _hoisted_12$4, [
        renderSlot(_ctx.$slots, "follow", {}, () => [
          createBaseVNode("span", _hoisted_13$3, toDisplayString$1(_ctx.t("hkust.footer.follow")), 1),
          _ctx.socialMedias && _ctx.socialMedias.length !== 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.socialMedias, (item2) => {
            return openBlock(), createElementBlock("a", {
              key: item2.path,
              class: "hkust-footer-follow__link",
              href: item2.path,
              target: item2.target,
              rel: "noreferrer"
            }, [
              createBaseVNode("img", {
                src: item2.icon,
                alt: "Facebook",
                class: "hkust-footer-follow__icon"
              }, null, 8, _hoisted_15$2)
            ], 8, _hoisted_14$2);
          }), 128)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            _hoisted_16$2
          ], 64))
        ])
      ])) : createCommentVNode("v-if", true),
      createBaseVNode("div", _hoisted_21$1, [
        renderSlot(_ctx.$slots, "footerLogoMobile", {}, () => [
          _ctx.lang === "zh-cn" ? (openBlock(), createElementBlock("img", _hoisted_22$1)) : (openBlock(), createElementBlock("img", _hoisted_23$1))
        ])
      ]),
      createBaseVNode("p", _hoisted_24$1, [
        createTextVNode(toDisplayString$1(_ctx.t("hkust.footer.copyright")) + " ", 1),
        createBaseVNode("a", _hoisted_25$1, toDisplayString$1(_ctx.t("hkust.footer.record")), 1)
      ])
    ])
  ]);
}
script.render = render$1S;
script.__file = "packages/components/footer/src/index.vue";
const HkustFooter = withInstall$2(script);
var ConfigProvider$1 = defineComponent({
  name: "HkustConfigProvider",
  props: {
    locale: {
      type: Object
    }
  },
  setup(_2, { slots }) {
    provideLocale$1();
    return () => renderSlot(slots, "default");
  }
});
const HkustConfigProvider = withInstall$2(ConfigProvider$1);
var components$1 = [
  HkustMenu,
  HkustMenuItem,
  HkustSubmenu,
  HkustDropdown,
  HkustDropdownItem,
  HkustDropdownMenu,
  HkustIcon,
  HkustHeader,
  HkustOverlay,
  HkustSearch,
  HkustCollapseTransition,
  HkustFooter,
  HkustDrawer,
  HkustConfigProvider
];
var index$1m = {
  install(app) {
    components$1.forEach((comp) => {
      app.use(comp);
    });
  },
  version: version$3
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d2 = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var lib$2 = {};
var defaults$e = {};
var makeInstaller$1 = {};
var config$4 = {};
Object.defineProperty(config$4, "__esModule", { value: true });
let $ELEMENT = {};
const setConfig = (option2) => {
  $ELEMENT = option2;
};
const getConfig = (key2) => {
  return $ELEMENT[key2];
};
config$4.getConfig = getConfig;
config$4.setConfig = setConfig;
var useAttrs$1 = {};
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
function fromPairs$2(pairs) {
  var index2 = -1, length = pairs == null ? 0 : pairs.length, result3 = {};
  while (++index2 < length) {
    var pair = pairs[index2];
    result3[pair[0]] = pair[1];
  }
  return result3;
}
var fromPairs_1 = fromPairs$2;
var error$5 = {};
Object.defineProperty(error$5, "__esModule", { value: true });
class ElementPlusError extends Error {
  constructor(m2) {
    super(m2);
    this.name = "ElementPlusError";
  }
}
function throwError(scope, m2) {
  throw new ElementPlusError(`[${scope}] ${m2}`);
}
function debugWarn(scope, message3) {
}
error$5.debugWarn = debugWarn;
error$5.throwError = throwError;
Object.defineProperty(useAttrs$1, "__esModule", { value: true });
var vue$2F = require$$0$1;
var fromPairs$1 = fromPairs_1;
var error$4 = error$5;
function _interopDefaultLegacy$6(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
var fromPairs__default$1 = /* @__PURE__ */ _interopDefaultLegacy$6(fromPairs$1);
const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
const LISTENER_PREFIX = /^on[A-Z]/;
const useAttrs = (params = {}) => {
  const { excludeListeners = false, excludeKeys = [] } = params;
  const allExcludeKeys = excludeKeys.concat(DEFAULT_EXCLUDE_KEYS);
  const instance = vue$2F.getCurrentInstance();
  if (!instance) {
    error$4.debugWarn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function");
    return vue$2F.computed(() => ({}));
  }
  return vue$2F.computed(() => {
    var _a;
    return fromPairs__default$1["default"](Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(([key2]) => !allExcludeKeys.includes(key2) && !(excludeListeners && LISTENER_PREFIX.test(key2))));
  });
};
useAttrs$1.useAttrs = useAttrs;
var useCommonProps = {};
var util$l = {};
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(shared_esmBundler);
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array4, key2) {
  var length = array4.length;
  while (length--) {
    if (eq$2(array4[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key2) {
  var data2 = this.__data__, index2 = assocIndexOf$3(data2, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key2) {
  var data2 = this.__data__, index2 = assocIndexOf$2(data2, key2);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key2) {
  return assocIndexOf$1(this.__data__, key2) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key2, value) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
  if (index2 < 0) {
    ++this.size;
    data2.push([key2, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key2) {
  var data2 = this.__data__, result3 = data2["delete"](key2);
  this.size = data2.size;
  return result3;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key2) {
  return this.__data__.get(key2);
}
var _stackGet = stackGet$1;
function stackHas$1(key2) {
  return this.__data__.has(key2);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$7 = root$8.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$e = Object.prototype;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag3 = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result3 = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag3;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result3;
}
var _getRawTag = getRawTag$1;
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString$2(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$2;
var Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString$1 = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
var _baseGetTag = baseGetTag$5;
function isObject$c(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var isObject_1 = isObject$c;
var baseGetTag$4 = _baseGetTag, isObject$b = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$5(value) {
  if (!isObject$b(value)) {
    return false;
  }
  var tag3 = baseGetTag$4(value);
  return tag3 == funcTag$2 || tag3 == genTag$1 || tag3 == asyncTag || tag3 == proxyTag;
}
var isFunction_1 = isFunction$5;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$4 = isFunction_1, isMasked = _isMasked, isObject$a = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$a(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction$4(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$2(object4, key2) {
  return object4 == null ? void 0 : object4[key2];
}
var _getValue = getValue$2;
var baseIsNative = _baseIsNative, getValue$1 = _getValue;
function getNative$7(object4, key2) {
  var value = getValue$1(object4, key2);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$6 = _root;
var Map$4 = getNative$6(root$6, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key2) {
  var result3 = this.has(key2) && delete this.__data__[key2];
  this.size -= result3 ? 1 : 0;
  return result3;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function hashGet$1(key2) {
  var data2 = this.__data__;
  if (nativeCreate$2) {
    var result3 = data2[key2];
    return result3 === HASH_UNDEFINED$2 ? void 0 : result3;
  }
  return hasOwnProperty$a.call(data2, key2) ? data2[key2] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function hashHas$1(key2) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key2] !== void 0 : hasOwnProperty$9.call(data2, key2);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key2, value) {
  var data2 = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data2[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key2) {
  var data2 = map.__data__;
  return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key2) {
  var result3 = getMapData$3(this, key2)["delete"](key2);
  this.size -= result3 ? 1 : 0;
  return result3;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key2) {
  return getMapData$2(this, key2).get(key2);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key2) {
  return getMapData$1(this, key2).has(key2);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key2, value) {
  var data2 = getMapData(this, key2), size2 = data2.size;
  data2.set(key2, value);
  this.size += data2.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(key2, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache$1) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key2, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache$2(pairs);
  }
  data2.set(key2, value);
  this.size = data2.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$2(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;
var _SetCache = SetCache$2;
function arraySome$1(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$2(cache2, key2) {
  return cache2.has(key2);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array4, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array4);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result3 = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache$1() : void 0;
  stack2.set(array4, other);
  stack2.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack2) : customizer(arrValue, othValue, index2, array4, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result3 = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result3 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result3 = false;
      break;
    }
  }
  stack2["delete"](array4);
  stack2["delete"](other);
  return result3;
}
var _equalArrays = equalArrays$2;
var root$5 = _root;
var Uint8Array$3 = root$5.Uint8Array;
var _Uint8Array = Uint8Array$3;
function mapToArray$1(map) {
  var index2 = -1, result3 = Array(map.size);
  map.forEach(function(value, key2) {
    result3[++index2] = [key2, value];
  });
  return result3;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set2) {
  var index2 = -1, result3 = Array(set2.size);
  set2.forEach(function(value) {
    result3[++index2] = value;
  });
  return result3;
}
var _setToArray = setToArray$3;
var Symbol$4 = _Symbol, Uint8Array$2 = _Uint8Array, eq$1 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]";
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag$1(object4, other, tag3, bitmask, customizer, equalFunc, stack2) {
  switch (tag3) {
    case dataViewTag$4:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag$3:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object4), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag$3:
    case dateTag$3:
    case numberTag$3:
      return eq$1(+object4, +other);
    case errorTag$2:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag$3:
    case stringTag$3:
      return object4 == other + "";
    case mapTag$5:
      var convert = mapToArray;
    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray$2);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack2.set(object4, other);
      var result3 = equalArrays$1(convert(object4), convert(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object4);
      return result3;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object4) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$3(array4, values) {
  var index2 = -1, length = values.length, offset2 = array4.length;
  while (++index2 < length) {
    array4[offset2 + index2] = values[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$3;
var isArray$a = Array.isArray;
var isArray_1 = isArray$a;
var arrayPush$2 = _arrayPush, isArray$9 = isArray_1;
function baseGetAllKeys$2(object4, keysFunc, symbolsFunc) {
  var result3 = keysFunc(object4);
  return isArray$9(object4) ? result3 : arrayPush$2(result3, symbolsFunc(object4));
}
var _baseGetAllKeys = baseGetAllKeys$2;
function arrayFilter$1(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result3 = [];
  while (++index2 < length) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result3[resIndex++] = value;
    }
  }
  return result3;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$9 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
    return propertyIsEnumerable$1.call(object4, symbol);
  });
};
var _getSymbols = getSymbols$3;
function baseTimes$1(n, iteratee) {
  var index2 = -1, result3 = Array(n);
  while (++index2 < n) {
    result3[index2] = iteratee(index2);
  }
  return result3;
}
var _baseTimes = baseTimes$1;
function isObjectLike$8(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$8;
var baseGetTag$3 = _baseGetTag, isObjectLike$7 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$7(value) && baseGetTag$3(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$6 = isObjectLike_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$6(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$2;
var isBuffer$4 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$4, isBuffer$4.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type4 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$2 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$5 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$5(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$2(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$8 = isArray_1, isBuffer$3 = isBuffer$4.exports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$8(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result3 = skipIndexes ? baseTimes(value.length, String) : [], length = result3.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$7.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
      result3.push(key2);
    }
  }
  return result3;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$6 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$6 = objectProto$5.hasOwnProperty;
function baseKeys$1(object4) {
  if (!isPrototype$2(object4)) {
    return nativeKeys(object4);
  }
  var result3 = [];
  for (var key2 in Object(object4)) {
    if (hasOwnProperty$6.call(object4, key2) && key2 != "constructor") {
      result3.push(key2);
    }
  }
  return result3;
}
var _baseKeys = baseKeys$1;
var isFunction$3 = isFunction_1, isLength = isLength_1;
function isArrayLike$3(value) {
  return value != null && isLength(value.length) && !isFunction$3(value);
}
var isArrayLike_1 = isArrayLike$3;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$2 = isArrayLike_1;
function keys$3(object4) {
  return isArrayLike$2(object4) ? arrayLikeKeys$1(object4) : baseKeys(object4);
}
var keys_1 = keys$3;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols$2 = _getSymbols, keys$2 = keys_1;
function getAllKeys$2(object4) {
  return baseGetAllKeys$1(object4, keys$2, getSymbols$2);
}
var _getAllKeys = getAllKeys$2;
var getAllKeys$1 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$5 = objectProto$4.hasOwnProperty;
function equalObjects$1(object4, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys$1(object4), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$5.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack2.get(object4);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result3 = true;
  stack2.set(object4, other);
  stack2.set(other, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object4[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack2) : customizer(objValue, othValue, key2, object4, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result3 = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result3 && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result3 = false;
    }
  }
  stack2["delete"](object4);
  stack2["delete"](other);
  return result3;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$4 = _root;
var DataView$1 = getNative$4(root$4, "DataView");
var _DataView = DataView$1;
var getNative$3 = _getNative, root$3 = _root;
var Promise$2 = getNative$3(root$3, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$2 = _root;
var Set$3 = getNative$2(root$2, "Set");
var _Set = Set$3;
var getNative$1 = _getNative, root$1 = _root;
var WeakMap$2 = getNative$1(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap$1 = _WeakMap, baseGetTag$1 = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag$4 = baseGetTag$1;
if (DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$4(new Map$1()) != mapTag$3 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$2 && getTag$4(new Set$2()) != setTag$3 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) {
  getTag$4 = function(value) {
    var result3 = baseGetTag$1(value), Ctor = result3 == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result3;
  };
}
var _getTag = getTag$4;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$3 = _getTag, isArray$7 = isArray_1, isBuffer$2 = isBuffer$4.exports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
var objectProto$3 = Object.prototype;
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
function baseIsEqualDeep$1(object4, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray$7(object4), othIsArr = isArray$7(other), objTag = objIsArr ? arrayTag$1 : getTag$3(object4), othTag = othIsArr ? arrayTag$1 : getTag$3(other);
  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object4)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack$1());
    return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$4.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$4.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack$1());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack2);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$4 = isObjectLike_1;
function baseIsEqual$2(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack2);
}
var _baseIsEqual = baseIsEqual$2;
var baseIsEqual$1 = _baseIsEqual;
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result3 = customizer ? customizer(value, other) : void 0;
  return result3 === void 0 ? baseIsEqual$1(value, other, void 0, customizer) : !!result3;
}
var isEqualWith_1 = isEqualWith;
var isServer$8 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var isServer2 = typeof window === "undefined";
  exports["default"] = isServer2;
})(isServer$8);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var isEqualWith2 = isEqualWith_1;
  var isServer2 = isServer$8;
  var error2 = error$5;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var isEqualWith__default = /* @__PURE__ */ _interopDefaultLegacy2(isEqualWith2);
  const SCOPE2 = "Util";
  function toObject(arr) {
    const res = {};
    for (let i = 0; i < arr.length; i++) {
      if (arr[i]) {
        shared2.extend(res, arr[i]);
      }
    }
    return res;
  }
  const getValueByPath = (obj, paths = "") => {
    let ret = obj;
    paths.split(".").map((path) => {
      ret = ret == null ? void 0 : ret[path];
    });
    return ret;
  };
  function getPropByPath(obj, path, strict) {
    let tempObj = obj;
    let key2, value;
    if (obj && shared2.hasOwn(obj, path)) {
      key2 = path;
      value = tempObj == null ? void 0 : tempObj[path];
    } else {
      path = path.replace(/\[(\w+)\]/g, ".$1");
      path = path.replace(/^\./, "");
      const keyArr = path.split(".");
      let i = 0;
      for (i; i < keyArr.length - 1; i++) {
        if (!tempObj && !strict)
          break;
        const key22 = keyArr[i];
        if (key22 in tempObj) {
          tempObj = tempObj[key22];
        } else {
          if (strict) {
            error2.throwError(SCOPE2, "Please transfer a valid prop path to form item!");
          }
          break;
        }
      }
      key2 = keyArr[i];
      value = tempObj == null ? void 0 : tempObj[keyArr[i]];
    }
    return {
      o: tempObj,
      k: key2,
      v: value
    };
  }
  const generateId2 = () => Math.floor(Math.random() * 1e4);
  const escapeRegexpString = (value = "") => String(value).replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  const coerceTruthyValueToArray = (arr) => {
    if (!arr && arr !== 0) {
      return [];
    }
    return Array.isArray(arr) ? arr : [arr];
  };
  const isFirefox = function() {
    return !isServer2["default"] && !!window.navigator.userAgent.match(/firefox/i);
  };
  const autoprefixer = function(style) {
    const rules2 = ["transform", "transition", "animation"];
    const prefixes2 = ["ms-", "webkit-"];
    rules2.forEach((rule) => {
      const value = style[rule];
      if (rule && value) {
        prefixes2.forEach((prefix) => {
          style[prefix + rule] = value;
        });
      }
    });
    return style;
  };
  const kebabCase = shared2.hyphenate;
  const isBool2 = (val) => typeof val === "boolean";
  const isNumber2 = (val) => typeof val === "number";
  const isHTMLElement2 = (val) => shared2.toRawType(val).startsWith("HTML");
  function rafThrottle(fn3) {
    let locked = false;
    return function(...args) {
      if (locked)
        return;
      locked = true;
      window.requestAnimationFrame(() => {
        Reflect.apply(fn3, this, args);
        locked = false;
      });
    };
  }
  const clearTimer = (timer2) => {
    clearTimeout(timer2.value);
    timer2.value = null;
  };
  function getRandomInt(max2) {
    return Math.floor(Math.random() * Math.floor(max2));
  }
  function isUndefined2(val) {
    return val === void 0;
  }
  function useGlobalConfig2() {
    const vm = vue2.getCurrentInstance();
    if ("$ELEMENT" in vm.proxy) {
      return vm.proxy.$ELEMENT;
    }
    return {};
  }
  function isEmpty(val) {
    if (!val && val !== 0 || shared2.isArray(val) && !val.length || shared2.isObject(val) && !Object.keys(val).length)
      return true;
    return false;
  }
  function arrayFlat(arr) {
    return arr.reduce((acm, item2) => {
      const val = Array.isArray(item2) ? arrayFlat(item2) : item2;
      return acm.concat(val);
    }, []);
  }
  function deduplicate(arr) {
    return Array.from(new Set(arr));
  }
  function addUnit2(value) {
    if (shared2.isString(value)) {
      return value;
    } else if (isNumber2(value)) {
      return `${value}px`;
    }
    error2.debugWarn(SCOPE2, "binding value must be a string or number");
    return "";
  }
  function isEqualWithFunction(obj, other) {
    return isEqualWith__default["default"](obj, other, (objVal, otherVal) => {
      return shared2.isFunction(objVal) && shared2.isFunction(otherVal) ? `${objVal}` === `${otherVal}` : void 0;
    });
  }
  const refAttacher = (ref2) => {
    return (val) => {
      ref2.value = val;
    };
  };
  Object.defineProperty(exports, "isVNode", {
    enumerable: true,
    get: function() {
      return vue2.isVNode;
    }
  });
  Object.defineProperty(exports, "camelize", {
    enumerable: true,
    get: function() {
      return shared2.camelize;
    }
  });
  Object.defineProperty(exports, "capitalize", {
    enumerable: true,
    get: function() {
      return shared2.capitalize;
    }
  });
  Object.defineProperty(exports, "extend", {
    enumerable: true,
    get: function() {
      return shared2.extend;
    }
  });
  Object.defineProperty(exports, "hasOwn", {
    enumerable: true,
    get: function() {
      return shared2.hasOwn;
    }
  });
  Object.defineProperty(exports, "isArray", {
    enumerable: true,
    get: function() {
      return shared2.isArray;
    }
  });
  Object.defineProperty(exports, "isObject", {
    enumerable: true,
    get: function() {
      return shared2.isObject;
    }
  });
  Object.defineProperty(exports, "isString", {
    enumerable: true,
    get: function() {
      return shared2.isString;
    }
  });
  Object.defineProperty(exports, "looseEqual", {
    enumerable: true,
    get: function() {
      return shared2.looseEqual;
    }
  });
  exports.SCOPE = SCOPE2;
  exports.addUnit = addUnit2;
  exports.arrayFlat = arrayFlat;
  exports.autoprefixer = autoprefixer;
  exports.clearTimer = clearTimer;
  exports.coerceTruthyValueToArray = coerceTruthyValueToArray;
  exports.deduplicate = deduplicate;
  exports.escapeRegexpString = escapeRegexpString;
  exports.generateId = generateId2;
  exports.getPropByPath = getPropByPath;
  exports.getRandomInt = getRandomInt;
  exports.getValueByPath = getValueByPath;
  exports.isBool = isBool2;
  exports.isEmpty = isEmpty;
  exports.isEqualWithFunction = isEqualWithFunction;
  exports.isFirefox = isFirefox;
  exports.isHTMLElement = isHTMLElement2;
  exports.isNumber = isNumber2;
  exports.isUndefined = isUndefined2;
  exports.kebabCase = kebabCase;
  exports.rafThrottle = rafThrottle;
  exports.refAttacher = refAttacher;
  exports.toObject = toObject;
  exports.useGlobalConfig = useGlobalConfig2;
})(util$l);
var form$7 = {};
Object.defineProperty(form$7, "__esModule", { value: true });
const elFormKey = Symbol("elForm");
const elFormItemKey = Symbol("elFormItem");
form$7.elFormItemKey = elFormItemKey;
form$7.elFormKey = elFormKey;
var button$6 = {};
Object.defineProperty(button$6, "__esModule", { value: true });
const buttonGroupContextKey = Symbol("buttonGroupContextKey");
button$6.buttonGroupContextKey = buttonGroupContextKey;
var breadcrumb$3 = {};
Object.defineProperty(breadcrumb$3, "__esModule", { value: true });
const elBreadcrumbKey = Symbol("elBreadcrumbKey");
breadcrumb$3.elBreadcrumbKey = elBreadcrumbKey;
var pagination$4 = {};
Object.defineProperty(pagination$4, "__esModule", { value: true });
const elPaginationKey = Symbol("elPaginationKey");
pagination$4.elPaginationKey = elPaginationKey;
var configProvider$5 = {};
Object.defineProperty(configProvider$5, "__esModule", { value: true });
const configProviderContextKey = Symbol();
configProvider$5.configProviderContextKey = configProviderContextKey;
var radio$6 = {};
Object.defineProperty(radio$6, "__esModule", { value: true });
const radioGroupKey = Symbol("radioGroupKey");
radio$6.radioGroupKey = radioGroupKey;
var tabs$3 = {};
Object.defineProperty(tabs$3, "__esModule", { value: true });
const tabsRootContextKey = Symbol("tabsRootContextKey");
tabs$3.tabsRootContextKey = tabsRootContextKey;
var scrollbar$4 = {};
Object.defineProperty(scrollbar$4, "__esModule", { value: true });
const scrollbarContextKey = Symbol("scrollbarContextKey");
scrollbar$4.scrollbarContextKey = scrollbarContextKey;
var props$N = {};
Object.defineProperty(props$N, "__esModule", { value: true });
var vue$2E = require$$0$1;
var shared$n = require$$1$1;
var fromPairs = fromPairs_1;
function _interopDefaultLegacy$5(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
var fromPairs__default = /* @__PURE__ */ _interopDefaultLegacy$5(fromPairs);
const wrapperKey = Symbol();
const propKey = Symbol();
function buildProp(option2, key2) {
  if (!shared$n.isObject(option2) || !!option2[propKey])
    return option2;
  const { values, required: required4, default: defaultValue, type: type4, validator: validator2 } = option2;
  const _validator = values || validator2 ? (val) => {
    let valid = false;
    let allowedValues = [];
    if (values) {
      allowedValues = [...values, defaultValue];
      valid || (valid = allowedValues.includes(val));
    }
    if (validator2)
      valid || (valid = validator2(val));
    if (!valid && allowedValues.length > 0) {
      const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
      vue$2E.warn(`Invalid prop: validation failed${key2 ? ` for prop "${key2}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
    }
    return valid;
  } : void 0;
  return {
    type: typeof type4 === "object" && Object.getOwnPropertySymbols(type4).includes(wrapperKey) ? type4[wrapperKey] : type4,
    required: !!required4,
    default: defaultValue,
    validator: _validator,
    [propKey]: true
  };
}
const buildProps = (props2) => fromPairs__default["default"](Object.entries(props2).map(([key2, option2]) => [
  key2,
  buildProp(option2, key2)
]));
const definePropType = (val) => ({ [wrapperKey]: val });
const keyOf = (arr) => Object.keys(arr);
const mutable = (val) => val;
const componentSize = ["large", "medium", "small", "mini"];
props$N.buildProp = buildProp;
props$N.buildProps = buildProps;
props$N.componentSize = componentSize;
props$N.definePropType = definePropType;
props$N.keyOf = keyOf;
props$N.mutable = mutable;
props$N.propKey = propKey;
var useProp$1 = {};
Object.defineProperty(useProp$1, "__esModule", { value: true });
var vue$2D = require$$0$1;
const useProp = (name) => {
  const vm = vue$2D.getCurrentInstance();
  return vue$2D.computed(() => {
    var _a, _b;
    return (_b = (_a = vm.proxy) == null ? void 0 : _a.$props[name]) != null ? _b : void 0;
  });
};
useProp$1.useProp = useProp;
var useGlobalConfig$1 = {};
Object.defineProperty(useGlobalConfig$1, "__esModule", { value: true });
var vue$2C = require$$0$1;
var configProvider$4 = configProvider$5;
function useGlobalConfig(key2) {
  const config2 = vue$2C.inject(configProvider$4.configProviderContextKey, {});
  if (key2) {
    return vue$2C.toRef(config2, key2);
  } else {
    return config2;
  }
}
useGlobalConfig$1.useGlobalConfig = useGlobalConfig;
Object.defineProperty(useCommonProps, "__esModule", { value: true });
var vue$2B = require$$0$1;
var util$k = util$l;
var props$M = props$N;
var index$1l = useProp$1;
var index$1$5 = useGlobalConfig$1;
var form$6 = form$7;
const useSizeProp = props$M.buildProp({
  type: String,
  values: ["", ...props$M.componentSize],
  default: ""
});
const useSize = (fallback, ignore = {}) => {
  const emptyRef = vue$2B.ref(void 0);
  const size2 = ignore.prop ? emptyRef : index$1l.useProp("size");
  const globalConfig = ignore.global ? emptyRef : index$1$5.useGlobalConfig("size");
  const globalConfigLegacy = ignore.global ? { size: void 0 } : util$k.useGlobalConfig();
  const form$12 = ignore.form ? { size: void 0 } : vue$2B.inject(form$6.elFormKey, void 0);
  const formItem2 = ignore.formItem ? { size: void 0 } : vue$2B.inject(form$6.elFormItemKey, void 0);
  return vue$2B.computed(() => size2.value || vue$2B.unref(fallback) || (formItem2 == null ? void 0 : formItem2.size) || (form$12 == null ? void 0 : form$12.size) || globalConfig.value || globalConfigLegacy.size || "");
};
const useDisabled$1 = (fallback) => {
  const disabled = index$1l.useProp("disabled");
  const form$12 = vue$2B.inject(form$6.elFormKey, void 0);
  return vue$2B.computed(() => disabled.value || vue$2B.unref(fallback) || (form$12 == null ? void 0 : form$12.disabled) || false);
};
useCommonProps.useDisabled = useDisabled$1;
useCommonProps.useSize = useSize;
useCommonProps.useSizeProp = useSizeProp;
var useFocus$1 = {};
Object.defineProperty(useFocus$1, "__esModule", { value: true });
const useFocus = (el) => {
  return {
    focus: () => {
      var _a, _b;
      (_b = (_a = el.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    }
  };
};
useFocus$1.useFocus = useFocus;
var useFormItem$1 = {};
Object.defineProperty(useFormItem$1, "__esModule", { value: true });
var vue$2A = require$$0$1;
var form$5 = form$7;
const useFormItem = () => {
  const form$12 = vue$2A.inject(form$5.elFormKey, void 0);
  const formItem2 = vue$2A.inject(form$5.elFormItemKey, void 0);
  return {
    form: form$12,
    formItem: formItem2
  };
};
useFormItem$1.useFormItem = useFormItem;
var useLocale$1 = {};
var baseGetTag = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var symbolTag$2 = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag(value) == symbolTag$2;
}
var isSymbol_1 = isSymbol$4;
var isArray$6 = isArray_1, isSymbol$3 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$1(value, object4) {
  if (isArray$6(value)) {
    return false;
  }
  var type4 = typeof value;
  if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol$3(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
}
var _isKey = isKey$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key2)) {
      return cache2.get(key2);
    }
    var result3 = func.apply(this, args);
    memoized.cache = cache2.set(key2, result3) || cache2;
    return result3;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result3 = memoize(func, function(key2) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key2;
  });
  var cache2 = result3.cache;
  return result3;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string3) {
  var result3 = [];
  if (string3.charCodeAt(0) === 46) {
    result3.push("");
  }
  string3.replace(rePropName, function(match, number4, quote, subString) {
    result3.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
  });
  return result3;
});
var _stringToPath = stringToPath$1;
function arrayMap$1(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, result3 = Array(length);
  while (++index2 < length) {
    result3[index2] = iteratee(array4[index2], index2, array4);
  }
  return result3;
}
var _arrayMap = arrayMap$1;
var Symbol$3 = _Symbol, arrayMap = _arrayMap, isArray$5 = isArray_1, isSymbol$2 = isSymbol_1;
var INFINITY$2 = 1 / 0;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$5(value)) {
    return arrayMap(value, baseToString$1) + "";
  }
  if (isSymbol$2(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result3 = value + "";
  return result3 == "0" && 1 / value == -INFINITY$2 ? "-0" : result3;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$3(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$3;
var isArray$4 = isArray_1, isKey = _isKey, stringToPath = _stringToPath, toString$2 = toString_1;
function castPath$1(value, object4) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object4) ? [value] : stringToPath(toString$2(value));
}
var _castPath = castPath$1;
var isSymbol$1 = isSymbol_1;
var INFINITY$1 = 1 / 0;
function toKey$1(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result3 = value + "";
  return result3 == "0" && 1 / value == -INFINITY$1 ? "-0" : result3;
}
var _toKey = toKey$1;
var castPath = _castPath, toKey = _toKey;
function baseGet$1(object4, path) {
  path = castPath(path, object4);
  var index2 = 0, length = path.length;
  while (object4 != null && index2 < length) {
    object4 = object4[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object4 : void 0;
}
var _baseGet = baseGet$1;
var baseGet = _baseGet;
function get$2(object4, path, defaultValue) {
  var result3 = object4 == null ? void 0 : baseGet(object4, path);
  return result3 === void 0 ? defaultValue : result3;
}
var get_1 = get$2;
var en$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var English = {
    name: "en",
    el: {
      colorpicker: {
        confirm: "OK",
        clear: "Clear"
      },
      datepicker: {
        now: "Now",
        today: "Today",
        cancel: "Cancel",
        clear: "Clear",
        confirm: "OK",
        selectDate: "Select date",
        selectTime: "Select time",
        startDate: "Start Date",
        startTime: "Start Time",
        endDate: "End Date",
        endTime: "End Time",
        prevYear: "Previous Year",
        nextYear: "Next Year",
        prevMonth: "Previous Month",
        nextMonth: "Next Month",
        year: "",
        month1: "January",
        month2: "February",
        month3: "March",
        month4: "April",
        month5: "May",
        month6: "June",
        month7: "July",
        month8: "August",
        month9: "September",
        month10: "October",
        month11: "November",
        month12: "December",
        week: "week",
        weeks: {
          sun: "Sun",
          mon: "Mon",
          tue: "Tue",
          wed: "Wed",
          thu: "Thu",
          fri: "Fri",
          sat: "Sat"
        },
        months: {
          jan: "Jan",
          feb: "Feb",
          mar: "Mar",
          apr: "Apr",
          may: "May",
          jun: "Jun",
          jul: "Jul",
          aug: "Aug",
          sep: "Sep",
          oct: "Oct",
          nov: "Nov",
          dec: "Dec"
        }
      },
      select: {
        loading: "Loading",
        noMatch: "No matching data",
        noData: "No data",
        placeholder: "Select"
      },
      cascader: {
        noMatch: "No matching data",
        loading: "Loading",
        placeholder: "Select",
        noData: "No data"
      },
      pagination: {
        goto: "Go to",
        pagesize: "/page",
        total: "Total {total}",
        pageClassifier: "",
        deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
      },
      messagebox: {
        title: "Message",
        confirm: "OK",
        cancel: "Cancel",
        error: "Illegal input"
      },
      upload: {
        deleteTip: "press delete to remove",
        delete: "Delete",
        preview: "Preview",
        continue: "Continue"
      },
      table: {
        emptyText: "No Data",
        confirmFilter: "Confirm",
        resetFilter: "Reset",
        clearFilter: "All",
        sumText: "Sum"
      },
      tree: {
        emptyText: "No Data"
      },
      transfer: {
        noMatch: "No matching data",
        noData: "No data",
        titles: ["List 1", "List 2"],
        filterPlaceholder: "Enter keyword",
        noCheckedFormat: "{total} items",
        hasCheckedFormat: "{checked}/{total} checked"
      },
      image: {
        error: "FAILED"
      },
      pageHeader: {
        title: "Back"
      },
      popconfirm: {
        confirmButtonText: "Yes",
        cancelButtonText: "No"
      }
    }
  };
  exports["default"] = English;
})(en$2);
Object.defineProperty(useLocale$1, "__esModule", { value: true });
var vue$2z = require$$0$1;
var get$1 = get_1;
var en$1 = en$2;
var props$L = props$N;
function _interopDefaultLegacy$4(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
var get__default = /* @__PURE__ */ _interopDefaultLegacy$4(get$1);
const useLocaleProps = props$L.buildProps({
  locale: {
    type: props$L.definePropType(Object)
  }
});
const localeContextKey = Symbol("localeContextKey");
let cache$2;
const provideLocale = () => {
  const vm = vue$2z.getCurrentInstance();
  const props2 = vm.props;
  const locale = vue$2z.computed(() => props2.locale || en$1["default"]);
  const lang = vue$2z.computed(() => locale.value.name);
  const t = buildTranslator(locale);
  const provides = {
    locale,
    lang,
    t
  };
  cache$2 = provides;
  vue$2z.provide(localeContextKey, provides);
};
const buildTranslator = (locale) => (path, option2) => translate$1(path, option2, vue$2z.unref(locale));
const translate$1 = (path, option2, locale) => get__default["default"](locale, path, path).replace(/\{(\w+)\}/g, (_2, key2) => {
  var _a;
  return `${(_a = option2 == null ? void 0 : option2[key2]) != null ? _a : `{${key2}}`}`;
});
const localeProviderMaker = (locale = en$1["default"]) => {
  const lang = vue$2z.ref(locale.name);
  const localeRef = vue$2z.ref(locale);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator(localeRef)
  };
};
const useLocale = () => {
  return vue$2z.inject(localeContextKey, cache$2 || localeProviderMaker(en$1["default"]));
};
useLocale$1.buildTranslator = buildTranslator;
useLocale$1.localeContextKey = localeContextKey;
useLocale$1.localeProviderMaker = localeProviderMaker;
useLocale$1.provideLocale = provideLocale;
useLocale$1.translate = translate$1;
useLocale$1.useLocale = useLocale;
useLocale$1.useLocaleProps = useLocaleProps;
var useLockscreen$1 = {};
var scrollbarWidth$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var isServer2 = isServer$8;
  let scrollBarWidth;
  function scrollbarWidth2() {
    var _a;
    if (isServer2["default"])
      return 0;
    if (scrollBarWidth !== void 0)
      return scrollBarWidth;
    const outer = document.createElement("div");
    outer.className = "el-scrollbar__wrap";
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.position = "absolute";
    outer.style.top = "-9999px";
    document.body.appendChild(outer);
    const widthNoScroll = outer.offsetWidth;
    outer.style.overflow = "scroll";
    const inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);
    const widthWithScroll = inner.offsetWidth;
    (_a = outer.parentNode) == null ? void 0 : _a.removeChild(outer);
    scrollBarWidth = widthNoScroll - widthWithScroll;
    return scrollBarWidth;
  }
  exports["default"] = scrollbarWidth2;
})(scrollbarWidth$1);
var dom$8 = {};
Object.defineProperty(dom$8, "__esModule", { value: true });
var isServer$7 = isServer$8;
var shared$m = require$$1$1;
const trimArr = function(s2) {
  return (s2 || "").split(" ").filter((item2) => !!item2.trim());
};
const on = function(element, event, handler, useCapture = false) {
  if (element && event && handler) {
    element == null ? void 0 : element.addEventListener(event, handler, useCapture);
  }
};
const off = function(element, event, handler, useCapture = false) {
  if (element && event && handler) {
    element == null ? void 0 : element.removeEventListener(event, handler, useCapture);
  }
};
const once = function(el, event, fn3) {
  const listener = function(...args) {
    if (fn3) {
      fn3.apply(this, args);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};
function hasClass(el, cls) {
  if (!el || !cls)
    return false;
  if (cls.indexOf(" ") !== -1)
    throw new Error("className should not contain space.");
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    const className = el.getAttribute("class") || "";
    return className.split(" ").includes(cls);
  }
}
function addClass(el, cls) {
  if (!el)
    return;
  let className = el.getAttribute("class") || "";
  const curClass = trimArr(className);
  const classes = (cls || "").split(" ").filter((item2) => !curClass.includes(item2) && !!item2.trim());
  if (el.classList) {
    el.classList.add(...classes);
  } else {
    className += ` ${classes.join(" ")}`;
    el.setAttribute("class", className);
  }
}
function removeClass(el, cls) {
  if (!el || !cls)
    return;
  const classes = trimArr(cls);
  let curClass = el.getAttribute("class") || "";
  if (el.classList) {
    el.classList.remove(...classes);
    return;
  }
  classes.forEach((item2) => {
    curClass = curClass.replace(` ${item2} `, " ");
  });
  const className = trimArr(curClass).join(" ");
  el.setAttribute("class", className);
}
const getStyle = function(element, styleName) {
  var _a;
  if (isServer$7["default"])
    return "";
  if (!element || !styleName)
    return "";
  styleName = shared$m.camelize(styleName);
  if (styleName === "float") {
    styleName = "cssFloat";
  }
  try {
    const style = element.style[styleName];
    if (style)
      return style;
    const computed2 = (_a = document.defaultView) == null ? void 0 : _a.getComputedStyle(element, "");
    return computed2 ? computed2[styleName] : "";
  } catch (e) {
    return element.style[styleName];
  }
};
function setStyle(element, styleName, value) {
  if (!element || !styleName)
    return;
  if (shared$m.isObject(styleName)) {
    Object.keys(styleName).forEach((prop) => {
      setStyle(element, prop, styleName[prop]);
    });
  } else {
    styleName = shared$m.camelize(styleName);
    element.style[styleName] = value;
  }
}
function removeStyle(element, style) {
  if (!element || !style)
    return;
  if (shared$m.isObject(style)) {
    Object.keys(style).forEach((prop) => {
      setStyle(element, prop, "");
    });
  } else {
    setStyle(element, style, "");
  }
}
const isScroll = (el, isVertical) => {
  if (isServer$7["default"])
    return null;
  const determinedDirection = isVertical === null || isVertical === void 0;
  const overflow = determinedDirection ? getStyle(el, "overflow") : isVertical ? getStyle(el, "overflow-y") : getStyle(el, "overflow-x");
  return overflow.match(/(scroll|auto|overlay)/);
};
const getScrollContainer = (el, isVertical) => {
  if (isServer$7["default"])
    return;
  let parent = el;
  while (parent) {
    if ([window, document, document.documentElement].includes(parent)) {
      return window;
    }
    if (isScroll(parent, isVertical)) {
      return parent;
    }
    parent = parent.parentNode;
  }
  return parent;
};
const isInContainer = (el, container2) => {
  if (isServer$7["default"] || !el || !container2)
    return false;
  const elRect = el.getBoundingClientRect();
  let containerRect;
  if (container2 instanceof Element) {
    containerRect = container2.getBoundingClientRect();
  } else {
    containerRect = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    };
  }
  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
};
const getOffsetTop = (el) => {
  let offset2 = 0;
  let parent = el;
  while (parent) {
    offset2 += parent.offsetTop;
    parent = parent.offsetParent;
  }
  return offset2;
};
const getOffsetTopDistance = (el, containerEl) => {
  return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));
};
const stop = (e) => e.stopPropagation();
const getClientXY = (event) => {
  let clientX;
  let clientY;
  if (event.type === "touchend") {
    clientY = event.changedTouches[0].clientY;
    clientX = event.changedTouches[0].clientX;
  } else if (event.type.startsWith("touch")) {
    clientY = event.touches[0].clientY;
    clientX = event.touches[0].clientX;
  } else {
    clientY = event.clientY;
    clientX = event.clientX;
  }
  return {
    clientX,
    clientY
  };
};
dom$8.addClass = addClass;
dom$8.getClientXY = getClientXY;
dom$8.getOffsetTop = getOffsetTop;
dom$8.getOffsetTopDistance = getOffsetTopDistance;
dom$8.getScrollContainer = getScrollContainer;
dom$8.getStyle = getStyle;
dom$8.hasClass = hasClass;
dom$8.isInContainer = isInContainer;
dom$8.isScroll = isScroll;
dom$8.off = off;
dom$8.on = on;
dom$8.once = once;
dom$8.removeClass = removeClass;
dom$8.removeStyle = removeStyle;
dom$8.setStyle = setStyle;
dom$8.stop = stop;
Object.defineProperty(useLockscreen$1, "__esModule", { value: true });
var vue$2y = require$$0$1;
var scrollbarWidth = scrollbarWidth$1;
var error$3 = error$5;
var dom$7 = dom$8;
var isServer$6 = isServer$8;
const useLockscreen = (trigger2) => {
  if (!vue$2y.isRef(trigger2)) {
    error$3.throwError("[useLockscreen]", "You need to pass a ref param to this function");
  }
  if (isServer$6["default"] || dom$7.hasClass(document.body, "el-popup-parent--hidden")) {
    return;
  }
  let scrollBarWidth = 0;
  let withoutHiddenClass = false;
  let bodyPaddingRight = "0";
  let computedBodyPaddingRight = 0;
  const cleanup = () => {
    dom$7.removeClass(document.body, "el-popup-parent--hidden");
    if (withoutHiddenClass) {
      document.body.style.paddingRight = bodyPaddingRight;
    }
  };
  vue$2y.watch(trigger2, (val) => {
    if (!val) {
      cleanup();
      return;
    }
    withoutHiddenClass = !dom$7.hasClass(document.body, "el-popup-parent--hidden");
    if (withoutHiddenClass) {
      bodyPaddingRight = document.body.style.paddingRight;
      computedBodyPaddingRight = parseInt(dom$7.getStyle(document.body, "paddingRight"), 10);
    }
    scrollBarWidth = scrollbarWidth["default"]();
    const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
    const bodyOverflowY = dom$7.getStyle(document.body, "overflowY");
    if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarWidth}px`;
    }
    dom$7.addClass(document.body, "el-popup-parent--hidden");
  });
  vue$2y.onScopeDispose(() => cleanup());
};
useLockscreen$1.useLockscreen = useLockscreen;
var useModal$1 = {};
var core$7 = {};
var shared$l = {};
var lib$1 = {};
(function(exports) {
  var Vue = require$$0$1;
  Object.keys(Vue).forEach(function(key2) {
    exports[key2] = Vue[key2];
  });
  exports.set = function(target2, key2, val) {
    if (Array.isArray(target2)) {
      target2.length = Math.max(target2.length, key2);
      target2.splice(key2, 1, val);
      return val;
    }
    target2[key2] = val;
    return val;
  };
  exports.del = function(target2, key2) {
    if (Array.isArray(target2)) {
      target2.splice(key2, 1);
      return;
    }
    delete target2[key2];
  };
  exports.Vue = Vue;
  exports.Vue2 = void 0;
  exports.isVue2 = false;
  exports.isVue3 = true;
  exports.install = function() {
  };
})(lib$1);
Object.defineProperty(shared$l, "__esModule", { value: true });
var vueDemi = lib$1;
function and(...args) {
  return vueDemi.computed(() => args.every((i) => vueDemi.unref(i)));
}
function biSyncRef(a2, b2) {
  const flush = "sync";
  const stop1 = vueDemi.watch(a2, (newValue) => {
    b2.value = newValue;
  }, {
    flush,
    immediate: true
  });
  const stop2 = vueDemi.watch(b2, (newValue) => {
    a2.value = newValue;
  }, {
    flush,
    immediate: true
  });
  return () => {
    stop1();
    stop2();
  };
}
function controlledComputed(source2, fn3) {
  let v2 = void 0;
  let track2;
  let trigger2;
  const dirty = vueDemi.ref(true);
  vueDemi.watch(source2, () => {
    dirty.value = true;
    trigger2();
  }, { flush: "sync" });
  return vueDemi.customRef((_track, _trigger) => {
    track2 = _track;
    trigger2 = _trigger;
    return {
      get() {
        if (dirty.value) {
          v2 = fn3();
          dirty.value = false;
        }
        track2();
        return v2;
      },
      set() {
      }
    };
  });
}
function __onlyVue3(name = "this function") {
  if (vueDemi.isVue3)
    return;
  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);
}
function extendRef(ref2, extend2, { enumerable: enumerable4 = false, unwrap = true } = {}) {
  __onlyVue3();
  for (const [key2, value] of Object.entries(extend2)) {
    if (key2 === "value")
      continue;
    if (vueDemi.isRef(value) && unwrap) {
      Object.defineProperty(ref2, key2, {
        get() {
          return value.value;
        },
        set(v2) {
          value.value = v2;
        },
        enumerable: enumerable4
      });
    } else {
      Object.defineProperty(ref2, key2, { value, enumerable: enumerable4 });
    }
  }
  return ref2;
}
function controlledRef(initial, options = {}) {
  let source2 = initial;
  let track2;
  let trigger2;
  const ref2 = vueDemi.customRef((_track, _trigger) => {
    track2 = _track;
    trigger2 = _trigger;
    return {
      get() {
        return get3();
      },
      set(v2) {
        set2(v2);
      }
    };
  });
  function get3(tracking = true) {
    if (tracking)
      track2();
    return source2;
  }
  function set2(value, triggering = true) {
    var _a, _b;
    if (value === source2)
      return;
    const old = source2;
    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)
      return;
    source2 = value;
    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);
    if (triggering)
      trigger2();
  }
  const untrackedGet = () => get3(false);
  const silentSet = (v2) => set2(v2, false);
  const peek = () => get3(false);
  const lay = (v2) => set2(v2, false);
  return extendRef(ref2, {
    get: get3,
    set: set2,
    untrackedGet,
    silentSet,
    peek,
    lay
  }, { enumerable: true });
}
function createEventHook() {
  const fns = [];
  const off2 = (fn3) => {
    const index2 = fns.indexOf(fn3);
    if (index2 !== -1)
      fns.splice(index2, 1);
  };
  const on2 = (fn3) => {
    fns.push(fn3);
    return {
      off: () => off2(fn3)
    };
  };
  const trigger2 = (param) => {
    fns.forEach((fn3) => fn3(param));
  };
  return {
    on: on2,
    off: off2,
    trigger: trigger2
  };
}
function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = vueDemi.effectScope(true);
  return () => {
    if (!initialized) {
      state = scope.run(stateFactory);
      initialized = true;
    }
    return state;
  };
}
function reactify(fn3) {
  return function(...args) {
    return vueDemi.computed(() => fn3.apply(this, args.map((i) => vueDemi.unref(i))));
  };
}
function tryOnScopeDispose(fn3) {
  if (vueDemi.getCurrentScope()) {
    vueDemi.onScopeDispose(fn3);
    return true;
  }
  return false;
}
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!state) {
      scope = vueDemi.effectScope(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}
const isClient = typeof window !== "undefined";
const isDef$3 = (val) => typeof val !== "undefined";
const assert = (condition, ...infos) => {
  if (!condition)
    console.warn(...infos);
};
const toString$1 = Object.prototype.toString;
const isBoolean$1 = (val) => typeof val === "boolean";
const isFunction$2 = (val) => typeof val === "function";
const isNumber$2 = (val) => typeof val === "number";
const isString$2 = (val) => typeof val === "string";
const isObject$9 = (val) => toString$1.call(val) === "[object Object]";
const isWindow = (val) => typeof window !== "undefined" && toString$1.call(val) === "[object Window]";
const now$2 = () => Date.now();
const timestamp = () => +Date.now();
const clamp = (n, min2, max2) => Math.min(max2, Math.max(min2, n));
const noop$3 = () => {
};
const rand = (min2, max2) => {
  min2 = Math.ceil(min2);
  max2 = Math.floor(max2);
  return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
};
function createFilterWrapper(filter2, fn3) {
  function wrapper(...args) {
    filter2(() => fn3.apply(this, args), { fn: fn3, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke2) => {
  return invoke2();
};
function debounceFilter(ms, options = {}) {
  let timer2;
  let maxTimer;
  const filter2 = (invoke2) => {
    const duration = vueDemi.unref(ms);
    const maxDuration = vueDemi.unref(options.maxWait);
    if (timer2)
      clearTimeout(timer2);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke2();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer2)
          clearTimeout(timer2);
        maxTimer = null;
        invoke2();
      }, maxDuration);
    }
    timer2 = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke2();
    }, duration);
  };
  return filter2;
}
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer2;
  let preventLeading = !leading;
  const clear2 = () => {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = void 0;
    }
  };
  const filter2 = (invoke2) => {
    const duration = vueDemi.unref(ms);
    const elapsed = Date.now() - lastExec;
    clear2();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke2();
    }
    if (elapsed > duration) {
      lastExec = Date.now();
      if (preventLeading)
        preventLeading = false;
      else
        invoke2();
    }
    if (trailing) {
      timer2 = setTimeout(() => {
        lastExec = Date.now();
        if (!leading)
          preventLeading = true;
        clear2();
        invoke2();
      }, duration);
    }
    if (!leading && !timer2)
      timer2 = setTimeout(() => preventLeading = true, duration);
  };
  return filter2;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = vueDemi.ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve2, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms);
    else
      setTimeout(resolve2, ms);
  });
}
function identity$3(arg) {
  return arg;
}
function createSingletonPromise(fn3) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn3();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function invoke(fn3) {
  return fn3();
}
function containsProp(obj, ...props2) {
  return props2.some((k) => k in obj);
}
function increaseWithUnit(target2, delta) {
  var _a;
  if (typeof target2 === "number")
    return target2 + delta;
  const value = ((_a = target2.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a[0]) || "";
  const unit = target2.slice(value.length);
  const result3 = parseFloat(value) + delta;
  if (Number.isNaN(result3))
    return target2;
  return result3 + unit;
}
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || !obj[k] === void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}
function useDebounceFn(fn3, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn3);
}
function useDebounce(value, ms = 200, options = {}) {
  if (ms <= 0)
    return value;
  const debounced = vueDemi.ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  vueDemi.watch(value, () => updater());
  return debounced;
}
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source2, exclude) => {
  var target2 = {};
  for (var prop in source2)
    if (__hasOwnProp$9.call(source2, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source2, prop))
        target2[prop] = source2[prop];
    }
  return target2;
};
function watchWithFilter(source2, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$5(_a, [
    "eventFilter"
  ]);
  return vueDemi.watch(source2, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$7 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key2, value) => key2 in obj ? __defProp$7(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$7 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$8.call(b2, prop))
      __defNormalProp$7(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b2)) {
      if (__propIsEnum$8.call(b2, prop))
        __defNormalProp$7(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$4 = (a2, b2) => __defProps$4(a2, __getOwnPropDescs$4(b2));
var __objRest$4 = (source2, exclude) => {
  var target2 = {};
  for (var prop in source2)
    if (__hasOwnProp$8.call(source2, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source2, prop))
        target2[prop] = source2[prop];
    }
  return target2;
};
function debouncedWatch(source2, cb, options = {}) {
  const _a = options, {
    debounce: debounce2 = 0
  } = _a, watchOptions = __objRest$4(_a, [
    "debounce"
  ]);
  return watchWithFilter(source2, cb, __spreadProps$4(__spreadValues$7({}, watchOptions), {
    eventFilter: debounceFilter(debounce2)
  }));
}
function eagerComputed(fn3) {
  const result3 = vueDemi.shallowRef();
  vueDemi.watchSyncEffect(() => {
    result3.value = fn3();
  });
  return vueDemi.readonly(result3);
}
function get(obj, key2) {
  if (key2 == null)
    return vueDemi.unref(obj);
  return vueDemi.unref(obj)[key2];
}
var __defProp$6 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key2, value) => key2 in obj ? __defProp$6(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$6 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$7.call(b2, prop))
      __defNormalProp$6(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b2)) {
      if (__propIsEnum$7.call(b2, prop))
        __defNormalProp$6(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$3 = (a2, b2) => __defProps$3(a2, __getOwnPropDescs$3(b2));
var __objRest$3 = (source2, exclude) => {
  var target2 = {};
  for (var prop in source2)
    if (__hasOwnProp$7.call(source2, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source2, prop))
        target2[prop] = source2[prop];
    }
  return target2;
};
function ignorableWatch(source2, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$3(_a, [
    "eventFilter"
  ]);
  const filteredCb = createFilterWrapper(eventFilter, cb);
  let ignoreUpdates;
  let ignorePrevAsyncUpdates;
  let stop2;
  if (watchOptions.flush === "sync") {
    const ignore = vueDemi.ref(false);
    ignorePrevAsyncUpdates = () => {
    };
    ignoreUpdates = (updater) => {
      ignore.value = true;
      updater();
      ignore.value = false;
    };
    stop2 = vueDemi.watch(source2, (...args) => {
      if (!ignore.value)
        filteredCb(...args);
    }, watchOptions);
  } else {
    const disposables = [];
    const ignoreCounter = vueDemi.ref(0);
    const syncCounter = vueDemi.ref(0);
    ignorePrevAsyncUpdates = () => {
      ignoreCounter.value = syncCounter.value;
    };
    disposables.push(vueDemi.watch(source2, () => {
      syncCounter.value++;
    }, __spreadProps$3(__spreadValues$6({}, watchOptions), { flush: "sync" })));
    ignoreUpdates = (updater) => {
      const syncCounterPrev = syncCounter.value;
      updater();
      ignoreCounter.value += syncCounter.value - syncCounterPrev;
    };
    disposables.push(vueDemi.watch(source2, (...args) => {
      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
      ignoreCounter.value = 0;
      syncCounter.value = 0;
      if (ignore)
        return;
      filteredCb(...args);
    }, watchOptions));
    stop2 = () => {
      disposables.forEach((fn3) => fn3());
    };
  }
  return { stop: stop2, ignoreUpdates, ignorePrevAsyncUpdates };
}
function isDefined(v2) {
  return vueDemi.unref(v2) != null;
}
var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key2, value) => key2 in obj ? __defProp$5(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$5 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$6.call(b2, prop))
      __defNormalProp$5(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b2)) {
      if (__propIsEnum$6.call(b2, prop))
        __defNormalProp$5(a2, prop, b2[prop]);
    }
  return a2;
};
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone = __spreadValues$5({}, obj);
    Object.defineProperty(clone, Symbol.iterator, {
      enumerable: false,
      value() {
        let index2 = 0;
        return {
          next: () => ({
            value: arr[index2++],
            done: index2 > arr.length
          })
        };
      }
    });
    return clone;
  } else {
    return Object.assign([...arr], obj);
  }
}
function not(v2) {
  return vueDemi.computed(() => !vueDemi.unref(v2));
}
function or(...args) {
  return vueDemi.computed(() => args.some((i) => vueDemi.unref(i)));
}
var __defProp$4 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key2, value) => key2 in obj ? __defProp$4(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$4 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$5.call(b2, prop))
      __defNormalProp$4(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b2)) {
      if (__propIsEnum$5.call(b2, prop))
        __defNormalProp$4(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$2 = (a2, b2) => __defProps$2(a2, __getOwnPropDescs$2(b2));
var __objRest$2 = (source2, exclude) => {
  var target2 = {};
  for (var prop in source2)
    if (__hasOwnProp$5.call(source2, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source2, prop))
        target2[prop] = source2[prop];
    }
  return target2;
};
function pausableWatch(source2, cb, options = {}) {
  const _a = options, {
    eventFilter: filter2
  } = _a, watchOptions = __objRest$2(_a, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop2 = watchWithFilter(source2, cb, __spreadProps$2(__spreadValues$4({}, watchOptions), {
    eventFilter
  }));
  return { stop: stop2, pause, resume, isActive };
}
function reactifyObject(obj, optionsOrKeys = {}) {
  let keys2 = [];
  if (Array.isArray(optionsOrKeys)) {
    keys2 = optionsOrKeys;
  } else {
    const { includeOwnProperties = true } = optionsOrKeys;
    keys2.push(...Object.keys(obj));
    if (includeOwnProperties)
      keys2.push(...Object.getOwnPropertyNames(obj));
  }
  return Object.fromEntries(keys2.map((key2) => {
    const value = obj[key2];
    return [
      key2,
      typeof value === "function" ? reactify(value.bind(obj)) : value
    ];
  }));
}
function reactivePick(obj, ...keys2) {
  return vueDemi.reactive(Object.fromEntries(keys2.map((k) => [k, vueDemi.toRef(obj, k)])));
}
function refDefault(source2, defaultValue) {
  return vueDemi.computed({
    get() {
      var _a;
      return (_a = source2.value) != null ? _a : defaultValue;
    },
    set(value) {
      source2.value = value;
    }
  });
}
function set(...args) {
  if (args.length === 2) {
    const [ref2, value] = args;
    ref2.value = value;
  }
  if (args.length === 3) {
    if (vueDemi.isVue2) {
      vueDemi.set(...args);
    } else {
      const [target2, key2, value] = args;
      target2[key2] = value;
    }
  }
}
function syncRef(source2, targets, {
  flush = "sync",
  deep = false,
  immediate = true
} = {}) {
  if (!Array.isArray(targets))
    targets = [targets];
  return vueDemi.watch(source2, (newValue) => targets.forEach((target2) => target2.value = newValue), { flush, deep, immediate });
}
function useThrottleFn(fn3, ms = 200, trailing = true, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn3);
}
function useThrottle(value, delay = 200, trailing = true, leading = true) {
  if (delay <= 0)
    return value;
  const throttled = vueDemi.ref(value.value);
  const updater = useThrottleFn(() => {
    throttled.value = value.value;
  }, delay, trailing, leading);
  vueDemi.watch(value, () => updater());
  return throttled;
}
var __defProp$3 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key2, value) => key2 in obj ? __defProp$3(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$4.call(b2, prop))
      __defNormalProp$3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b2)) {
      if (__propIsEnum$4.call(b2, prop))
        __defNormalProp$3(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$1 = (a2, b2) => __defProps$1(a2, __getOwnPropDescs$1(b2));
var __objRest$1 = (source2, exclude) => {
  var target2 = {};
  for (var prop in source2)
    if (__hasOwnProp$4.call(source2, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source2, prop))
        target2[prop] = source2[prop];
    }
  return target2;
};
function throttledWatch(source2, cb, options = {}) {
  const _a = options, {
    throttle: throttle2 = 0,
    trailing = true,
    leading = true
  } = _a, watchOptions = __objRest$1(_a, [
    "throttle",
    "trailing",
    "leading"
  ]);
  return watchWithFilter(source2, cb, __spreadProps$1(__spreadValues$3({}, watchOptions), {
    eventFilter: throttleFilter(throttle2, trailing, leading)
  }));
}
function toReactive(objectRef) {
  if (!vueDemi.isRef(objectRef))
    return vueDemi.reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_2, p2, receiver) {
      return Reflect.get(objectRef.value, p2, receiver);
    },
    set(_2, p2, value) {
      objectRef.value[p2] = value;
      return true;
    },
    deleteProperty(_2, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(_2, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return vueDemi.reactive(proxy);
}
var __defProp$2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key2, value) => key2 in obj ? __defProp$2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$3.call(b2, prop))
      __defNormalProp$2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b2)) {
      if (__propIsEnum$3.call(b2, prop))
        __defNormalProp$2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
function toRefs(objectRef) {
  if (!vueDemi.isRef(objectRef))
    return vueDemi.toRefs(objectRef);
  const result3 = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};
  for (const key2 in objectRef.value) {
    result3[key2] = vueDemi.customRef(() => ({
      get() {
        return objectRef.value[key2];
      },
      set(v2) {
        if (Array.isArray(objectRef.value)) {
          const copy = [...objectRef.value];
          copy[key2] = v2;
          objectRef.value = copy;
        } else {
          objectRef.value = __spreadProps2(__spreadValues$2({}, objectRef.value), { [key2]: v2 });
        }
      }
    }));
  }
  return result3;
}
function tryOnBeforeUnmount(fn3) {
  if (vueDemi.getCurrentInstance())
    vueDemi.onBeforeUnmount(fn3);
}
function tryOnMounted(fn3, sync = true) {
  if (vueDemi.getCurrentInstance())
    vueDemi.onMounted(fn3);
  else if (sync)
    fn3();
  else
    vueDemi.nextTick(fn3);
}
function tryOnUnmounted(fn3) {
  if (vueDemi.getCurrentInstance())
    vueDemi.onUnmounted(fn3);
}
function until(r) {
  let isNot = false;
  function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
    let stop2 = null;
    const watcher2 = new Promise((resolve2) => {
      stop2 = vueDemi.watch(r, (v2) => {
        if (condition(v2) === !isNot) {
          stop2 == null ? void 0 : stop2();
          resolve2();
        }
      }, {
        flush,
        deep,
        immediate: true
      });
    });
    const promises = [watcher2];
    if (timeout) {
      promises.push(promiseTimeout(timeout, throwOnTimeout).finally(() => {
        stop2 == null ? void 0 : stop2();
      }));
    }
    return Promise.race(promises);
  }
  function toBe(value, options) {
    return toMatch((v2) => v2 === vueDemi.unref(value), options);
  }
  function toBeTruthy(options) {
    return toMatch((v2) => Boolean(v2), options);
  }
  function toBeNull(options) {
    return toBe(null, options);
  }
  function toBeUndefined(options) {
    return toBe(void 0, options);
  }
  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }
  function toContains(value, options) {
    return toMatch((v2) => {
      const array4 = Array.from(v2);
      return array4.includes(value) || array4.includes(vueDemi.unref(value));
    }, options);
  }
  function changed(options) {
    return changedTimes(1, options);
  }
  function changedTimes(n = 1, options) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options);
  }
  if (Array.isArray(vueDemi.unref(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        isNot = !isNot;
        return this;
      }
    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,
      get not() {
        isNot = !isNot;
        return this;
      }
    };
    return instance;
  }
}
function useCounter(initialValue = 0, options = {}) {
  const count = vueDemi.ref(initialValue);
  const {
    max: max2 = Infinity,
    min: min2 = -Infinity
  } = options;
  const inc2 = (delta = 1) => count.value = Math.min(max2, count.value + delta);
  const dec = (delta = 1) => count.value = Math.max(min2, count.value - delta);
  const get3 = () => count.value;
  const set2 = (val) => count.value = val;
  const reset2 = (val = initialValue) => {
    initialValue = val;
    return set2(val);
  };
  return { count, inc: inc2, dec, get: get3, set: set2, reset: reset2 };
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer2 = null;
  const isActive = vueDemi.ref(false);
  function clean() {
    if (timer2) {
      clearInterval(timer2);
      timer2 = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    if (interval <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer2 = setInterval(cb, interval);
  }
  if (immediate && isClient)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key2, value) => key2 in obj ? __defProp$1(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$2.call(b2, prop))
      __defNormalProp$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b2)) {
      if (__propIsEnum$2.call(b2, prop))
        __defNormalProp$1(a2, prop, b2[prop]);
    }
  return a2;
};
function useInterval(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    immediate = true
  } = options;
  const counter = vueDemi.ref(0);
  const controls = useIntervalFn(() => counter.value += 1, interval, { immediate });
  if (exposeControls) {
    return __spreadValues$1({
      counter
    }, controls);
  } else {
    return counter;
  }
}
function useLastChanged(source2, options = {}) {
  var _a;
  const ms = vueDemi.ref((_a = options.initialValue) != null ? _a : null);
  vueDemi.watch(source2, () => ms.value = timestamp(), options);
  return ms;
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = vueDemi.ref(false);
  let timer2 = null;
  function clear2() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  function stop2() {
    isPending.value = false;
    clear2();
  }
  function start2(...args) {
    clear2();
    isPending.value = true;
    timer2 = setTimeout(() => {
      isPending.value = false;
      timer2 = null;
      cb(...args);
    }, vueDemi.unref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop2);
  return {
    isPending,
    start: start2,
    stop: stop2
  };
}
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
function useTimeout$2(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false
  } = options;
  const controls = useTimeoutFn(noop$3, interval, options);
  const ready = vueDemi.computed(() => !controls.isPending.value);
  if (exposeControls) {
    return __spreadValues2({
      ready
    }, controls);
  } else {
    return ready;
  }
}
function useToggle(initialValue = false) {
  if (vueDemi.isRef(initialValue)) {
    return (value) => {
      initialValue.value = typeof value === "boolean" ? value : !initialValue.value;
    };
  } else {
    const boolean = vueDemi.ref(initialValue);
    const toggle = (value) => {
      boolean.value = typeof value === "boolean" ? value : !boolean.value;
    };
    return [boolean, toggle];
  }
}
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __objRest = (source2, exclude) => {
  var target2 = {};
  for (var prop in source2)
    if (__hasOwnProp2.call(source2, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source2, prop))
        target2[prop] = source2[prop];
    }
  return target2;
};
function watchAtMost(source2, cb, options) {
  const _a = options, {
    count
  } = _a, watchOptions = __objRest(_a, [
    "count"
  ]);
  const current2 = vueDemi.ref(0);
  const stop2 = watchWithFilter(source2, (...args) => {
    current2.value += 1;
    if (current2.value >= vueDemi.unref(count))
      stop2();
    cb(...args);
  }, watchOptions);
  return { count: current2, stop: stop2 };
}
function watchOnce(source2, cb, options) {
  const stop2 = vueDemi.watch(source2, (...args) => {
    stop2();
    return cb(...args);
  }, options);
}
function whenever(source2, cb, options) {
  return vueDemi.watch(source2, (v2, ov, onInvalidate) => {
    if (v2)
      cb(v2, ov, onInvalidate);
  }, options);
}
shared$l.and = and;
shared$l.assert = assert;
shared$l.biSyncRef = biSyncRef;
shared$l.bypassFilter = bypassFilter;
shared$l.clamp = clamp;
shared$l.containsProp = containsProp;
shared$l.controlledComputed = controlledComputed;
shared$l.controlledRef = controlledRef;
shared$l.createEventHook = createEventHook;
shared$l.createFilterWrapper = createFilterWrapper;
shared$l.createGlobalState = createGlobalState;
shared$l.createReactiveFn = reactify;
shared$l.createSharedComposable = createSharedComposable;
shared$l.createSingletonPromise = createSingletonPromise;
shared$l.debounceFilter = debounceFilter;
shared$l.debouncedRef = useDebounce;
shared$l.debouncedWatch = debouncedWatch;
shared$l.eagerComputed = eagerComputed;
shared$l.extendRef = extendRef;
shared$l.get = get;
shared$l.identity = identity$3;
shared$l.ignorableWatch = ignorableWatch;
shared$l.increaseWithUnit = increaseWithUnit;
shared$l.invoke = invoke;
shared$l.isBoolean = isBoolean$1;
shared$l.isClient = isClient;
shared$l.isDef = isDef$3;
shared$l.isDefined = isDefined;
shared$l.isFunction = isFunction$2;
shared$l.isNumber = isNumber$2;
shared$l.isObject = isObject$9;
shared$l.isString = isString$2;
shared$l.isWindow = isWindow;
shared$l.makeDestructurable = makeDestructurable;
shared$l.noop = noop$3;
shared$l.not = not;
shared$l.now = now$2;
shared$l.objectPick = objectPick;
shared$l.or = or;
shared$l.pausableFilter = pausableFilter;
shared$l.pausableWatch = pausableWatch;
shared$l.promiseTimeout = promiseTimeout;
shared$l.rand = rand;
shared$l.reactify = reactify;
shared$l.reactifyObject = reactifyObject;
shared$l.reactivePick = reactivePick;
shared$l.refDefault = refDefault;
shared$l.set = set;
shared$l.syncRef = syncRef;
shared$l.throttleFilter = throttleFilter;
shared$l.throttledRef = useThrottle;
shared$l.throttledWatch = throttledWatch;
shared$l.timestamp = timestamp;
shared$l.toReactive = toReactive;
shared$l.toRefs = toRefs;
shared$l.tryOnBeforeUnmount = tryOnBeforeUnmount;
shared$l.tryOnMounted = tryOnMounted;
shared$l.tryOnScopeDispose = tryOnScopeDispose;
shared$l.tryOnUnmounted = tryOnUnmounted;
shared$l.until = until;
shared$l.useCounter = useCounter;
shared$l.useDebounce = useDebounce;
shared$l.useDebounceFn = useDebounceFn;
shared$l.useInterval = useInterval;
shared$l.useIntervalFn = useIntervalFn;
shared$l.useLastChanged = useLastChanged;
shared$l.useThrottle = useThrottle;
shared$l.useThrottleFn = useThrottleFn;
shared$l.useTimeout = useTimeout$2;
shared$l.useTimeoutFn = useTimeoutFn;
shared$l.useToggle = useToggle;
shared$l.watchAtMost = watchAtMost;
shared$l.watchOnce = watchOnce;
shared$l.watchWithFilter = watchWithFilter;
shared$l.whenever = whenever;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var shared2 = shared$l;
  var vueDemi2 = lib$1;
  var core2 = core$7;
  function asyncComputed(evaluationCallback, initialState2, optionsOrRef) {
    let options;
    if (vueDemi2.isRef(optionsOrRef)) {
      options = {
        evaluating: optionsOrRef
      };
    } else {
      options = optionsOrRef || {};
    }
    const {
      lazy = false,
      evaluating = void 0,
      onError = shared2.noop
    } = options;
    const started = vueDemi2.ref(!lazy);
    const current2 = vueDemi2.ref(initialState2);
    let counter = 0;
    vueDemi2.watchEffect(async (onInvalidate) => {
      if (!started.value)
        return;
      counter++;
      const counterAtBeginning = counter;
      let hasFinished = false;
      try {
        if (evaluating) {
          Promise.resolve().then(() => {
            evaluating.value = true;
          });
        }
        const result3 = await evaluationCallback((cancelCallback) => {
          onInvalidate(() => {
            if (evaluating)
              evaluating.value = false;
            if (!hasFinished)
              cancelCallback();
          });
        });
        if (counterAtBeginning === counter)
          current2.value = result3;
      } catch (e) {
        onError(e);
      } finally {
        if (evaluating)
          evaluating.value = false;
        hasFinished = true;
      }
    });
    if (lazy) {
      return vueDemi2.computed(() => {
        started.value = true;
        return current2.value;
      });
    } else {
      return current2;
    }
  }
  function autoResetRef(defaultValue, afterMs = 1e4) {
    return vueDemi2.customRef((track2, trigger2) => {
      let value = defaultValue;
      let timer2;
      const resetAfter = () => setTimeout(() => {
        value = defaultValue;
        trigger2();
      }, vueDemi2.unref(afterMs));
      return {
        get() {
          track2();
          return value;
        },
        set(newValue) {
          value = newValue;
          trigger2();
          clearTimeout(timer2);
          timer2 = resetAfter();
        }
      };
    });
  }
  function computedInject(key2, options, defaultSource, treatDefaultAsFactory) {
    let source2 = vueDemi2.inject(key2);
    if (defaultSource)
      source2 = vueDemi2.inject(key2, defaultSource);
    if (treatDefaultAsFactory)
      source2 = vueDemi2.inject(key2, defaultSource, treatDefaultAsFactory);
    if (typeof options === "function") {
      return vueDemi2.computed((ctx) => options(source2, ctx));
    } else {
      return vueDemi2.computed({
        get: (ctx) => options.get(source2, ctx),
        set: options.set
      });
    }
  }
  const createUnrefFn = (fn3) => {
    return function(...args) {
      return fn3.apply(this, args.map((i) => vueDemi2.unref(i)));
    };
  };
  function unrefElement(elRef) {
    var _a2;
    const plain = vueDemi2.unref(elRef);
    return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
  }
  const defaultWindow = shared2.isClient ? window : void 0;
  const defaultDocument = shared2.isClient ? window.document : void 0;
  const defaultNavigator = shared2.isClient ? window.navigator : void 0;
  const defaultLocation = shared2.isClient ? window.location : void 0;
  function useEventListener(...args) {
    let target2;
    let event;
    let listener;
    let options;
    if (shared2.isString(args[0])) {
      [event, listener, options] = args;
      target2 = defaultWindow;
    } else {
      [target2, event, listener, options] = args;
    }
    if (!target2)
      return shared2.noop;
    let cleanup = shared2.noop;
    const stopWatch = vueDemi2.watch(() => vueDemi2.unref(target2), (el) => {
      cleanup();
      if (!el)
        return;
      el.addEventListener(event, listener, options);
      cleanup = () => {
        el.removeEventListener(event, listener, options);
        cleanup = shared2.noop;
      };
    }, { immediate: true, flush: "post" });
    const stop2 = () => {
      stopWatch();
      cleanup();
    };
    shared2.tryOnScopeDispose(stop2);
    return stop2;
  }
  function onClickOutside(target2, handler, options = {}) {
    const { window: window2 = defaultWindow } = options;
    if (!window2)
      return;
    const shouldListen = vueDemi2.ref(true);
    const listener = (event) => {
      const el = unrefElement(target2);
      if (!el || el === event.target || event.composedPath().includes(el) || !shouldListen.value)
        return;
      handler(event);
    };
    const cleanup = [
      useEventListener(window2, "click", listener, { passive: true, capture: true }),
      useEventListener(window2, "pointerdown", (e) => {
        const el = unrefElement(target2);
        shouldListen.value = !!el && !e.composedPath().includes(el);
      }, { passive: true })
    ];
    const stop2 = () => cleanup.forEach((fn3) => fn3());
    return stop2;
  }
  var __defProp$g = Object.defineProperty;
  var __defProps$8 = Object.defineProperties;
  var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
  var __hasOwnProp$i = Object.prototype.hasOwnProperty;
  var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$g = (obj, key2, value) => key2 in obj ? __defProp$g(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$g = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$i.call(b2, prop))
        __defNormalProp$g(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$i)
      for (var prop of __getOwnPropSymbols$i(b2)) {
        if (__propIsEnum$i.call(b2, prop))
          __defNormalProp$g(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps$8 = (a2, b2) => __defProps$8(a2, __getOwnPropDescs$8(b2));
  const createKeyPredicate = (keyFilter) => {
    if (typeof keyFilter === "function")
      return keyFilter;
    else if (typeof keyFilter === "string")
      return (event) => event.key === keyFilter;
    else if (Array.isArray(keyFilter))
      return (event) => keyFilter.includes(event.key);
    else if (keyFilter)
      return () => true;
    else
      return () => false;
  };
  function onKeyStroke(key2, handler, options = {}) {
    const { target: target2 = defaultWindow, eventName = "keydown", passive: passive2 = false } = options;
    const predicate = createKeyPredicate(key2);
    const listener = (e) => {
      if (predicate(e))
        handler(e);
    };
    return useEventListener(target2, eventName, listener, passive2);
  }
  function onKeyDown(key2, handler, options = {}) {
    return onKeyStroke(key2, handler, __spreadProps$8(__spreadValues$g({}, options), { eventName: "keydown" }));
  }
  function onKeyPressed(key2, handler, options = {}) {
    return onKeyStroke(key2, handler, __spreadProps$8(__spreadValues$g({}, options), { eventName: "keypress" }));
  }
  function onKeyUp(key2, handler, options = {}) {
    return onKeyStroke(key2, handler, __spreadProps$8(__spreadValues$g({}, options), { eventName: "keyup" }));
  }
  const isFocusedElementEditable = () => {
    const { activeElement, body } = document;
    if (!activeElement)
      return false;
    if (activeElement === body)
      return false;
    switch (activeElement.tagName) {
      case "INPUT":
      case "TEXTAREA":
        return true;
    }
    return activeElement.hasAttribute("contenteditable");
  };
  const isTypedCharValid = ({
    keyCode,
    metaKey,
    ctrlKey,
    altKey
  }) => {
    if (metaKey || ctrlKey || altKey)
      return false;
    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)
      return true;
    if (keyCode >= 65 && keyCode <= 90)
      return true;
    return false;
  };
  function onStartTyping(callback, options = {}) {
    const { document: document2 = defaultDocument } = options;
    const keydown = (event) => {
      !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);
    };
    if (document2)
      useEventListener(document2, "keydown", keydown, { passive: true });
  }
  function templateRef(key2, initialValue = null) {
    const instance = vueDemi2.getCurrentInstance();
    let _trigger = () => {
    };
    const element = vueDemi2.customRef((track2, trigger2) => {
      _trigger = trigger2;
      return {
        get() {
          var _a2, _b2;
          track2();
          return (_b2 = (_a2 = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a2.$refs[key2]) != null ? _b2 : initialValue;
        },
        set() {
        }
      };
    });
    vueDemi2.onMounted(_trigger);
    vueDemi2.onUpdated(_trigger);
    return element;
  }
  function useActiveElement(options = {}) {
    const { window: window2 = defaultWindow } = options;
    const counter = vueDemi2.ref(0);
    if (window2) {
      useEventListener(window2, "blur", () => counter.value += 1, true);
      useEventListener(window2, "focus", () => counter.value += 1, true);
    }
    return vueDemi2.computed(() => {
      counter.value;
      return window2 == null ? void 0 : window2.document.activeElement;
    });
  }
  function useAsyncQueue(tasks, options = {}) {
    const {
      interrupt = true,
      onError = shared2.noop,
      onFinished = shared2.noop
    } = options;
    const promiseState = {
      pending: "pending",
      rejected: "rejected",
      fulfilled: "fulfilled"
    };
    const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));
    const result3 = vueDemi2.reactive(initialResult);
    const activeIndex = vueDemi2.ref(-1);
    if (!tasks || tasks.length === 0) {
      onFinished();
      return {
        activeIndex,
        result: result3
      };
    }
    function updateResult(state, res) {
      activeIndex.value++;
      result3[activeIndex.value].data = res;
      result3[activeIndex.value].state = state;
    }
    tasks.reduce((prev2, curr) => {
      return prev2.then((prevRes) => {
        var _a2;
        if (((_a2 = result3[activeIndex.value]) == null ? void 0 : _a2.state) === promiseState.rejected && interrupt) {
          onFinished();
          return;
        }
        return curr(prevRes).then((currentRes) => {
          updateResult(promiseState.fulfilled, currentRes);
          activeIndex.value === tasks.length - 1 && onFinished();
          return currentRes;
        });
      }).catch((e) => {
        updateResult(promiseState.rejected, e);
        onError();
        return e;
      });
    }, Promise.resolve());
    return {
      activeIndex,
      result: result3
    };
  }
  function useAsyncState(promise, initialState2, options = {}) {
    const {
      immediate = true,
      delay = 0,
      onError = shared2.noop,
      resetOnExecute = true,
      shallow = true
    } = options;
    const state = shallow ? vueDemi2.shallowRef(initialState2) : vueDemi2.ref(initialState2);
    const isReady = vueDemi2.ref(false);
    const error2 = vueDemi2.ref(void 0);
    async function execute(delay2 = 0, ...args) {
      if (resetOnExecute)
        state.value = initialState2;
      error2.value = void 0;
      isReady.value = false;
      if (delay2 > 0)
        await shared2.promiseTimeout(delay2);
      const _promise = typeof promise === "function" ? promise(...args) : promise;
      try {
        const data2 = await _promise;
        state.value = data2;
        isReady.value = true;
      } catch (e) {
        error2.value = e;
        onError(e);
      }
      return state.value;
    }
    if (immediate)
      execute(delay);
    return {
      state,
      isReady,
      error: error2,
      execute
    };
  }
  function useBase64(target2, options) {
    const base64 = vueDemi2.ref("");
    const promise = vueDemi2.ref();
    function execute() {
      if (!shared2.isClient)
        return;
      promise.value = new Promise((resolve2, reject) => {
        try {
          const _target = vueDemi2.unref(target2);
          if (_target === void 0 || _target === null) {
            resolve2("");
          } else if (typeof _target === "string") {
            resolve2(blobToBase64(new Blob([_target], { type: "text/plain" })));
          } else if (_target instanceof Blob) {
            resolve2(blobToBase64(_target));
          } else if (_target instanceof ArrayBuffer) {
            resolve2(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
          } else if (_target instanceof HTMLCanvasElement) {
            resolve2(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
          } else if (_target instanceof HTMLImageElement) {
            const img2 = _target.cloneNode(false);
            img2.crossOrigin = "Anonymous";
            imgLoaded(img2).then(() => {
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");
              canvas.width = img2.width;
              canvas.height = img2.height;
              ctx.drawImage(img2, 0, 0, canvas.width, canvas.height);
              resolve2(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
            }).catch(reject);
          } else {
            reject(new Error("target is unsupported types"));
          }
        } catch (error2) {
          reject(error2);
        }
      });
      promise.value.then((res) => base64.value = res);
      return promise.value;
    }
    vueDemi2.watch(target2, execute, { immediate: true });
    return {
      base64,
      promise,
      execute
    };
  }
  function imgLoaded(img2) {
    return new Promise((resolve2, reject) => {
      if (!img2.complete) {
        img2.onload = () => {
          resolve2();
        };
        img2.onerror = reject;
      } else {
        resolve2();
      }
    });
  }
  function blobToBase64(blob) {
    return new Promise((resolve2, reject) => {
      const fr = new FileReader();
      fr.onload = (e) => {
        resolve2(e.target.result);
      };
      fr.onerror = reject;
      fr.readAsDataURL(blob);
    });
  }
  function useBattery({ navigator: navigator2 = defaultNavigator } = {}) {
    const events2 = ["chargingchange", "chargingtimechange", "dischargingtimechange", "levelchange"];
    const isSupported = navigator2 && "getBattery" in navigator2;
    const charging = vueDemi2.ref(false);
    const chargingTime = vueDemi2.ref(0);
    const dischargingTime = vueDemi2.ref(0);
    const level = vueDemi2.ref(1);
    let battery;
    function updateBatteryInfo() {
      charging.value = this.charging;
      chargingTime.value = this.chargingTime || 0;
      dischargingTime.value = this.dischargingTime || 0;
      level.value = this.level;
    }
    if (isSupported) {
      navigator2.getBattery().then((_battery) => {
        battery = _battery;
        updateBatteryInfo.call(battery);
        for (const event of events2)
          useEventListener(battery, event, updateBatteryInfo, { passive: true });
      });
    }
    return {
      isSupported,
      charging,
      chargingTime,
      dischargingTime,
      level
    };
  }
  function useMediaQuery(query, options = {}) {
    const { window: window2 = defaultWindow } = options;
    let mediaQuery;
    const matches2 = vueDemi2.ref(false);
    const update3 = () => {
      if (!window2)
        return;
      if (!mediaQuery)
        mediaQuery = window2.matchMedia(query);
      matches2.value = mediaQuery.matches;
    };
    shared2.tryOnMounted(() => {
      update3();
      if (!mediaQuery)
        return;
      if ("addEventListener" in mediaQuery)
        mediaQuery.addEventListener("change", update3);
      else
        mediaQuery.addListener(update3);
      shared2.tryOnScopeDispose(() => {
        if ("removeEventListener" in update3)
          mediaQuery.removeEventListener("change", update3);
        else
          mediaQuery.removeListener(update3);
      });
    });
    return matches2;
  }
  const breakpointsTailwind = {
    "sm": 640,
    "md": 768,
    "lg": 1024,
    "xl": 1280,
    "2xl": 1536
  };
  const breakpointsBootstrapV5 = {
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    xxl: 1400
  };
  const breakpointsVuetify = {
    xs: 600,
    sm: 960,
    md: 1264,
    lg: 1904
  };
  const breakpointsAntDesign = {
    xs: 480,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    xxl: 1600
  };
  const breakpointsQuasar = {
    xs: 600,
    sm: 1024,
    md: 1440,
    lg: 1920
  };
  const breakpointsSematic = {
    mobileS: 320,
    mobileM: 375,
    mobileL: 425,
    tablet: 768,
    laptop: 1024,
    laptopL: 1440,
    desktop4K: 2560
  };
  var __defProp$f = Object.defineProperty;
  var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
  var __hasOwnProp$h = Object.prototype.hasOwnProperty;
  var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$f = (obj, key2, value) => key2 in obj ? __defProp$f(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$f = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$h.call(b2, prop))
        __defNormalProp$f(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$h)
      for (var prop of __getOwnPropSymbols$h(b2)) {
        if (__propIsEnum$h.call(b2, prop))
          __defNormalProp$f(a2, prop, b2[prop]);
      }
    return a2;
  };
  function useBreakpoints(breakpoints, options = {}) {
    function getValue3(k, delta) {
      let v2 = breakpoints[k];
      if (delta != null)
        v2 = shared2.increaseWithUnit(v2, delta);
      if (typeof v2 === "number")
        v2 = `${v2}px`;
      return v2;
    }
    const { window: window2 = defaultWindow } = options;
    function match(query) {
      if (!window2)
        return false;
      return window2.matchMedia(query).matches;
    }
    const greater = (k) => {
      return useMediaQuery(`(min-width: ${getValue3(k)})`, options);
    };
    const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
      Object.defineProperty(shortcuts, k, {
        get: () => greater(k),
        enumerable: true,
        configurable: true
      });
      return shortcuts;
    }, {});
    return __spreadValues$f({
      greater,
      smaller(k) {
        return useMediaQuery(`(max-width: ${getValue3(k, -0.1)})`, options);
      },
      between(a2, b2) {
        return useMediaQuery(`(min-width: ${getValue3(a2)}) and (max-width: ${getValue3(b2, -0.1)})`, options);
      },
      isGreater(k) {
        return match(`(min-width: ${getValue3(k)})`);
      },
      isSmaller(k) {
        return match(`(max-width: ${getValue3(k, -0.1)})`);
      },
      isInBetween(a2, b2) {
        return match(`(min-width: ${getValue3(a2)}) and (max-width: ${getValue3(b2, -0.1)})`);
      }
    }, shortcutMethods);
  }
  function useBrowserLocation({ window: window2 = defaultWindow } = {}) {
    const buildState2 = (trigger2) => {
      const { state: state2, length } = (window2 == null ? void 0 : window2.history) || {};
      const { hash: hash2, host, hostname, href, origin, pathname, port, protocol, search: search2 } = (window2 == null ? void 0 : window2.location) || {};
      return {
        trigger: trigger2,
        state: state2,
        length,
        hash: hash2,
        host,
        hostname,
        href,
        origin,
        pathname,
        port,
        protocol,
        search: search2
      };
    };
    const state = vueDemi2.ref(buildState2("load"));
    if (window2) {
      useEventListener(window2, "popstate", () => state.value = buildState2("popstate"), { passive: true });
      useEventListener(window2, "hashchange", () => state.value = buildState2("hashchange"), { passive: true });
    }
    return state;
  }
  function useClamp(value, min2, max2) {
    const _value = vueDemi2.ref(value);
    return vueDemi2.computed({
      get() {
        return shared2.clamp(_value.value, vueDemi2.unref(min2), vueDemi2.unref(max2));
      },
      set(value2) {
        _value.value = shared2.clamp(value2, vueDemi2.unref(min2), vueDemi2.unref(max2));
      }
    });
  }
  function useClipboard(options = {}) {
    const {
      navigator: navigator2 = defaultNavigator,
      read: read2 = false,
      source: source2,
      copiedDuring = 1500
    } = options;
    const events2 = ["copy", "cut"];
    const isSupported = Boolean(navigator2 && "clipboard" in navigator2);
    const text = vueDemi2.ref("");
    const copied = vueDemi2.ref(false);
    const timeout = shared2.useTimeoutFn(() => copied.value = false, copiedDuring);
    function updateText() {
      navigator2.clipboard.readText().then((value) => {
        text.value = value;
      });
    }
    if (isSupported && read2) {
      for (const event of events2)
        useEventListener(event, updateText);
    }
    async function copy(value = vueDemi2.unref(source2)) {
      if (isSupported && value != null) {
        await navigator2.clipboard.writeText(value);
        text.value = value;
        copied.value = true;
        timeout.start();
      }
    }
    return {
      isSupported,
      text,
      copied,
      copy
    };
  }
  function guessSerializerType(rawInit) {
    return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
  }
  const StorageSerializers = {
    boolean: {
      read: (v2) => v2 === "true",
      write: (v2) => String(v2)
    },
    object: {
      read: (v2) => JSON.parse(v2),
      write: (v2) => JSON.stringify(v2)
    },
    number: {
      read: (v2) => Number.parseFloat(v2),
      write: (v2) => String(v2)
    },
    any: {
      read: (v2) => v2,
      write: (v2) => String(v2)
    },
    string: {
      read: (v2) => v2,
      write: (v2) => String(v2)
    },
    map: {
      read: (v2) => new Map(JSON.parse(v2)),
      write: (v2) => JSON.stringify(Array.from(v2.entries()))
    },
    set: {
      read: (v2) => new Set(JSON.parse(v2)),
      write: (v2) => JSON.stringify(Array.from(v2.entries()))
    }
  };
  function useStorage(key2, initialValue, storage = ((_a2) => (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage)(), options = {}) {
    var _a2;
    const {
      flush = "pre",
      deep = true,
      listenToStorageChanges = true,
      writeDefaults = true,
      shallow,
      window: window2 = defaultWindow,
      eventFilter,
      onError = (e) => {
        console.error(e);
      }
    } = options;
    const rawInit = vueDemi2.unref(initialValue);
    const type4 = guessSerializerType(rawInit);
    const data2 = (shallow ? vueDemi2.shallowRef : vueDemi2.ref)(initialValue);
    const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type4];
    function read2(event) {
      if (!storage || event && event.key !== key2)
        return;
      try {
        const rawValue = event ? event.newValue : storage.getItem(key2);
        if (rawValue == null) {
          data2.value = rawInit;
          if (writeDefaults && rawInit !== null)
            storage.setItem(key2, serializer.write(rawInit));
        } else {
          data2.value = serializer.read(rawValue);
        }
      } catch (e) {
        onError(e);
      }
    }
    read2();
    if (window2 && listenToStorageChanges)
      useEventListener(window2, "storage", (e) => setTimeout(() => read2(e), 0));
    if (storage) {
      shared2.watchWithFilter(data2, () => {
        try {
          if (data2.value == null)
            storage.removeItem(key2);
          else
            storage.setItem(key2, serializer.write(data2.value));
        } catch (e) {
          onError(e);
        }
      }, {
        flush,
        deep,
        eventFilter
      });
    }
    return data2;
  }
  function usePreferredDark(options) {
    return useMediaQuery("(prefers-color-scheme: dark)", options);
  }
  var __defProp$e = Object.defineProperty;
  var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
  var __hasOwnProp$g = Object.prototype.hasOwnProperty;
  var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$e = (obj, key2, value) => key2 in obj ? __defProp$e(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$e = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$g.call(b2, prop))
        __defNormalProp$e(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$g)
      for (var prop of __getOwnPropSymbols$g(b2)) {
        if (__propIsEnum$g.call(b2, prop))
          __defNormalProp$e(a2, prop, b2[prop]);
      }
    return a2;
  };
  function useColorMode(options = {}) {
    var _a2;
    const {
      selector = "html",
      attribute = "class",
      window: window2 = defaultWindow,
      storage = (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage,
      storageKey = "vueuse-color-scheme",
      listenToStorageChanges = true,
      storageRef
    } = options;
    const modes = __spreadValues$e({
      auto: "",
      light: "light",
      dark: "dark"
    }, options.modes || {});
    const preferredDark = usePreferredDark({ window: window2 });
    const preferredMode = vueDemi2.computed(() => preferredDark.value ? "dark" : "light");
    const store2 = storageRef || (storageKey == null ? vueDemi2.ref("auto") : useStorage(storageKey, "auto", storage, { window: window2, listenToStorageChanges }));
    const state = vueDemi2.computed({
      get() {
        return store2.value === "auto" ? preferredMode.value : store2.value;
      },
      set(v2) {
        store2.value = v2;
      }
    });
    function defaultOnChanged(value) {
      const el = window2 == null ? void 0 : window2.document.querySelector(selector);
      if (!el)
        return;
      if (attribute === "class") {
        const current2 = (modes[value] || "").split(/\s/g);
        Object.values(modes).flatMap((i) => (i || "").split(/\s/g)).filter(Boolean).forEach((v2) => {
          if (current2.includes(v2))
            el.classList.add(v2);
          else
            el.classList.remove(v2);
        });
      } else {
        el.setAttribute(attribute, value);
      }
    }
    function onChanged(mode) {
      if (options.onChanged)
        options.onChanged(mode, defaultOnChanged);
      else
        defaultOnChanged(mode);
    }
    vueDemi2.watch(state, onChanged, { flush: "post" });
    shared2.tryOnMounted(() => onChanged(state.value));
    return state;
  }
  function useConfirmDialog(revealed = vueDemi2.ref(false)) {
    const confirmHook = shared2.createEventHook();
    const cancelHook = shared2.createEventHook();
    const revealHook = shared2.createEventHook();
    let _resolve = shared2.noop;
    const reveal = (data2) => {
      revealHook.trigger(data2);
      revealed.value = true;
      return new Promise((resolve2) => {
        _resolve = resolve2;
      });
    };
    const confirm = (data2) => {
      revealed.value = false;
      confirmHook.trigger(data2);
      _resolve({ data: data2, isCanceled: false });
    };
    const cancel = (data2) => {
      revealed.value = false;
      cancelHook.trigger(data2);
      _resolve({ data: data2, isCanceled: true });
    };
    return {
      isRevealed: vueDemi2.computed(() => revealed.value),
      reveal,
      confirm,
      cancel,
      onReveal: revealHook.on,
      onConfirm: confirmHook.on,
      onCancel: cancelHook.on
    };
  }
  function useCssVar(prop, target2, { window: window2 = defaultWindow } = {}) {
    const variable = vueDemi2.ref("");
    const elRef = vueDemi2.computed(() => {
      var _a2;
      return unrefElement(target2) || ((_a2 = window2 == null ? void 0 : window2.document) == null ? void 0 : _a2.documentElement);
    });
    vueDemi2.watch(elRef, (el) => {
      if (el && window2)
        variable.value = window2.getComputedStyle(el).getPropertyValue(prop);
    }, { immediate: true });
    vueDemi2.watch(variable, (val) => {
      var _a2;
      if ((_a2 = elRef.value) == null ? void 0 : _a2.style)
        elRef.value.style.setProperty(prop, val);
    });
    return variable;
  }
  function useCycleList(list2, options) {
    const state = vueDemi2.shallowRef((options == null ? void 0 : options.initialValue) || list2[0]);
    const index2 = vueDemi2.computed({
      get() {
        var _a2;
        let index22 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list2) : list2.indexOf(state.value);
        if (index22 < 0)
          index22 = (_a2 = options == null ? void 0 : options.fallbackIndex) != null ? _a2 : 0;
        return index22;
      },
      set(v2) {
        set2(v2);
      }
    });
    function set2(i) {
      const length = list2.length;
      const index22 = i % length + length % length;
      const value = list2[index22];
      state.value = value;
      return value;
    }
    function shift(delta = 1) {
      return set2(index2.value + delta);
    }
    function next2(n = 1) {
      return shift(n);
    }
    function prev2(n = 1) {
      return shift(-n);
    }
    return {
      state,
      index: index2,
      next: next2,
      prev: prev2
    };
  }
  var __defProp$d = Object.defineProperty;
  var __defProps$7 = Object.defineProperties;
  var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
  var __hasOwnProp$f = Object.prototype.hasOwnProperty;
  var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$d = (obj, key2, value) => key2 in obj ? __defProp$d(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$d = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$f.call(b2, prop))
        __defNormalProp$d(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$f)
      for (var prop of __getOwnPropSymbols$f(b2)) {
        if (__propIsEnum$f.call(b2, prop))
          __defNormalProp$d(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps$7 = (a2, b2) => __defProps$7(a2, __getOwnPropDescs$7(b2));
  function useDark(options = {}) {
    const {
      valueDark = "dark",
      valueLight = "",
      window: window2 = defaultWindow
    } = options;
    const mode = useColorMode(__spreadProps$7(__spreadValues$d({}, options), {
      onChanged: (mode2, defaultHandler) => {
        var _a2;
        if (options.onChanged)
          (_a2 = options.onChanged) == null ? void 0 : _a2.call(options, mode2 === "dark");
        else
          defaultHandler(mode2);
      },
      modes: {
        dark: valueDark,
        light: valueLight
      }
    }));
    const preferredDark = usePreferredDark({ window: window2 });
    const isDark = vueDemi2.computed({
      get() {
        return mode.value === "dark";
      },
      set(v2) {
        if (v2 === preferredDark.value)
          mode.value = "auto";
        else
          mode.value = v2 ? "dark" : "light";
      }
    });
    return isDark;
  }
  const fnClone = (v2) => JSON.parse(JSON.stringify(v2));
  const fnBypass = (v2) => v2;
  const fnSetSource = (source2, value) => source2.value = value;
  function defaultDump(clone) {
    return clone ? shared2.isFunction(clone) ? clone : fnClone : fnBypass;
  }
  function defaultParse(clone) {
    return clone ? shared2.isFunction(clone) ? clone : fnClone : fnBypass;
  }
  function useManualRefHistory(source2, options = {}) {
    const {
      clone = false,
      dump = defaultDump(clone),
      parse: parse2 = defaultParse(clone),
      setSource = fnSetSource
    } = options;
    function _createHistoryRecord() {
      return vueDemi2.markRaw({
        snapshot: dump(source2.value),
        timestamp: shared2.timestamp()
      });
    }
    const last = vueDemi2.ref(_createHistoryRecord());
    const undoStack = vueDemi2.ref([]);
    const redoStack = vueDemi2.ref([]);
    const _setSource = (record) => {
      setSource(source2, parse2(record.snapshot));
      last.value = record;
    };
    const commit2 = () => {
      undoStack.value.unshift(last.value);
      last.value = _createHistoryRecord();
      if (options.capacity && undoStack.value.length > options.capacity)
        undoStack.value.splice(options.capacity, Infinity);
      if (redoStack.value.length)
        redoStack.value.splice(0, redoStack.value.length);
    };
    const clear2 = () => {
      undoStack.value.splice(0, undoStack.value.length);
      redoStack.value.splice(0, redoStack.value.length);
    };
    const undo = () => {
      const state = undoStack.value.shift();
      if (state) {
        redoStack.value.unshift(last.value);
        _setSource(state);
      }
    };
    const redo = () => {
      const state = redoStack.value.shift();
      if (state) {
        undoStack.value.unshift(last.value);
        _setSource(state);
      }
    };
    const reset2 = () => {
      _setSource(last.value);
    };
    const history2 = vueDemi2.computed(() => [last.value, ...undoStack.value]);
    const canUndo = vueDemi2.computed(() => undoStack.value.length > 0);
    const canRedo = vueDemi2.computed(() => redoStack.value.length > 0);
    return {
      source: source2,
      undoStack,
      redoStack,
      last,
      history: history2,
      canUndo,
      canRedo,
      clear: clear2,
      commit: commit2,
      reset: reset2,
      undo,
      redo
    };
  }
  var __defProp$c = Object.defineProperty;
  var __defProps$6 = Object.defineProperties;
  var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
  var __hasOwnProp$e = Object.prototype.hasOwnProperty;
  var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$c = (obj, key2, value) => key2 in obj ? __defProp$c(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$c = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$e.call(b2, prop))
        __defNormalProp$c(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$e)
      for (var prop of __getOwnPropSymbols$e(b2)) {
        if (__propIsEnum$e.call(b2, prop))
          __defNormalProp$c(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps$6 = (a2, b2) => __defProps$6(a2, __getOwnPropDescs$6(b2));
  function useRefHistory(source2, options = {}) {
    const {
      deep = false,
      flush = "pre",
      eventFilter
    } = options;
    const {
      eventFilter: composedFilter,
      pause,
      resume: resumeTracking,
      isActive: isTracking2
    } = shared2.pausableFilter(eventFilter);
    const {
      ignoreUpdates,
      ignorePrevAsyncUpdates,
      stop: stop2
    } = shared2.ignorableWatch(source2, commit2, { deep, flush, eventFilter: composedFilter });
    function setSource(source22, value) {
      ignorePrevAsyncUpdates();
      ignoreUpdates(() => {
        source22.value = value;
      });
    }
    const manualHistory = useManualRefHistory(source2, __spreadProps$6(__spreadValues$c({}, options), { clone: options.clone || deep, setSource }));
    const { clear: clear2, commit: manualCommit } = manualHistory;
    function commit2() {
      ignorePrevAsyncUpdates();
      manualCommit();
    }
    function resume(commitNow) {
      resumeTracking();
      if (commitNow)
        commit2();
    }
    function batch(fn3) {
      let canceled = false;
      const cancel = () => canceled = true;
      ignoreUpdates(() => {
        fn3(cancel);
      });
      if (!canceled)
        commit2();
    }
    function dispose() {
      stop2();
      clear2();
    }
    return __spreadProps$6(__spreadValues$c({}, manualHistory), {
      isTracking: isTracking2,
      pause,
      resume,
      commit: commit2,
      batch,
      dispose
    });
  }
  var __defProp$b = Object.defineProperty;
  var __defProps$5 = Object.defineProperties;
  var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
  var __hasOwnProp$d = Object.prototype.hasOwnProperty;
  var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$b = (obj, key2, value) => key2 in obj ? __defProp$b(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$b = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$d.call(b2, prop))
        __defNormalProp$b(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$d)
      for (var prop of __getOwnPropSymbols$d(b2)) {
        if (__propIsEnum$d.call(b2, prop))
          __defNormalProp$b(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps$5 = (a2, b2) => __defProps$5(a2, __getOwnPropDescs$5(b2));
  function useDebouncedRefHistory(source2, options = {}) {
    const filter2 = options.debounce ? shared2.debounceFilter(options.debounce) : void 0;
    const history2 = useRefHistory(source2, __spreadProps$5(__spreadValues$b({}, options), { eventFilter: filter2 }));
    return __spreadValues$b({}, history2);
  }
  function useDeviceMotion(options = {}) {
    const {
      window: window2 = defaultWindow,
      eventFilter = shared2.bypassFilter
    } = options;
    const acceleration = vueDemi2.ref({ x: null, y: null, z: null });
    const rotationRate = vueDemi2.ref({ alpha: null, beta: null, gamma: null });
    const interval = vueDemi2.ref(0);
    const accelerationIncludingGravity = vueDemi2.ref({
      x: null,
      y: null,
      z: null
    });
    if (window2) {
      const onDeviceMotion = shared2.createFilterWrapper(eventFilter, (event) => {
        acceleration.value = event.acceleration;
        accelerationIncludingGravity.value = event.accelerationIncludingGravity;
        rotationRate.value = event.rotationRate;
        interval.value = event.interval;
      });
      useEventListener(window2, "devicemotion", onDeviceMotion);
    }
    return {
      acceleration,
      accelerationIncludingGravity,
      rotationRate,
      interval
    };
  }
  function useDeviceOrientation(options = {}) {
    const { window: window2 = defaultWindow } = options;
    const isSupported = Boolean(window2 && "DeviceOrientationEvent" in window2);
    const isAbsolute = vueDemi2.ref(false);
    const alpha = vueDemi2.ref(null);
    const beta = vueDemi2.ref(null);
    const gamma = vueDemi2.ref(null);
    if (window2 && isSupported) {
      useEventListener(window2, "deviceorientation", (event) => {
        isAbsolute.value = event.absolute;
        alpha.value = event.alpha;
        beta.value = event.beta;
        gamma.value = event.gamma;
      });
    }
    return {
      isSupported,
      isAbsolute,
      alpha,
      beta,
      gamma
    };
  }
  const DEVICE_PIXEL_RATIO_SCALES = [
    1,
    1.325,
    1.4,
    1.5,
    1.8,
    2,
    2.4,
    2.5,
    2.75,
    3,
    3.5,
    4
  ];
  function useDevicePixelRatio({
    window: window2 = defaultWindow
  } = {}) {
    if (!window2) {
      return {
        pixelRatio: vueDemi2.ref(1)
      };
    }
    const pixelRatio = vueDemi2.ref(window2.devicePixelRatio);
    const handleDevicePixelRatio = () => {
      pixelRatio.value = window2.devicePixelRatio;
    };
    useEventListener(window2, "resize", handleDevicePixelRatio, { passive: true });
    DEVICE_PIXEL_RATIO_SCALES.forEach((dppx) => {
      const mqlMin = useMediaQuery(`screen and (min-resolution: ${dppx}dppx)`);
      const mqlMax = useMediaQuery(`screen and (max-resolution: ${dppx}dppx)`);
      vueDemi2.watch([mqlMin, mqlMax], handleDevicePixelRatio);
    });
    return { pixelRatio };
  }
  function usePermission(permissionDesc, options = {}) {
    const {
      controls = false,
      navigator: navigator2 = defaultNavigator
    } = options;
    const isSupported = Boolean(navigator2 && "permissions" in navigator2);
    let permissionStatus;
    const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
    const state = vueDemi2.ref();
    const onChange = () => {
      if (permissionStatus)
        state.value = permissionStatus.state;
    };
    const query = shared2.createSingletonPromise(async () => {
      if (!isSupported)
        return;
      if (!permissionStatus) {
        try {
          permissionStatus = await navigator2.permissions.query(desc);
          useEventListener(permissionStatus, "change", onChange);
          onChange();
        } catch (e) {
          state.value = "prompt";
        }
      }
      return permissionStatus;
    });
    query();
    if (controls) {
      return {
        state,
        isSupported,
        query
      };
    } else {
      return state;
    }
  }
  function useDevicesList(options = {}) {
    const {
      navigator: navigator2 = defaultNavigator,
      requestPermissions = false,
      constraints = { audio: true, video: true },
      onUpdated: onUpdated2
    } = options;
    const devices = vueDemi2.ref([]);
    const videoInputs = vueDemi2.computed(() => devices.value.filter((i) => i.kind === "videoinput"));
    const audioInputs = vueDemi2.computed(() => devices.value.filter((i) => i.kind === "audioinput"));
    const audioOutputs = vueDemi2.computed(() => devices.value.filter((i) => i.kind === "audiooutput"));
    let isSupported = false;
    const permissionGranted = vueDemi2.ref(false);
    async function update3() {
      if (!isSupported)
        return;
      devices.value = await navigator2.mediaDevices.enumerateDevices();
      onUpdated2 == null ? void 0 : onUpdated2(devices.value);
    }
    async function ensurePermissions() {
      if (!isSupported)
        return false;
      if (permissionGranted.value)
        return true;
      const { state, query } = usePermission("camera", { controls: true });
      await query();
      if (state.value !== "granted") {
        const stream = await navigator2.mediaDevices.getUserMedia(constraints);
        stream.getTracks().forEach((t) => t.stop());
        update3();
        permissionGranted.value = true;
      } else {
        permissionGranted.value = true;
      }
      return permissionGranted.value;
    }
    if (navigator2) {
      isSupported = Boolean(navigator2.mediaDevices && navigator2.mediaDevices.enumerateDevices);
      if (isSupported) {
        if (requestPermissions)
          ensurePermissions();
        useEventListener(navigator2.mediaDevices, "devicechange", update3);
        update3();
      }
    }
    return {
      devices,
      ensurePermissions,
      permissionGranted,
      videoInputs,
      audioInputs,
      audioOutputs,
      isSupported
    };
  }
  function useDisplayMedia(options = {}) {
    var _a2, _b2;
    const enabled = vueDemi2.ref((_a2 = options.enabled) != null ? _a2 : false);
    const video = options.video;
    const audio = options.audio;
    const { navigator: navigator2 = defaultNavigator } = options;
    const isSupported = Boolean((_b2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _b2.getDisplayMedia);
    const constraint = { audio, video };
    const stream = vueDemi2.shallowRef();
    async function _start() {
      if (!isSupported || stream.value)
        return;
      stream.value = await navigator2.mediaDevices.getDisplayMedia(constraint);
      return stream.value;
    }
    async function _stop() {
      var _a22;
      (_a22 = stream.value) == null ? void 0 : _a22.getTracks().forEach((t) => t.stop());
      stream.value = void 0;
    }
    function stop2() {
      _stop();
      enabled.value = false;
    }
    async function start2() {
      await _start();
      if (stream.value)
        enabled.value = true;
      return stream.value;
    }
    vueDemi2.watch(enabled, (v2) => {
      if (v2)
        _start();
      else
        _stop();
    }, { immediate: true });
    return {
      isSupported,
      stream,
      start: start2,
      stop: stop2,
      enabled
    };
  }
  function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
    if (!document2)
      return vueDemi2.ref("visible");
    const visibility = vueDemi2.ref(document2.visibilityState);
    useEventListener(document2, "visibilitychange", () => {
      visibility.value = document2.visibilityState;
    });
    return visibility;
  }
  var __defProp$a = Object.defineProperty;
  var __defProps$42 = Object.defineProperties;
  var __getOwnPropDescs$42 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
  var __hasOwnProp$c = Object.prototype.hasOwnProperty;
  var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$a = (obj, key2, value) => key2 in obj ? __defProp$a(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$a = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$c.call(b2, prop))
        __defNormalProp$a(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$c)
      for (var prop of __getOwnPropSymbols$c(b2)) {
        if (__propIsEnum$c.call(b2, prop))
          __defNormalProp$a(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps$42 = (a2, b2) => __defProps$42(a2, __getOwnPropDescs$42(b2));
  function useDraggable(target2, options = {}) {
    var _a2, _b2;
    const draggingElement = (_a2 = options.draggingElement) != null ? _a2 : defaultWindow;
    const position2 = vueDemi2.ref((_b2 = options.initialValue) != null ? _b2 : { x: 0, y: 0 });
    const pressedDelta = vueDemi2.ref();
    const filterEvent = (e) => {
      if (options.pointerTypes)
        return options.pointerTypes.includes(e.pointerType);
      return true;
    };
    const preventDefault2 = (e) => {
      if (vueDemi2.unref(options.preventDefault))
        e.preventDefault();
    };
    const start2 = (e) => {
      var _a22;
      if (!filterEvent(e))
        return;
      if (vueDemi2.unref(options.exact) && e.target !== vueDemi2.unref(target2))
        return;
      const rect = vueDemi2.unref(target2).getBoundingClientRect();
      const pos = {
        x: e.pageX - rect.left,
        y: e.pageY - rect.top
      };
      if (((_a22 = options.onStart) == null ? void 0 : _a22.call(options, pos, e)) === false)
        return;
      pressedDelta.value = pos;
      preventDefault2(e);
    };
    const move = (e) => {
      var _a22;
      if (!filterEvent(e))
        return;
      if (!pressedDelta.value)
        return;
      position2.value = {
        x: e.pageX - pressedDelta.value.x,
        y: e.pageY - pressedDelta.value.y
      };
      (_a22 = options.onMove) == null ? void 0 : _a22.call(options, position2.value, e);
      preventDefault2(e);
    };
    const end2 = (e) => {
      var _a22;
      if (!filterEvent(e))
        return;
      pressedDelta.value = void 0;
      (_a22 = options.onEnd) == null ? void 0 : _a22.call(options, position2.value, e);
      preventDefault2(e);
    };
    if (shared2.isClient) {
      useEventListener(target2, "pointerdown", start2, true);
      useEventListener(draggingElement, "pointermove", move, true);
      useEventListener(draggingElement, "pointerup", end2, true);
    }
    return __spreadProps$42(__spreadValues$a({}, shared2.toRefs(position2)), {
      position: position2,
      isDragging: vueDemi2.computed(() => !!pressedDelta.value),
      style: vueDemi2.computed(() => `left:${position2.value.x}px;top:${position2.value.y}px;`)
    });
  }
  var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
  var __hasOwnProp$b = Object.prototype.hasOwnProperty;
  var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
  var __objRest$22 = (source2, exclude) => {
    var target2 = {};
    for (var prop in source2)
      if (__hasOwnProp$b.call(source2, prop) && exclude.indexOf(prop) < 0)
        target2[prop] = source2[prop];
    if (source2 != null && __getOwnPropSymbols$b)
      for (var prop of __getOwnPropSymbols$b(source2)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$b.call(source2, prop))
          target2[prop] = source2[prop];
      }
    return target2;
  };
  function useResizeObserver(target2, callback, options = {}) {
    const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$22(_a2, ["window"]);
    let observer;
    const isSupported = window2 && "ResizeObserver" in window2;
    const cleanup = () => {
      if (observer) {
        observer.disconnect();
        observer = void 0;
      }
    };
    const stopWatch = vueDemi2.watch(() => unrefElement(target2), (el) => {
      cleanup();
      if (isSupported && window2 && el) {
        observer = new window2.ResizeObserver(callback);
        observer.observe(el, observerOptions);
      }
    }, { immediate: true, flush: "post" });
    const stop2 = () => {
      cleanup();
      stopWatch();
    };
    shared2.tryOnScopeDispose(stop2);
    return {
      isSupported,
      stop: stop2
    };
  }
  function useElementBounding(target2) {
    const height = vueDemi2.ref(0);
    const bottom2 = vueDemi2.ref(0);
    const left2 = vueDemi2.ref(0);
    const right2 = vueDemi2.ref(0);
    const top2 = vueDemi2.ref(0);
    const width = vueDemi2.ref(0);
    const x2 = vueDemi2.ref(0);
    const y = vueDemi2.ref(0);
    function update3() {
      const el = unrefElement(target2);
      if (!el) {
        height.value = 0;
        bottom2.value = 0;
        left2.value = 0;
        right2.value = 0;
        top2.value = 0;
        width.value = 0;
        x2.value = 0;
        y.value = 0;
        return;
      }
      const rect = el.getBoundingClientRect();
      height.value = rect.height;
      bottom2.value = rect.bottom;
      left2.value = rect.left;
      right2.value = rect.right;
      top2.value = rect.top;
      width.value = rect.width;
      x2.value = rect.x;
      y.value = rect.y;
    }
    useEventListener("scroll", update3, true);
    useResizeObserver(target2, update3);
    return {
      height,
      bottom: bottom2,
      left: left2,
      right: right2,
      top: top2,
      width,
      x: x2,
      y,
      update: update3
    };
  }
  var __defProp$9 = Object.defineProperty;
  var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
  var __hasOwnProp$a = Object.prototype.hasOwnProperty;
  var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$9 = (obj, key2, value) => key2 in obj ? __defProp$9(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$9 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$a.call(b2, prop))
        __defNormalProp$9(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$a)
      for (var prop of __getOwnPropSymbols$a(b2)) {
        if (__propIsEnum$a.call(b2, prop))
          __defNormalProp$9(a2, prop, b2[prop]);
      }
    return a2;
  };
  function useElementByPoint(options) {
    const element = vueDemi2.ref(null);
    const { x: x2, y } = options;
    const controls = core2.useRafFn(() => {
      element.value = document.elementFromPoint(vueDemi2.unref(x2), vueDemi2.unref(y));
    });
    return __spreadValues$9({
      element
    }, controls);
  }
  function useElementHover(el) {
    const isHovered = vueDemi2.ref(false);
    useEventListener(el, "mouseenter", () => isHovered.value = true);
    useEventListener(el, "mouseleave", () => isHovered.value = false);
    return isHovered;
  }
  function useElementSize(target2, initialSize = { width: 0, height: 0 }, options = {}) {
    const width = vueDemi2.ref(initialSize.width);
    const height = vueDemi2.ref(initialSize.height);
    useResizeObserver(target2, ([entry]) => {
      width.value = entry.contentRect.width;
      height.value = entry.contentRect.height;
    }, options);
    return {
      width,
      height
    };
  }
  function useElementVisibility(element, { window: window2 = defaultWindow, scrollTarget } = {}) {
    const elementIsVisible = vueDemi2.ref(false);
    const testBounding = () => {
      if (!window2)
        return;
      const document2 = window2.document;
      if (!element.value) {
        elementIsVisible.value = false;
      } else {
        const rect = element.value.getBoundingClientRect();
        elementIsVisible.value = rect.top <= (window2.innerHeight || document2.documentElement.clientHeight) && rect.left <= (window2.innerWidth || document2.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0;
      }
    };
    shared2.tryOnMounted(testBounding);
    if (window2)
      shared2.tryOnMounted(() => useEventListener((scrollTarget == null ? void 0 : scrollTarget.value) || window2, "scroll", testBounding, { capture: false, passive: true }));
    return elementIsVisible;
  }
  const events = /* @__PURE__ */ new Map();
  function useEventBus(key2) {
    const scope = vueDemi2.getCurrentScope();
    function on2(listener) {
      const listeners = events.get(key2) || [];
      listeners.push(listener);
      events.set(key2, listeners);
      const _off = () => off2(listener);
      scope == null ? void 0 : scope.cleanups.push(_off);
      return _off;
    }
    function once2(listener) {
      function _listener(...args) {
        off2(_listener);
        listener(...args);
      }
      return on2(_listener);
    }
    function off2(listener) {
      const listeners = events.get(key2);
      if (!listeners)
        return;
      const index2 = listeners.indexOf(listener);
      if (index2 > -1)
        listeners.splice(index2, 1);
      if (!listeners.length)
        events.delete(key2);
    }
    function reset2() {
      events.delete(key2);
    }
    function emit(event) {
      var _a2;
      (_a2 = events.get(key2)) == null ? void 0 : _a2.forEach((v2) => v2(event));
    }
    return { on: on2, once: once2, off: off2, emit, reset: reset2 };
  }
  function useEventSource(url2, events2 = [], options = {}) {
    const event = vueDemi2.ref(null);
    const data2 = vueDemi2.ref(null);
    const status = vueDemi2.ref("CONNECTING");
    const eventSource = vueDemi2.ref(null);
    const error2 = vueDemi2.ref(null);
    const {
      withCredentials = false
    } = options;
    const close2 = () => {
      if (eventSource.value) {
        eventSource.value.close();
        eventSource.value = null;
        status.value = "CLOSED";
      }
    };
    const es2 = new EventSource(url2, { withCredentials });
    eventSource.value = es2;
    es2.onopen = () => {
      status.value = "OPEN";
      error2.value = null;
    };
    es2.onerror = (e) => {
      status.value = "CLOSED";
      error2.value = e;
    };
    es2.onmessage = (e) => {
      event.value = null;
      data2.value = e.data;
    };
    for (const event_name of events2) {
      useEventListener(es2, event_name, (e) => {
        event.value = event_name;
        data2.value = e.data || null;
      });
    }
    shared2.tryOnScopeDispose(() => {
      close2();
    });
    return {
      eventSource,
      event,
      data: data2,
      status,
      error: error2,
      close: close2
    };
  }
  function useEyeDropper(options = {}) {
    const { initialValue = "" } = options;
    const isSupported = Boolean(typeof window !== "undefined" && "EyeDropper" in window);
    const sRGBHex = vueDemi2.ref(initialValue);
    async function open2(openOptions) {
      if (!isSupported)
        return;
      const eyeDropper = new window.EyeDropper();
      const result3 = await eyeDropper.open(openOptions);
      sRGBHex.value = result3.sRGBHex;
      return result3;
    }
    return { isSupported, sRGBHex, open: open2 };
  }
  function useFavicon(newIcon = null, options = {}) {
    const {
      baseUrl = "",
      rel = "icon",
      document: document2 = defaultDocument
    } = options;
    const favicon = vueDemi2.isRef(newIcon) ? newIcon : vueDemi2.ref(newIcon);
    const applyIcon = (icon3) => {
      document2 == null ? void 0 : document2.head.querySelectorAll(`link[rel*="${rel}"]`).forEach((el) => el.href = `${baseUrl}${icon3}`);
    };
    vueDemi2.watch(favicon, (i, o2) => {
      if (shared2.isString(i) && i !== o2)
        applyIcon(i);
    }, { immediate: true });
    return favicon;
  }
  var __defProp$8 = Object.defineProperty;
  var __defProps$32 = Object.defineProperties;
  var __getOwnPropDescs$32 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$92 = Object.getOwnPropertySymbols;
  var __hasOwnProp$92 = Object.prototype.hasOwnProperty;
  var __propIsEnum$92 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$8 = (obj, key2, value) => key2 in obj ? __defProp$8(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$8 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$92.call(b2, prop))
        __defNormalProp$8(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$92)
      for (var prop of __getOwnPropSymbols$92(b2)) {
        if (__propIsEnum$92.call(b2, prop))
          __defNormalProp$8(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps$32 = (a2, b2) => __defProps$32(a2, __getOwnPropDescs$32(b2));
  const payloadMapping = {
    json: "application/json",
    text: "text/plain",
    formData: "multipart/form-data"
  };
  function isFetchOptions(obj) {
    return shared2.containsProp(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError");
  }
  function headersToObject(headers) {
    if (headers instanceof Headers)
      return Object.fromEntries([...headers.entries()]);
    return headers;
  }
  function createFetch(config2 = {}) {
    const _options = config2.options || {};
    const _fetchOptions = config2.fetchOptions || {};
    function useFactoryFetch(url2, ...args) {
      const computedUrl = vueDemi2.computed(() => config2.baseUrl ? joinPaths(vueDemi2.unref(config2.baseUrl), vueDemi2.unref(url2)) : vueDemi2.unref(url2));
      let options = _options;
      let fetchOptions = _fetchOptions;
      if (args.length > 0) {
        if (isFetchOptions(args[0])) {
          options = __spreadValues$8(__spreadValues$8({}, options), args[0]);
        } else {
          fetchOptions = __spreadProps$32(__spreadValues$8(__spreadValues$8({}, fetchOptions), args[0]), {
            headers: __spreadValues$8(__spreadValues$8({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})
          });
        }
      }
      if (args.length > 1 && isFetchOptions(args[1]))
        options = __spreadValues$8(__spreadValues$8({}, options), args[1]);
      return useFetch(computedUrl, fetchOptions, options);
    }
    return useFactoryFetch;
  }
  function useFetch(url2, ...args) {
    var _a2;
    const supportsAbort = typeof AbortController === "function";
    let fetchOptions = {};
    let options = { immediate: true, refetch: false, timeout: 0 };
    const config2 = {
      method: "get",
      type: "text",
      payload: void 0
    };
    if (args.length > 0) {
      if (isFetchOptions(args[0]))
        options = __spreadValues$8(__spreadValues$8({}, options), args[0]);
      else
        fetchOptions = args[0];
    }
    if (args.length > 1) {
      if (isFetchOptions(args[1]))
        options = __spreadValues$8(__spreadValues$8({}, options), args[1]);
    }
    const {
      fetch = (_a2 = defaultWindow) == null ? void 0 : _a2.fetch,
      initialData,
      timeout
    } = options;
    const responseEvent = shared2.createEventHook();
    const errorEvent = shared2.createEventHook();
    const finallyEvent = shared2.createEventHook();
    const isFinished = vueDemi2.ref(false);
    const isFetching = vueDemi2.ref(false);
    const aborted = vueDemi2.ref(false);
    const statusCode = vueDemi2.ref(null);
    const response = vueDemi2.shallowRef(null);
    const error2 = vueDemi2.ref(null);
    const data2 = vueDemi2.shallowRef(initialData);
    const canAbort = vueDemi2.computed(() => supportsAbort && isFetching.value);
    let controller;
    let timer2;
    const abort = () => {
      if (supportsAbort && controller)
        controller.abort();
    };
    const loading2 = (isLoading) => {
      isFetching.value = isLoading;
      isFinished.value = !isLoading;
    };
    if (timeout)
      timer2 = shared2.useTimeoutFn(abort, timeout, { immediate: false });
    const execute = async (throwOnFailed = false) => {
      var _a22;
      loading2(true);
      error2.value = null;
      statusCode.value = null;
      aborted.value = false;
      controller = void 0;
      if (supportsAbort) {
        controller = new AbortController();
        controller.signal.onabort = () => aborted.value = true;
        fetchOptions = __spreadProps$32(__spreadValues$8({}, fetchOptions), {
          signal: controller.signal
        });
      }
      const defaultFetchOptions = {
        method: config2.method,
        headers: {}
      };
      if (config2.payload) {
        const headers = headersToObject(defaultFetchOptions.headers);
        if (config2.payloadType)
          headers["Content-Type"] = (_a22 = payloadMapping[config2.payloadType]) != null ? _a22 : config2.payloadType;
        defaultFetchOptions.body = config2.payloadType === "json" ? JSON.stringify(vueDemi2.unref(config2.payload)) : vueDemi2.unref(config2.payload);
      }
      let isCanceled = false;
      const context = { url: vueDemi2.unref(url2), options: fetchOptions, cancel: () => {
        isCanceled = true;
      } };
      if (options.beforeFetch)
        Object.assign(context, await options.beforeFetch(context));
      if (isCanceled || !fetch) {
        loading2(false);
        return Promise.resolve(null);
      }
      let responseData = null;
      if (timer2)
        timer2.start();
      return new Promise((resolve2, reject) => {
        var _a3;
        fetch(context.url, __spreadProps$32(__spreadValues$8(__spreadValues$8({}, defaultFetchOptions), context.options), {
          headers: __spreadValues$8(__spreadValues$8({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))
        })).then(async (fetchResponse) => {
          response.value = fetchResponse;
          statusCode.value = fetchResponse.status;
          responseData = await fetchResponse[config2.type]();
          if (options.afterFetch)
            ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));
          data2.value = responseData;
          if (!fetchResponse.ok)
            throw new Error(fetchResponse.statusText);
          responseEvent.trigger(fetchResponse);
          return resolve2(fetchResponse);
        }).catch(async (fetchError) => {
          let errorData = fetchError.message || fetchError.name;
          if (options.onFetchError)
            ({ data: responseData, error: errorData } = await options.onFetchError({ data: responseData, error: fetchError }));
          data2.value = responseData;
          error2.value = errorData;
          errorEvent.trigger(fetchError);
          if (throwOnFailed)
            return reject(fetchError);
          return resolve2(null);
        }).finally(() => {
          loading2(false);
          if (timer2)
            timer2.stop();
          finallyEvent.trigger(null);
        });
      });
    };
    vueDemi2.watch(() => [
      vueDemi2.unref(url2),
      vueDemi2.unref(options.refetch)
    ], () => vueDemi2.unref(options.refetch) && execute(), { deep: true });
    const shell = {
      isFinished,
      statusCode,
      response,
      error: error2,
      data: data2,
      isFetching,
      canAbort,
      aborted,
      abort,
      execute,
      onFetchResponse: responseEvent.on,
      onFetchError: errorEvent.on,
      onFetchFinally: finallyEvent.on,
      get: setMethod("get"),
      put: setMethod("put"),
      post: setMethod("post"),
      delete: setMethod("delete"),
      json: setType("json"),
      text: setType("text"),
      blob: setType("blob"),
      arrayBuffer: setType("arrayBuffer"),
      formData: setType("formData")
    };
    function setMethod(method4) {
      return (payload, payloadType) => {
        if (!isFetching.value) {
          config2.method = method4;
          config2.payload = payload;
          config2.payloadType = payloadType;
          if (vueDemi2.isRef(config2.payload)) {
            vueDemi2.watch(() => [
              vueDemi2.unref(config2.payload),
              vueDemi2.unref(options.refetch)
            ], () => vueDemi2.unref(options.refetch) && execute(), { deep: true });
          }
          if (!payloadType && vueDemi2.unref(payload) && Object.getPrototypeOf(vueDemi2.unref(payload)) === Object.prototype)
            config2.payloadType = "json";
          return shell;
        }
        return void 0;
      };
    }
    function waitUntilFinished() {
      return new Promise((resolve2, reject) => {
        shared2.until(isFinished).toBe(true).then(() => resolve2(shell)).catch((error22) => reject(error22));
      });
    }
    function setType(type4) {
      return () => {
        if (!isFetching.value) {
          config2.type = type4;
          return __spreadProps$32(__spreadValues$8({}, shell), {
            then(onFulfilled, onRejected) {
              return waitUntilFinished().then(onFulfilled, onRejected);
            }
          });
        }
        return void 0;
      };
    }
    if (options.immediate)
      setTimeout(execute, 0);
    return __spreadProps$32(__spreadValues$8({}, shell), {
      then(onFulfilled, onRejected) {
        return waitUntilFinished().then(onFulfilled, onRejected);
      }
    });
  }
  function joinPaths(start2, end2) {
    if (!start2.endsWith("/") && !end2.startsWith("/"))
      return `${start2}/${end2}`;
    return `${start2}${end2}`;
  }
  function useFocus2(options = {}) {
    const {
      initialValue = false
    } = options;
    const activeElement = useActiveElement(options);
    const target2 = vueDemi2.computed(() => unrefElement(options.target));
    const focused = vueDemi2.computed({
      get() {
        return activeElement.value === target2.value;
      },
      set(value) {
        var _a2, _b2;
        if (!value && focused.value)
          (_a2 = target2.value) == null ? void 0 : _a2.blur();
        if (value && !focused.value)
          (_b2 = target2.value) == null ? void 0 : _b2.focus();
      }
    });
    vueDemi2.watch(target2, () => {
      focused.value = initialValue;
    }, { immediate: true, flush: "post" });
    return { focused };
  }
  function useFocusWithin(target2, options = {}) {
    const activeElement = useActiveElement(options);
    const targetElement = vueDemi2.computed(() => unrefElement(target2));
    const focused = vueDemi2.computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);
    return { focused };
  }
  function useRafFn(fn3, options = {}) {
    const {
      immediate = true,
      window: window2 = defaultWindow
    } = options;
    const isActive = vueDemi2.ref(false);
    function loop() {
      if (!isActive.value || !window2)
        return;
      fn3();
      window2.requestAnimationFrame(loop);
    }
    function resume() {
      if (!isActive.value && window2) {
        isActive.value = true;
        loop();
      }
    }
    function pause() {
      isActive.value = false;
    }
    if (immediate)
      resume();
    shared2.tryOnScopeDispose(pause);
    return {
      isActive,
      pause,
      resume
    };
  }
  function useFps(options) {
    var _a2;
    const fps = vueDemi2.ref(0);
    const every = (_a2 = options == null ? void 0 : options.every) != null ? _a2 : 10;
    let last = performance.now();
    let ticks = 0;
    useRafFn(() => {
      ticks += 1;
      if (ticks >= every) {
        const now2 = performance.now();
        const diff = now2 - last;
        fps.value = Math.round(1e3 / (diff / ticks));
        last = now2;
        ticks = 0;
      }
    });
    return fps;
  }
  const functionsMap = [
    [
      "requestFullscreen",
      "exitFullscreen",
      "fullscreenElement",
      "fullscreenEnabled",
      "fullscreenchange",
      "fullscreenerror"
    ],
    [
      "webkitRequestFullscreen",
      "webkitExitFullscreen",
      "webkitFullscreenElement",
      "webkitFullscreenEnabled",
      "webkitfullscreenchange",
      "webkitfullscreenerror"
    ],
    [
      "webkitRequestFullScreen",
      "webkitCancelFullScreen",
      "webkitCurrentFullScreenElement",
      "webkitCancelFullScreen",
      "webkitfullscreenchange",
      "webkitfullscreenerror"
    ],
    [
      "mozRequestFullScreen",
      "mozCancelFullScreen",
      "mozFullScreenElement",
      "mozFullScreenEnabled",
      "mozfullscreenchange",
      "mozfullscreenerror"
    ],
    [
      "msRequestFullscreen",
      "msExitFullscreen",
      "msFullscreenElement",
      "msFullscreenEnabled",
      "MSFullscreenChange",
      "MSFullscreenError"
    ]
  ];
  function useFullscreen(target2, options = {}) {
    const { document: document2 = defaultDocument } = options;
    const targetRef = target2 || (document2 == null ? void 0 : document2.querySelector("html"));
    const isFullscreen = vueDemi2.ref(false);
    let isSupported = false;
    let map = functionsMap[0];
    if (!document2) {
      isSupported = false;
    } else {
      for (const m2 of functionsMap) {
        if (m2[1] in document2) {
          map = m2;
          isSupported = true;
          break;
        }
      }
    }
    const [REQUEST, EXIT, ELEMENT, , EVENT] = map;
    async function exit() {
      if (!isSupported)
        return;
      if (document2 == null ? void 0 : document2[ELEMENT])
        await document2[EXIT]();
      isFullscreen.value = false;
    }
    async function enter() {
      if (!isSupported)
        return;
      await exit();
      const target22 = unrefElement(targetRef);
      if (target22) {
        await target22[REQUEST]();
        isFullscreen.value = true;
      }
    }
    async function toggle() {
      if (isFullscreen.value)
        await exit();
      else
        await enter();
    }
    if (document2) {
      useEventListener(document2, EVENT, () => {
        isFullscreen.value = !!(document2 == null ? void 0 : document2[ELEMENT]);
      }, false);
    }
    return {
      isSupported,
      isFullscreen,
      enter,
      exit,
      toggle
    };
  }
  function useGeolocation(options = {}) {
    const {
      enableHighAccuracy = true,
      maximumAge = 3e4,
      timeout = 27e3,
      navigator: navigator2 = defaultNavigator
    } = options;
    const isSupported = navigator2 && "geolocation" in navigator2;
    const locatedAt = vueDemi2.ref(null);
    const error2 = vueDemi2.ref(null);
    const coords = vueDemi2.ref({
      accuracy: 0,
      latitude: Infinity,
      longitude: Infinity,
      altitude: null,
      altitudeAccuracy: null,
      heading: null,
      speed: null
    });
    function updatePosition(position2) {
      locatedAt.value = position2.timestamp;
      coords.value = position2.coords;
      error2.value = null;
    }
    let watcher2;
    if (isSupported) {
      watcher2 = navigator2.geolocation.watchPosition(updatePosition, (err) => error2.value = err, {
        enableHighAccuracy,
        maximumAge,
        timeout
      });
    }
    shared2.tryOnScopeDispose(() => {
      if (watcher2 && navigator2)
        navigator2.geolocation.clearWatch(watcher2);
    });
    return {
      isSupported,
      coords,
      locatedAt,
      error: error2
    };
  }
  const defaultEvents$1 = ["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"];
  const oneMinute = 6e4;
  function useIdle(timeout = oneMinute, options = {}) {
    const {
      initialState: initialState2 = false,
      listenForVisibilityChange = true,
      events: events2 = defaultEvents$1,
      window: window2 = defaultWindow,
      eventFilter = shared2.throttleFilter(50)
    } = options;
    const idle = vueDemi2.ref(initialState2);
    const lastActive = vueDemi2.ref(shared2.timestamp());
    let timer2;
    const onEvent = shared2.createFilterWrapper(eventFilter, () => {
      idle.value = false;
      lastActive.value = shared2.timestamp();
      clearTimeout(timer2);
      timer2 = setTimeout(() => idle.value = true, timeout);
    });
    if (window2) {
      const document2 = window2.document;
      for (const event of events2)
        useEventListener(window2, event, onEvent, { passive: true });
      if (listenForVisibilityChange) {
        useEventListener(document2, "visibilitychange", () => {
          if (!document2.hidden)
            onEvent();
        });
      }
    }
    timer2 = setTimeout(() => idle.value = true, timeout);
    return { idle, lastActive };
  }
  function useIntersectionObserver(target2, callback, options = {}) {
    const {
      root: root2,
      rootMargin = "0px",
      threshold = 0.1,
      window: window2 = defaultWindow
    } = options;
    const isSupported = window2 && "IntersectionObserver" in window2;
    let cleanup = shared2.noop;
    const stopWatch = isSupported ? vueDemi2.watch(() => ({
      el: unrefElement(target2),
      root: unrefElement(root2)
    }), ({ el, root: root22 }) => {
      cleanup();
      if (!el)
        return;
      const observer = new window2.IntersectionObserver(callback, {
        root: root22,
        rootMargin,
        threshold
      });
      observer.observe(el);
      cleanup = () => {
        observer.disconnect();
        cleanup = shared2.noop;
      };
    }, { immediate: true, flush: "post" }) : shared2.noop;
    const stop2 = () => {
      cleanup();
      stopWatch();
    };
    shared2.tryOnScopeDispose(stop2);
    return {
      isSupported,
      stop: stop2
    };
  }
  const defaultEvents = ["mousedown", "mouseup", "keydown", "keyup"];
  function useKeyModifier(modifier, options = {}) {
    const {
      events: events2 = defaultEvents,
      document: document2 = defaultDocument,
      initial = null
    } = options;
    const state = vueDemi2.ref(initial);
    if (document2) {
      events2.forEach((listenerEvent) => {
        useEventListener(document2, listenerEvent, (evt) => {
          state.value = evt.getModifierState(modifier);
        });
      });
    }
    return state;
  }
  function useLocalStorage(key2, initialValue, options = {}) {
    const { window: window2 = defaultWindow } = options;
    return useStorage(key2, initialValue, window2 == null ? void 0 : window2.localStorage, options);
  }
  const DefaultMagicKeysAliasMap = {
    ctrl: "control",
    command: "meta",
    cmd: "meta",
    option: "alt",
    up: "arrowup",
    down: "arrowdown",
    left: "arrowleft",
    right: "arrowright"
  };
  function useMagicKeys(options = {}) {
    const {
      reactive: useReactive = false,
      target: target2 = defaultWindow,
      aliasMap = DefaultMagicKeysAliasMap,
      passive: passive2 = true,
      onEventFired = shared2.noop
    } = options;
    const current2 = vueDemi2.reactive(/* @__PURE__ */ new Set());
    const obj = { toJSON() {
      return {};
    }, current: current2 };
    const refs = useReactive ? vueDemi2.reactive(obj) : obj;
    function updateRefs(e, value) {
      const key2 = e.key.toLowerCase();
      const code2 = e.code.toLowerCase();
      const values = [code2, key2];
      if (value)
        current2.add(e.code);
      else
        current2.delete(e.code);
      for (const key22 of values) {
        if (key22 in refs) {
          if (useReactive)
            refs[key22] = value;
          else
            refs[key22].value = value;
        }
      }
    }
    if (target2) {
      useEventListener(target2, "keydown", (e) => {
        updateRefs(e, true);
        return onEventFired(e);
      }, { passive: passive2 });
      useEventListener(target2, "keyup", (e) => {
        updateRefs(e, false);
        return onEventFired(e);
      }, { passive: passive2 });
    }
    const proxy = new Proxy(refs, {
      get(target22, prop, rec) {
        if (typeof prop !== "string")
          return Reflect.get(target22, prop, rec);
        prop = prop.toLowerCase();
        if (prop in aliasMap)
          prop = aliasMap[prop];
        if (!(prop in refs)) {
          if (/[+_-]/.test(prop)) {
            const keys3 = prop.split(/[+_-]/g).map((i) => i.trim());
            refs[prop] = vueDemi2.computed(() => keys3.every((key2) => vueDemi2.unref(proxy[key2])));
          } else {
            refs[prop] = vueDemi2.ref(false);
          }
        }
        const r = Reflect.get(target22, prop, rec);
        return useReactive ? vueDemi2.unref(r) : r;
      }
    });
    return proxy;
  }
  var __defProp$72 = Object.defineProperty;
  var __getOwnPropSymbols$82 = Object.getOwnPropertySymbols;
  var __hasOwnProp$82 = Object.prototype.hasOwnProperty;
  var __propIsEnum$82 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$72 = (obj, key2, value) => key2 in obj ? __defProp$72(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$72 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$82.call(b2, prop))
        __defNormalProp$72(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$82)
      for (var prop of __getOwnPropSymbols$82(b2)) {
        if (__propIsEnum$82.call(b2, prop))
          __defNormalProp$72(a2, prop, b2[prop]);
      }
    return a2;
  };
  function usingElRef(source2, cb) {
    if (vueDemi2.unref(source2))
      cb(vueDemi2.unref(source2));
  }
  function timeRangeToArray(timeRanges) {
    let ranges = [];
    for (let i = 0; i < timeRanges.length; ++i)
      ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];
    return ranges;
  }
  function tracksToArray(tracks) {
    return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));
  }
  const defaultOptions = {
    src: "",
    tracks: []
  };
  function useMediaControls(target2, options = {}) {
    options = __spreadValues$72(__spreadValues$72({}, defaultOptions), options);
    const {
      document: document2 = defaultDocument
    } = options;
    const currentTime = vueDemi2.ref(0);
    const duration = vueDemi2.ref(0);
    const seeking = vueDemi2.ref(false);
    const volume = vueDemi2.ref(1);
    const waiting = vueDemi2.ref(false);
    const ended = vueDemi2.ref(false);
    const playing = vueDemi2.ref(false);
    const rate3 = vueDemi2.ref(1);
    const stalled = vueDemi2.ref(false);
    const buffered = vueDemi2.ref([]);
    const tracks = vueDemi2.ref([]);
    const selectedTrack = vueDemi2.ref(-1);
    const isPictureInPicture = vueDemi2.ref(false);
    const muted = vueDemi2.ref(false);
    const supportsPictureInPicture = document2 && "pictureInPictureEnabled" in document2;
    const sourceErrorEvent = shared2.createEventHook();
    const disableTrack = (track2) => {
      usingElRef(target2, (el) => {
        if (track2) {
          const id = shared2.isNumber(track2) ? track2 : track2.id;
          el.textTracks[id].mode = "disabled";
        } else {
          for (let i = 0; i < el.textTracks.length; ++i)
            el.textTracks[i].mode = "disabled";
        }
        selectedTrack.value = -1;
      });
    };
    const enableTrack = (track2, disableTracks = true) => {
      usingElRef(target2, (el) => {
        const id = shared2.isNumber(track2) ? track2 : track2.id;
        if (disableTracks)
          disableTrack();
        el.textTracks[id].mode = "showing";
        selectedTrack.value = id;
      });
    };
    const togglePictureInPicture = () => {
      return new Promise((resolve2, reject) => {
        usingElRef(target2, async (el) => {
          if (supportsPictureInPicture) {
            if (!isPictureInPicture.value) {
              el.requestPictureInPicture().then(resolve2).catch(reject);
            } else {
              document2.exitPictureInPicture().then(resolve2).catch(reject);
            }
          }
        });
      });
    };
    vueDemi2.watchEffect(() => {
      if (!document2)
        return;
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      const src2 = vueDemi2.unref(options.src);
      let sources = [];
      if (!src2)
        return;
      if (shared2.isString(src2))
        sources = [{ src: src2 }];
      else if (Array.isArray(src2))
        sources = src2;
      else if (shared2.isObject(src2))
        sources = [src2];
      el.querySelectorAll("source").forEach((e) => {
        e.removeEventListener("error", sourceErrorEvent.trigger);
        e.remove();
      });
      sources.forEach(({ src: src22, type: type4 }) => {
        const source2 = document2.createElement("source");
        source2.setAttribute("src", src22);
        source2.setAttribute("type", type4 || "");
        source2.addEventListener("error", sourceErrorEvent.trigger);
        el.appendChild(source2);
      });
      el.load();
    });
    shared2.tryOnScopeDispose(() => {
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      el.querySelectorAll("source").forEach((e) => e.removeEventListener("error", sourceErrorEvent.trigger));
    });
    vueDemi2.watch(volume, (vol) => {
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      el.volume = vol;
    });
    vueDemi2.watch(muted, (mute2) => {
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      el.muted = mute2;
    });
    vueDemi2.watch(rate3, (rate22) => {
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      el.playbackRate = rate22;
    });
    vueDemi2.watchEffect(() => {
      if (!document2)
        return;
      const textTracks = vueDemi2.unref(options.tracks);
      const el = vueDemi2.unref(target2);
      if (!textTracks || !textTracks.length || !el)
        return;
      el.querySelectorAll("track").forEach((e) => e.remove());
      textTracks.forEach(({ default: isDefault, kind, label, src: src2, srcLang }, i) => {
        const track2 = document2.createElement("track");
        track2.default = isDefault || false;
        track2.kind = kind;
        track2.label = label;
        track2.src = src2;
        track2.srclang = srcLang;
        if (track2.default)
          selectedTrack.value = i;
        el.appendChild(track2);
      });
    });
    const { ignoreUpdates: ignoreCurrentTimeUpdates } = shared2.ignorableWatch(currentTime, (time) => {
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      el.currentTime = time;
    });
    const { ignoreUpdates: ignorePlayingUpdates } = shared2.ignorableWatch(playing, (isPlaying) => {
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      isPlaying ? el.play() : el.pause();
    });
    useEventListener(target2, "timeupdate", () => ignoreCurrentTimeUpdates(() => currentTime.value = vueDemi2.unref(target2).currentTime));
    useEventListener(target2, "durationchange", () => duration.value = vueDemi2.unref(target2).duration);
    useEventListener(target2, "progress", () => buffered.value = timeRangeToArray(vueDemi2.unref(target2).buffered));
    useEventListener(target2, "seeking", () => seeking.value = true);
    useEventListener(target2, "seeked", () => seeking.value = false);
    useEventListener(target2, "waiting", () => waiting.value = true);
    useEventListener(target2, "playing", () => waiting.value = false);
    useEventListener(target2, "ratechange", () => rate3.value = vueDemi2.unref(target2).playbackRate);
    useEventListener(target2, "stalled", () => stalled.value = true);
    useEventListener(target2, "ended", () => ended.value = true);
    useEventListener(target2, "pause", () => ignorePlayingUpdates(() => playing.value = false));
    useEventListener(target2, "play", () => ignorePlayingUpdates(() => playing.value = true));
    useEventListener(target2, "enterpictureinpicture", () => isPictureInPicture.value = true);
    useEventListener(target2, "leavepictureinpicture", () => isPictureInPicture.value = false);
    useEventListener(target2, "volumechange", () => {
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      volume.value = el.volume;
      muted.value = el.muted;
    });
    const listeners = [];
    const stop2 = vueDemi2.watch([target2], () => {
      const el = vueDemi2.unref(target2);
      if (!el)
        return;
      stop2();
      listeners[0] = useEventListener(el.textTracks, "addtrack", () => tracks.value = tracksToArray(el.textTracks));
      listeners[1] = useEventListener(el.textTracks, "removetrack", () => tracks.value = tracksToArray(el.textTracks));
      listeners[2] = useEventListener(el.textTracks, "change", () => tracks.value = tracksToArray(el.textTracks));
    });
    shared2.tryOnScopeDispose(() => listeners.forEach((listener) => listener()));
    return {
      currentTime,
      duration,
      waiting,
      seeking,
      ended,
      stalled,
      buffered,
      playing,
      rate: rate3,
      volume,
      muted,
      tracks,
      selectedTrack,
      enableTrack,
      disableTrack,
      supportsPictureInPicture,
      togglePictureInPicture,
      isPictureInPicture,
      onSourceError: sourceErrorEvent.on
    };
  }
  function useMemory(options = {}) {
    const memory = vueDemi2.ref();
    const isSupported = performance && "memory" in performance;
    if (isSupported) {
      const { interval = 1e3 } = options;
      shared2.useIntervalFn(() => {
        memory.value = performance.memory;
      }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });
    }
    return { isSupported, memory };
  }
  function useMounted() {
    const isMounted = vueDemi2.ref(false);
    vueDemi2.onMounted(() => {
      isMounted.value = true;
    });
    return isMounted;
  }
  function useMouse(options = {}) {
    const {
      type: type4 = "page",
      touch = true,
      resetOnTouchEnds = false,
      initialValue = { x: 0, y: 0 },
      window: window2 = defaultWindow
    } = options;
    const x2 = vueDemi2.ref(initialValue.x);
    const y = vueDemi2.ref(initialValue.y);
    const sourceType = vueDemi2.ref(null);
    const mouseHandler = (event) => {
      if (type4 === "page") {
        x2.value = event.pageX;
        y.value = event.pageY;
      } else if (type4 === "client") {
        x2.value = event.clientX;
        y.value = event.clientY;
      }
      sourceType.value = "mouse";
    };
    const reset2 = () => {
      x2.value = initialValue.x;
      y.value = initialValue.y;
    };
    const touchHandler = (event) => {
      if (event.touches.length > 0) {
        const touch2 = event.touches[0];
        if (type4 === "page") {
          x2.value = touch2.pageX;
          y.value = touch2.pageY;
        } else if (type4 === "client") {
          x2.value = touch2.clientX;
          y.value = touch2.clientY;
        }
        sourceType.value = "touch";
      }
    };
    if (window2) {
      useEventListener(window2, "mousemove", mouseHandler, { passive: true });
      useEventListener(window2, "dragover", mouseHandler, { passive: true });
      if (touch) {
        useEventListener(window2, "touchstart", touchHandler, { passive: true });
        useEventListener(window2, "touchmove", touchHandler, { passive: true });
        if (resetOnTouchEnds)
          useEventListener(window2, "touchend", reset2, { passive: true });
      }
    }
    return {
      x: x2,
      y,
      sourceType
    };
  }
  function useMouseInElement(target2, options = {}) {
    const {
      handleOutside = true,
      window: window2 = defaultWindow
    } = options;
    const { x: x2, y, sourceType } = useMouse(options);
    const targetRef = vueDemi2.ref(target2 != null ? target2 : window2 == null ? void 0 : window2.document.body);
    const elementX = vueDemi2.ref(0);
    const elementY = vueDemi2.ref(0);
    const elementPositionX = vueDemi2.ref(0);
    const elementPositionY = vueDemi2.ref(0);
    const elementHeight = vueDemi2.ref(0);
    const elementWidth = vueDemi2.ref(0);
    const isOutside = vueDemi2.ref(false);
    let stop2 = () => {
    };
    if (window2) {
      stop2 = vueDemi2.watch([targetRef, x2, y], () => {
        const el = unrefElement(targetRef);
        if (!el)
          return;
        const {
          left: left2,
          top: top2,
          width,
          height
        } = el.getBoundingClientRect();
        elementPositionX.value = left2 + window2.pageXOffset;
        elementPositionY.value = top2 + window2.pageYOffset;
        elementHeight.value = height;
        elementWidth.value = width;
        const elX = x2.value - elementPositionX.value;
        const elY = y.value - elementPositionY.value;
        isOutside.value = elX < 0 || elY < 0 || elX > elementWidth.value || elY > elementHeight.value;
        if (handleOutside || !isOutside.value) {
          elementX.value = elX;
          elementY.value = elY;
        }
      }, { immediate: true });
    }
    return {
      x: x2,
      y,
      sourceType,
      elementX,
      elementY,
      elementPositionX,
      elementPositionY,
      elementHeight,
      elementWidth,
      isOutside,
      stop: stop2
    };
  }
  function useMousePressed(options = {}) {
    const {
      touch = true,
      drag = true,
      initialValue = false,
      window: window2 = defaultWindow
    } = options;
    const pressed = vueDemi2.ref(initialValue);
    const sourceType = vueDemi2.ref(null);
    if (!window2) {
      return {
        pressed,
        sourceType
      };
    }
    const onPressed = (srcType) => () => {
      pressed.value = true;
      sourceType.value = srcType;
    };
    const onReleased = () => {
      pressed.value = false;
      sourceType.value = null;
    };
    const target2 = vueDemi2.computed(() => unrefElement(options.target) || window2);
    useEventListener(target2, "mousedown", onPressed("mouse"), { passive: true });
    useEventListener(window2, "mouseleave", onReleased, { passive: true });
    useEventListener(window2, "mouseup", onReleased, { passive: true });
    if (drag) {
      useEventListener(target2, "dragstart", onPressed("mouse"), { passive: true });
      useEventListener(window2, "drop", onReleased, { passive: true });
      useEventListener(window2, "dragend", onReleased, { passive: true });
    }
    if (touch) {
      useEventListener(target2, "touchstart", onPressed("touch"), { passive: true });
      useEventListener(window2, "touchend", onReleased, { passive: true });
      useEventListener(window2, "touchcancel", onReleased, { passive: true });
    }
    return {
      pressed,
      sourceType
    };
  }
  var __getOwnPropSymbols$72 = Object.getOwnPropertySymbols;
  var __hasOwnProp$72 = Object.prototype.hasOwnProperty;
  var __propIsEnum$72 = Object.prototype.propertyIsEnumerable;
  var __objRest$12 = (source2, exclude) => {
    var target2 = {};
    for (var prop in source2)
      if (__hasOwnProp$72.call(source2, prop) && exclude.indexOf(prop) < 0)
        target2[prop] = source2[prop];
    if (source2 != null && __getOwnPropSymbols$72)
      for (var prop of __getOwnPropSymbols$72(source2)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$72.call(source2, prop))
          target2[prop] = source2[prop];
      }
    return target2;
  };
  function useMutationObserver(target2, callback, options = {}) {
    const _a2 = options, { window: window2 = defaultWindow } = _a2, mutationOptions = __objRest$12(_a2, ["window"]);
    let observer;
    const isSupported = window2 && "IntersectionObserver" in window2;
    const cleanup = () => {
      if (observer) {
        observer.disconnect();
        observer = void 0;
      }
    };
    const stopWatch = vueDemi2.watch(() => unrefElement(target2), (el) => {
      cleanup();
      if (isSupported && window2 && el) {
        observer = new window2.MutationObserver(callback);
        observer.observe(el, mutationOptions);
      }
    }, { immediate: true });
    const stop2 = () => {
      cleanup();
      stopWatch();
    };
    shared2.tryOnScopeDispose(stop2);
    return {
      isSupported,
      stop: stop2
    };
  }
  const useNavigatorLanguage = (options = {}) => {
    const { window: window2 = defaultWindow } = options;
    const navigator2 = window2 == null ? void 0 : window2.navigator;
    const isSupported = Boolean(navigator2 && "language" in navigator2);
    const language = vueDemi2.ref(navigator2 == null ? void 0 : navigator2.language);
    useEventListener(window2, "languagechange", () => {
      if (navigator2)
        language.value = navigator2.language;
    });
    return {
      isSupported,
      language
    };
  };
  function useNetwork(options = {}) {
    const { window: window2 = defaultWindow } = options;
    const navigator2 = window2 == null ? void 0 : window2.navigator;
    const isSupported = Boolean(navigator2 && "connection" in navigator2);
    const isOnline = vueDemi2.ref(true);
    const saveData = vueDemi2.ref(false);
    const offlineAt = vueDemi2.ref(void 0);
    const downlink = vueDemi2.ref(void 0);
    const downlinkMax = vueDemi2.ref(void 0);
    const rtt = vueDemi2.ref(void 0);
    const effectiveType = vueDemi2.ref(void 0);
    const type4 = vueDemi2.ref("unknown");
    const connection2 = isSupported && navigator2.connection;
    function updateNetworkInformation() {
      if (!navigator2)
        return;
      isOnline.value = navigator2.onLine;
      offlineAt.value = isOnline.value ? void 0 : Date.now();
      if (connection2) {
        downlink.value = connection2.downlink;
        downlinkMax.value = connection2.downlinkMax;
        effectiveType.value = connection2.effectiveType;
        rtt.value = connection2.rtt;
        saveData.value = connection2.saveData;
        type4.value = connection2.type;
      }
    }
    if (window2) {
      useEventListener(window2, "offline", () => {
        isOnline.value = false;
        offlineAt.value = Date.now();
      });
      useEventListener(window2, "online", () => {
        isOnline.value = true;
      });
    }
    if (connection2)
      useEventListener(connection2, "change", updateNetworkInformation, false);
    updateNetworkInformation();
    return {
      isSupported,
      isOnline,
      saveData,
      offlineAt,
      downlink,
      downlinkMax,
      effectiveType,
      rtt,
      type: type4
    };
  }
  var __defProp$62 = Object.defineProperty;
  var __getOwnPropSymbols$62 = Object.getOwnPropertySymbols;
  var __hasOwnProp$62 = Object.prototype.hasOwnProperty;
  var __propIsEnum$62 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$62 = (obj, key2, value) => key2 in obj ? __defProp$62(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$62 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$62.call(b2, prop))
        __defNormalProp$62(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$62)
      for (var prop of __getOwnPropSymbols$62(b2)) {
        if (__propIsEnum$62.call(b2, prop))
          __defNormalProp$62(a2, prop, b2[prop]);
      }
    return a2;
  };
  function useNow(options = {}) {
    const {
      controls: exposeControls = false,
      interval = "requestAnimationFrame"
    } = options;
    const now2 = vueDemi2.ref(new Date());
    const update3 = () => now2.value = new Date();
    const controls = interval === "requestAnimationFrame" ? useRafFn(update3, { immediate: true }) : shared2.useIntervalFn(update3, interval, { immediate: true });
    if (exposeControls) {
      return __spreadValues$62({
        now: now2
      }, controls);
    } else {
      return now2;
    }
  }
  function useOnline(options = {}) {
    const { isOnline } = useNetwork(options);
    return isOnline;
  }
  function usePageLeave(options = {}) {
    const { window: window2 = defaultWindow } = options;
    const isLeft = vueDemi2.ref(false);
    const handler = (event) => {
      if (!window2)
        return;
      event = event || window2.event;
      const from = event.relatedTarget || event.toElement;
      isLeft.value = !from;
    };
    if (window2) {
      useEventListener(window2, "mouseout", handler, { passive: true });
      useEventListener(window2.document, "mouseleave", handler, { passive: true });
      useEventListener(window2.document, "mouseenter", handler, { passive: true });
    }
    return isLeft;
  }
  function useParallax(target2, options = {}) {
    const {
      deviceOrientationTiltAdjust = (i) => i,
      deviceOrientationRollAdjust = (i) => i,
      mouseTiltAdjust = (i) => i,
      mouseRollAdjust = (i) => i,
      window: window2 = defaultWindow
    } = options;
    const orientation = vueDemi2.reactive(useDeviceOrientation({ window: window2 }));
    const {
      elementX: x2,
      elementY: y,
      elementWidth: width,
      elementHeight: height
    } = useMouseInElement(target2, { handleOutside: false, window: window2 });
    const source2 = vueDemi2.computed(() => {
      if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))
        return "deviceOrientation";
      return "mouse";
    });
    const roll = vueDemi2.computed(() => {
      if (source2.value === "deviceOrientation") {
        const value = -orientation.beta / 90;
        return deviceOrientationRollAdjust(value);
      } else {
        const value = -(y.value - height.value / 2) / height.value;
        return mouseRollAdjust(value);
      }
    });
    const tilt = vueDemi2.computed(() => {
      if (source2.value === "deviceOrientation") {
        const value = orientation.gamma / 90;
        return deviceOrientationTiltAdjust(value);
      } else {
        const value = (x2.value - width.value / 2) / width.value;
        return mouseTiltAdjust(value);
      }
    });
    return { roll, tilt, source: source2 };
  }
  var __defProp$52 = Object.defineProperty;
  var __defProps$22 = Object.defineProperties;
  var __getOwnPropDescs$22 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$52 = Object.getOwnPropertySymbols;
  var __hasOwnProp$52 = Object.prototype.hasOwnProperty;
  var __propIsEnum$52 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$52 = (obj, key2, value) => key2 in obj ? __defProp$52(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$52 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$52.call(b2, prop))
        __defNormalProp$52(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$52)
      for (var prop of __getOwnPropSymbols$52(b2)) {
        if (__propIsEnum$52.call(b2, prop))
          __defNormalProp$52(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps$22 = (a2, b2) => __defProps$22(a2, __getOwnPropDescs$22(b2));
  const defaultState = {
    x: 0,
    y: 0,
    pointerId: 0,
    pressure: 0,
    tiltX: 0,
    tiltY: 0,
    width: 0,
    height: 0,
    twist: 0,
    pointerType: null
  };
  const keys2 = /* @__PURE__ */ Object.keys(defaultState);
  function usePointer(options = {}) {
    const {
      target: target2 = defaultWindow
    } = options;
    const isInside = vueDemi2.ref(false);
    const state = vueDemi2.ref(options.initialValue || {});
    Object.assign(state.value, defaultState, state.value);
    const handler = (event) => {
      isInside.value = true;
      if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
        return;
      state.value = shared2.objectPick(event, keys2, false);
    };
    if (target2) {
      useEventListener(target2, "pointerdown", handler, { passive: true });
      useEventListener(target2, "pointermove", handler, { passive: true });
      useEventListener(target2, "pointerleave", () => isInside.value = false, { passive: true });
    }
    return __spreadProps$22(__spreadValues$52({}, shared2.toRefs(state)), {
      isInside
    });
  }
  var SwipeDirection = /* @__PURE__ */ ((SwipeDirection2) => {
    SwipeDirection2["UP"] = "UP";
    SwipeDirection2["RIGHT"] = "RIGHT";
    SwipeDirection2["DOWN"] = "DOWN";
    SwipeDirection2["LEFT"] = "LEFT";
    SwipeDirection2["NONE"] = "NONE";
    return SwipeDirection2;
  })(SwipeDirection || {});
  function useSwipe(target2, options = {}) {
    const {
      threshold = 50,
      onSwipe,
      onSwipeEnd,
      onSwipeStart,
      passive: passive2 = true,
      window: window2 = defaultWindow
    } = options;
    const coordsStart = vueDemi2.reactive({ x: 0, y: 0 });
    const coordsEnd = vueDemi2.reactive({ x: 0, y: 0 });
    const diffX = vueDemi2.computed(() => coordsStart.x - coordsEnd.x);
    const diffY = vueDemi2.computed(() => coordsStart.y - coordsEnd.y);
    const { max: max2, abs } = Math;
    const isThresholdExceeded = vueDemi2.computed(() => max2(abs(diffX.value), abs(diffY.value)) >= threshold);
    const isSwiping = vueDemi2.ref(false);
    const direction2 = vueDemi2.computed(() => {
      if (!isThresholdExceeded.value)
        return "NONE";
      if (abs(diffX.value) > abs(diffY.value)) {
        return diffX.value > 0 ? "LEFT" : "RIGHT";
      } else {
        return diffY.value > 0 ? "UP" : "DOWN";
      }
    });
    const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];
    const updateCoordsStart = (x2, y) => {
      coordsStart.x = x2;
      coordsStart.y = y;
    };
    const updateCoordsEnd = (x2, y) => {
      coordsEnd.x = x2;
      coordsEnd.y = y;
    };
    let listenerOptions;
    const isPassiveEventSupported = checkPassiveEventSupport(window2 == null ? void 0 : window2.document);
    if (!passive2)
      listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };
    else
      listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };
    const onTouchEnd = (e) => {
      if (isSwiping.value)
        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction2.value);
      isSwiping.value = false;
    };
    const stops = [
      useEventListener(target2, "touchstart", (e) => {
        if (listenerOptions.capture && !listenerOptions.passive)
          e.preventDefault();
        const [x2, y] = getTouchEventCoords(e);
        updateCoordsStart(x2, y);
        updateCoordsEnd(x2, y);
        onSwipeStart == null ? void 0 : onSwipeStart(e);
      }, listenerOptions),
      useEventListener(target2, "touchmove", (e) => {
        const [x2, y] = getTouchEventCoords(e);
        updateCoordsEnd(x2, y);
        if (!isSwiping.value && isThresholdExceeded.value)
          isSwiping.value = true;
        if (isSwiping.value)
          onSwipe == null ? void 0 : onSwipe(e);
      }, listenerOptions),
      useEventListener(target2, "touchend", onTouchEnd, listenerOptions),
      useEventListener(target2, "touchcancel", onTouchEnd, listenerOptions)
    ];
    const stop2 = () => stops.forEach((s2) => s2());
    return {
      isPassiveEventSupported,
      isSwiping,
      direction: direction2,
      coordsStart,
      coordsEnd,
      lengthX: diffX,
      lengthY: diffY,
      stop: stop2
    };
  }
  function checkPassiveEventSupport(document2) {
    if (!document2)
      return false;
    let supportsPassive = false;
    const optionsBlock = {
      get passive() {
        supportsPassive = true;
        return false;
      }
    };
    document2.addEventListener("x", shared2.noop, optionsBlock);
    document2.removeEventListener("x", shared2.noop);
    return supportsPassive;
  }
  function usePointerSwipe(target2, options = {}) {
    const targetRef = vueDemi2.ref(target2);
    const {
      threshold = 50,
      onSwipe,
      onSwipeEnd,
      onSwipeStart
    } = options;
    const posStart = vueDemi2.reactive({ x: 0, y: 0 });
    const updatePosStart = (x2, y) => {
      posStart.x = x2;
      posStart.y = y;
    };
    const posEnd = vueDemi2.reactive({ x: 0, y: 0 });
    const updatePosEnd = (x2, y) => {
      posEnd.x = x2;
      posEnd.y = y;
    };
    const distanceX = vueDemi2.computed(() => posStart.x - posEnd.x);
    const distanceY = vueDemi2.computed(() => posStart.y - posEnd.y);
    const { max: max2, abs } = Math;
    const isThresholdExceeded = vueDemi2.computed(() => max2(abs(distanceX.value), abs(distanceY.value)) >= threshold);
    const isSwiping = vueDemi2.ref(false);
    const isPointerDown = vueDemi2.ref(false);
    const direction2 = vueDemi2.computed(() => {
      if (!isThresholdExceeded.value)
        return SwipeDirection.NONE;
      if (abs(distanceX.value) > abs(distanceY.value)) {
        return distanceX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;
      } else {
        return distanceY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;
      }
    });
    const filterEvent = (e) => {
      if (options.pointerTypes)
        return options.pointerTypes.includes(e.pointerType);
      return true;
    };
    const stops = [
      useEventListener(target2, "pointerdown", (e) => {
        var _a2, _b2;
        if (!filterEvent(e))
          return;
        isPointerDown.value = true;
        (_b2 = (_a2 = targetRef.value) == null ? void 0 : _a2.style) == null ? void 0 : _b2.setProperty("touch-action", "none");
        const eventTarget = e.target;
        eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);
        const { clientX: x2, clientY: y } = e;
        updatePosStart(x2, y);
        updatePosEnd(x2, y);
        onSwipeStart == null ? void 0 : onSwipeStart(e);
      }),
      useEventListener(target2, "pointermove", (e) => {
        if (!filterEvent(e))
          return;
        if (!isPointerDown.value)
          return;
        const { clientX: x2, clientY: y } = e;
        updatePosEnd(x2, y);
        if (!isSwiping.value && isThresholdExceeded.value)
          isSwiping.value = true;
        if (isSwiping.value)
          onSwipe == null ? void 0 : onSwipe(e);
      }),
      useEventListener(target2, "pointerup", (e) => {
        var _a2, _b2;
        if (!filterEvent(e))
          return;
        if (isSwiping.value)
          onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction2.value);
        isPointerDown.value = false;
        isSwiping.value = false;
        (_b2 = (_a2 = targetRef.value) == null ? void 0 : _a2.style) == null ? void 0 : _b2.setProperty("touch-action", "initial");
      })
    ];
    const stop2 = () => stops.forEach((s2) => s2());
    return {
      isSwiping: vueDemi2.readonly(isSwiping),
      direction: vueDemi2.readonly(direction2),
      posStart: vueDemi2.readonly(posStart),
      posEnd: vueDemi2.readonly(posEnd),
      distanceX,
      distanceY,
      stop: stop2
    };
  }
  function usePreferredColorScheme(options) {
    const isLight = useMediaQuery("(prefers-color-scheme: light)", options);
    const isDark = useMediaQuery("(prefers-color-scheme: dark)", options);
    return vueDemi2.computed(() => {
      if (isDark.value)
        return "dark";
      if (isLight.value)
        return "light";
      return "no-preference";
    });
  }
  function usePreferredLanguages(options = {}) {
    const { window: window2 = defaultWindow } = options;
    if (!window2)
      return vueDemi2.ref(["en"]);
    const navigator2 = window2.navigator;
    const value = vueDemi2.ref(navigator2.languages);
    useEventListener(window2, "languagechange", () => {
      value.value = navigator2.languages;
    });
    return value;
  }
  const topVarName = "--vueuse-safe-area-top";
  const rightVarName = "--vueuse-safe-area-right";
  const bottomVarName = "--vueuse-safe-area-bottom";
  const leftVarName = "--vueuse-safe-area-left";
  function useScreenSafeArea() {
    const top2 = vueDemi2.ref("");
    const right2 = vueDemi2.ref("");
    const bottom2 = vueDemi2.ref("");
    const left2 = vueDemi2.ref("");
    if (core2.isClient) {
      const topCssVar = core2.useCssVar(topVarName);
      const rightCssVar = core2.useCssVar(rightVarName);
      const bottomCssVar = core2.useCssVar(bottomVarName);
      const leftCssVar = core2.useCssVar(leftVarName);
      topCssVar.value = "env(safe-area-inset-top, 0px)";
      rightCssVar.value = "env(safe-area-inset-right, 0px)";
      bottomCssVar.value = "env(safe-area-inset-bottom, 0px)";
      leftCssVar.value = "env(safe-area-inset-left, 0px)";
      update3();
      core2.useEventListener("resize", core2.useDebounceFn(update3));
    }
    function update3() {
      top2.value = getValue2(topVarName);
      right2.value = getValue2(rightVarName);
      bottom2.value = getValue2(bottomVarName);
      left2.value = getValue2(leftVarName);
    }
    return {
      top: top2,
      right: right2,
      bottom: bottom2,
      left: left2,
      update: update3
    };
  }
  function getValue2(position2) {
    return getComputedStyle(document.documentElement).getPropertyValue(position2);
  }
  function useScriptTag(src2, onLoaded = shared2.noop, options = {}) {
    const {
      immediate = true,
      manual = false,
      type: type4 = "text/javascript",
      async = true,
      crossOrigin,
      referrerPolicy,
      noModule,
      defer,
      document: document2 = defaultDocument
    } = options;
    const scriptTag = vueDemi2.ref(null);
    let _promise = null;
    const loadScript = (waitForScriptLoad) => new Promise((resolve2, reject) => {
      const resolveWithElement = (el2) => {
        scriptTag.value = el2;
        resolve2(el2);
        return el2;
      };
      if (!document2) {
        resolve2(false);
        return;
      }
      let shouldAppend = false;
      let el = document2.querySelector(`script[src="${src2}"]`);
      if (!el) {
        el = document2.createElement("script");
        el.type = type4;
        el.async = async;
        el.src = vueDemi2.unref(src2);
        if (defer)
          el.defer = defer;
        if (crossOrigin)
          el.crossOrigin = crossOrigin;
        if (noModule)
          el.noModule = noModule;
        if (referrerPolicy)
          el.referrerPolicy = referrerPolicy;
        shouldAppend = true;
      } else if (el.hasAttribute("data-loaded")) {
        resolveWithElement(el);
      }
      el.addEventListener("error", (event) => reject(event));
      el.addEventListener("abort", (event) => reject(event));
      el.addEventListener("load", () => {
        el.setAttribute("data-loaded", "true");
        onLoaded(el);
        resolveWithElement(el);
      });
      if (shouldAppend)
        el = document2.head.appendChild(el);
      if (!waitForScriptLoad)
        resolveWithElement(el);
    });
    const load = (waitForScriptLoad = true) => {
      if (!_promise)
        _promise = loadScript(waitForScriptLoad);
      return _promise;
    };
    const unload = () => {
      if (!document2)
        return;
      _promise = null;
      if (scriptTag.value) {
        document2.head.removeChild(scriptTag.value);
        scriptTag.value = null;
      }
    };
    if (immediate && !manual)
      shared2.tryOnMounted(load);
    if (!manual)
      shared2.tryOnUnmounted(unload);
    return { scriptTag, load, unload };
  }
  function useScroll(element, options = {}) {
    const {
      throttle: throttle2 = 0,
      idle = 200,
      onStop = shared2.noop,
      onScroll = shared2.noop,
      offset: offset2 = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      },
      eventListenerOptions = {
        capture: false,
        passive: true
      }
    } = options;
    const x2 = vueDemi2.ref(0);
    const y = vueDemi2.ref(0);
    const isScrolling = vueDemi2.ref(false);
    const arrivedState = vueDemi2.reactive({
      left: true,
      right: false,
      top: true,
      bottom: false
    });
    const directions = vueDemi2.reactive({
      left: false,
      right: false,
      top: false,
      bottom: false
    });
    if (element) {
      const onScrollEnd = shared2.useDebounceFn((e) => {
        isScrolling.value = false;
        directions.left = false;
        directions.right = false;
        directions.top = false;
        directions.bottom = false;
        onStop(e);
      }, throttle2 + idle);
      const onScrollHandler = (e) => {
        const eventTarget = e.target === document ? e.target.documentElement : e.target;
        const scrollLeft = eventTarget.scrollLeft;
        directions.left = scrollLeft < x2.value;
        directions.right = scrollLeft > x2.value;
        arrivedState.left = scrollLeft <= 0 + (offset2.left || 0);
        arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset2.right || 0);
        x2.value = scrollLeft;
        const scrollTop = eventTarget.scrollTop;
        directions.top = scrollTop < y.value;
        directions.bottom = scrollTop > y.value;
        arrivedState.top = scrollTop <= 0 + (offset2.top || 0);
        arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset2.bottom || 0);
        y.value = scrollTop;
        isScrolling.value = true;
        onScrollEnd(e);
        onScroll(e);
      };
      useEventListener(element, "scroll", throttle2 ? shared2.useThrottleFn(onScrollHandler, throttle2) : onScrollHandler, eventListenerOptions);
    }
    return {
      x: x2,
      y,
      isScrolling,
      arrivedState,
      directions
    };
  }
  var _a, _b;
  function preventDefault(rawEvent) {
    const e = rawEvent || window.event;
    if (e.touches.length > 1)
      return true;
    if (e.preventDefault)
      e.preventDefault();
    return false;
  }
  const isIOS = shared2.isClient && (window == null ? void 0 : window.navigator) && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.platform) && /iP(ad|hone|od)/.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.platform);
  function useScrollLock(element, initialState2 = false) {
    const isLocked = vueDemi2.ref(initialState2);
    let touchMoveListener = null;
    let initialOverflow;
    const lock2 = () => {
      const ele = vueDemi2.unref(element);
      if (!ele || isLocked.value)
        return;
      initialOverflow = ele.style.overflow;
      if (isIOS) {
        touchMoveListener = useEventListener(document, "touchmove", preventDefault, { passive: false });
      }
      ele.style.overflow = "hidden";
      isLocked.value = true;
    };
    const unlock2 = () => {
      const ele = vueDemi2.unref(element);
      if (!ele || !isLocked.value)
        return;
      isIOS && (touchMoveListener == null ? void 0 : touchMoveListener());
      ele.style.overflow = initialOverflow;
      isLocked.value = false;
    };
    return vueDemi2.computed({
      get() {
        return isLocked.value;
      },
      set(v2) {
        if (v2)
          lock2();
        else
          unlock2();
      }
    });
  }
  function useSessionStorage(key2, initialValue, options = {}) {
    const { window: window2 = defaultWindow } = options;
    return useStorage(key2, initialValue, window2 == null ? void 0 : window2.sessionStorage, options);
  }
  var __defProp$42 = Object.defineProperty;
  var __getOwnPropSymbols$42 = Object.getOwnPropertySymbols;
  var __hasOwnProp$42 = Object.prototype.hasOwnProperty;
  var __propIsEnum$42 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$42 = (obj, key2, value) => key2 in obj ? __defProp$42(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$42 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$42.call(b2, prop))
        __defNormalProp$42(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$42)
      for (var prop of __getOwnPropSymbols$42(b2)) {
        if (__propIsEnum$42.call(b2, prop))
          __defNormalProp$42(a2, prop, b2[prop]);
      }
    return a2;
  };
  function useShare(shareOptions = {}, options = {}) {
    const { navigator: navigator2 = defaultNavigator } = options;
    const _navigator = navigator2;
    const isSupported = _navigator && "canShare" in _navigator;
    const share2 = async (overrideOptions = {}) => {
      if (isSupported) {
        const data2 = __spreadValues$42(__spreadValues$42({}, vueDemi2.unref(shareOptions)), vueDemi2.unref(overrideOptions));
        let granted = true;
        if (data2.files && _navigator.canShare)
          granted = _navigator.canShare({ files: data2.files });
        if (granted)
          return _navigator.share(data2);
      }
    };
    return {
      isSupported,
      share: share2
    };
  }
  function useSpeechRecognition(options = {}) {
    const {
      interimResults = true,
      continuous = true,
      window: window2 = defaultWindow
    } = options;
    const lang = vueDemi2.ref(options.lang || "en-US");
    const isListening = vueDemi2.ref(false);
    const isFinal = vueDemi2.ref(false);
    const result3 = vueDemi2.ref("");
    const error2 = vueDemi2.shallowRef(void 0);
    const toggle = (value = !isListening.value) => {
      isListening.value = value;
    };
    const start2 = () => {
      isListening.value = true;
    };
    const stop2 = () => {
      isListening.value = false;
    };
    const SpeechRecognition = window2 && (window2.SpeechRecognition || window2.webkitSpeechRecognition);
    const isSupported = Boolean(SpeechRecognition);
    let recognition;
    if (isSupported) {
      recognition = new SpeechRecognition();
      recognition.continuous = continuous;
      recognition.interimResults = interimResults;
      recognition.lang = vueDemi2.unref(lang);
      recognition.onstart = () => {
        isFinal.value = false;
      };
      vueDemi2.watch(lang, (lang2) => {
        if (recognition && !isListening.value)
          recognition.lang = lang2;
      });
      recognition.onresult = (event) => {
        const transcript = Array.from(event.results).map((result22) => {
          isFinal.value = result22.isFinal;
          return result22[0];
        }).map((result22) => result22.transcript).join("");
        result3.value = transcript;
        error2.value = void 0;
      };
      recognition.onerror = (event) => {
        error2.value = event;
      };
      recognition.onend = () => {
        isListening.value = false;
        recognition.lang = vueDemi2.unref(lang);
      };
      vueDemi2.watch(isListening, () => {
        if (isListening.value)
          recognition.start();
        else
          recognition.stop();
      });
    }
    shared2.tryOnScopeDispose(() => {
      isListening.value = false;
    });
    return {
      isSupported,
      isListening,
      isFinal,
      recognition,
      result: result3,
      error: error2,
      toggle,
      start: start2,
      stop: stop2
    };
  }
  function useSpeechSynthesis(text, options = {}) {
    var _a2, _b2;
    const {
      pitch = 1,
      rate: rate3 = 1,
      volume = 1,
      window: window2 = defaultWindow
    } = options;
    const synth = window2 && window2.speechSynthesis;
    const isSupported = Boolean(synth);
    const isPlaying = vueDemi2.ref(false);
    const status = vueDemi2.ref("init");
    const voiceInfo = {
      lang: ((_a2 = options.voice) == null ? void 0 : _a2.lang) || "default",
      name: ((_b2 = options.voice) == null ? void 0 : _b2.name) || ""
    };
    const spokenText = vueDemi2.ref(text || "");
    const lang = vueDemi2.ref(options.lang || "en-US");
    const error2 = vueDemi2.shallowRef(void 0);
    const toggle = (value = !isPlaying.value) => {
      isPlaying.value = value;
    };
    const bindEventsForUtterance = (utterance2) => {
      utterance2.lang = vueDemi2.unref(lang);
      options.voice && (utterance2.voice = options.voice);
      utterance2.pitch = pitch;
      utterance2.rate = rate3;
      utterance2.volume = volume;
      utterance2.onstart = () => {
        isPlaying.value = true;
        status.value = "play";
      };
      utterance2.onpause = () => {
        isPlaying.value = false;
        status.value = "pause";
      };
      utterance2.onresume = () => {
        isPlaying.value = true;
        status.value = "play";
      };
      utterance2.onend = () => {
        isPlaying.value = false;
        status.value = "end";
      };
      utterance2.onerror = (event) => {
        error2.value = event;
      };
      utterance2.onend = () => {
        isPlaying.value = false;
        utterance2.lang = vueDemi2.unref(lang);
      };
    };
    const utterance = vueDemi2.computed(() => {
      isPlaying.value = false;
      status.value = "init";
      const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
      bindEventsForUtterance(newUtterance);
      return newUtterance;
    });
    const speak = () => {
      synth.cancel();
      utterance && synth.speak(utterance.value);
    };
    if (isSupported) {
      bindEventsForUtterance(utterance.value);
      vueDemi2.watch(lang, (lang2) => {
        if (utterance.value && !isPlaying.value)
          utterance.value.lang = lang2;
      });
      vueDemi2.watch(isPlaying, () => {
        if (isPlaying.value)
          synth.resume();
        else
          synth.pause();
      });
    }
    shared2.tryOnScopeDispose(() => {
      isPlaying.value = false;
    });
    return {
      isSupported,
      isPlaying,
      status,
      voiceInfo,
      utterance,
      error: error2,
      toggle,
      speak
    };
  }
  function useStorageAsync(key2, initialValue, storage = ((_a2) => (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage)(), options = {}) {
    var _a2;
    const {
      flush = "pre",
      deep = true,
      listenToStorageChanges = true,
      writeDefaults = true,
      shallow,
      window: window2 = defaultWindow,
      eventFilter,
      onError = (e) => {
        console.error(e);
      }
    } = options;
    const rawInit = vueDemi2.unref(initialValue);
    const type4 = guessSerializerType(rawInit);
    const data2 = (shallow ? vueDemi2.shallowRef : vueDemi2.ref)(initialValue);
    const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type4];
    async function read2(event) {
      if (!storage || event && event.key !== key2)
        return;
      try {
        const rawValue = event ? event.newValue : await storage.getItem(key2);
        if (rawValue == null) {
          data2.value = rawInit;
          if (writeDefaults && rawInit !== null)
            await storage.setItem(key2, await serializer.write(rawInit));
        } else {
          data2.value = await serializer.read(rawValue);
        }
      } catch (e) {
        onError(e);
      }
    }
    read2();
    if (window2 && listenToStorageChanges)
      useEventListener(window2, "storage", (e) => setTimeout(() => read2(e), 0));
    if (storage) {
      shared2.watchWithFilter(data2, async () => {
        try {
          if (data2.value == null)
            await storage.removeItem(key2);
          else
            await storage.setItem(key2, await serializer.write(data2.value));
        } catch (e) {
          onError(e);
        }
      }, {
        flush,
        deep,
        eventFilter
      });
    }
    return data2;
  }
  function useTemplateRefsList() {
    const refs = vueDemi2.ref([]);
    refs.value.set = (el) => {
      if (el)
        refs.value.push(el);
    };
    vueDemi2.onBeforeUpdate(() => {
      refs.value.length = 0;
    });
    return refs;
  }
  var __defProp$32 = Object.defineProperty;
  var __defProps$12 = Object.defineProperties;
  var __getOwnPropDescs$12 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$32 = Object.getOwnPropertySymbols;
  var __hasOwnProp$32 = Object.prototype.hasOwnProperty;
  var __propIsEnum$32 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$32 = (obj, key2, value) => key2 in obj ? __defProp$32(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$32 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$32.call(b2, prop))
        __defNormalProp$32(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$32)
      for (var prop of __getOwnPropSymbols$32(b2)) {
        if (__propIsEnum$32.call(b2, prop))
          __defNormalProp$32(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps$12 = (a2, b2) => __defProps$12(a2, __getOwnPropDescs$12(b2));
  const initialRect = {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    height: 0,
    width: 0
  };
  const initialState = __spreadValues$32({
    text: ""
  }, initialRect);
  function getRectFromSelection(selection) {
    if (!selection || selection.rangeCount < 1)
      return initialRect;
    const range3 = selection.getRangeAt(0);
    const { height, width, top: top2, left: left2, right: right2, bottom: bottom2 } = range3.getBoundingClientRect();
    return {
      height,
      width,
      top: top2,
      left: left2,
      right: right2,
      bottom: bottom2
    };
  }
  function useTextSelection(element) {
    const state = vueDemi2.ref(initialState);
    if (!(window == null ? void 0 : window.getSelection))
      return state;
    const onMouseup = () => {
      var _a2;
      const text = (_a2 = window.getSelection()) == null ? void 0 : _a2.toString();
      if (text) {
        const rect = getRectFromSelection(window.getSelection());
        state.value = __spreadProps$12(__spreadValues$32(__spreadValues$32({}, state.value), rect), {
          text
        });
      }
    };
    const onMousedown = () => {
      var _a2;
      state.value.text && (state.value = initialState);
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
    };
    useEventListener(element != null ? element : document, "mouseup", onMouseup);
    useEventListener(document, "mousedown", onMousedown);
    return state;
  }
  var __defProp$22 = Object.defineProperty;
  var __defProps3 = Object.defineProperties;
  var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$22 = Object.getOwnPropertySymbols;
  var __hasOwnProp$22 = Object.prototype.hasOwnProperty;
  var __propIsEnum$22 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$22 = (obj, key2, value) => key2 in obj ? __defProp$22(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$22 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$22.call(b2, prop))
        __defNormalProp$22(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$22)
      for (var prop of __getOwnPropSymbols$22(b2)) {
        if (__propIsEnum$22.call(b2, prop))
          __defNormalProp$22(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps3 = (a2, b2) => __defProps3(a2, __getOwnPropDescs3(b2));
  function useThrottledRefHistory(source2, options = {}) {
    const { throttle: throttle2 = 200, trailing = true } = options;
    const filter2 = shared2.throttleFilter(throttle2, trailing);
    const history2 = useRefHistory(source2, __spreadProps3(__spreadValues$22({}, options), { eventFilter: filter2 }));
    return __spreadValues$22({}, history2);
  }
  var __defProp$12 = Object.defineProperty;
  var __getOwnPropSymbols$12 = Object.getOwnPropertySymbols;
  var __hasOwnProp$12 = Object.prototype.hasOwnProperty;
  var __propIsEnum$12 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$12 = (obj, key2, value) => key2 in obj ? __defProp$12(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues$12 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp$12.call(b2, prop))
        __defNormalProp$12(a2, prop, b2[prop]);
    if (__getOwnPropSymbols$12)
      for (var prop of __getOwnPropSymbols$12(b2)) {
        if (__propIsEnum$12.call(b2, prop))
          __defNormalProp$12(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __objRest2 = (source2, exclude) => {
    var target2 = {};
    for (var prop in source2)
      if (__hasOwnProp$12.call(source2, prop) && exclude.indexOf(prop) < 0)
        target2[prop] = source2[prop];
    if (source2 != null && __getOwnPropSymbols$12)
      for (var prop of __getOwnPropSymbols$12(source2)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$12.call(source2, prop))
          target2[prop] = source2[prop];
      }
    return target2;
  };
  const UNITS = [
    { max: 6e4, value: 1e3, name: "second" },
    { max: 276e4, value: 6e4, name: "minute" },
    { max: 72e6, value: 36e5, name: "hour" },
    { max: 5184e5, value: 864e5, name: "day" },
    { max: 24192e5, value: 6048e5, name: "week" },
    { max: 28512e6, value: 2592e6, name: "month" },
    { max: Infinity, value: 31536e6, name: "year" }
  ];
  const DEFAULT_MESSAGES = {
    justNow: "just now",
    past: (n) => n.match(/\d/) ? `${n} ago` : n,
    future: (n) => n.match(/\d/) ? `in ${n}` : n,
    month: (n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`,
    year: (n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`,
    day: (n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`,
    week: (n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`,
    hour: (n) => `${n} hour${n > 1 ? "s" : ""}`,
    minute: (n) => `${n} minute${n > 1 ? "s" : ""}`,
    second: (n) => `${n} second${n > 1 ? "s" : ""}`
  };
  const DEFAULT_FORMATTER = (date4) => date4.toISOString().slice(0, 10);
  function useTimeAgo(time, options = {}) {
    const {
      controls: exposeControls = false,
      max: max2,
      updateInterval = 3e4,
      messages: messages2 = DEFAULT_MESSAGES,
      fullDateFormatter = DEFAULT_FORMATTER
    } = options;
    const { abs, round: round2 } = Math;
    const _a2 = useNow({ interval: updateInterval, controls: true }), { now: now2 } = _a2, controls = __objRest2(_a2, ["now"]);
    function getTimeago(from, now22) {
      var _a22;
      const diff = +now22 - +from;
      const absDiff = abs(diff);
      if (absDiff < 6e4)
        return messages2.justNow;
      if (typeof max2 === "number" && absDiff > max2)
        return fullDateFormatter(new Date(from));
      if (typeof max2 === "string") {
        const unitMax = (_a22 = UNITS.find((i) => i.name === max2)) == null ? void 0 : _a22.max;
        if (unitMax && absDiff > unitMax)
          return fullDateFormatter(new Date(from));
      }
      for (const unit of UNITS) {
        if (absDiff < unit.max)
          return format2(diff, unit);
      }
    }
    function applyFormat(name, val, isPast) {
      const formatter = messages2[name];
      if (typeof formatter === "function")
        return formatter(val, isPast);
      return formatter.replace("{0}", val.toString());
    }
    function format2(diff, unit) {
      const val = round2(abs(diff) / unit.value);
      const past = diff > 0;
      const str = applyFormat(unit.name, val, past);
      return applyFormat(past ? "past" : "future", str, past);
    }
    const timeAgo = vueDemi2.computed(() => getTimeago(new Date(vueDemi2.unref(time)), vueDemi2.unref(now2.value)));
    if (exposeControls) {
      return __spreadValues$12({
        timeAgo
      }, controls);
    } else {
      return timeAgo;
    }
  }
  var __defProp3 = Object.defineProperty;
  var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp3 = (obj, key2, value) => key2 in obj ? __defProp3(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues3 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp3.call(b2, prop))
        __defNormalProp3(a2, prop, b2[prop]);
    if (__getOwnPropSymbols3)
      for (var prop of __getOwnPropSymbols3(b2)) {
        if (__propIsEnum3.call(b2, prop))
          __defNormalProp3(a2, prop, b2[prop]);
      }
    return a2;
  };
  function useTimestamp(options = {}) {
    const {
      controls: exposeControls = false,
      offset: offset2 = 0,
      immediate = true,
      interval = "requestAnimationFrame"
    } = options;
    const ts = vueDemi2.ref(shared2.timestamp() + offset2);
    const update3 = () => ts.value = shared2.timestamp() + offset2;
    const controls = interval === "requestAnimationFrame" ? useRafFn(update3, { immediate }) : shared2.useIntervalFn(update3, interval, { immediate });
    if (exposeControls) {
      return __spreadValues3({
        timestamp: ts
      }, controls);
    } else {
      return ts;
    }
  }
  function useTitle(newTitle = null, options = {}) {
    var _a2, _b2;
    const {
      document: document2 = defaultDocument,
      observe = false
    } = options;
    const title = vueDemi2.ref((_a2 = newTitle != null ? newTitle : document2 == null ? void 0 : document2.title) != null ? _a2 : null);
    vueDemi2.watch(title, (t, o2) => {
      if (shared2.isString(t) && t !== o2 && document2)
        document2.title = t;
    }, { immediate: true });
    if (observe && document2) {
      useMutationObserver((_b2 = document2.head) == null ? void 0 : _b2.querySelector("title"), () => {
        if (document2 && document2.title !== title.value)
          title.value = document2.title;
      }, { childList: true });
    }
    return title;
  }
  const TransitionPresets = {
    linear: shared2.identity,
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInOutSine: [0.37, 0, 0.63, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInOutQuad: [0.45, 0, 0.55, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6]
  };
  function createEasingFunction([p0, p1, p2, p3]) {
    const a2 = (a1, a22) => 1 - 3 * a22 + 3 * a1;
    const b2 = (a1, a22) => 3 * a22 - 6 * a1;
    const c2 = (a1) => 3 * a1;
    const calcBezier = (t, a1, a22) => ((a2(a1, a22) * t + b2(a1, a22)) * t + c2(a1)) * t;
    const getSlope = (t, a1, a22) => 3 * a2(a1, a22) * t * t + 2 * b2(a1, a22) * t + c2(a1);
    const getTforX = (x2) => {
      let aGuessT = x2;
      for (let i = 0; i < 4; ++i) {
        const currentSlope = getSlope(aGuessT, p0, p2);
        if (currentSlope === 0)
          return aGuessT;
        const currentX = calcBezier(aGuessT, p0, p2) - x2;
        aGuessT -= currentX / currentSlope;
      }
      return aGuessT;
    };
    return (x2) => p0 === p1 && p2 === p3 ? x2 : calcBezier(getTforX(x2), p1, p3);
  }
  function useTransition(source2, options = {}) {
    const {
      delay = 0,
      disabled = false,
      duration = 1e3,
      onFinished = shared2.noop,
      onStarted = shared2.noop,
      transition = shared2.identity
    } = options;
    const currentTransition = vueDemi2.computed(() => {
      const t = vueDemi2.unref(transition);
      return shared2.isFunction(t) ? t : createEasingFunction(t);
    });
    const sourceValue = vueDemi2.computed(() => {
      const s2 = vueDemi2.unref(source2);
      return shared2.isNumber(s2) ? s2 : s2.map(vueDemi2.unref);
    });
    const sourceVector = vueDemi2.computed(() => shared2.isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value);
    const outputVector = vueDemi2.ref(sourceVector.value.slice(0));
    let currentDuration;
    let diffVector;
    let endAt;
    let startAt;
    let startVector;
    const { resume, pause } = useRafFn(() => {
      const now2 = Date.now();
      const progress3 = shared2.clamp(1 - (endAt - now2) / currentDuration, 0, 1);
      outputVector.value = startVector.map((val, i) => {
        var _a2;
        return val + ((_a2 = diffVector[i]) != null ? _a2 : 0) * currentTransition.value(progress3);
      });
      if (progress3 >= 1) {
        pause();
        onFinished();
      }
    }, { immediate: false });
    const start2 = () => {
      pause();
      currentDuration = vueDemi2.unref(duration);
      diffVector = outputVector.value.map((n, i) => {
        var _a2, _b2;
        return ((_a2 = sourceVector.value[i]) != null ? _a2 : 0) - ((_b2 = outputVector.value[i]) != null ? _b2 : 0);
      });
      startVector = outputVector.value.slice(0);
      startAt = Date.now();
      endAt = startAt + currentDuration;
      resume();
      onStarted();
    };
    const timeout = shared2.useTimeoutFn(start2, delay, { immediate: false });
    vueDemi2.watch(sourceVector, () => {
      if (vueDemi2.unref(disabled)) {
        outputVector.value = sourceVector.value.slice(0);
      } else {
        if (vueDemi2.unref(delay) <= 0)
          start2();
        else
          timeout.start();
      }
    }, { deep: true });
    return vueDemi2.computed(() => {
      const targetVector = vueDemi2.unref(disabled) ? sourceVector : outputVector;
      return shared2.isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value;
    });
  }
  function useUrlSearchParams(mode = "history", options = {}) {
    const {
      initialValue = {},
      removeNullishValues = true,
      removeFalsyValues = false,
      window: window2 = defaultWindow
    } = options;
    if (!window2)
      return vueDemi2.reactive(initialValue);
    const state = vueDemi2.reactive(initialValue);
    function getRawParams() {
      if (mode === "history") {
        return window2.location.search || "";
      } else if (mode === "hash") {
        const hash2 = window2.location.hash || "";
        const index2 = hash2.indexOf("?");
        return index2 > 0 ? hash2.slice(index2) : "";
      } else {
        return (window2.location.hash || "").replace(/^#/, "");
      }
    }
    function constructQuery(params) {
      const stringified = params.toString();
      if (mode === "history")
        return `${stringified ? `?${stringified}` : ""}${location.hash || ""}`;
      if (mode === "hash-params")
        return `${location.search || ""}${stringified ? `#${stringified}` : ""}`;
      const hash2 = window2.location.hash || "#";
      const index2 = hash2.indexOf("?");
      if (index2 > 0)
        return `${hash2.slice(0, index2)}${stringified ? `?${stringified}` : ""}`;
      return `${hash2}${stringified ? `?${stringified}` : ""}`;
    }
    function read2() {
      return new URLSearchParams(getRawParams());
    }
    function updateState(params) {
      const unusedKeys = new Set(Object.keys(state));
      for (const key2 of params.keys()) {
        const paramsForKey = params.getAll(key2);
        state[key2] = paramsForKey.length > 1 ? paramsForKey : params.get(key2) || "";
        unusedKeys.delete(key2);
      }
      Array.from(unusedKeys).forEach((key2) => delete state[key2]);
    }
    const { pause, resume } = shared2.pausableWatch(state, () => {
      const params = new URLSearchParams("");
      Object.keys(state).forEach((key2) => {
        const mapEntry = state[key2];
        if (Array.isArray(mapEntry))
          mapEntry.forEach((value) => params.append(key2, value));
        else if (removeNullishValues && mapEntry == null)
          params.delete(key2);
        else if (removeFalsyValues && !mapEntry)
          params.delete(key2);
        else
          params.set(key2, mapEntry);
      });
      write2(params);
    }, { deep: true });
    function write2(params, shouldUpdate) {
      pause();
      if (shouldUpdate)
        updateState(params);
      window2.history.replaceState({}, "", window2.location.pathname + constructQuery(params));
      resume();
    }
    function onChanged() {
      write2(read2(), true);
    }
    useEventListener(window2, "popstate", onChanged, false);
    if (mode !== "history")
      useEventListener(window2, "hashchange", onChanged, false);
    updateState(read2());
    return state;
  }
  function useUserMedia(options = {}) {
    var _a2, _b2, _c;
    const enabled = vueDemi2.ref((_a2 = options.enabled) != null ? _a2 : false);
    const autoSwitch = vueDemi2.ref((_b2 = options.autoSwitch) != null ? _b2 : true);
    const videoDeviceId = vueDemi2.ref(options.videoDeviceId);
    const audioDeviceId = vueDemi2.ref(options.audioDeviceId);
    const { navigator: navigator2 = defaultNavigator } = options;
    const isSupported = Boolean((_c = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _c.getUserMedia);
    const stream = vueDemi2.shallowRef();
    function getDeviceOptions(device) {
      if (device.value === "none" || device.value === false)
        return false;
      if (device.value == null)
        return true;
      return {
        deviceId: device.value
      };
    }
    async function _start() {
      if (!isSupported || stream.value)
        return;
      stream.value = await navigator2.mediaDevices.getUserMedia({
        video: getDeviceOptions(videoDeviceId),
        audio: getDeviceOptions(audioDeviceId)
      });
      return stream.value;
    }
    async function _stop() {
      var _a22;
      (_a22 = stream.value) == null ? void 0 : _a22.getTracks().forEach((t) => t.stop());
      stream.value = void 0;
    }
    function stop2() {
      _stop();
      enabled.value = false;
    }
    async function start2() {
      await _start();
      if (stream.value)
        enabled.value = true;
      return stream.value;
    }
    async function restart() {
      _stop();
      return await start2();
    }
    vueDemi2.watch(enabled, (v2) => {
      if (v2)
        _start();
      else
        _stop();
    }, { immediate: true });
    vueDemi2.watch([videoDeviceId, audioDeviceId], () => {
      if (autoSwitch.value && stream.value)
        restart();
    }, { immediate: true });
    return {
      isSupported,
      stream,
      start: start2,
      stop: stop2,
      restart,
      videoDeviceId,
      audioDeviceId,
      enabled,
      autoSwitch
    };
  }
  function useVModel(props2, key2, emit, options = {}) {
    var _a2, _b2, _c;
    const {
      passive: passive2 = false,
      eventName,
      deep = false
    } = options;
    const vm = vueDemi2.getCurrentInstance();
    const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm));
    let event = eventName;
    if (!key2) {
      if (vueDemi2.isVue2) {
        const modelOptions = (_c = (_b2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b2.$options) == null ? void 0 : _c.model;
        key2 = (modelOptions == null ? void 0 : modelOptions.value) || "value";
        if (!eventName)
          event = (modelOptions == null ? void 0 : modelOptions.event) || "input";
      } else {
        key2 = "modelValue";
      }
    }
    event = eventName || event || `update:${key2}`;
    if (passive2) {
      const proxy = vueDemi2.ref(props2[key2]);
      vueDemi2.watch(() => props2[key2], (v2) => proxy.value = v2);
      vueDemi2.watch(proxy, (v2) => {
        if (v2 !== props2[key2] || deep)
          _emit(event, v2);
      }, {
        deep
      });
      return proxy;
    } else {
      return vueDemi2.computed({
        get() {
          return props2[key2];
        },
        set(value) {
          _emit(event, value);
        }
      });
    }
  }
  function useVModels(props2, emit, options = {}) {
    const ret = {};
    for (const key2 in props2)
      ret[key2] = useVModel(props2, key2, emit, options);
    return ret;
  }
  function useVirtualList(list2, options) {
    const containerRef = vueDemi2.ref();
    const size2 = useElementSize(containerRef);
    const currentList = vueDemi2.ref([]);
    const source2 = vueDemi2.shallowRef(list2);
    const state = vueDemi2.ref({ start: 0, end: 10 });
    const { itemHeight, overscan = 5 } = options;
    const getViewCapacity = (containerHeight) => {
      if (typeof itemHeight === "number")
        return Math.ceil(containerHeight / itemHeight);
      const { start: start2 = 0 } = state.value;
      let sum = 0;
      let capacity = 0;
      for (let i = start2; i < source2.value.length; i++) {
        const height = itemHeight(i);
        sum += height;
        if (sum >= containerHeight) {
          capacity = i;
          break;
        }
      }
      return capacity - start2;
    };
    const getOffset = (scrollTop) => {
      if (typeof itemHeight === "number")
        return Math.floor(scrollTop / itemHeight) + 1;
      let sum = 0;
      let offset2 = 0;
      for (let i = 0; i < source2.value.length; i++) {
        const height = itemHeight(i);
        sum += height;
        if (sum >= scrollTop) {
          offset2 = i;
          break;
        }
      }
      return offset2 + 1;
    };
    const calculateRange = () => {
      const element = containerRef.value;
      if (element) {
        const offset2 = getOffset(element.scrollTop);
        const viewCapacity = getViewCapacity(element.clientHeight);
        const from = offset2 - overscan;
        const to = offset2 + viewCapacity + overscan;
        state.value = {
          start: from < 0 ? 0 : from,
          end: to > source2.value.length ? source2.value.length : to
        };
        currentList.value = source2.value.slice(state.value.start, state.value.end).map((ele, index2) => ({
          data: ele,
          index: index2 + state.value.start
        }));
      }
    };
    vueDemi2.watch([size2.width, size2.height, list2], () => {
      calculateRange();
    });
    const totalHeight = vueDemi2.computed(() => {
      if (typeof itemHeight === "number")
        return source2.value.length * itemHeight;
      return source2.value.reduce((sum, _2, index2) => sum + itemHeight(index2), 0);
    });
    const getDistanceTop = (index2) => {
      if (typeof itemHeight === "number") {
        const height2 = index2 * itemHeight;
        return height2;
      }
      const height = source2.value.slice(0, index2).reduce((sum, _2, i) => sum + itemHeight(i), 0);
      return height;
    };
    const scrollTo = (index2) => {
      if (containerRef.value) {
        containerRef.value.scrollTop = getDistanceTop(index2);
        calculateRange();
      }
    };
    const offsetTop = vueDemi2.computed(() => getDistanceTop(state.value.start));
    const wrapperProps = vueDemi2.computed(() => {
      return {
        style: {
          width: "100%",
          height: `${totalHeight.value - offsetTop.value}px`,
          marginTop: `${offsetTop.value}px`
        }
      };
    });
    const containerStyle = { overflowY: "auto" };
    return {
      list: currentList,
      scrollTo,
      containerProps: {
        ref: containerRef,
        onScroll: () => {
          calculateRange();
        },
        style: containerStyle
      },
      wrapperProps
    };
  }
  const useWakeLock = (options = {}) => {
    const { navigator: navigator2 = defaultNavigator, document: document2 = defaultDocument } = options;
    let wakeLock;
    const isSupported = navigator2 && "wakeLock" in navigator2;
    const isActive = vueDemi2.ref(false);
    async function onVisibilityChange() {
      if (!isSupported || !wakeLock)
        return;
      if (document2 && document2.visibilityState === "visible")
        wakeLock = await navigator2.wakeLock.request("screen");
      isActive.value = !wakeLock.released;
    }
    if (document2)
      useEventListener(document2, "visibilitychange", onVisibilityChange, { passive: true });
    async function request2(type4) {
      if (!isSupported)
        return;
      wakeLock = await navigator2.wakeLock.request(type4);
      isActive.value = !wakeLock.released;
    }
    async function release() {
      if (!isSupported || !wakeLock)
        return;
      await wakeLock.release();
      isActive.value = !wakeLock.released;
      wakeLock = null;
    }
    return {
      isSupported,
      isActive,
      request: request2,
      release
    };
  };
  function resolveNestedOptions(options) {
    if (options === true)
      return {};
    return options;
  }
  function useWebSocket(url2, options = {}) {
    const {
      onConnected,
      onDisconnected,
      onError,
      onMessage,
      immediate = true,
      autoClose = true,
      protocols = []
    } = options;
    const data2 = vueDemi2.ref(null);
    const status = vueDemi2.ref("CONNECTING");
    const wsRef = vueDemi2.ref();
    let heartbeatPause;
    let heartbeatResume;
    let explicitlyClosed = false;
    let retried = 0;
    let bufferedData = [];
    const close2 = (code2 = 1e3, reason) => {
      if (!wsRef.value)
        return;
      explicitlyClosed = true;
      heartbeatPause == null ? void 0 : heartbeatPause();
      wsRef.value.close(code2, reason);
    };
    const _sendBuffer = () => {
      if (bufferedData.length && wsRef.value && status.value === "OPEN") {
        for (const buffer2 of bufferedData)
          wsRef.value.send(buffer2);
        bufferedData = [];
      }
    };
    const send = (data22, useBuffer = true) => {
      if (!wsRef.value || status.value !== "OPEN") {
        if (useBuffer)
          bufferedData.push(data22);
        return false;
      }
      _sendBuffer();
      wsRef.value.send(data22);
      return true;
    };
    const _init = () => {
      const ws = new WebSocket(url2, protocols);
      wsRef.value = ws;
      status.value = "CONNECTING";
      explicitlyClosed = false;
      ws.onopen = () => {
        status.value = "OPEN";
        onConnected == null ? void 0 : onConnected(ws);
        heartbeatResume == null ? void 0 : heartbeatResume();
        _sendBuffer();
      };
      ws.onclose = (ev) => {
        status.value = "CLOSED";
        wsRef.value = void 0;
        onDisconnected == null ? void 0 : onDisconnected(ws, ev);
        if (!explicitlyClosed && options.autoReconnect) {
          const {
            retries = -1,
            delay = 1e3,
            onFailed
          } = resolveNestedOptions(options.autoReconnect);
          retried += 1;
          if (retries < 0 || retried < retries)
            setTimeout(_init, delay);
          else
            onFailed == null ? void 0 : onFailed();
        }
      };
      ws.onerror = (e) => {
        onError == null ? void 0 : onError(ws, e);
      };
      ws.onmessage = (e) => {
        data2.value = e.data;
        onMessage == null ? void 0 : onMessage(ws, e);
      };
    };
    if (options.heartbeat) {
      const {
        message: message3 = "ping",
        interval = 1e3
      } = resolveNestedOptions(options.heartbeat);
      const { pause, resume } = shared2.useIntervalFn(() => send(message3, false), interval, { immediate: false });
      heartbeatPause = pause;
      heartbeatResume = resume;
    }
    if (immediate)
      _init();
    if (autoClose) {
      useEventListener(window, "beforeunload", close2);
      shared2.tryOnScopeDispose(close2);
    }
    const open2 = () => {
      close2();
      retried = 0;
      _init();
    };
    return {
      data: data2,
      status,
      close: close2,
      send,
      open: open2,
      ws: wsRef
    };
  }
  function useWebWorker(url2, workerOptions, options = {}) {
    const {
      window: window2 = defaultWindow
    } = options;
    const data2 = vueDemi2.ref(null);
    const worker = vueDemi2.shallowRef();
    const post = function post2(val) {
      if (!worker.value)
        return;
      worker.value.postMessage(val);
    };
    const terminate = function terminate2() {
      if (!worker.value)
        return;
      worker.value.terminate();
    };
    if (window2) {
      worker.value = new window2.Worker(url2, workerOptions);
      worker.value.onmessage = (e) => {
        data2.value = e.data;
      };
      shared2.tryOnScopeDispose(() => {
        if (worker.value)
          worker.value.terminate();
      });
    }
    return {
      data: data2,
      post,
      terminate,
      worker
    };
  }
  const jobRunner = (userFunc) => (e) => {
    const userFuncArgs = e.data[0];
    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result3) => {
      postMessage(["SUCCESS", result3]);
    }).catch((error2) => {
      postMessage(["ERROR", error2]);
    });
  };
  const depsParser = (deps) => {
    if (deps.length === 0)
      return "";
    const depsString = deps.map((dep) => `${dep}`).toString();
    return `importScripts('${depsString}')`;
  };
  const createWorkerBlobUrl = (fn3, deps) => {
    const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn3})`;
    const blob = new Blob([blobCode], { type: "text/javascript" });
    const url2 = URL.createObjectURL(blob);
    return url2;
  };
  const useWebWorkerFn = (fn3, options = {}) => {
    const {
      dependencies = [],
      timeout,
      window: window2 = defaultWindow
    } = options;
    const worker = vueDemi2.ref();
    const workerStatus = vueDemi2.ref("PENDING");
    const promise = vueDemi2.ref({});
    const timeoutId = vueDemi2.ref();
    const workerTerminate = (status = "PENDING") => {
      if (worker.value && worker.value._url && window2) {
        worker.value.terminate();
        URL.revokeObjectURL(worker.value._url);
        promise.value = {};
        worker.value = void 0;
        window2.clearTimeout(timeoutId.value);
        workerStatus.value = status;
      }
    };
    workerTerminate();
    shared2.tryOnScopeDispose(workerTerminate);
    const generateWorker = () => {
      const blobUrl = createWorkerBlobUrl(fn3, dependencies);
      const newWorker = new Worker(blobUrl);
      newWorker._url = blobUrl;
      newWorker.onmessage = (e) => {
        const { resolve: resolve2 = () => {
        }, reject = () => {
        } } = promise.value;
        const [status, result3] = e.data;
        switch (status) {
          case "SUCCESS":
            resolve2(result3);
            workerTerminate(status);
            break;
          default:
            reject(result3);
            workerTerminate("ERROR");
            break;
        }
      };
      newWorker.onerror = (e) => {
        const { reject = () => {
        } } = promise.value;
        reject(e);
        workerTerminate("ERROR");
      };
      if (timeout) {
        timeoutId.value = setTimeout(() => workerTerminate("TIMEOUT_EXPIRED"), timeout);
      }
      return newWorker;
    };
    const callWorker = (...fnArgs) => new Promise((resolve2, reject) => {
      promise.value = {
        resolve: resolve2,
        reject
      };
      worker.value && worker.value.postMessage([[...fnArgs]]);
      workerStatus.value = "RUNNING";
    });
    const workerFn = (...fnArgs) => {
      if (workerStatus.value === "RUNNING") {
        console.error("[useWebWorkerFn] You can only run one instance of the worker at a time.");
        return Promise.reject();
      }
      worker.value = generateWorker();
      return callWorker(...fnArgs);
    };
    return {
      workerFn,
      workerStatus,
      workerTerminate
    };
  };
  function useWindowFocus({ window: window2 = defaultWindow } = {}) {
    if (!window2)
      return vueDemi2.ref(false);
    const focused = vueDemi2.ref(window2.document.hasFocus());
    useEventListener(window2, "blur", () => {
      focused.value = false;
    });
    useEventListener(window2, "focus", () => {
      focused.value = true;
    });
    return focused;
  }
  function useWindowScroll({ window: window2 = defaultWindow } = {}) {
    if (!window2) {
      return {
        x: vueDemi2.ref(0),
        y: vueDemi2.ref(0)
      };
    }
    const x2 = vueDemi2.ref(window2.pageXOffset);
    const y = vueDemi2.ref(window2.pageYOffset);
    useEventListener("scroll", () => {
      x2.value = window2.pageXOffset;
      y.value = window2.pageYOffset;
    }, {
      capture: false,
      passive: true
    });
    return { x: x2, y };
  }
  function useWindowSize({ window: window2 = defaultWindow, initialWidth = Infinity, initialHeight = Infinity } = {}) {
    const width = vueDemi2.ref(initialWidth);
    const height = vueDemi2.ref(initialHeight);
    const update3 = () => {
      if (window2) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      }
    };
    update3();
    shared2.tryOnMounted(update3);
    useEventListener("resize", update3, { passive: true });
    return { width, height };
  }
  exports.DefaultMagicKeysAliasMap = DefaultMagicKeysAliasMap;
  exports.StorageSerializers = StorageSerializers;
  exports.SwipeDirection = SwipeDirection;
  exports.TransitionPresets = TransitionPresets;
  exports.asyncComputed = asyncComputed;
  exports.autoResetRef = autoResetRef;
  exports.breakpointsAntDesign = breakpointsAntDesign;
  exports.breakpointsBootstrapV5 = breakpointsBootstrapV5;
  exports.breakpointsQuasar = breakpointsQuasar;
  exports.breakpointsSematic = breakpointsSematic;
  exports.breakpointsTailwind = breakpointsTailwind;
  exports.breakpointsVuetify = breakpointsVuetify;
  exports.computedInject = computedInject;
  exports.createFetch = createFetch;
  exports.createUnrefFn = createUnrefFn;
  exports.defaultDocument = defaultDocument;
  exports.defaultLocation = defaultLocation;
  exports.defaultNavigator = defaultNavigator;
  exports.defaultWindow = defaultWindow;
  exports.onClickOutside = onClickOutside;
  exports.onKeyDown = onKeyDown;
  exports.onKeyPressed = onKeyPressed;
  exports.onKeyStroke = onKeyStroke;
  exports.onKeyUp = onKeyUp;
  exports.onStartTyping = onStartTyping;
  exports.templateRef = templateRef;
  exports.unrefElement = unrefElement;
  exports.useActiveElement = useActiveElement;
  exports.useAsyncQueue = useAsyncQueue;
  exports.useAsyncState = useAsyncState;
  exports.useBase64 = useBase64;
  exports.useBattery = useBattery;
  exports.useBreakpoints = useBreakpoints;
  exports.useBrowserLocation = useBrowserLocation;
  exports.useClamp = useClamp;
  exports.useClipboard = useClipboard;
  exports.useColorMode = useColorMode;
  exports.useConfirmDialog = useConfirmDialog;
  exports.useCssVar = useCssVar;
  exports.useCycleList = useCycleList;
  exports.useDark = useDark;
  exports.useDebouncedRefHistory = useDebouncedRefHistory;
  exports.useDeviceMotion = useDeviceMotion;
  exports.useDeviceOrientation = useDeviceOrientation;
  exports.useDevicePixelRatio = useDevicePixelRatio;
  exports.useDevicesList = useDevicesList;
  exports.useDisplayMedia = useDisplayMedia;
  exports.useDocumentVisibility = useDocumentVisibility;
  exports.useDraggable = useDraggable;
  exports.useElementBounding = useElementBounding;
  exports.useElementByPoint = useElementByPoint;
  exports.useElementHover = useElementHover;
  exports.useElementSize = useElementSize;
  exports.useElementVisibility = useElementVisibility;
  exports.useEventBus = useEventBus;
  exports.useEventListener = useEventListener;
  exports.useEventSource = useEventSource;
  exports.useEyeDropper = useEyeDropper;
  exports.useFavicon = useFavicon;
  exports.useFetch = useFetch;
  exports.useFocus = useFocus2;
  exports.useFocusWithin = useFocusWithin;
  exports.useFps = useFps;
  exports.useFullscreen = useFullscreen;
  exports.useGeolocation = useGeolocation;
  exports.useIdle = useIdle;
  exports.useIntersectionObserver = useIntersectionObserver;
  exports.useKeyModifier = useKeyModifier;
  exports.useLocalStorage = useLocalStorage;
  exports.useMagicKeys = useMagicKeys;
  exports.useManualRefHistory = useManualRefHistory;
  exports.useMediaControls = useMediaControls;
  exports.useMediaQuery = useMediaQuery;
  exports.useMemory = useMemory;
  exports.useMounted = useMounted;
  exports.useMouse = useMouse;
  exports.useMouseInElement = useMouseInElement;
  exports.useMousePressed = useMousePressed;
  exports.useMutationObserver = useMutationObserver;
  exports.useNavigatorLanguage = useNavigatorLanguage;
  exports.useNetwork = useNetwork;
  exports.useNow = useNow;
  exports.useOnline = useOnline;
  exports.usePageLeave = usePageLeave;
  exports.useParallax = useParallax;
  exports.usePermission = usePermission;
  exports.usePointer = usePointer;
  exports.usePointerSwipe = usePointerSwipe;
  exports.usePreferredColorScheme = usePreferredColorScheme;
  exports.usePreferredDark = usePreferredDark;
  exports.usePreferredLanguages = usePreferredLanguages;
  exports.useRafFn = useRafFn;
  exports.useRefHistory = useRefHistory;
  exports.useResizeObserver = useResizeObserver;
  exports.useScreenSafeArea = useScreenSafeArea;
  exports.useScriptTag = useScriptTag;
  exports.useScroll = useScroll;
  exports.useScrollLock = useScrollLock;
  exports.useSessionStorage = useSessionStorage;
  exports.useShare = useShare;
  exports.useSpeechRecognition = useSpeechRecognition;
  exports.useSpeechSynthesis = useSpeechSynthesis;
  exports.useStorage = useStorage;
  exports.useStorageAsync = useStorageAsync;
  exports.useSwipe = useSwipe;
  exports.useTemplateRefsList = useTemplateRefsList;
  exports.useTextSelection = useTextSelection;
  exports.useThrottledRefHistory = useThrottledRefHistory;
  exports.useTimeAgo = useTimeAgo;
  exports.useTimestamp = useTimestamp;
  exports.useTitle = useTitle;
  exports.useTransition = useTransition;
  exports.useUrlSearchParams = useUrlSearchParams;
  exports.useUserMedia = useUserMedia;
  exports.useVModel = useVModel;
  exports.useVModels = useVModels;
  exports.useVirtualList = useVirtualList;
  exports.useWakeLock = useWakeLock;
  exports.useWebSocket = useWebSocket;
  exports.useWebWorker = useWebWorker;
  exports.useWebWorkerFn = useWebWorkerFn;
  exports.useWindowFocus = useWindowFocus;
  exports.useWindowScroll = useWindowScroll;
  exports.useWindowSize = useWindowSize;
  Object.keys(shared2).forEach(function(k) {
    if (k !== "default" && !exports.hasOwnProperty(k))
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return shared2[k];
        }
      });
  });
})(core$7);
var aria$5 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const EVENT_CODE2 = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
    numpadEnter: "NumpadEnter"
  };
  const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
  const isVisible = (element) => {
    const computed2 = getComputedStyle(element);
    return computed2.position === "fixed" ? false : element.offsetParent !== null;
  };
  const obtainAllFocusableElements = (element) => {
    return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item2) => isFocusable(item2) && isVisible(item2));
  };
  const isFocusable = (element) => {
    if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
      return true;
    }
    if (element.disabled) {
      return false;
    }
    switch (element.nodeName) {
      case "A": {
        return !!element.href && element.rel !== "ignore";
      }
      case "INPUT": {
        return !(element.type === "hidden" || element.type === "file");
      }
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA": {
        return true;
      }
      default: {
        return false;
      }
    }
  };
  const attemptFocus = (element) => {
    var _a;
    if (!isFocusable(element)) {
      return false;
    }
    Utils.IgnoreUtilFocusChanges = true;
    (_a = element.focus) == null ? void 0 : _a.call(element);
    Utils.IgnoreUtilFocusChanges = false;
    return document.activeElement === element;
  };
  const triggerEvent2 = function(elm, name, ...opts) {
    let eventName;
    if (name.includes("mouse") || name.includes("click")) {
      eventName = "MouseEvents";
    } else if (name.includes("key")) {
      eventName = "KeyboardEvent";
    } else {
      eventName = "HTMLEvents";
    }
    const evt = document.createEvent(eventName);
    evt.initEvent(name, ...opts);
    elm.dispatchEvent(evt);
    return elm;
  };
  const isLeaf = (el) => !el.getAttribute("aria-owns");
  const getSibling = (el, distance, elClass) => {
    const { parentNode } = el;
    if (!parentNode)
      return null;
    const siblings = parentNode.querySelectorAll(elClass);
    const index2 = Array.prototype.indexOf.call(siblings, el);
    return siblings[index2 + distance] || null;
  };
  const focusNode = (el) => {
    if (!el)
      return;
    el.focus();
    !isLeaf(el) && el.click();
  };
  const Utils = {
    IgnoreUtilFocusChanges: false,
    focusFirstDescendant(element) {
      for (let i = 0; i < element.childNodes.length; i++) {
        const child = element.childNodes[i];
        if (attemptFocus(child) || this.focusFirstDescendant(child)) {
          return true;
        }
      }
      return false;
    },
    focusLastDescendant(element) {
      for (let i = element.childNodes.length - 1; i >= 0; i--) {
        const child = element.childNodes[i];
        if (attemptFocus(child) || this.focusLastDescendant(child)) {
          return true;
        }
      }
      return false;
    }
  };
  exports.EVENT_CODE = EVENT_CODE2;
  exports.attemptFocus = attemptFocus;
  exports["default"] = Utils;
  exports.focusNode = focusNode;
  exports.getSibling = getSibling;
  exports.isFocusable = isFocusable;
  exports.isLeaf = isLeaf;
  exports.isVisible = isVisible;
  exports.obtainAllFocusableElements = obtainAllFocusableElements;
  exports.triggerEvent = triggerEvent2;
})(aria$5);
Object.defineProperty(useModal$1, "__esModule", { value: true });
var vue$2x = require$$0$1;
var core$6 = core$7;
var aria$4 = aria$5;
const modalStack = [];
const closeModal = (e) => {
  if (modalStack.length === 0)
    return;
  if (e.code === aria$4.EVENT_CODE.esc) {
    e.stopPropagation();
    const topModal = modalStack[modalStack.length - 1];
    topModal.handleClose();
  }
};
const useModal = (instance, visibleRef) => {
  vue$2x.watch(visibleRef, (val) => {
    if (val) {
      modalStack.push(instance);
    } else {
      modalStack.splice(modalStack.findIndex((modal) => modal === instance), 1);
    }
  });
};
if (core$6.isClient)
  core$6.useEventListener(document, "keydown", closeModal);
useModal$1.useModal = useModal;
var useModelToggle$1 = {};
var constants$f = {};
Object.defineProperty(constants$f, "__esModule", { value: true });
const UPDATE_MODEL_EVENT = "update:modelValue";
const CHANGE_EVENT = "change";
const INPUT_EVENT = "input";
constants$f.CHANGE_EVENT = CHANGE_EVENT;
constants$f.INPUT_EVENT = INPUT_EVENT;
constants$f.UPDATE_MODEL_EVENT = UPDATE_MODEL_EVENT;
Object.defineProperty(useModelToggle$1, "__esModule", { value: true });
var vue$2w = require$$0$1;
var shared$k = require$$1$1;
var util$j = util$l;
var constants$e = constants$f;
var isServer$5 = isServer$8;
var props$K = props$N;
const useModelToggleProps = props$K.buildProps({
  modelValue: {
    type: props$K.definePropType(Boolean),
    default: null
  },
  "onUpdate:modelValue": Function
});
const useModelToggleEmits = [constants$e.UPDATE_MODEL_EVENT];
const useModelToggle = ({
  indicator,
  shouldHideWhenRouteChanges,
  shouldProceed,
  onShow,
  onHide
}) => {
  const instance = vue$2w.getCurrentInstance();
  const props2 = instance.props;
  const { emit } = instance;
  const hasUpdateHandler = vue$2w.computed(() => shared$k.isFunction(props2["onUpdate:modelValue"]));
  const isModelBindingAbsent = vue$2w.computed(() => props2.modelValue === null);
  const doShow = () => {
    if (indicator.value === true) {
      return;
    }
    indicator.value = true;
    if (shared$k.isFunction(onShow)) {
      onShow();
    }
  };
  const doHide = () => {
    if (indicator.value === false) {
      return;
    }
    indicator.value = false;
    if (shared$k.isFunction(onHide)) {
      onHide();
    }
  };
  const show = () => {
    if (props2.disabled === true || shared$k.isFunction(shouldProceed) && !shouldProceed())
      return;
    const shouldEmit = hasUpdateHandler.value && !isServer$5["default"];
    if (shouldEmit) {
      emit(constants$e.UPDATE_MODEL_EVENT, true);
    }
    if (isModelBindingAbsent.value || !shouldEmit) {
      doShow();
    }
  };
  const hide2 = () => {
    if (props2.disabled === true || isServer$5["default"])
      return;
    const shouldEmit = hasUpdateHandler.value && !isServer$5["default"];
    if (shouldEmit) {
      emit(constants$e.UPDATE_MODEL_EVENT, false);
    }
    if (isModelBindingAbsent.value || !shouldEmit) {
      doHide();
    }
  };
  const onChange = (val) => {
    if (!util$j.isBool(val))
      return;
    if (props2.disabled && val) {
      if (hasUpdateHandler.value) {
        emit(constants$e.UPDATE_MODEL_EVENT, false);
      }
    } else if (indicator.value !== val) {
      if (val) {
        doShow();
      } else {
        doHide();
      }
    }
  };
  const toggle = () => {
    if (indicator.value) {
      hide2();
    } else {
      show();
    }
  };
  vue$2w.watch(() => props2.modelValue, onChange);
  if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
    vue$2w.watch(() => __spreadValues({}, instance.proxy.$route), () => {
      if (shouldHideWhenRouteChanges.value && indicator.value) {
        hide2();
      }
    });
  }
  vue$2w.onMounted(() => {
    onChange(props2.modelValue);
  });
  return {
    hide: hide2,
    show,
    toggle
  };
};
useModelToggle$1.useModelToggle = useModelToggle;
useModelToggle$1.useModelToggleEmits = useModelToggleEmits;
useModelToggle$1.useModelToggleProps = useModelToggleProps;
var usePopper$1 = {};
var top$1 = "top";
var bottom$1 = "bottom";
var right$1 = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top$1, bottom$1, right$1, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper$4 = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main$2 = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main$2, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node3) {
  if (node3 == null) {
    return window;
  }
  if (node3.toString() !== "[object Window]") {
    var ownerDocument = node3.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node3;
}
function isElement(node3) {
  var OwnElement = getWindow(node3).Element;
  return node3 instanceof OwnElement || node3 instanceof Element;
}
function isHTMLElement(node3) {
  var OwnElement = getWindow(node3).HTMLElement;
  return node3 instanceof OwnElement || node3 instanceof HTMLElement;
}
function isShadowRoot(node3) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node3).ShadowRoot;
  return node3 instanceof OwnElement || node3 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$12, value, max$12) {
  return max(min$12, min(value, max$12));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject2 = function toPaddingObject3(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow$3(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right$1].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject2(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top$1 : left;
  var maxProp = axis === "y" ? bottom$1 : right$1;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$4 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow$3,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x2 = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top$1;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top$1 || (placement === left || placement === right$1) && variation === end) {
      sideY = bottom$1;
      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top$1 || placement === bottom$1) && variation === end) {
      sideX = right$1;
      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y + "px)" : "translate3d(" + x2 + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref4) {
  var state = _ref4.state, options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize2 = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize2) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize2) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn2() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node3) {
  var win = getWindow(node3);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node3) {
  if (["html", "body", "#document"].indexOf(getNodeName(node3)) >= 0) {
    return node3.ownerDocument.body;
  }
  if (isHTMLElement(node3) && isScrollParent(node3)) {
    return node3;
  }
  return getScrollParent(getParentNode(node3));
}
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target2);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target2)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body" && (canEscapeClipping ? getComputedStyle$1(clippingParent).position !== "static" : true);
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top$1:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom$1:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right$1:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper$4 : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper$4 ? reference : popper$4;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper$4 ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper$4 && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right$1, bottom$1].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top$1, bottom$1].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$12 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$12.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$12;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top$1, bottom$1].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right$1 : left : isStartVariation ? bottom$1 : top$1;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top$1, right$1, bottom$1, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right$1].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state.placement], x2 = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data2;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top$1 : left;
    var altSide = mainAxis === "y" ? bottom$1 : right$1;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$12 = offset2 + overflow[mainSide];
    var max$12 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$12, tetherMin) : min$12, offset2, tether ? max(max$12, tetherMax) : max$12);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top$1 : left;
    var _altSide = mainAxis === "x" ? bottom$1 : right$1;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top$1, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data2;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node3) {
  if (node3 === getWindow(node3) || !isHTMLElement(node3)) {
    return getWindowScroll(node3);
  } else {
    return getHTMLElementScroll(node3);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result3 = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result3.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result3;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$5(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current2) {
    var existing = merged2[current2.name];
    merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
      options: Object.assign({}, existing.options, current2.options),
      data: Object.assign({}, existing.data, current2.data)
    }) : current2;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce$5(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper$2 = /* @__PURE__ */ popperGenerator();
var defaultModifiers$2 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /* @__PURE__ */ popperGenerator({
  defaultModifiers: defaultModifiers$2
});
var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$4, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers: defaultModifiers$1
});
var lib = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  popperGenerator,
  detectOverflow,
  createPopperBase: createPopper$2,
  createPopper,
  createPopperLite: createPopper$1,
  top: top$1,
  bottom: bottom$1,
  right: right$1,
  left,
  auto,
  basePlacements,
  start,
  end,
  clippingParents,
  viewport,
  popper: popper$4,
  reference,
  variationPlacements,
  placements,
  beforeRead,
  read,
  afterRead,
  beforeMain,
  main: main$2,
  afterMain,
  beforeWrite,
  write,
  afterWrite,
  modifierPhases,
  applyStyles: applyStyles$1,
  arrow: arrow$4,
  computeStyles: computeStyles$1,
  eventListeners,
  flip: flip$1,
  hide: hide$1,
  offset: offset$1,
  popperOffsets: popperOffsets$1,
  preventOverflow: preventOverflow$1
});
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(lib);
var clickOutside = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dom2 = dom$8;
  var isServer2 = isServer$8;
  const nodeList2 = /* @__PURE__ */ new Map();
  let startClick2;
  if (!isServer2["default"]) {
    dom2.on(document, "mousedown", (e) => startClick2 = e);
    dom2.on(document, "mouseup", (e) => {
      for (const handlers of nodeList2.values()) {
        for (const { documentHandler } of handlers) {
          documentHandler(e, startClick2);
        }
      }
    });
  }
  function createDocumentHandler2(el, binding) {
    let excludes = [];
    if (Array.isArray(binding.arg)) {
      excludes = binding.arg;
    } else if (binding.arg instanceof HTMLElement) {
      excludes.push(binding.arg);
    }
    return function(mouseup, mousedown) {
      const popperRef = binding.instance.popperRef;
      const mouseUpTarget = mouseup.target;
      const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
      const isBound = !binding || !binding.instance;
      const isTargetExists = !mouseUpTarget || !mouseDownTarget;
      const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
      const isSelf = el === mouseUpTarget;
      const isTargetExcluded = excludes.length && excludes.some((item2) => item2 == null ? void 0 : item2.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
      const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
      if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
        return;
      }
      binding.value(mouseup, mousedown);
    };
  }
  const ClickOutside2 = {
    beforeMount(el, binding) {
      if (!nodeList2.has(el)) {
        nodeList2.set(el, []);
      }
      nodeList2.get(el).push({
        documentHandler: createDocumentHandler2(el, binding),
        bindingFn: binding.value
      });
    },
    updated(el, binding) {
      if (!nodeList2.has(el)) {
        nodeList2.set(el, []);
      }
      const handlers = nodeList2.get(el);
      const oldHandlerIndex = handlers.findIndex((item2) => item2.bindingFn === binding.oldValue);
      const newHandler = {
        documentHandler: createDocumentHandler2(el, binding),
        bindingFn: binding.value
      };
      if (oldHandlerIndex >= 0) {
        handlers.splice(oldHandlerIndex, 1, newHandler);
      } else {
        handlers.push(newHandler);
      }
    },
    unmounted(el) {
      nodeList2.delete(el);
    }
  };
  exports["default"] = ClickOutside2;
})(clickOutside);
var repeatClick = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dom2 = dom$8;
  var RepeatClick = {
    beforeMount(el, binding) {
      let interval = null;
      let startTime;
      const handler = () => binding.value && binding.value();
      const clear2 = () => {
        if (Date.now() - startTime < 100) {
          handler();
        }
        clearInterval(interval);
        interval = null;
      };
      dom2.on(el, "mousedown", (e) => {
        if (e.button !== 0)
          return;
        startTime = Date.now();
        dom2.once(document, "mouseup", clear2);
        clearInterval(interval);
        interval = setInterval(handler, 100);
      });
    }
  };
  exports["default"] = RepeatClick;
})(repeatClick);
var trapFocus = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var aria2 = aria$5;
  const FOCUSABLE_CHILDREN = "_trap-focus-children";
  const TRAP_FOCUS_HANDLER = "_trap-focus-handler";
  const FOCUS_STACK = [];
  const FOCUS_HANDLER = (e) => {
    if (FOCUS_STACK.length === 0)
      return;
    const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
    if (focusableElement.length > 0 && e.code === aria2.EVENT_CODE.tab) {
      if (focusableElement.length === 1) {
        e.preventDefault();
        if (document.activeElement !== focusableElement[0]) {
          focusableElement[0].focus();
        }
        return;
      }
      const goingBackward = e.shiftKey;
      const isFirst = e.target === focusableElement[0];
      const isLast = e.target === focusableElement[focusableElement.length - 1];
      if (isFirst && goingBackward) {
        e.preventDefault();
        focusableElement[focusableElement.length - 1].focus();
      }
      if (isLast && !goingBackward) {
        e.preventDefault();
        focusableElement[0].focus();
      }
    }
  };
  const TrapFocus = {
    beforeMount(el) {
      el[FOCUSABLE_CHILDREN] = aria2.obtainAllFocusableElements(el);
      FOCUS_STACK.push(el);
      if (FOCUS_STACK.length <= 1) {
        dom2.on(document, "keydown", FOCUS_HANDLER);
      }
    },
    updated(el) {
      vue2.nextTick(() => {
        el[FOCUSABLE_CHILDREN] = aria2.obtainAllFocusableElements(el);
      });
    },
    unmounted() {
      FOCUS_STACK.shift();
      if (FOCUS_STACK.length === 0) {
        dom2.off(document, "keydown", FOCUS_HANDLER);
      }
    }
  };
  exports.FOCUSABLE_CHILDREN = FOCUSABLE_CHILDREN;
  exports.TRAP_FOCUS_HANDLER = TRAP_FOCUS_HANDLER;
  exports["default"] = TrapFocus;
})(trapFocus);
var mousewheel = {};
var h = false, o, s, f, u, d, D, l, p, m, w, N, E, x, A, M;
function a() {
  if (!h) {
    h = true;
    var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
    if (E = /\b(iPhone|iP[ao]d)/.exec(e), x = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), A = /FBAN\/\w+;/i.exec(e), M = /Mobile/i.exec(e), N = !!/Win64/.exec(e), n) {
      o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(e);
      D = r ? parseFloat(r[1]) + 4 : o, s = n[2] ? parseFloat(n[2]) : NaN, f = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
    } else {
      o = s = f = d = u = NaN;
    }
    if (i) {
      if (i[1]) {
        var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
        l = t ? parseFloat(t[1].replace("_", ".")) : true;
      } else {
        l = false;
      }
      p = !!i[2], m = !!i[3];
    } else {
      l = p = m = false;
    }
  }
}
var _ = { ie: function() {
  return a() || o;
}, ieCompatibilityMode: function() {
  return a() || D > o;
}, ie64: function() {
  return _.ie() && N;
}, firefox: function() {
  return a() || s;
}, opera: function() {
  return a() || f;
}, webkit: function() {
  return a() || u;
}, safari: function() {
  return _.webkit();
}, chrome: function() {
  return a() || d;
}, windows: function() {
  return a() || p;
}, osx: function() {
  return a() || l;
}, linux: function() {
  return a() || m;
}, iphone: function() {
  return a() || E;
}, mobile: function() {
  return a() || E || x || w || M;
}, nativeApp: function() {
  return a() || A;
}, android: function() {
  return a() || w;
}, ipad: function() {
  return a() || x;
} }, F = _;
var c = !!(typeof window != "undefined" && window.document && window.document.createElement), I = { canUseDOM: c, canUseWorkers: typeof Worker != "undefined", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c }, v = I;
var X;
v.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
function S(e, n) {
  if (!v.canUseDOM || n && !("addEventListener" in document)) {
    return false;
  }
  var i = "on" + e, r = i in document;
  if (!r) {
    var t = document.createElement("div");
    t.setAttribute(i, "return;"), r = typeof t[i] == "function";
  }
  return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var b = S;
var O = 10, P = 40, T = 800;
function U(e) {
  var n = 0, i = 0, r = 0, t = 0;
  return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= P, t *= P) : (r *= T, t *= T)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
}
U.getEventType = function() {
  return F.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
};
var W = U;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
var dist = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": W
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(dist);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var normalizeWheel = require$$0;
  var util2 = util$l;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var normalizeWheel__default = /* @__PURE__ */ _interopDefaultLegacy2(normalizeWheel);
  const mousewheel2 = function(element, callback) {
    if (element && element.addEventListener) {
      const fn3 = function(event) {
        const normalized = normalizeWheel__default["default"](event);
        callback && callback.apply(this, [event, normalized]);
      };
      if (util2.isFirefox()) {
        element.addEventListener("DOMMouseScroll", fn3);
      } else {
        element.onmousewheel = fn3;
      }
    }
  };
  const Mousewheel = {
    beforeMount(el, binding) {
      mousewheel2(el, binding.value);
    }
  };
  exports["default"] = Mousewheel;
})(mousewheel);
var resize = {};
var resizeEvent = {};
Object.defineProperty(resizeEvent, "__esModule", { value: true });
var isServer$4 = isServer$8;
const resizeHandler = function(entries) {
  for (const entry of entries) {
    const listeners = entry.target.__resizeListeners__ || [];
    if (listeners.length) {
      listeners.forEach((fn3) => {
        fn3();
      });
    }
  }
};
const addResizeListener = function(element, fn3) {
  if (isServer$4["default"] || !element)
    return;
  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new ResizeObserver(resizeHandler);
    element.__ro__.observe(element);
  }
  element.__resizeListeners__.push(fn3);
};
const removeResizeListener = function(element, fn3) {
  var _a;
  if (!element || !element.__resizeListeners__)
    return;
  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn3), 1);
  if (!element.__resizeListeners__.length) {
    (_a = element.__ro__) == null ? void 0 : _a.disconnect();
  }
};
resizeEvent.addResizeListener = addResizeListener;
resizeEvent.removeResizeListener = removeResizeListener;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resizeEvent$1 = resizeEvent;
  const Resize = {
    beforeMount(el, binding) {
      el._handleResize = () => {
        var _a;
        el && ((_a = binding.value) == null ? void 0 : _a.call(binding, el));
      };
      resizeEvent$1.addResizeListener(el, el._handleResize);
    },
    beforeUnmount(el) {
      resizeEvent$1.removeResizeListener(el, el._handleResize);
    }
  };
  exports["default"] = Resize;
})(resize);
var vnode$1 = {};
Object.defineProperty(vnode$1, "__esModule", { value: true });
var vue$2v = require$$0$1;
var shared$j = require$$1$1;
var error$2 = error$5;
const TEMPLATE = "template";
const SCOPE = "VNode";
var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
  PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
  PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
  PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
  PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
  PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
  PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
  PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
  PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
  PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
  PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
  PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
  return PatchFlags2;
})(PatchFlags || {});
const isFragment = (node3) => vue$2v.isVNode(node3) && node3.type === vue$2v.Fragment;
const isText = (node3) => node3.type === vue$2v.Text;
const isComment = (node3) => node3.type === vue$2v.Comment;
const isTemplate = (node3) => node3.type === TEMPLATE;
function getChildren(node3, depth) {
  if (isComment(node3))
    return;
  if (isFragment(node3) || isTemplate(node3)) {
    return depth > 0 ? getFirstValidNode(node3.children, depth - 1) : void 0;
  }
  return node3;
}
const isValidElementNode = (node3) => vue$2v.isVNode(node3) && !isFragment(node3) && !isComment(node3);
const getFirstValidNode = (nodes, maxDepth = 3) => {
  if (Array.isArray(nodes)) {
    return getChildren(nodes[0], maxDepth);
  } else {
    return getChildren(nodes, maxDepth);
  }
};
function renderIf(condition, node3, props2, children, patchFlag, patchProps) {
  return condition ? renderBlock(node3, props2, children, patchFlag, patchProps) : vue$2v.createCommentVNode("v-if", true);
}
function renderBlock(node3, props2, children, patchFlag, patchProps) {
  return vue$2v.openBlock(), vue$2v.createBlock(node3, props2, children, patchFlag, patchProps);
}
const getNormalizedProps = (node3) => {
  if (!vue$2v.isVNode(node3)) {
    error$2.debugWarn(SCOPE, "value must be a VNode");
    return;
  }
  const raw = node3.props || {};
  const type4 = node3.type.props || {};
  const props2 = {};
  Object.keys(type4).forEach((key2) => {
    if (shared$j.hasOwn(type4[key2], "default")) {
      props2[key2] = type4[key2].default;
    }
  });
  Object.keys(raw).forEach((key2) => {
    props2[vue$2v.camelize(key2)] = raw[key2];
  });
  return props2;
};
vnode$1.PatchFlags = PatchFlags;
vnode$1.SCOPE = SCOPE;
vnode$1.getFirstValidNode = getFirstValidNode;
vnode$1.getNormalizedProps = getNormalizedProps;
vnode$1.isComment = isComment;
vnode$1.isFragment = isFragment;
vnode$1.isTemplate = isTemplate;
vnode$1.isText = isText;
vnode$1.isValidElementNode = isValidElementNode;
vnode$1.renderBlock = renderBlock;
vnode$1.renderIf = renderIf;
var popupManager$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var isServer2 = isServer$8;
  var config2 = config$4;
  var dom2 = dom$8;
  var aria2 = aria$5;
  const onTouchMove2 = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  const onModalClick2 = () => {
    PopupManager2 == null ? void 0 : PopupManager2.doOnModalClick();
  };
  let hasModal2 = false;
  let zIndex2;
  const getModal2 = function() {
    if (isServer2["default"])
      return;
    let modalDom = PopupManager2.modalDom;
    if (modalDom) {
      hasModal2 = true;
    } else {
      hasModal2 = false;
      modalDom = document.createElement("div");
      PopupManager2.modalDom = modalDom;
      dom2.on(modalDom, "touchmove", onTouchMove2);
      dom2.on(modalDom, "click", onModalClick2);
    }
    return modalDom;
  };
  const instances2 = {};
  const PopupManager2 = {
    modalFade: true,
    modalDom: void 0,
    zIndex: zIndex2,
    getInstance(id) {
      return instances2[id];
    },
    register(id, instance) {
      if (id && instance) {
        instances2[id] = instance;
      }
    },
    deregister(id) {
      if (id) {
        instances2[id] = null;
        delete instances2[id];
      }
    },
    nextZIndex() {
      return ++PopupManager2.zIndex;
    },
    modalStack: [],
    doOnModalClick() {
      const topItem = PopupManager2.modalStack[PopupManager2.modalStack.length - 1];
      if (!topItem)
        return;
      const instance = PopupManager2.getInstance(topItem.id);
      if (instance && instance.closeOnClickModal.value) {
        instance.close();
      }
    },
    openModal(id, zIndex22, dom$12, modalClass, modalFade) {
      if (isServer2["default"])
        return;
      if (!id || zIndex22 === void 0)
        return;
      this.modalFade = modalFade;
      const modalStack2 = this.modalStack;
      for (let i = 0, j = modalStack2.length; i < j; i++) {
        const item2 = modalStack2[i];
        if (item2.id === id) {
          return;
        }
      }
      const modalDom = getModal2();
      dom2.addClass(modalDom, "v-modal");
      if (this.modalFade && !hasModal2) {
        dom2.addClass(modalDom, "v-modal-enter");
      }
      if (modalClass) {
        const classArr = modalClass.trim().split(/\s+/);
        classArr.forEach((item2) => dom2.addClass(modalDom, item2));
      }
      setTimeout(() => {
        dom2.removeClass(modalDom, "v-modal-enter");
      }, 200);
      if (dom$12 && dom$12.parentNode && dom$12.parentNode.nodeType !== 11) {
        dom$12.parentNode.appendChild(modalDom);
      } else {
        document.body.appendChild(modalDom);
      }
      if (zIndex22) {
        modalDom.style.zIndex = String(zIndex22);
      }
      modalDom.tabIndex = 0;
      modalDom.style.display = "";
      this.modalStack.push({ id, zIndex: zIndex22, modalClass });
    },
    closeModal(id) {
      const modalStack2 = this.modalStack;
      const modalDom = getModal2();
      if (modalStack2.length > 0) {
        const topItem = modalStack2[modalStack2.length - 1];
        if (topItem.id === id) {
          if (topItem.modalClass) {
            const classArr = topItem.modalClass.trim().split(/\s+/);
            classArr.forEach((item2) => dom2.removeClass(modalDom, item2));
          }
          modalStack2.pop();
          if (modalStack2.length > 0) {
            modalDom.style.zIndex = modalStack2[modalStack2.length - 1].zIndex;
          }
        } else {
          for (let i = modalStack2.length - 1; i >= 0; i--) {
            if (modalStack2[i].id === id) {
              modalStack2.splice(i, 1);
              break;
            }
          }
        }
      }
      if (modalStack2.length === 0) {
        if (this.modalFade) {
          dom2.addClass(modalDom, "v-modal-leave");
        }
        setTimeout(() => {
          if (modalStack2.length === 0) {
            if (modalDom.parentNode)
              modalDom.parentNode.removeChild(modalDom);
            modalDom.style.display = "none";
            PopupManager2.modalDom = void 0;
          }
          dom2.removeClass(modalDom, "v-modal-leave");
        }, 200);
      }
    }
  };
  Object.defineProperty(PopupManager2, "zIndex", {
    configurable: true,
    get() {
      if (zIndex2 === void 0) {
        zIndex2 = config2.getConfig("zIndex") || 2e3;
      }
      return zIndex2;
    },
    set(value) {
      zIndex2 = value;
    }
  });
  const getTopPopup2 = function() {
    if (isServer2["default"])
      return;
    if (PopupManager2.modalStack.length > 0) {
      const topPopup = PopupManager2.modalStack[PopupManager2.modalStack.length - 1];
      if (!topPopup)
        return;
      const instance = PopupManager2.getInstance(topPopup.id);
      return instance;
    }
  };
  if (!isServer2["default"]) {
    dom2.on(window, "keydown", function(event) {
      if (event.code === aria2.EVENT_CODE.esc) {
        const topPopup = getTopPopup2();
        if (topPopup && topPopup.closeOnPressEscape.value) {
          topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction("cancel") : topPopup.close();
        }
      }
    });
  }
  exports["default"] = PopupManager2;
})(popupManager$3);
var useTeleport$1 = {};
var globalNodes$2 = {};
Object.defineProperty(globalNodes$2, "__esModule", { value: true });
var isServer$3 = isServer$8;
const globalNodes$1 = [];
let target = isServer$3["default"] ? void 0 : document.body;
function createGlobalNode(id) {
  const el = document.createElement("div");
  if (id !== void 0) {
    el.id = id;
  }
  target.appendChild(el);
  globalNodes$1.push(el);
  return el;
}
function removeGlobalNode(el) {
  globalNodes$1.splice(globalNodes$1.indexOf(el), 1);
  el.remove();
}
function changeGlobalNodesTarget(el) {
  if (el !== target) {
    target = el;
    globalNodes$1.forEach((el2) => {
      if (el2.contains(target) === false) {
        target.appendChild(el2);
      }
    });
  }
}
globalNodes$2.changeGlobalNodesTarget = changeGlobalNodesTarget;
globalNodes$2.createGlobalNode = createGlobalNode;
globalNodes$2.removeGlobalNode = removeGlobalNode;
Object.defineProperty(useTeleport$1, "__esModule", { value: true });
var vue$2u = require$$0$1;
var shared$i = require$$1$1;
var core$5 = core$7;
var globalNodes = globalNodes$2;
const useTeleport = (contentRenderer, appendToBody) => {
  const isTeleportVisible = vue$2u.ref(false);
  if (!core$5.isClient) {
    return {
      isTeleportVisible,
      showTeleport: shared$i.NOOP,
      hideTeleport: shared$i.NOOP,
      renderTeleport: shared$i.NOOP
    };
  }
  let $el = null;
  const showTeleport = () => {
    isTeleportVisible.value = true;
    if ($el !== null)
      return;
    $el = globalNodes.createGlobalNode();
  };
  const hideTeleport = () => {
    isTeleportVisible.value = false;
    if ($el !== null) {
      globalNodes.removeGlobalNode($el);
      $el = null;
    }
  };
  const renderTeleport = () => {
    return appendToBody.value !== true ? contentRenderer() : isTeleportVisible.value ? [vue$2u.h(vue$2u.Teleport, { to: $el }, contentRenderer())] : void 0;
  };
  vue$2u.onUnmounted(hideTeleport);
  return {
    isTeleportVisible,
    showTeleport,
    hideTeleport,
    renderTeleport
  };
};
useTeleport$1.useTeleport = useTeleport;
var useTimeout$1 = {};
Object.defineProperty(useTimeout$1, "__esModule", { value: true });
var core$4 = core$7;
function useTimeout() {
  let timeoutHandle;
  const registerTimeout = (fn3, delay) => {
    cancelTimeout();
    timeoutHandle = window.setTimeout(fn3, delay);
  };
  const cancelTimeout = () => window.clearTimeout(timeoutHandle);
  core$4.tryOnScopeDispose(() => cancelTimeout());
  return {
    registerTimeout,
    cancelTimeout
  };
}
useTimeout$1.useTimeout = useTimeout;
var useTransitionFallthrough$1 = {};
Object.defineProperty(useTransitionFallthrough$1, "__esModule", { value: true });
var vue$2t = require$$0$1;
const AFTER_APPEAR = "after-appear";
const AFTER_ENTER = "after-enter";
const AFTER_LEAVE = "after-leave";
const APPEAR = "appear";
const APPEAR_CANCELLED = "appear-cancelled";
const BEFORE_ENTER = "before-enter";
const BEFORE_LEAVE = "before-leave";
const ENTER = "enter";
const ENTER_CANCELLED = "enter-cancelled";
const LEAVE = "leave";
const LEAVE_CANCELLED = "leave-cancelled";
const useTransitionFallthroughEmits = [
  AFTER_APPEAR,
  AFTER_ENTER,
  AFTER_LEAVE,
  APPEAR,
  APPEAR_CANCELLED,
  BEFORE_ENTER,
  BEFORE_LEAVE,
  ENTER,
  ENTER_CANCELLED,
  LEAVE,
  LEAVE_CANCELLED
];
const useTransitionFallthrough = () => {
  const { emit } = vue$2t.getCurrentInstance();
  return {
    onAfterAppear: () => {
      emit(AFTER_APPEAR);
    },
    onAfterEnter: () => {
      emit(AFTER_ENTER);
    },
    onAfterLeave: () => {
      emit(AFTER_LEAVE);
    },
    onAppearCancelled: () => {
      emit(APPEAR_CANCELLED);
    },
    onBeforeEnter: () => {
      emit(BEFORE_ENTER);
    },
    onBeforeLeave: () => {
      emit(BEFORE_LEAVE);
    },
    onEnter: () => {
      emit(ENTER);
    },
    onEnterCancelled: () => {
      emit(ENTER_CANCELLED);
    },
    onLeave: () => {
      emit(LEAVE);
    },
    onLeaveCancelled: () => {
      emit(LEAVE_CANCELLED);
    }
  };
};
useTransitionFallthrough$1.useTransitionFallthrough = useTransitionFallthrough;
useTransitionFallthrough$1.useTransitionFallthroughEmits = useTransitionFallthroughEmits;
var usePopperOptions$1 = {};
Object.defineProperty(usePopperOptions$1, "__esModule", { value: true });
const DEFAULT_FALLBACK_PLACEMENTS = [];
const defaultModifiers = [
  {
    name: "offset",
    options: {
      offset: [0, 12]
    }
  },
  {
    name: "preventOverflow",
    options: {
      padding: {
        top: 2,
        bottom: 2,
        left: 5,
        right: 5
      }
    }
  },
  {
    name: "flip",
    options: {
      padding: 5,
      fallbackPlacements: []
    }
  },
  {
    name: "computeStyles",
    options: {
      gpuAcceleration: true,
      adaptive: true
    }
  }
];
const defaultPopperOptions = {
  type: Object,
  default: () => {
    return {
      fallbackPlacements: DEFAULT_FALLBACK_PLACEMENTS,
      strategy: "fixed",
      modifiers: defaultModifiers
    };
  }
};
usePopperOptions$1.DEFAULT_FALLBACK_PLACEMENTS = DEFAULT_FALLBACK_PLACEMENTS;
usePopperOptions$1.defaultModifiers = defaultModifiers;
usePopperOptions$1.defaultPopperOptions = defaultPopperOptions;
var useTargetEvents$2 = {};
Object.defineProperty(useTargetEvents$2, "__esModule", { value: true });
var vue$2s = require$$0$1;
var shared$h = require$$1$1;
const DEFAULT_TRIGGER = "hover";
const useTargetEvents$1 = (onShow, onHide, onToggle) => {
  const { props: props2 } = vue$2s.getCurrentInstance();
  let triggerFocused = false;
  const popperEventsHandler = (e) => {
    e.stopPropagation();
    switch (e.type) {
      case "click": {
        if (triggerFocused) {
          triggerFocused = false;
        } else {
          onToggle();
        }
        break;
      }
      case "mouseenter": {
        onShow();
        break;
      }
      case "mouseleave": {
        onHide();
        break;
      }
      case "focus": {
        triggerFocused = true;
        onShow();
        break;
      }
      case "blur": {
        triggerFocused = false;
        onHide();
        break;
      }
    }
  };
  const triggerEventsMap = {
    click: ["onClick"],
    hover: ["onMouseenter", "onMouseleave"],
    focus: ["onFocus", "onBlur"]
  };
  const mapEvents = (t) => {
    var _a;
    const events = {};
    (_a = triggerEventsMap[t]) == null ? void 0 : _a.forEach((event) => {
      events[event] = popperEventsHandler;
    });
    return events;
  };
  return vue$2s.computed(() => {
    if (shared$h.isArray(props2.trigger)) {
      return Object.values(props2.trigger).reduce((pre, t) => {
        return __spreadValues(__spreadValues({}, pre), mapEvents(t));
      }, {});
    } else {
      return mapEvents(props2.trigger);
    }
  });
};
useTargetEvents$2.DEFAULT_TRIGGER = DEFAULT_TRIGGER;
useTargetEvents$2.useTargetEvents = useTargetEvents$1;
Object.defineProperty(usePopper$1, "__esModule", { value: true });
var vue$2r = require$$0$1;
var shared$g = require$$1$1;
var core$3 = require$$1;
var util$i = util$l;
var vnode = vnode$1;
var dom$6 = dom$8;
var popupManager$2 = popupManager$3;
var error$1 = error$5;
var index$1k = useTeleport$1;
var index$2$2 = useTimeout$1;
var index$1$4 = useModelToggle$1;
var index$3$1 = useTransitionFallthrough$1;
var usePopperOptions = usePopperOptions$1;
var useTargetEvents = useTargetEvents$2;
var index$4$1 = clickOutside;
const DARK_EFFECT = "dark";
const LIGHT_EFFECT = "light";
const usePopperControlProps = {
  appendToBody: {
    type: Boolean,
    default: true
  },
  arrowOffset: {
    type: Number
  },
  popperOptions: usePopperOptions.defaultPopperOptions,
  popperClass: {
    type: String,
    default: ""
  }
};
const usePopperProps = __spreadProps(__spreadValues({}, usePopperControlProps), {
  autoClose: {
    type: Number,
    default: 0
  },
  content: {
    type: String,
    default: ""
  },
  class: String,
  style: Object,
  hideAfter: {
    type: Number,
    default: 200
  },
  disabled: {
    type: Boolean,
    default: false
  },
  effect: {
    type: String,
    default: DARK_EFFECT
  },
  enterable: {
    type: Boolean,
    default: true
  },
  manualMode: {
    type: Boolean,
    default: false
  },
  showAfter: {
    type: Number,
    default: 0
  },
  pure: {
    type: Boolean,
    default: false
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  transition: {
    type: String,
    default: "el-fade-in-linear"
  },
  trigger: {
    type: [String, Array],
    default: useTargetEvents.DEFAULT_TRIGGER
  },
  visible: {
    type: Boolean,
    default: void 0
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  }
});
const usePopperHook = () => {
  var _a;
  const vm = vue$2r.getCurrentInstance();
  const props2 = (_a = vm.proxy) == null ? void 0 : _a.$props;
  const { slots } = vm;
  const arrowRef = vue$2r.ref(null);
  const triggerRef2 = vue$2r.ref(null);
  const popperRef = vue$2r.ref(null);
  const popperStyle = vue$2r.ref({ zIndex: popupManager$2["default"].nextZIndex() });
  const visible = vue$2r.ref(false);
  const isManual = vue$2r.computed(() => props2.manualMode || props2.trigger === "manual");
  const popperId = `el-popper-${util$i.generateId()}`;
  let popperInstance = null;
  const { renderTeleport, showTeleport, hideTeleport } = index$1k.useTeleport(popupRenderer, vue$2r.toRef(props2, "appendToBody"));
  const { show, hide: hide2 } = index$1$4.useModelToggle({
    indicator: visible,
    onShow,
    onHide
  });
  const { registerTimeout, cancelTimeout } = index$2$2.useTimeout();
  function onShow() {
    popperStyle.value.zIndex = popupManager$2["default"].nextZIndex();
    vue$2r.nextTick(initializePopper);
  }
  function onHide() {
    hideTeleport();
    vue$2r.nextTick(detachPopper);
  }
  function delayShow() {
    if (isManual.value || props2.disabled)
      return;
    showTeleport();
    registerTimeout(show, props2.showAfter);
  }
  function delayHide() {
    if (isManual.value)
      return;
    registerTimeout(hide2, props2.hideAfter);
  }
  function onToggle() {
    if (visible.value) {
      delayShow();
    } else {
      delayHide();
    }
  }
  function detachPopper() {
    var _a2;
    (_a2 = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a2.call(popperInstance);
    popperInstance = null;
  }
  function onPopperMouseEnter() {
    if (props2.enterable && props2.trigger !== "click") {
      cancelTimeout();
    }
  }
  function onPopperMouseLeave() {
    const { trigger: trigger2 } = props2;
    const shouldPrevent = shared$g.isString(trigger2) && (trigger2 === "click" || trigger2 === "focus") || trigger2.length === 1 && (trigger2[0] === "click" || trigger2[0] === "focus");
    if (shouldPrevent)
      return;
    delayHide();
  }
  function initializePopper() {
    if (!visible.value || popperInstance !== null) {
      return;
    }
    const unwrappedTrigger = triggerRef2.value;
    const $el = util$i.isHTMLElement(unwrappedTrigger) ? unwrappedTrigger : unwrappedTrigger.$el;
    popperInstance = core$3.createPopper($el, popperRef.value, buildPopperOptions());
    popperInstance.update();
  }
  function buildPopperOptions() {
    const modifiers = [...usePopperOptions.defaultModifiers, ...props2.popperOptions.modifiers];
    if (props2.showArrow) {
      modifiers.push({
        name: "arrow",
        options: {
          padding: props2.arrowOffset || 5,
          element: arrowRef.value
        }
      });
    }
    return __spreadProps(__spreadValues({}, props2.popperOptions), {
      modifiers
    });
  }
  const { onAfterEnter, onAfterLeave, onBeforeEnter, onBeforeLeave } = index$3$1.useTransitionFallthrough();
  const events = useTargetEvents.useTargetEvents(delayShow, delayHide, onToggle);
  const arrowRefAttacher = util$i.refAttacher(arrowRef);
  const popperRefAttacher = util$i.refAttacher(popperRef);
  const triggerRefAttacher = util$i.refAttacher(triggerRef2);
  function popupRenderer() {
    const mouseUpAndDown = props2.stopPopperMouseEvent ? dom$6.stop : shared$g.NOOP;
    return vue$2r.h(vue$2r.Transition, {
      name: props2.transition,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave
    }, {
      default: () => () => visible.value ? vue$2r.h("div", {
        "aria-hidden": false,
        class: [
          props2.popperClass,
          "el-popper",
          `is-${props2.effect}`,
          props2.pure ? "is-pure" : ""
        ],
        style: popperStyle.value,
        id: popperId,
        ref: popperRefAttacher,
        role: "tooltip",
        onMouseenter: onPopperMouseEnter,
        onMouseleave: onPopperMouseLeave,
        onClick: dom$6.stop,
        onMousedown: mouseUpAndDown,
        onMouseup: mouseUpAndDown
      }, [
        vue$2r.renderSlot(slots, "default", {}, () => [
          vue$2r.toDisplayString(props2.content)
        ]),
        arrowRenderer()
      ]) : null
    });
  }
  function arrowRenderer() {
    return props2.showArrow ? vue$2r.h("div", {
      ref: arrowRefAttacher,
      class: "el-popper__arrow",
      "data-popper-arrow": ""
    }, null) : null;
  }
  function triggerRenderer(triggerProps) {
    var _a2;
    const trigger2 = (_a2 = slots.trigger) == null ? void 0 : _a2.call(slots);
    const firstElement = vnode.getFirstValidNode(trigger2, 1);
    if (!firstElement)
      error$1.throwError("renderTrigger", "trigger expects single rooted node");
    return vue$2r.cloneVNode(firstElement, triggerProps, true);
  }
  function render2() {
    const trigger2 = triggerRenderer(__spreadValues({
      "aria-describedby": popperId,
      class: props2.class,
      style: props2.style,
      ref: triggerRefAttacher
    }, events));
    return vue$2r.h(vue$2r.Fragment, null, [
      isManual.value ? trigger2 : vue$2r.withDirectives(trigger2, [[index$4$1["default"], delayHide]]),
      renderTeleport()
    ]);
  }
  return {
    render: render2
  };
};
usePopper$1.DARK_EFFECT = DARK_EFFECT;
usePopper$1.LIGHT_EFFECT = LIGHT_EFFECT;
usePopper$1.usePopperControlProps = usePopperControlProps;
usePopper$1.usePopperHook = usePopperHook;
usePopper$1.usePopperProps = usePopperProps;
var usePreventGlobal$1 = {};
Object.defineProperty(usePreventGlobal$1, "__esModule", { value: true });
var vue$2q = require$$0$1;
var core$2 = core$7;
const usePreventGlobal = (indicator, evt, cb) => {
  const prevent = (e) => {
    if (cb(e))
      e.stopImmediatePropagation();
  };
  let stop2 = void 0;
  vue$2q.watch(() => indicator.value, (val) => {
    if (val) {
      stop2 = core$2.useEventListener(document, evt, prevent, true);
    } else {
      stop2 == null ? void 0 : stop2();
    }
  }, { immediate: true });
};
usePreventGlobal$1.usePreventGlobal = usePreventGlobal;
var useRestoreActive$1 = {};
Object.defineProperty(useRestoreActive$1, "__esModule", { value: true });
var vue$2p = require$$0$1;
const useRestoreActive = (toggle, initialFocus) => {
  let previousActive;
  vue$2p.watch(() => toggle.value, (val) => {
    var _a, _b;
    if (val) {
      previousActive = document.activeElement;
      if (vue$2p.isRef(initialFocus)) {
        (_b = (_a = initialFocus.value).focus) == null ? void 0 : _b.call(_a);
      }
    } else {
      {
        previousActive.focus();
      }
    }
  });
};
useRestoreActive$1.useRestoreActive = useRestoreActive;
var useSameTarget$1 = {};
Object.defineProperty(useSameTarget$1, "__esModule", { value: true });
var shared$f = require$$1$1;
const useSameTarget = (handleClick) => {
  if (!handleClick) {
    return { onClick: shared$f.NOOP, onMousedown: shared$f.NOOP, onMouseup: shared$f.NOOP };
  }
  let mousedownTarget = false;
  let mouseupTarget = false;
  const onClick = (e) => {
    if (mousedownTarget && mouseupTarget) {
      handleClick(e);
    }
    mousedownTarget = mouseupTarget = false;
  };
  const onMousedown = (e) => {
    mousedownTarget = e.target === e.currentTarget;
  };
  const onMouseup = (e) => {
    mouseupTarget = e.target === e.currentTarget;
  };
  return { onClick, onMousedown, onMouseup };
};
useSameTarget$1.useSameTarget = useSameTarget;
var useThrottleRender$1 = {};
Object.defineProperty(useThrottleRender$1, "__esModule", { value: true });
var vue$2o = require$$0$1;
const useThrottleRender = (loading2, throttle2 = 0) => {
  if (throttle2 === 0)
    return loading2;
  const throttled = vue$2o.ref(false);
  let timeoutHandle = 0;
  const dispatchThrottling = () => {
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
    }
    timeoutHandle = window.setTimeout(() => {
      throttled.value = loading2.value;
    }, throttle2);
  };
  vue$2o.onMounted(dispatchThrottling);
  vue$2o.watch(() => loading2.value, (val) => {
    if (val) {
      dispatchThrottling();
    } else {
      throttled.value = val;
    }
  });
  return throttled;
};
useThrottleRender$1.useThrottleRender = useThrottleRender;
var version$2 = {};
Object.defineProperty(version$2, "__esModule", { value: true });
const version$1 = "1.2.0-beta.6";
version$2.version = version$1;
Object.defineProperty(makeInstaller$1, "__esModule", { value: true });
var config$3 = config$4;
var version = version$2;
var index$1j = useLocale$1;
const makeInstaller = (components2 = []) => {
  const apps = [];
  const install2 = (app, opts) => {
    const defaultInstallOpt = {
      size: "",
      zIndex: 2e3
    };
    const option2 = Object.assign(defaultInstallOpt, opts);
    if (apps.includes(app))
      return;
    apps.push(app);
    components2.forEach((c2) => app.use(c2));
    if (option2.locale) {
      const localeProvides = index$1j.localeProviderMaker(opts.locale);
      app.provide(index$1j.localeContextKey, localeProvides);
    }
    app.config.globalProperties.$ELEMENT = option2;
    config$3.setConfig(option2);
  };
  return {
    version: version.version,
    install: install2
  };
};
makeInstaller$1.makeInstaller = makeInstaller;
var component = {};
var affix$2 = {};
var withInstall$1 = {};
Object.defineProperty(withInstall$1, "__esModule", { value: true });
var shared$e = require$$1$1;
const withInstall = (main2, extra) => {
  main2.install = (app) => {
    for (const comp of [main2, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key2, comp] of Object.entries(extra)) {
      main2[key2] = comp;
    }
  }
  return main2;
};
const withInstallFunction = (fn3, name) => {
  fn3.install = (app) => {
    app.config.globalProperties[name] = fn3;
  };
  return fn3;
};
const withNoopInstall = (component2) => {
  component2.install = shared$e.NOOP;
  return component2;
};
withInstall$1.withInstall = withInstall;
withInstall$1.withInstallFunction = withInstallFunction;
withInstall$1.withNoopInstall = withNoopInstall;
var affix2 = {};
var affix_vue_vue_type_script_lang = {};
var affix$1 = {};
Object.defineProperty(affix$1, "__esModule", { value: true });
var props$J = props$N;
const affixProps = props$J.buildProps({
  zIndex: {
    type: props$J.definePropType([Number, String]),
    default: 100
  },
  target: {
    type: String,
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    values: ["top", "bottom"],
    default: "top"
  }
});
const affixEmits = {
  scroll: ({ scrollTop, fixed }) => typeof scrollTop === "number" && typeof fixed === "boolean",
  change: (fixed) => typeof fixed === "boolean"
};
affix$1.affixEmits = affixEmits;
affix$1.affixProps = affixProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var dom2 = dom$8;
  var affix3 = affix$1;
  var script2 = vue2.defineComponent({
    name: "ElAffix",
    props: affix3.affixProps,
    emits: affix3.affixEmits,
    setup(props2, { emit }) {
      const target2 = vue2.shallowRef();
      const root2 = vue2.shallowRef();
      const scrollContainer = vue2.shallowRef();
      const state = vue2.reactive({
        fixed: false,
        height: 0,
        width: 0,
        scrollTop: 0,
        clientHeight: 0,
        transform: 0
      });
      const rootStyle = vue2.computed(() => {
        return {
          height: state.fixed ? `${state.height}px` : "",
          width: state.fixed ? `${state.width}px` : ""
        };
      });
      const affixStyle = vue2.computed(() => {
        if (!state.fixed)
          return;
        const offset2 = props2.offset ? `${props2.offset}px` : 0;
        const transform2 = state.transform ? `translateY(${state.transform}px)` : "";
        return {
          height: `${state.height}px`,
          width: `${state.width}px`,
          top: props2.position === "top" ? offset2 : "",
          bottom: props2.position === "bottom" ? offset2 : "",
          transform: transform2,
          zIndex: props2.zIndex
        };
      });
      const update3 = () => {
        if (!root2.value || !target2.value || !scrollContainer.value)
          return;
        const rootRect = root2.value.getBoundingClientRect();
        const targetRect = target2.value.getBoundingClientRect();
        state.height = rootRect.height;
        state.width = rootRect.width;
        state.scrollTop = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop;
        state.clientHeight = document.documentElement.clientHeight;
        if (props2.position === "top") {
          if (props2.target) {
            const difference = targetRect.bottom - props2.offset - state.height;
            state.fixed = props2.offset > rootRect.top && targetRect.bottom > 0;
            state.transform = difference < 0 ? difference : 0;
          } else {
            state.fixed = props2.offset > rootRect.top;
          }
        } else {
          if (props2.target) {
            const difference = state.clientHeight - targetRect.top - props2.offset - state.height;
            state.fixed = state.clientHeight - props2.offset < rootRect.bottom && state.clientHeight > targetRect.top;
            state.transform = difference < 0 ? -difference : 0;
          } else {
            state.fixed = state.clientHeight - props2.offset < rootRect.bottom;
          }
        }
      };
      const onScroll = () => {
        update3();
        emit("scroll", {
          scrollTop: state.scrollTop,
          fixed: state.fixed
        });
      };
      vue2.watch(() => state.fixed, () => {
        emit("change", state.fixed);
      });
      vue2.onMounted(() => {
        var _a;
        if (props2.target) {
          target2.value = (_a = document.querySelector(props2.target)) != null ? _a : void 0;
          if (!target2.value) {
            throw new Error(`Target is not existed: ${props2.target}`);
          }
        } else {
          target2.value = document.documentElement;
        }
        scrollContainer.value = dom2.getScrollContainer(root2.value, true);
      });
      core2.useEventListener(scrollContainer, "scroll", onScroll);
      core2.useResizeObserver(root2, () => update3());
      core2.useResizeObserver(target2, () => update3());
      return {
        root: root2,
        state,
        rootStyle,
        affixStyle,
        update: update3
      };
    }
  });
  exports["default"] = script2;
})(affix_vue_vue_type_script_lang);
var affix_vue_vue_type_template_id_0745df9e_lang = {};
Object.defineProperty(affix_vue_vue_type_template_id_0745df9e_lang, "__esModule", { value: true });
var vue$2n = require$$0$1;
function render$1R(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$2n.openBlock(), vue$2n.createElementBlock("div", {
    ref: "root",
    class: "el-affix",
    style: vue$2n.normalizeStyle(_ctx.rootStyle)
  }, [
    vue$2n.createElementVNode("div", {
      class: vue$2n.normalizeClass({ "el-affix--fixed": _ctx.state.fixed }),
      style: vue$2n.normalizeStyle(_ctx.affixStyle)
    }, [
      vue$2n.renderSlot(_ctx.$slots, "default")
    ], 6)
  ], 4);
}
affix_vue_vue_type_template_id_0745df9e_lang.render = render$1R;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var affix_vue_vue_type_script_lang$1 = affix_vue_vue_type_script_lang;
  var affix_vue_vue_type_template_id_0745df9e_lang$1 = affix_vue_vue_type_template_id_0745df9e_lang;
  affix_vue_vue_type_script_lang$1["default"].render = affix_vue_vue_type_template_id_0745df9e_lang$1.render;
  affix_vue_vue_type_script_lang$1["default"].__file = "packages/components/affix/src/affix.vue";
  exports["default"] = affix_vue_vue_type_script_lang$1["default"];
})(affix2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var affix3 = affix$1;
  var affix_vue_vue_type_script_lang$1 = affix_vue_vue_type_script_lang;
  const ElAffix = withInstall2.withInstall(affix_vue_vue_type_script_lang$1["default"]);
  exports.affixEmits = affix3.affixEmits;
  exports.affixProps = affix3.affixProps;
  exports.ElAffix = ElAffix;
  exports["default"] = ElAffix;
})(affix$2);
var alert$2 = {};
var alert2 = {};
var alert_vue_vue_type_script_lang = {};
var icon$4 = {};
var icon2 = {};
var icon_vue_vue_type_script_lang = {};
var icon$3 = {};
Object.defineProperty(icon$3, "__esModule", { value: true });
var props$I = props$N;
const iconProps = props$I.buildProps({
  size: {
    type: props$I.definePropType([Number, String])
  },
  color: {
    type: String
  }
});
icon$3.iconProps = iconProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$l;
  var icon3 = icon$3;
  var shared2 = require$$1$1;
  var script2 = vue2.defineComponent({
    name: "ElIcon",
    inheritAttrs: false,
    props: icon3.iconProps,
    setup(props2) {
      return {
        style: vue2.computed(() => {
          if (!props2.size && !props2.color) {
            return {};
          }
          let size2 = props2.size;
          if (util2.isNumber(size2) || shared2.isString(size2) && !size2.endsWith("px")) {
            size2 = `${size2}px`;
          }
          return __spreadValues(__spreadValues({}, props2.size ? { "--font-size": size2 } : {}), props2.color ? { "--color": props2.color } : {});
        })
      };
    }
  });
  exports["default"] = script2;
})(icon_vue_vue_type_script_lang);
var icon_vue_vue_type_template_id_89b755b6_lang = {};
Object.defineProperty(icon_vue_vue_type_template_id_89b755b6_lang, "__esModule", { value: true });
var vue$2m = require$$0$1;
function render$1Q(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$2m.openBlock(), vue$2m.createElementBlock("i", vue$2m.mergeProps({
    class: "el-icon",
    style: _ctx.style
  }, _ctx.$attrs), [
    vue$2m.renderSlot(_ctx.$slots, "default")
  ], 16);
}
icon_vue_vue_type_template_id_89b755b6_lang.render = render$1Q;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var icon_vue_vue_type_script_lang$1 = icon_vue_vue_type_script_lang;
  var icon_vue_vue_type_template_id_89b755b6_lang$1 = icon_vue_vue_type_template_id_89b755b6_lang;
  icon_vue_vue_type_script_lang$1["default"].render = icon_vue_vue_type_template_id_89b755b6_lang$1.render;
  icon_vue_vue_type_script_lang$1["default"].__file = "packages/components/icon/src/icon.vue";
  exports["default"] = icon_vue_vue_type_script_lang$1["default"];
})(icon2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var icon3 = icon$3;
  var icon_vue_vue_type_script_lang$1 = icon_vue_vue_type_script_lang;
  const ElIcon = withInstall2.withInstall(icon_vue_vue_type_script_lang$1["default"]);
  exports.iconProps = icon3.iconProps;
  exports.ElIcon = ElIcon;
  exports["default"] = ElIcon;
})(icon$4);
var icon$2 = {};
var _export_sfc = (sfc, props2) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key2, val] of props2) {
    target2[key2] = val;
  }
  return target2;
};
const _sfc_main$4n = defineComponent({
  name: "AddLocation"
});
const _hoisted_1$5K = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5l = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_3$57 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 10-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 01704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_4$1M = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 384h96a32 32 0 110 64h-96v96a32 32 0 01-64 0v-96h-96a32 32 0 010-64h96v-96a32 32 0 0164 0v96z"
}, null, -1);
const _hoisted_5$J = [
  _hoisted_2$5l,
  _hoisted_3$57,
  _hoisted_4$1M
];
function _sfc_render$4n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5K, _hoisted_5$J);
}
var addLocation = /* @__PURE__ */ _export_sfc(_sfc_main$4n, [["render", _sfc_render$4n]]);
const _sfc_main$4m = defineComponent({
  name: "Aim"
});
const _hoisted_1$5J = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5k = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3$56 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 96a32 32 0 0132 32v192a32 32 0 01-64 0V128a32 32 0 0132-32zm0 576a32 32 0 0132 32v192a32 32 0 11-64 0V704a32 32 0 0132-32zM96 512a32 32 0 0132-32h192a32 32 0 010 64H128a32 32 0 01-32-32zm576 0a32 32 0 0132-32h192a32 32 0 110 64H704a32 32 0 01-32-32z"
}, null, -1);
const _hoisted_4$1L = [
  _hoisted_2$5k,
  _hoisted_3$56
];
function _sfc_render$4m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5J, _hoisted_4$1L);
}
var aim = /* @__PURE__ */ _export_sfc(_sfc_main$4m, [["render", _sfc_render$4m]]);
const _sfc_main$4l = defineComponent({
  name: "AlarmClock"
});
const _hoisted_1$5I = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5j = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 832a320 320 0 100-640 320 320 0 000 640zm0 64a384 384 0 110-768 384 384 0 010 768z"
}, null, -1);
const _hoisted_3$55 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M292.288 824.576l55.424 32-48 83.136a32 32 0 11-55.424-32l48-83.136zm439.424 0l-55.424 32 48 83.136a32 32 0 1055.424-32l-48-83.136zM512 512h160a32 32 0 110 64H480a32 32 0 01-32-32V320a32 32 0 0164 0v192zM90.496 312.256A160 160 0 01312.32 90.496l-46.848 46.848a96 96 0 00-128 128L90.56 312.256zm835.264 0A160 160 0 00704 90.496l46.848 46.848a96 96 0 01128 128l46.912 46.912z"
}, null, -1);
const _hoisted_4$1K = [
  _hoisted_2$5j,
  _hoisted_3$55
];
function _sfc_render$4l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5I, _hoisted_4$1K);
}
var alarmClock = /* @__PURE__ */ _export_sfc(_sfc_main$4l, [["render", _sfc_render$4l]]);
const _sfc_main$4k = defineComponent({
  name: "Apple"
});
const _hoisted_1$5H = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5i = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M599.872 203.776a189.44 189.44 0 0164.384-4.672l2.624.128c31.168 1.024 51.2 4.096 79.488 16.32 37.632 16.128 74.496 45.056 111.488 89.344 96.384 115.264 82.752 372.8-34.752 521.728-7.68 9.728-32 41.6-30.72 39.936a426.624 426.624 0 01-30.08 35.776c-31.232 32.576-65.28 49.216-110.08 50.048-31.36.64-53.568-5.312-84.288-18.752l-6.528-2.88c-20.992-9.216-30.592-11.904-47.296-11.904-18.112 0-28.608 2.88-51.136 12.672l-6.464 2.816c-28.416 12.224-48.32 18.048-76.16 19.2-74.112 2.752-116.928-38.08-180.672-132.16-96.64-142.08-132.608-349.312-55.04-486.4 46.272-81.92 129.92-133.632 220.672-135.04 32.832-.576 60.288 6.848 99.648 22.72 27.136 10.88 34.752 13.76 37.376 14.272 16.256-20.16 27.776-36.992 34.56-50.24 13.568-26.304 27.2-59.968 40.704-100.8a32 32 0 1160.8 20.224c-12.608 37.888-25.408 70.4-38.528 97.664zm-51.52 78.08c-14.528 17.792-31.808 37.376-51.904 58.816a32 32 0 11-46.72-43.776l12.288-13.248c-28.032-11.2-61.248-26.688-95.68-26.112-70.4 1.088-135.296 41.6-171.648 105.792C121.6 492.608 176 684.16 247.296 788.992c34.816 51.328 76.352 108.992 130.944 106.944 52.48-2.112 72.32-34.688 135.872-34.688 63.552 0 81.28 34.688 136.96 33.536 56.448-1.088 75.776-39.04 126.848-103.872 107.904-136.768 107.904-362.752 35.776-449.088-72.192-86.272-124.672-84.096-151.68-85.12-41.472-4.288-81.6 12.544-113.664 25.152z"
}, null, -1);
const _hoisted_3$54 = [
  _hoisted_2$5i
];
function _sfc_render$4k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5H, _hoisted_3$54);
}
var apple = /* @__PURE__ */ _export_sfc(_sfc_main$4k, [["render", _sfc_render$4k]]);
const _sfc_main$4j = defineComponent({
  name: "ArrowDownBold"
});
const _hoisted_1$5G = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5h = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M104.704 338.752a64 64 0 0190.496 0l316.8 316.8 316.8-316.8a64 64 0 0190.496 90.496L557.248 791.296a64 64 0 01-90.496 0L104.704 429.248a64 64 0 010-90.496z"
}, null, -1);
const _hoisted_3$53 = [
  _hoisted_2$5h
];
function _sfc_render$4j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5G, _hoisted_3$53);
}
var arrowDownBold = /* @__PURE__ */ _export_sfc(_sfc_main$4j, [["render", _sfc_render$4j]]);
const _sfc_main$4i = defineComponent({
  name: "ArrowDown"
});
const _hoisted_1$5F = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5g = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M831.872 340.864L512 652.672 192.128 340.864a30.592 30.592 0 00-42.752 0 29.12 29.12 0 000 41.6L489.664 714.24a32 32 0 0044.672 0l340.288-331.712a29.12 29.12 0 000-41.728 30.592 30.592 0 00-42.752 0z"
}, null, -1);
const _hoisted_3$52 = [
  _hoisted_2$5g
];
function _sfc_render$4i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5F, _hoisted_3$52);
}
var arrowDown = /* @__PURE__ */ _export_sfc(_sfc_main$4i, [["render", _sfc_render$4i]]);
const _sfc_main$4h = defineComponent({
  name: "ArrowLeftBold"
});
const _hoisted_1$5E = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5f = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M685.248 104.704a64 64 0 010 90.496L368.448 512l316.8 316.8a64 64 0 01-90.496 90.496L232.704 557.248a64 64 0 010-90.496l362.048-362.048a64 64 0 0190.496 0z"
}, null, -1);
const _hoisted_3$51 = [
  _hoisted_2$5f
];
function _sfc_render$4h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5E, _hoisted_3$51);
}
var arrowLeftBold = /* @__PURE__ */ _export_sfc(_sfc_main$4h, [["render", _sfc_render$4h]]);
const _sfc_main$4g = defineComponent({
  name: "ArrowLeft"
});
const _hoisted_1$5D = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5e = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M609.408 149.376L277.76 489.6a32 32 0 000 44.672l331.648 340.352a29.12 29.12 0 0041.728 0 30.592 30.592 0 000-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 000-42.688 29.12 29.12 0 00-41.728 0z"
}, null, -1);
const _hoisted_3$50 = [
  _hoisted_2$5e
];
function _sfc_render$4g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5D, _hoisted_3$50);
}
var arrowLeft = /* @__PURE__ */ _export_sfc(_sfc_main$4g, [["render", _sfc_render$4g]]);
const _sfc_main$4f = defineComponent({
  name: "ArrowRightBold"
});
const _hoisted_1$5C = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5d = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M338.752 104.704a64 64 0 000 90.496l316.8 316.8-316.8 316.8a64 64 0 0090.496 90.496l362.048-362.048a64 64 0 000-90.496L429.248 104.704a64 64 0 00-90.496 0z"
}, null, -1);
const _hoisted_3$4$ = [
  _hoisted_2$5d
];
function _sfc_render$4f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5C, _hoisted_3$4$);
}
var arrowRightBold = /* @__PURE__ */ _export_sfc(_sfc_main$4f, [["render", _sfc_render$4f]]);
const _sfc_main$4e = defineComponent({
  name: "ArrowRight"
});
const _hoisted_1$5B = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5c = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M340.864 149.312a30.592 30.592 0 000 42.752L652.736 512 340.864 831.872a30.592 30.592 0 000 42.752 29.12 29.12 0 0041.728 0L714.24 534.336a32 32 0 000-44.672L382.592 149.376a29.12 29.12 0 00-41.728 0z"
}, null, -1);
const _hoisted_3$4_ = [
  _hoisted_2$5c
];
function _sfc_render$4e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5B, _hoisted_3$4_);
}
var arrowRight = /* @__PURE__ */ _export_sfc(_sfc_main$4e, [["render", _sfc_render$4e]]);
const _sfc_main$4d = defineComponent({
  name: "ArrowUpBold"
});
const _hoisted_1$5A = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5b = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M104.704 685.248a64 64 0 0090.496 0l316.8-316.8 316.8 316.8a64 64 0 0090.496-90.496L557.248 232.704a64 64 0 00-90.496 0L104.704 594.752a64 64 0 000 90.496z"
}, null, -1);
const _hoisted_3$4Z = [
  _hoisted_2$5b
];
function _sfc_render$4d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5A, _hoisted_3$4Z);
}
var arrowUpBold = /* @__PURE__ */ _export_sfc(_sfc_main$4d, [["render", _sfc_render$4d]]);
const _sfc_main$4c = defineComponent({
  name: "ArrowUp"
});
const _hoisted_1$5z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5a = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M488.832 344.32l-339.84 356.672a32 32 0 000 44.16l.384.384a29.44 29.44 0 0042.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0042.688 0l.384-.384a32 32 0 000-44.16L535.168 344.32a32 32 0 00-46.336 0z"
}, null, -1);
const _hoisted_3$4Y = [
  _hoisted_2$5a
];
function _sfc_render$4c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5z, _hoisted_3$4Y);
}
var arrowUp = /* @__PURE__ */ _export_sfc(_sfc_main$4c, [["render", _sfc_render$4c]]);
const _sfc_main$4b = defineComponent({
  name: "Avatar"
});
const _hoisted_1$5y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$59 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M628.736 528.896A416 416 0 01928 928H96a415.872 415.872 0 01299.264-399.104L512 704l116.736-175.104zM720 304a208 208 0 11-416 0 208 208 0 01416 0z"
}, null, -1);
const _hoisted_3$4X = [
  _hoisted_2$59
];
function _sfc_render$4b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5y, _hoisted_3$4X);
}
var avatar$3 = /* @__PURE__ */ _export_sfc(_sfc_main$4b, [["render", _sfc_render$4b]]);
const _sfc_main$4a = defineComponent({
  name: "Back"
});
const _hoisted_1$5x = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$58 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M224 480h640a32 32 0 110 64H224a32 32 0 010-64z"
}, null, -1);
const _hoisted_3$4W = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M237.248 512l265.408 265.344a32 32 0 01-45.312 45.312l-288-288a32 32 0 010-45.312l288-288a32 32 0 1145.312 45.312L237.248 512z"
}, null, -1);
const _hoisted_4$1J = [
  _hoisted_2$58,
  _hoisted_3$4W
];
function _sfc_render$4a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5x, _hoisted_4$1J);
}
var back = /* @__PURE__ */ _export_sfc(_sfc_main$4a, [["render", _sfc_render$4a]]);
const _sfc_main$49 = defineComponent({
  name: "Baseball"
});
const _hoisted_1$5w = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$57 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M195.2 828.8a448 448 0 11633.6-633.6 448 448 0 01-633.6 633.6zm45.248-45.248a384 384 0 10543.104-543.104 384 384 0 00-543.104 543.104z"
}, null, -1);
const _hoisted_3$4V = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M497.472 96.896c22.784 4.672 44.416 9.472 64.896 14.528a256.128 256.128 0 00350.208 350.208c5.056 20.48 9.856 42.112 14.528 64.896A320.128 320.128 0 01497.472 96.896zM108.48 491.904a320.128 320.128 0 01423.616 423.68c-23.04-3.648-44.992-7.424-65.728-11.52a256.128 256.128 0 00-346.496-346.432 1736.64 1736.64 0 01-11.392-65.728z"
}, null, -1);
const _hoisted_4$1I = [
  _hoisted_2$57,
  _hoisted_3$4V
];
function _sfc_render$49(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5w, _hoisted_4$1I);
}
var baseball = /* @__PURE__ */ _export_sfc(_sfc_main$49, [["render", _sfc_render$49]]);
const _sfc_main$48 = defineComponent({
  name: "Basketball"
});
const _hoisted_1$5v = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$56 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M778.752 788.224a382.464 382.464 0 00116.032-245.632 256.512 256.512 0 00-241.728-13.952 762.88 762.88 0 01125.696 259.584zm-55.04 44.224a699.648 699.648 0 00-125.056-269.632 256.128 256.128 0 00-56.064 331.968 382.72 382.72 0 00181.12-62.336zm-254.08 61.248A320.128 320.128 0 01557.76 513.6a715.84 715.84 0 00-48.192-48.128 320.128 320.128 0 01-379.264 88.384 382.4 382.4 0 00110.144 229.696 382.4 382.4 0 00229.184 110.08zM129.28 481.088a256.128 256.128 0 00331.072-56.448 699.648 699.648 0 00-268.8-124.352 382.656 382.656 0 00-62.272 180.8zm106.56-235.84a762.88 762.88 0 01258.688 125.056 256.512 256.512 0 00-13.44-241.088A382.464 382.464 0 00235.84 245.248zm318.08-114.944c40.576 89.536 37.76 193.92-8.448 281.344a779.84 779.84 0 0166.176 66.112 320.832 320.832 0 01282.112-8.128 382.4 382.4 0 00-110.144-229.12 382.4 382.4 0 00-229.632-110.208zM828.8 828.8a448 448 0 11-633.6-633.6 448 448 0 01633.6 633.6z"
}, null, -1);
const _hoisted_3$4U = [
  _hoisted_2$56
];
function _sfc_render$48(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5v, _hoisted_3$4U);
}
var basketball = /* @__PURE__ */ _export_sfc(_sfc_main$48, [["render", _sfc_render$48]]);
const _sfc_main$47 = defineComponent({
  name: "BellFilled"
});
const _hoisted_1$5u = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$55 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 832a128 128 0 01-256 0h256zm192-64H134.4a38.4 38.4 0 010-76.8H192V448c0-154.88 110.08-284.16 256.32-313.6a64 64 0 11127.36 0A320.128 320.128 0 01832 448v243.2h57.6a38.4 38.4 0 010 76.8H832z"
}, null, -1);
const _hoisted_3$4T = [
  _hoisted_2$55
];
function _sfc_render$47(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5u, _hoisted_3$4T);
}
var bellFilled = /* @__PURE__ */ _export_sfc(_sfc_main$47, [["render", _sfc_render$47]]);
const _sfc_main$46 = defineComponent({
  name: "Bell"
});
const _hoisted_1$5t = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$54 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a64 64 0 0164 64v64H448v-64a64 64 0 0164-64z"
}, null, -1);
const _hoisted_3$4S = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 768h512V448a256 256 0 10-512 0v320zm256-640a320 320 0 01320 320v384H192V448a320 320 0 01320-320z"
}, null, -1);
const _hoisted_4$1H = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M96 768h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32zM448 896h128a64 64 0 01-128 0z"
}, null, -1);
const _hoisted_5$I = [
  _hoisted_2$54,
  _hoisted_3$4S,
  _hoisted_4$1H
];
function _sfc_render$46(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5t, _hoisted_5$I);
}
var bell = /* @__PURE__ */ _export_sfc(_sfc_main$46, [["render", _sfc_render$46]]);
const _sfc_main$45 = defineComponent({
  name: "Bicycle"
});
const _hoisted_1$5s = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$53 = /* @__PURE__ */ createStaticVNode('<path fill="currentColor" d="M256 832a128 128 0 100-256 128 128 0 000 256zm0 64a192 192 0 110-384 192 192 0 010 384z"></path><path fill="currentColor" d="M288 672h320q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"></path><path fill="currentColor" d="M768 832a128 128 0 100-256 128 128 0 000 256zm0 64a192 192 0 110-384 192 192 0 010 384z"></path><path fill="currentColor" d="M480 192a32 32 0 010-64h160a32 32 0 0131.04 24.256l96 384a32 32 0 01-62.08 15.488L615.04 192H480zM96 384a32 32 0 010-64h128a32 32 0 0130.336 21.888l64 192a32 32 0 11-60.672 20.224L200.96 384H96z"></path><path fill="currentColor" d="M373.376 599.808l-42.752-47.616 320-288 42.752 47.616z"></path>', 5);
const _hoisted_7$d = [
  _hoisted_2$53
];
function _sfc_render$45(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5s, _hoisted_7$d);
}
var bicycle = /* @__PURE__ */ _export_sfc(_sfc_main$45, [["render", _sfc_render$45]]);
const _sfc_main$44 = defineComponent({
  name: "BottomLeft"
});
const _hoisted_1$5r = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$52 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 768h416a32 32 0 110 64H224a32 32 0 01-32-32V352a32 32 0 0164 0v416z"
}, null, -1);
const _hoisted_3$4R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M246.656 822.656a32 32 0 01-45.312-45.312l544-544a32 32 0 0145.312 45.312l-544 544z"
}, null, -1);
const _hoisted_4$1G = [
  _hoisted_2$52,
  _hoisted_3$4R
];
function _sfc_render$44(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5r, _hoisted_4$1G);
}
var bottomLeft = /* @__PURE__ */ _export_sfc(_sfc_main$44, [["render", _sfc_render$44]]);
const _sfc_main$43 = defineComponent({
  name: "BottomRight"
});
const _hoisted_1$5q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$51 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 768a32 32 0 100 64h448a32 32 0 0032-32V352a32 32 0 00-64 0v416H352z"
}, null, -1);
const _hoisted_3$4Q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M777.344 822.656a32 32 0 0045.312-45.312l-544-544a32 32 0 00-45.312 45.312l544 544z"
}, null, -1);
const _hoisted_4$1F = [
  _hoisted_2$51,
  _hoisted_3$4Q
];
function _sfc_render$43(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5q, _hoisted_4$1F);
}
var bottomRight = /* @__PURE__ */ _export_sfc(_sfc_main$43, [["render", _sfc_render$43]]);
const _sfc_main$42 = defineComponent({
  name: "Bottom"
});
const _hoisted_1$5p = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$50 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 805.888V168a32 32 0 10-64 0v637.888L246.656 557.952a30.72 30.72 0 00-45.312 0 35.52 35.52 0 000 48.064l288 306.048a30.72 30.72 0 0045.312 0l288-306.048a35.52 35.52 0 000-48 30.72 30.72 0 00-45.312 0L544 805.824z"
}, null, -1);
const _hoisted_3$4P = [
  _hoisted_2$50
];
function _sfc_render$42(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5p, _hoisted_3$4P);
}
var bottom = /* @__PURE__ */ _export_sfc(_sfc_main$42, [["render", _sfc_render$42]]);
const _sfc_main$41 = defineComponent({
  name: "Bowl"
});
const _hoisted_1$5o = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4$ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M714.432 704a351.744 351.744 0 00148.16-256H161.408a351.744 351.744 0 00148.16 256h404.864zM288 766.592A415.68 415.68 0 0196 416a32 32 0 0132-32h768a32 32 0 0132 32 415.68 415.68 0 01-192 350.592V832a64 64 0 01-64 64H352a64 64 0 01-64-64v-65.408zM493.248 320h-90.496l254.4-254.4a32 32 0 1145.248 45.248L493.248 320zm187.328 0h-128l269.696-155.712a32 32 0 0132 55.424L680.576 320zM352 768v64h320v-64H352z"
}, null, -1);
const _hoisted_3$4O = [
  _hoisted_2$4$
];
function _sfc_render$41(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5o, _hoisted_3$4O);
}
var bowl = /* @__PURE__ */ _export_sfc(_sfc_main$41, [["render", _sfc_render$41]]);
const _sfc_main$40 = defineComponent({
  name: "Box"
});
const _hoisted_1$5n = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4_ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M317.056 128L128 344.064V896h768V344.064L706.944 128H317.056zm-14.528-64h418.944a32 32 0 0124.064 10.88l206.528 236.096A32 32 0 01960 332.032V928a32 32 0 01-32 32H96a32 32 0 01-32-32V332.032a32 32 0 017.936-21.12L278.4 75.008A32 32 0 01302.528 64z"
}, null, -1);
const _hoisted_3$4N = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M64 320h896v64H64z"
}, null, -1);
const _hoisted_4$1E = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M448 327.872V640h128V327.872L526.08 128h-28.16L448 327.872zM448 64h128l64 256v352a32 32 0 01-32 32H416a32 32 0 01-32-32V320l64-256z"
}, null, -1);
const _hoisted_5$H = [
  _hoisted_2$4_,
  _hoisted_3$4N,
  _hoisted_4$1E
];
function _sfc_render$40(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5n, _hoisted_5$H);
}
var box = /* @__PURE__ */ _export_sfc(_sfc_main$40, [["render", _sfc_render$40]]);
const _sfc_main$3$ = defineComponent({
  name: "Briefcase"
});
const _hoisted_1$5m = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4Z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M320 320V128h384v192h192v192H128V320h192zM128 576h768v320H128V576zm256-256h256.064V192H384v128z"
}, null, -1);
const _hoisted_3$4M = [
  _hoisted_2$4Z
];
function _sfc_render$3$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5m, _hoisted_3$4M);
}
var briefcase = /* @__PURE__ */ _export_sfc(_sfc_main$3$, [["render", _sfc_render$3$]]);
const _sfc_main$3_ = defineComponent({
  name: "BrushFilled"
});
const _hoisted_1$5l = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4Y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M608 704v160a96 96 0 01-192 0V704h-96a128 128 0 01-128-128h640a128 128 0 01-128 128h-96zM192 512V128.064h640V512H192z"
}, null, -1);
const _hoisted_3$4L = [
  _hoisted_2$4Y
];
function _sfc_render$3_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5l, _hoisted_3$4L);
}
var brushFilled = /* @__PURE__ */ _export_sfc(_sfc_main$3_, [["render", _sfc_render$3_]]);
const _sfc_main$3Z = defineComponent({
  name: "Brush"
});
const _hoisted_1$5k = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4X = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M896 448H128v192a64 64 0 0064 64h192v192h256V704h192a64 64 0 0064-64V448zm-770.752-64c0-47.552 5.248-90.24 15.552-128 14.72-54.016 42.496-107.392 83.2-160h417.28l-15.36 70.336L736 96h211.2c-24.832 42.88-41.92 96.256-51.2 160a663.872 663.872 0 00-6.144 128H960v256a128 128 0 01-128 128H704v160a32 32 0 01-32 32H352a32 32 0 01-32-32V768H192A128 128 0 0164 640V384h61.248zm64 0h636.544c-2.048-45.824.256-91.584 6.848-137.216 4.48-30.848 10.688-59.776 18.688-86.784h-96.64l-221.12 141.248L561.92 160H256.512c-25.856 37.888-43.776 75.456-53.952 112.832-8.768 32.064-13.248 69.12-13.312 111.168z"
}, null, -1);
const _hoisted_3$4K = [
  _hoisted_2$4X
];
function _sfc_render$3Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5k, _hoisted_3$4K);
}
var brush = /* @__PURE__ */ _export_sfc(_sfc_main$3Z, [["render", _sfc_render$3Z]]);
const _sfc_main$3Y = defineComponent({
  name: "Burger"
});
const _hoisted_1$5j = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4W = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 512a32 32 0 00-32 32v64a32 32 0 0030.08 32H864a32 32 0 0032-32v-64a32 32 0 00-32-32H160zm736-58.56A96 96 0 01960 544v64a96 96 0 01-51.968 85.312L855.36 833.6a96 96 0 01-89.856 62.272H258.496A96 96 0 01168.64 833.6l-52.608-140.224A96 96 0 0164 608v-64a96 96 0 0164-90.56V448a384 384 0 11768 5.44zM832 448a320 320 0 00-640 0h640zM512 704H188.352l40.192 107.136a32 32 0 0029.952 20.736h507.008a32 32 0 0029.952-20.736L835.648 704H512z"
}, null, -1);
const _hoisted_3$4J = [
  _hoisted_2$4W
];
function _sfc_render$3Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5j, _hoisted_3$4J);
}
var burger = /* @__PURE__ */ _export_sfc(_sfc_main$3Y, [["render", _sfc_render$3Y]]);
const _sfc_main$3X = defineComponent({
  name: "Calendar"
});
const _hoisted_1$5i = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4V = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 384v512h768V192H768v32a32 32 0 11-64 0v-32H320v32a32 32 0 01-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1164 0v32h160a32 32 0 0132 32v768a32 32 0 01-32 32H96a32 32 0 01-32-32V160a32 32 0 0132-32h160V96a32 32 0 0164 0v32zm-32 384h64a32 32 0 010 64h-64a32 32 0 010-64zm0 192h64a32 32 0 110 64h-64a32 32 0 110-64zm192-192h64a32 32 0 010 64h-64a32 32 0 010-64zm0 192h64a32 32 0 110 64h-64a32 32 0 110-64zm192-192h64a32 32 0 110 64h-64a32 32 0 110-64zm0 192h64a32 32 0 110 64h-64a32 32 0 110-64z"
}, null, -1);
const _hoisted_3$4I = [
  _hoisted_2$4V
];
function _sfc_render$3X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5i, _hoisted_3$4I);
}
var calendar$3 = /* @__PURE__ */ _export_sfc(_sfc_main$3X, [["render", _sfc_render$3X]]);
const _sfc_main$3W = defineComponent({
  name: "CameraFilled"
});
const _hoisted_1$5h = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4U = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 224a64 64 0 00-64 64v512a64 64 0 0064 64h704a64 64 0 0064-64V288a64 64 0 00-64-64H748.416l-46.464-92.672A64 64 0 00644.736 96H379.328a64 64 0 00-57.216 35.392L275.776 224H160zm352 435.2a115.2 115.2 0 100-230.4 115.2 115.2 0 000 230.4zm0 140.8a256 256 0 110-512 256 256 0 010 512z"
}, null, -1);
const _hoisted_3$4H = [
  _hoisted_2$4U
];
function _sfc_render$3W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5h, _hoisted_3$4H);
}
var cameraFilled = /* @__PURE__ */ _export_sfc(_sfc_main$3W, [["render", _sfc_render$3W]]);
const _sfc_main$3V = defineComponent({
  name: "Camera"
});
const _hoisted_1$5g = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4T = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M896 256H128v576h768V256zm-199.424-64l-32.064-64h-304.96l-32 64h369.024zM96 192h160l46.336-92.608A64 64 0 01359.552 64h304.96a64 64 0 0157.216 35.328L768.192 192H928a32 32 0 0132 32v640a32 32 0 01-32 32H96a32 32 0 01-32-32V224a32 32 0 0132-32zm416 512a160 160 0 100-320 160 160 0 000 320zm0 64a224 224 0 110-448 224 224 0 010 448z"
}, null, -1);
const _hoisted_3$4G = [
  _hoisted_2$4T
];
function _sfc_render$3V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5g, _hoisted_3$4G);
}
var camera = /* @__PURE__ */ _export_sfc(_sfc_main$3V, [["render", _sfc_render$3V]]);
const _sfc_main$3U = defineComponent({
  name: "CaretBottom"
});
const _hoisted_1$5f = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4S = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 384l320 384 320-384z"
}, null, -1);
const _hoisted_3$4F = [
  _hoisted_2$4S
];
function _sfc_render$3U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5f, _hoisted_3$4F);
}
var caretBottom = /* @__PURE__ */ _export_sfc(_sfc_main$3U, [["render", _sfc_render$3U]]);
const _sfc_main$3T = defineComponent({
  name: "CaretLeft"
});
const _hoisted_1$5e = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M672 192L288 511.936 672 832z"
}, null, -1);
const _hoisted_3$4E = [
  _hoisted_2$4R
];
function _sfc_render$3T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5e, _hoisted_3$4E);
}
var caretLeft = /* @__PURE__ */ _export_sfc(_sfc_main$3T, [["render", _sfc_render$3T]]);
const _sfc_main$3S = defineComponent({
  name: "CaretRight"
});
const _hoisted_1$5d = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4Q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 192v640l384-320.064z"
}, null, -1);
const _hoisted_3$4D = [
  _hoisted_2$4Q
];
function _sfc_render$3S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5d, _hoisted_3$4D);
}
var caretRight = /* @__PURE__ */ _export_sfc(_sfc_main$3S, [["render", _sfc_render$3S]]);
const _sfc_main$3R = defineComponent({
  name: "CaretTop"
});
const _hoisted_1$5c = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4P = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 320L192 704h639.936z"
}, null, -1);
const _hoisted_3$4C = [
  _hoisted_2$4P
];
function _sfc_render$3R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5c, _hoisted_3$4C);
}
var caretTop = /* @__PURE__ */ _export_sfc(_sfc_main$3R, [["render", _sfc_render$3R]]);
const _sfc_main$3Q = defineComponent({
  name: "Cellphone"
});
const _hoisted_1$5b = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 128a64 64 0 00-64 64v640a64 64 0 0064 64h512a64 64 0 0064-64V192a64 64 0 00-64-64H256zm0-64h512a128 128 0 01128 128v640a128 128 0 01-128 128H256a128 128 0 01-128-128V192A128 128 0 01256 64zm128 128h256a32 32 0 110 64H384a32 32 0 010-64zm128 640a64 64 0 110-128 64 64 0 010 128z"
}, null, -1);
const _hoisted_3$4B = [
  _hoisted_2$4O
];
function _sfc_render$3Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5b, _hoisted_3$4B);
}
var cellphone = /* @__PURE__ */ _export_sfc(_sfc_main$3Q, [["render", _sfc_render$3Q]]);
const _sfc_main$3P = defineComponent({
  name: "ChatDotRound"
});
const _hoisted_1$5a = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4N = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M174.72 855.68l135.296-45.12 23.68 11.84C388.096 849.536 448.576 864 512 864c211.84 0 384-166.784 384-352S723.84 160 512 160 128 326.784 128 512c0 69.12 24.96 139.264 70.848 199.232l22.08 28.8-46.272 115.584zm-45.248 82.56A32 32 0 0189.6 896l58.368-145.92C94.72 680.32 64 596.864 64 512 64 299.904 256 96 512 96s448 203.904 448 416-192 416-448 416a461.056 461.056 0 01-206.912-48.384l-175.616 58.56z"
}, null, -1);
const _hoisted_3$4A = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 563.2a51.2 51.2 0 110-102.4 51.2 51.2 0 010 102.4zm192 0a51.2 51.2 0 110-102.4 51.2 51.2 0 010 102.4zm-384 0a51.2 51.2 0 110-102.4 51.2 51.2 0 010 102.4z"
}, null, -1);
const _hoisted_4$1D = [
  _hoisted_2$4N,
  _hoisted_3$4A
];
function _sfc_render$3P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5a, _hoisted_4$1D);
}
var chatDotRound = /* @__PURE__ */ _export_sfc(_sfc_main$3P, [["render", _sfc_render$3P]]);
const _sfc_main$3O = defineComponent({
  name: "ChatDotSquare"
});
const _hoisted_1$59 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4M = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M273.536 736H800a64 64 0 0064-64V256a64 64 0 00-64-64H224a64 64 0 00-64 64v570.88L273.536 736zM296 800L147.968 918.4A32 32 0 0196 893.44V256a128 128 0 01128-128h576a128 128 0 01128 128v416a128 128 0 01-128 128H296z"
}, null, -1);
const _hoisted_3$4z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 499.2a51.2 51.2 0 110-102.4 51.2 51.2 0 010 102.4zm192 0a51.2 51.2 0 110-102.4 51.2 51.2 0 010 102.4zm-384 0a51.2 51.2 0 110-102.4 51.2 51.2 0 010 102.4z"
}, null, -1);
const _hoisted_4$1C = [
  _hoisted_2$4M,
  _hoisted_3$4z
];
function _sfc_render$3O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$59, _hoisted_4$1C);
}
var chatDotSquare = /* @__PURE__ */ _export_sfc(_sfc_main$3O, [["render", _sfc_render$3O]]);
const _sfc_main$3N = defineComponent({
  name: "ChatLineRound"
});
const _hoisted_1$58 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4L = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M174.72 855.68l135.296-45.12 23.68 11.84C388.096 849.536 448.576 864 512 864c211.84 0 384-166.784 384-352S723.84 160 512 160 128 326.784 128 512c0 69.12 24.96 139.264 70.848 199.232l22.08 28.8-46.272 115.584zm-45.248 82.56A32 32 0 0189.6 896l58.368-145.92C94.72 680.32 64 596.864 64 512 64 299.904 256 96 512 96s448 203.904 448 416-192 416-448 416a461.056 461.056 0 01-206.912-48.384l-175.616 58.56z"
}, null, -1);
const _hoisted_3$4y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 576h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zM384 384h256q32 0 32 32t-32 32H384q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$1B = [
  _hoisted_2$4L,
  _hoisted_3$4y
];
function _sfc_render$3N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$58, _hoisted_4$1B);
}
var chatLineRound = /* @__PURE__ */ _export_sfc(_sfc_main$3N, [["render", _sfc_render$3N]]);
const _sfc_main$3M = defineComponent({
  name: "ChatLineSquare"
});
const _hoisted_1$57 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4K = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 826.88L273.536 736H800a64 64 0 0064-64V256a64 64 0 00-64-64H224a64 64 0 00-64 64v570.88zM296 800L147.968 918.4A32 32 0 0196 893.44V256a128 128 0 01128-128h576a128 128 0 01128 128v416a128 128 0 01-128 128H296z"
}, null, -1);
const _hoisted_3$4x = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 512h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zM352 320h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$1A = [
  _hoisted_2$4K,
  _hoisted_3$4x
];
function _sfc_render$3M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$57, _hoisted_4$1A);
}
var chatLineSquare = /* @__PURE__ */ _export_sfc(_sfc_main$3M, [["render", _sfc_render$3M]]);
const _sfc_main$3L = defineComponent({
  name: "ChatRound"
});
const _hoisted_1$56 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4J = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M174.72 855.68l130.048-43.392 23.424 11.392C382.4 849.984 444.352 864 512 864c223.744 0 384-159.872 384-352 0-192.832-159.104-352-384-352S128 319.168 128 512a341.12 341.12 0 0069.248 204.288l21.632 28.8-44.16 110.528zm-45.248 82.56A32 32 0 0189.6 896l56.512-141.248A405.12 405.12 0 0164 512C64 299.904 235.648 96 512 96s448 203.904 448 416-173.44 416-448 416c-79.68 0-150.848-17.152-211.712-46.72l-170.88 56.96z"
}, null, -1);
const _hoisted_3$4w = [
  _hoisted_2$4J
];
function _sfc_render$3L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$56, _hoisted_3$4w);
}
var chatRound = /* @__PURE__ */ _export_sfc(_sfc_main$3L, [["render", _sfc_render$3L]]);
const _sfc_main$3K = defineComponent({
  name: "ChatSquare"
});
const _hoisted_1$55 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4I = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M273.536 736H800a64 64 0 0064-64V256a64 64 0 00-64-64H224a64 64 0 00-64 64v570.88L273.536 736zM296 800L147.968 918.4A32 32 0 0196 893.44V256a128 128 0 01128-128h576a128 128 0 01128 128v416a128 128 0 01-128 128H296z"
}, null, -1);
const _hoisted_3$4v = [
  _hoisted_2$4I
];
function _sfc_render$3K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$55, _hoisted_3$4v);
}
var chatSquare = /* @__PURE__ */ _export_sfc(_sfc_main$3K, [["render", _sfc_render$3K]]);
const _sfc_main$3J = defineComponent({
  name: "Check"
});
const _hoisted_1$54 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4H = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z"
}, null, -1);
const _hoisted_3$4u = [
  _hoisted_2$4H
];
function _sfc_render$3J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$54, _hoisted_3$4u);
}
var check = /* @__PURE__ */ _export_sfc(_sfc_main$3J, [["render", _sfc_render$3J]]);
const _sfc_main$3I = defineComponent({
  name: "Checked"
});
const _hoisted_1$53 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4G = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 192h160v736H160V192h160.064v64H704v-64zM311.616 537.28l-45.312 45.248L447.36 763.52l316.8-316.8-45.312-45.184L447.36 673.024 311.616 537.28zM384 192V96h256v96H384z"
}, null, -1);
const _hoisted_3$4t = [
  _hoisted_2$4G
];
function _sfc_render$3I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$53, _hoisted_3$4t);
}
var checked = /* @__PURE__ */ _export_sfc(_sfc_main$3I, [["render", _sfc_render$3I]]);
const _sfc_main$3H = defineComponent({
  name: "Cherry"
});
const _hoisted_1$52 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4F = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M261.056 449.6c13.824-69.696 34.88-128.96 63.36-177.728 23.744-40.832 61.12-88.64 112.256-143.872H320a32 32 0 010-64h384a32 32 0 110 64H554.752c14.912 39.168 41.344 86.592 79.552 141.76 47.36 68.48 84.8 106.752 106.304 114.304a224 224 0 11-84.992 14.784c-22.656-22.912-47.04-53.76-73.92-92.608-38.848-56.128-67.008-105.792-84.352-149.312-55.296 58.24-94.528 107.52-117.76 147.2-23.168 39.744-41.088 88.768-53.568 147.072a224.064 224.064 0 11-64.96-1.6zM288 832a160 160 0 100-320 160 160 0 000 320zm448-64a160 160 0 100-320 160 160 0 000 320z"
}, null, -1);
const _hoisted_3$4s = [
  _hoisted_2$4F
];
function _sfc_render$3H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$52, _hoisted_3$4s);
}
var cherry = /* @__PURE__ */ _export_sfc(_sfc_main$3H, [["render", _sfc_render$3H]]);
const _sfc_main$3G = defineComponent({
  name: "Chicken"
});
const _hoisted_1$51 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4E = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M349.952 716.992L478.72 588.16a106.688 106.688 0 01-26.176-19.072 106.688 106.688 0 01-19.072-26.176L304.704 671.744c.768 3.072 1.472 6.144 2.048 9.216l2.048 31.936 31.872 1.984c3.136.64 6.208 1.28 9.28 2.112zm57.344 33.152a128 128 0 11-216.32 114.432l-1.92-32-32-1.92a128 128 0 11114.432-216.32L416.64 469.248c-2.432-101.44 58.112-239.104 149.056-330.048 107.328-107.328 231.296-85.504 316.8 0 85.44 85.44 107.328 209.408 0 316.8-91.008 90.88-228.672 151.424-330.112 149.056L407.296 750.08zm90.496-226.304c49.536 49.536 233.344-7.04 339.392-113.088 78.208-78.208 63.232-163.072 0-226.304-63.168-63.232-148.032-78.208-226.24 0C504.896 290.496 448.32 474.368 497.792 523.84zM244.864 708.928a64 64 0 10-59.84 59.84l56.32-3.52 3.52-56.32zm8.064 127.68a64 64 0 1059.84-59.84l-56.32 3.52-3.52 56.32z"
}, null, -1);
const _hoisted_3$4r = [
  _hoisted_2$4E
];
function _sfc_render$3G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$51, _hoisted_3$4r);
}
var chicken = /* @__PURE__ */ _export_sfc(_sfc_main$3G, [["render", _sfc_render$3G]]);
const _sfc_main$3F = defineComponent({
  name: "CircleCheckFilled"
});
const _hoisted_1$50 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4D = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm-55.808 536.384l-99.52-99.584a38.4 38.4 0 10-54.336 54.336l126.72 126.72a38.272 38.272 0 0054.336 0l262.4-262.464a38.4 38.4 0 10-54.272-54.336L456.192 600.384z"
}, null, -1);
const _hoisted_3$4q = [
  _hoisted_2$4D
];
function _sfc_render$3F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$50, _hoisted_3$4q);
}
var circleCheckFilled = /* @__PURE__ */ _export_sfc(_sfc_main$3F, [["render", _sfc_render$3F]]);
const _sfc_main$3E = defineComponent({
  name: "CircleCheck"
});
const _hoisted_1$4$ = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4C = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3$4p = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M745.344 361.344a32 32 0 0145.312 45.312l-288 288a32 32 0 01-45.312 0l-160-160a32 32 0 1145.312-45.312L480 626.752l265.344-265.408z"
}, null, -1);
const _hoisted_4$1z = [
  _hoisted_2$4C,
  _hoisted_3$4p
];
function _sfc_render$3E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4$, _hoisted_4$1z);
}
var circleCheck = /* @__PURE__ */ _export_sfc(_sfc_main$3E, [["render", _sfc_render$3E]]);
const _sfc_main$3D = defineComponent({
  name: "CircleCloseFilled"
});
const _hoisted_1$4_ = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4B = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm0 393.664L407.936 353.6a38.4 38.4 0 10-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1054.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1054.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 10-54.336-54.336L512 457.664z"
}, null, -1);
const _hoisted_3$4o = [
  _hoisted_2$4B
];
function _sfc_render$3D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4_, _hoisted_3$4o);
}
var circleCloseFilled = /* @__PURE__ */ _export_sfc(_sfc_main$3D, [["render", _sfc_render$3D]]);
const _sfc_main$3C = defineComponent({
  name: "CircleClose"
});
const _hoisted_1$4Z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4A = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M466.752 512l-90.496-90.496a32 32 0 0145.248-45.248L512 466.752l90.496-90.496a32 32 0 1145.248 45.248L557.248 512l90.496 90.496a32 32 0 11-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 01-45.248-45.248L466.752 512z"
}, null, -1);
const _hoisted_3$4n = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_4$1y = [
  _hoisted_2$4A,
  _hoisted_3$4n
];
function _sfc_render$3C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4Z, _hoisted_4$1y);
}
var circleClose = /* @__PURE__ */ _export_sfc(_sfc_main$3C, [["render", _sfc_render$3C]]);
const _sfc_main$3B = defineComponent({
  name: "CirclePlusFilled"
});
const _hoisted_1$4Y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm-38.4 409.6H326.4a38.4 38.4 0 100 76.8h147.2v147.2a38.4 38.4 0 0076.8 0V550.4h147.2a38.4 38.4 0 000-76.8H550.4V326.4a38.4 38.4 0 10-76.8 0v147.2z"
}, null, -1);
const _hoisted_3$4m = [
  _hoisted_2$4z
];
function _sfc_render$3B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4Y, _hoisted_3$4m);
}
var circlePlusFilled = /* @__PURE__ */ _export_sfc(_sfc_main$3B, [["render", _sfc_render$3B]]);
const _sfc_main$3A = defineComponent({
  name: "CirclePlus"
});
const _hoisted_1$4X = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 480h320a32 32 0 110 64H352a32 32 0 010-64z"
}, null, -1);
const _hoisted_3$4l = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 672V352a32 32 0 1164 0v320a32 32 0 01-64 0z"
}, null, -1);
const _hoisted_4$1x = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_5$G = [
  _hoisted_2$4y,
  _hoisted_3$4l,
  _hoisted_4$1x
];
function _sfc_render$3A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4X, _hoisted_5$G);
}
var circlePlus = /* @__PURE__ */ _export_sfc(_sfc_main$3A, [["render", _sfc_render$3A]]);
const _sfc_main$3z = defineComponent({
  name: "Clock"
});
const _hoisted_1$4W = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4x = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3$4k = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 256a32 32 0 0132 32v256a32 32 0 01-64 0V288a32 32 0 0132-32z"
}, null, -1);
const _hoisted_4$1w = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_5$F = [
  _hoisted_2$4x,
  _hoisted_3$4k,
  _hoisted_4$1w
];
function _sfc_render$3z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4W, _hoisted_5$F);
}
var clock = /* @__PURE__ */ _export_sfc(_sfc_main$3z, [["render", _sfc_render$3z]]);
const _sfc_main$3y = defineComponent({
  name: "CloseBold"
});
const _hoisted_1$4V = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4w = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M195.2 195.2a64 64 0 0190.496 0L512 421.504 738.304 195.2a64 64 0 0190.496 90.496L602.496 512 828.8 738.304a64 64 0 01-90.496 90.496L512 602.496 285.696 828.8a64 64 0 01-90.496-90.496L421.504 512 195.2 285.696a64 64 0 010-90.496z"
}, null, -1);
const _hoisted_3$4j = [
  _hoisted_2$4w
];
function _sfc_render$3y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4V, _hoisted_3$4j);
}
var closeBold = /* @__PURE__ */ _export_sfc(_sfc_main$3y, [["render", _sfc_render$3y]]);
const _sfc_main$3x = defineComponent({
  name: "Close"
});
const _hoisted_1$4U = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4v = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M764.288 214.592L512 466.88 259.712 214.592a31.936 31.936 0 00-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1045.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0045.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 10-45.12-45.184z"
}, null, -1);
const _hoisted_3$4i = [
  _hoisted_2$4v
];
function _sfc_render$3x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4U, _hoisted_3$4i);
}
var close = /* @__PURE__ */ _export_sfc(_sfc_main$3x, [["render", _sfc_render$3x]]);
const _sfc_main$3w = defineComponent({
  name: "Cloudy"
});
const _hoisted_1$4T = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4u = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M598.4 831.872H328.192a256 256 0 01-34.496-510.528A352 352 0 11598.4 831.872zm-271.36-64h272.256a288 288 0 10-248.512-417.664L335.04 381.44l-34.816 3.584a192 192 0 0026.88 382.848z"
}, null, -1);
const _hoisted_3$4h = [
  _hoisted_2$4u
];
function _sfc_render$3w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4T, _hoisted_3$4h);
}
var cloudy = /* @__PURE__ */ _export_sfc(_sfc_main$3w, [["render", _sfc_render$3w]]);
const _sfc_main$3v = defineComponent({
  name: "CoffeeCup"
});
const _hoisted_1$4S = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4t = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M768 192a192 192 0 11-8 383.808A256.128 256.128 0 01512 768H320A256 256 0 0164 512V160a32 32 0 0132-32h640a32 32 0 0132 32v32zm0 64v256a128 128 0 100-256zM96 832h640a32 32 0 110 64H96a32 32 0 110-64zm32-640v320a192 192 0 00192 192h192a192 192 0 00192-192V192H128z"
}, null, -1);
const _hoisted_3$4g = [
  _hoisted_2$4t
];
function _sfc_render$3v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4S, _hoisted_3$4g);
}
var coffeeCup = /* @__PURE__ */ _export_sfc(_sfc_main$3v, [["render", _sfc_render$3v]]);
const _sfc_main$3u = defineComponent({
  name: "Coffee"
});
const _hoisted_1$4R = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4s = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M822.592 192h14.272a32 32 0 0131.616 26.752l21.312 128A32 32 0 01858.24 384h-49.344l-39.04 546.304A32 32 0 01737.92 960H285.824a32 32 0 01-32-29.696L214.912 384H165.76a32 32 0 01-31.552-37.248l21.312-128A32 32 0 01187.136 192h14.016l-6.72-93.696A32 32 0 01226.368 64h571.008a32 32 0 0131.936 34.304L822.592 192zm-64.128 0l4.544-64H260.736l4.544 64h493.184zm-548.16 128H820.48l-10.688-64H214.208l-10.688 64h6.784zm68.736 64l36.544 512H708.16l36.544-512H279.04z"
}, null, -1);
const _hoisted_3$4f = [
  _hoisted_2$4s
];
function _sfc_render$3u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4R, _hoisted_3$4f);
}
var coffee = /* @__PURE__ */ _export_sfc(_sfc_main$3u, [["render", _sfc_render$3u]]);
const _sfc_main$3t = defineComponent({
  name: "Coin"
});
const _hoisted_1$4Q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4r = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M161.92 580.736l29.888 58.88C171.328 659.776 160 681.728 160 704c0 82.304 155.328 160 352 160s352-77.696 352-160c0-22.272-11.392-44.16-31.808-64.32l30.464-58.432C903.936 615.808 928 657.664 928 704c0 129.728-188.544 224-416 224S96 833.728 96 704c0-46.592 24.32-88.576 65.92-123.264z"
}, null, -1);
const _hoisted_3$4e = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M161.92 388.736l29.888 58.88C171.328 467.84 160 489.792 160 512c0 82.304 155.328 160 352 160s352-77.696 352-160c0-22.272-11.392-44.16-31.808-64.32l30.464-58.432C903.936 423.808 928 465.664 928 512c0 129.728-188.544 224-416 224S96 641.728 96 512c0-46.592 24.32-88.576 65.92-123.264z"
}, null, -1);
const _hoisted_4$1v = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 544c-227.456 0-416-94.272-416-224S284.544 96 512 96s416 94.272 416 224-188.544 224-416 224zm0-64c196.672 0 352-77.696 352-160S708.672 160 512 160s-352 77.696-352 160 155.328 160 352 160z"
}, null, -1);
const _hoisted_5$E = [
  _hoisted_2$4r,
  _hoisted_3$4e,
  _hoisted_4$1v
];
function _sfc_render$3t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4Q, _hoisted_5$E);
}
var coin = /* @__PURE__ */ _export_sfc(_sfc_main$3t, [["render", _sfc_render$3t]]);
const _sfc_main$3s = defineComponent({
  name: "ColdDrink"
});
const _hoisted_1$4P = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M768 64a192 192 0 11-69.952 370.88L480 725.376V896h96a32 32 0 110 64H320a32 32 0 110-64h96V725.376L76.8 273.536a64 64 0 01-12.8-38.4v-10.688a32 32 0 0132-32h71.808l-65.536-83.84a32 32 0 0150.432-39.424l96.256 123.264h337.728A192.064 192.064 0 01768 64zM656.896 192.448H800a32 32 0 0132 32v10.624a64 64 0 01-12.8 38.4l-80.448 107.2a128 128 0 10-81.92-188.16v-.064zm-357.888 64l129.472 165.76a32 32 0 01-50.432 39.36l-160.256-205.12H144l304 404.928 304-404.928H299.008z"
}, null, -1);
const _hoisted_3$4d = [
  _hoisted_2$4q
];
function _sfc_render$3s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4P, _hoisted_3$4d);
}
var coldDrink = /* @__PURE__ */ _export_sfc(_sfc_main$3s, [["render", _sfc_render$3s]]);
const _sfc_main$3r = defineComponent({
  name: "CollectionTag"
});
const _hoisted_1$4O = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4p = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 128v698.88l196.032-156.864a96 96 0 01119.936 0L768 826.816V128H256zm-32-64h576a32 32 0 0132 32v797.44a32 32 0 01-51.968 24.96L531.968 720a32 32 0 00-39.936 0L243.968 918.4A32 32 0 01192 893.44V96a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$4c = [
  _hoisted_2$4p
];
function _sfc_render$3r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4O, _hoisted_3$4c);
}
var collectionTag = /* @__PURE__ */ _export_sfc(_sfc_main$3r, [["render", _sfc_render$3r]]);
const _sfc_main$3q = defineComponent({
  name: "Collection"
});
const _hoisted_1$4N = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4o = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 736h640V128H256a64 64 0 00-64 64v544zm64-672h608a32 32 0 0132 32v672a32 32 0 01-32 32H160l-32 57.536V192A128 128 0 01256 64z"
}, null, -1);
const _hoisted_3$4b = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M240 800a48 48 0 100 96h592v-96H240zm0-64h656v160a64 64 0 01-64 64H240a112 112 0 010-224zm144-608v250.88l96-76.8 96 76.8V128H384zm-64-64h320v381.44a32 32 0 01-51.968 24.96L480 384l-108.032 86.4A32 32 0 01320 445.44V64z"
}, null, -1);
const _hoisted_4$1u = [
  _hoisted_2$4o,
  _hoisted_3$4b
];
function _sfc_render$3q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4N, _hoisted_4$1u);
}
var collection = /* @__PURE__ */ _export_sfc(_sfc_main$3q, [["render", _sfc_render$3q]]);
const _sfc_main$3p = defineComponent({
  name: "Comment"
});
const _hoisted_1$4M = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4n = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M736 504a56 56 0 110-112 56 56 0 010 112zm-224 0a56 56 0 110-112 56 56 0 010 112zm-224 0a56 56 0 110-112 56 56 0 010 112zM128 128v640h192v160l224-160h352V128H128z"
}, null, -1);
const _hoisted_3$4a = [
  _hoisted_2$4n
];
function _sfc_render$3p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4M, _hoisted_3$4a);
}
var comment = /* @__PURE__ */ _export_sfc(_sfc_main$3p, [["render", _sfc_render$3p]]);
const _sfc_main$3o = defineComponent({
  name: "Compass"
});
const _hoisted_1$4L = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4m = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3$49 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M725.888 315.008C676.48 428.672 624 513.28 568.576 568.64c-55.424 55.424-139.968 107.904-253.568 157.312a12.8 12.8 0 01-16.896-16.832c49.536-113.728 102.016-198.272 157.312-253.632 55.36-55.296 139.904-107.776 253.632-157.312a12.8 12.8 0 0116.832 16.832z"
}, null, -1);
const _hoisted_4$1t = [
  _hoisted_2$4m,
  _hoisted_3$49
];
function _sfc_render$3o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4L, _hoisted_4$1t);
}
var compass = /* @__PURE__ */ _export_sfc(_sfc_main$3o, [["render", _sfc_render$3o]]);
const _sfc_main$3n = defineComponent({
  name: "Connection"
});
const _hoisted_1$4K = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4l = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 384v64H448a128 128 0 00-128 128v128a128 128 0 00128 128h320a128 128 0 00128-128V576a128 128 0 00-64-110.848V394.88c74.56 26.368 128 97.472 128 181.056v128a192 192 0 01-192 192H448a192 192 0 01-192-192V576a192 192 0 01192-192h192z"
}, null, -1);
const _hoisted_3$48 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 640v-64h192a128 128 0 00128-128V320a128 128 0 00-128-128H256a128 128 0 00-128 128v128a128 128 0 0064 110.848v70.272A192.064 192.064 0 0164 448V320a192 192 0 01192-192h320a192 192 0 01192 192v128a192 192 0 01-192 192H384z"
}, null, -1);
const _hoisted_4$1s = [
  _hoisted_2$4l,
  _hoisted_3$48
];
function _sfc_render$3n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4K, _hoisted_4$1s);
}
var connection = /* @__PURE__ */ _export_sfc(_sfc_main$3n, [["render", _sfc_render$3n]]);
const _sfc_main$3m = defineComponent({
  name: "Coordinate"
});
const _hoisted_1$4J = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4k = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 512h64v320h-64z"
}, null, -1);
const _hoisted_3$47 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 896h640a64 64 0 00-64-64H256a64 64 0 00-64 64zm64-128h512a128 128 0 01128 128v64H128v-64a128 128 0 01128-128zm256-256a192 192 0 100-384 192 192 0 000 384zm0 64a256 256 0 110-512 256 256 0 010 512z"
}, null, -1);
const _hoisted_4$1r = [
  _hoisted_2$4k,
  _hoisted_3$47
];
function _sfc_render$3m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4J, _hoisted_4$1r);
}
var coordinate = /* @__PURE__ */ _export_sfc(_sfc_main$3m, [["render", _sfc_render$3m]]);
const _sfc_main$3l = defineComponent({
  name: "CopyDocument"
});
const _hoisted_1$4I = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4j = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M768 832a128 128 0 01-128 128H192A128 128 0 0164 832V384a128 128 0 01128-128v64a64 64 0 00-64 64v448a64 64 0 0064 64h448a64 64 0 0064-64h64z"
}, null, -1);
const _hoisted_3$46 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 128a64 64 0 00-64 64v448a64 64 0 0064 64h448a64 64 0 0064-64V192a64 64 0 00-64-64H384zm0-64h448a128 128 0 01128 128v448a128 128 0 01-128 128H384a128 128 0 01-128-128V192A128 128 0 01384 64z"
}, null, -1);
const _hoisted_4$1q = [
  _hoisted_2$4j,
  _hoisted_3$46
];
function _sfc_render$3l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4I, _hoisted_4$1q);
}
var copyDocument = /* @__PURE__ */ _export_sfc(_sfc_main$3l, [["render", _sfc_render$3l]]);
const _sfc_main$3k = defineComponent({
  name: "Cpu"
});
const _hoisted_1$4H = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4i = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M320 256a64 64 0 00-64 64v384a64 64 0 0064 64h384a64 64 0 0064-64V320a64 64 0 00-64-64H320zm0-64h384a128 128 0 01128 128v384a128 128 0 01-128 128H320a128 128 0 01-128-128V320a128 128 0 01128-128z"
}, null, -1);
const _hoisted_3$45 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0132 32v128h-64V96a32 32 0 0132-32zm160 0a32 32 0 0132 32v128h-64V96a32 32 0 0132-32zm-320 0a32 32 0 0132 32v128h-64V96a32 32 0 0132-32zm160 896a32 32 0 01-32-32V800h64v128a32 32 0 01-32 32zm160 0a32 32 0 01-32-32V800h64v128a32 32 0 01-32 32zm-320 0a32 32 0 01-32-32V800h64v128a32 32 0 01-32 32zM64 512a32 32 0 0132-32h128v64H96a32 32 0 01-32-32zm0-160a32 32 0 0132-32h128v64H96a32 32 0 01-32-32zm0 320a32 32 0 0132-32h128v64H96a32 32 0 01-32-32zm896-160a32 32 0 01-32 32H800v-64h128a32 32 0 0132 32zm0-160a32 32 0 01-32 32H800v-64h128a32 32 0 0132 32zm0 320a32 32 0 01-32 32H800v-64h128a32 32 0 0132 32z"
}, null, -1);
const _hoisted_4$1p = [
  _hoisted_2$4i,
  _hoisted_3$45
];
function _sfc_render$3k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4H, _hoisted_4$1p);
}
var cpu = /* @__PURE__ */ _export_sfc(_sfc_main$3k, [["render", _sfc_render$3k]]);
const _sfc_main$3j = defineComponent({
  name: "CreditCard"
});
const _hoisted_1$4G = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4h = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M896 324.096c0-42.368-2.496-55.296-9.536-68.48a52.352 52.352 0 00-22.144-22.08c-13.12-7.04-26.048-9.536-68.416-9.536H228.096c-42.368 0-55.296 2.496-68.48 9.536a52.352 52.352 0 00-22.08 22.144c-7.04 13.12-9.536 26.048-9.536 68.416v375.808c0 42.368 2.496 55.296 9.536 68.48a52.352 52.352 0 0022.144 22.08c13.12 7.04 26.048 9.536 68.416 9.536h567.808c42.368 0 55.296-2.496 68.48-9.536a52.352 52.352 0 0022.08-22.144c7.04-13.12 9.536-26.048 9.536-68.416V324.096zm64 0v375.808c0 57.088-5.952 77.76-17.088 98.56-11.136 20.928-27.52 37.312-48.384 48.448-20.864 11.136-41.6 17.088-98.56 17.088H228.032c-57.088 0-77.76-5.952-98.56-17.088a116.288 116.288 0 01-48.448-48.384c-11.136-20.864-17.088-41.6-17.088-98.56V324.032c0-57.088 5.952-77.76 17.088-98.56 11.136-20.928 27.52-37.312 48.384-48.448 20.864-11.136 41.6-17.088 98.56-17.088H795.84c57.088 0 77.76 5.952 98.56 17.088 20.928 11.136 37.312 27.52 48.448 48.384 11.136 20.864 17.088 41.6 17.088 98.56z"
}, null, -1);
const _hoisted_3$44 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M64 320h896v64H64v-64zm0 128h896v64H64v-64zm128 192h256v64H192z"
}, null, -1);
const _hoisted_4$1o = [
  _hoisted_2$4h,
  _hoisted_3$44
];
function _sfc_render$3j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4G, _hoisted_4$1o);
}
var creditCard = /* @__PURE__ */ _export_sfc(_sfc_main$3j, [["render", _sfc_render$3j]]);
const _sfc_main$3i = defineComponent({
  name: "Crop"
});
const _hoisted_1$4F = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4g = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 768h672a32 32 0 110 64H224a32 32 0 01-32-32V96a32 32 0 0164 0v672z"
}, null, -1);
const _hoisted_3$43 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M832 224v704a32 32 0 11-64 0V256H96a32 32 0 010-64h704a32 32 0 0132 32z"
}, null, -1);
const _hoisted_4$1n = [
  _hoisted_2$4g,
  _hoisted_3$43
];
function _sfc_render$3i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4F, _hoisted_4$1n);
}
var crop = /* @__PURE__ */ _export_sfc(_sfc_main$3i, [["render", _sfc_render$3i]]);
const _sfc_main$3h = defineComponent({
  name: "DArrowLeft"
});
const _hoisted_1$4E = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4f = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M529.408 149.376a29.12 29.12 0 0141.728 0 30.592 30.592 0 010 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 01-.512 43.264 29.12 29.12 0 01-41.216-.512L197.76 534.272a32 32 0 010-44.672l331.648-340.224zm256 0a29.12 29.12 0 0141.728 0 30.592 30.592 0 010 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 01-.512 43.264 29.12 29.12 0 01-41.216-.512L453.76 534.272a32 32 0 010-44.672l331.648-340.224z"
}, null, -1);
const _hoisted_3$42 = [
  _hoisted_2$4f
];
function _sfc_render$3h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4E, _hoisted_3$42);
}
var dArrowLeft = /* @__PURE__ */ _export_sfc(_sfc_main$3h, [["render", _sfc_render$3h]]);
const _sfc_main$3g = defineComponent({
  name: "DArrowRight"
});
const _hoisted_1$4D = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4e = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M452.864 149.312a29.12 29.12 0 0141.728.064L826.24 489.664a32 32 0 010 44.672L494.592 874.624a29.12 29.12 0 01-41.728 0 30.592 30.592 0 010-42.752L764.736 512 452.864 192a30.592 30.592 0 010-42.688zm-256 0a29.12 29.12 0 0141.728.064L570.24 489.664a32 32 0 010 44.672L238.592 874.624a29.12 29.12 0 01-41.728 0 30.592 30.592 0 010-42.752L508.736 512 196.864 192a30.592 30.592 0 010-42.688z"
}, null, -1);
const _hoisted_3$41 = [
  _hoisted_2$4e
];
function _sfc_render$3g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4D, _hoisted_3$41);
}
var dArrowRight = /* @__PURE__ */ _export_sfc(_sfc_main$3g, [["render", _sfc_render$3g]]);
const _sfc_main$3f = defineComponent({
  name: "DCaret"
});
const _hoisted_1$4C = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4d = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 128l288 320H224l288-320zM224 576h576L512 896 224 576z"
}, null, -1);
const _hoisted_3$40 = [
  _hoisted_2$4d
];
function _sfc_render$3f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4C, _hoisted_3$40);
}
var dCaret = /* @__PURE__ */ _export_sfc(_sfc_main$3f, [["render", _sfc_render$3f]]);
const _sfc_main$3e = defineComponent({
  name: "DataAnalysis"
});
const _hoisted_1$4B = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4c = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M665.216 768l110.848 192h-73.856L591.36 768H433.024L322.176 960H248.32l110.848-192H160a32 32 0 01-32-32V192H64a32 32 0 010-64h896a32 32 0 110 64h-64v544a32 32 0 01-32 32H665.216zM832 192H192v512h640V192zM352 448a32 32 0 0132 32v64a32 32 0 01-64 0v-64a32 32 0 0132-32zm160-64a32 32 0 0132 32v128a32 32 0 01-64 0V416a32 32 0 0132-32zm160-64a32 32 0 0132 32v192a32 32 0 11-64 0V352a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$3$ = [
  _hoisted_2$4c
];
function _sfc_render$3e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4B, _hoisted_3$3$);
}
var dataAnalysis = /* @__PURE__ */ _export_sfc(_sfc_main$3e, [["render", _sfc_render$3e]]);
const _sfc_main$3d = defineComponent({
  name: "DataBoard"
});
const _hoisted_1$4A = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4b = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M32 128h960v64H32z"
}, null, -1);
const _hoisted_3$3_ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 192v512h640V192H192zm-64-64h768v608a32 32 0 01-32 32H160a32 32 0 01-32-32V128z"
}, null, -1);
const _hoisted_4$1m = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M322.176 960H248.32l144.64-250.56 55.424 32L322.176 960zm453.888 0h-73.856L576 741.44l55.424-32L776.064 960z"
}, null, -1);
const _hoisted_5$D = [
  _hoisted_2$4b,
  _hoisted_3$3_,
  _hoisted_4$1m
];
function _sfc_render$3d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4A, _hoisted_5$D);
}
var dataBoard = /* @__PURE__ */ _export_sfc(_sfc_main$3d, [["render", _sfc_render$3d]]);
const _sfc_main$3c = defineComponent({
  name: "DataLine"
});
const _hoisted_1$4z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4a = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M359.168 768H160a32 32 0 01-32-32V192H64a32 32 0 010-64h896a32 32 0 110 64h-64v544a32 32 0 01-32 32H665.216l110.848 192h-73.856L591.36 768H433.024L322.176 960H248.32l110.848-192zM832 192H192v512h640V192zM342.656 534.656a32 32 0 11-45.312-45.312L444.992 341.76l125.44 94.08L679.04 300.032a32 32 0 1149.92 39.936L581.632 524.224 451.008 426.24 342.656 534.592z"
}, null, -1);
const _hoisted_3$3Z = [
  _hoisted_2$4a
];
function _sfc_render$3c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4z, _hoisted_3$3Z);
}
var dataLine = /* @__PURE__ */ _export_sfc(_sfc_main$3c, [["render", _sfc_render$3c]]);
const _sfc_main$3b = defineComponent({
  name: "DeleteFilled"
});
const _hoisted_1$4y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$49 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 192V95.936a32 32 0 0132-32h256a32 32 0 0132 32V192h256a32 32 0 110 64H96a32 32 0 010-64h256zm64 0h192v-64H416v64zM192 960a32 32 0 01-32-32V256h704v672a32 32 0 01-32 32H192zm224-192a32 32 0 0032-32V416a32 32 0 00-64 0v320a32 32 0 0032 32zm192 0a32 32 0 0032-32V416a32 32 0 00-64 0v320a32 32 0 0032 32z"
}, null, -1);
const _hoisted_3$3Y = [
  _hoisted_2$49
];
function _sfc_render$3b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4y, _hoisted_3$3Y);
}
var deleteFilled = /* @__PURE__ */ _export_sfc(_sfc_main$3b, [["render", _sfc_render$3b]]);
const _sfc_main$3a = defineComponent({
  name: "DeleteLocation"
});
const _hoisted_1$4x = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$48 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_3$3X = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 10-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 01704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_4$1l = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 384h256q32 0 32 32t-32 32H384q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_5$C = [
  _hoisted_2$48,
  _hoisted_3$3X,
  _hoisted_4$1l
];
function _sfc_render$3a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4x, _hoisted_5$C);
}
var deleteLocation = /* @__PURE__ */ _export_sfc(_sfc_main$3a, [["render", _sfc_render$3a]]);
const _sfc_main$39 = defineComponent({
  name: "Delete"
});
const _hoisted_1$4w = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$47 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 256H96a32 32 0 010-64h256V95.936a32 32 0 0132-32h256a32 32 0 0132 32V192h256a32 32 0 110 64h-64v672a32 32 0 01-32 32H192a32 32 0 01-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 01-32-32V416a32 32 0 0164 0v320a32 32 0 01-32 32zm192 0a32 32 0 01-32-32V416a32 32 0 0164 0v320a32 32 0 01-32 32z"
}, null, -1);
const _hoisted_3$3W = [
  _hoisted_2$47
];
function _sfc_render$39(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4w, _hoisted_3$3W);
}
var _delete = /* @__PURE__ */ _export_sfc(_sfc_main$39, [["render", _sfc_render$39]]);
const _sfc_main$38 = defineComponent({
  name: "Dessert"
});
const _hoisted_1$4v = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$46 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 416v-48a144 144 0 01168.64-141.888 224.128 224.128 0 01430.72 0A144 144 0 01896 368v48a384 384 0 01-352 382.72V896h-64v-97.28A384 384 0 01128 416zm287.104-32.064h193.792a143.808 143.808 0 0158.88-132.736 160.064 160.064 0 00-311.552 0 143.808 143.808 0 0158.88 132.8zm-72.896 0a72 72 0 10-140.48 0h140.48zm339.584 0h140.416a72 72 0 10-140.48 0zM512 736a320 320 0 00318.4-288.064H193.6A320 320 0 00512 736zM384 896.064h256a32 32 0 110 64H384a32 32 0 110-64z"
}, null, -1);
const _hoisted_3$3V = [
  _hoisted_2$46
];
function _sfc_render$38(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4v, _hoisted_3$3V);
}
var dessert = /* @__PURE__ */ _export_sfc(_sfc_main$38, [["render", _sfc_render$38]]);
const _sfc_main$37 = defineComponent({
  name: "Discount"
});
const _hoisted_1$4u = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$45 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M224 704h576V318.336L552.512 115.84a64 64 0 00-81.024 0L224 318.336V704zm0 64v128h576V768H224zM593.024 66.304l259.2 212.096A32 32 0 01864 303.168V928a32 32 0 01-32 32H192a32 32 0 01-32-32V303.168a32 32 0 0111.712-24.768l259.2-212.096a128 128 0 01162.112 0z"
}, null, -1);
const _hoisted_3$3U = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 448a64 64 0 100-128 64 64 0 000 128zm0 64a128 128 0 110-256 128 128 0 010 256z"
}, null, -1);
const _hoisted_4$1k = [
  _hoisted_2$45,
  _hoisted_3$3U
];
function _sfc_render$37(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4u, _hoisted_4$1k);
}
var discount = /* @__PURE__ */ _export_sfc(_sfc_main$37, [["render", _sfc_render$37]]);
const _sfc_main$36 = defineComponent({
  name: "DishDot"
});
const _hoisted_1$4t = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$44 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384.064 274.56l.064-50.688A128 128 0 01512.128 96c70.528 0 127.68 57.152 127.68 127.68v50.752A448.192 448.192 0 01955.392 768H68.544A448.192 448.192 0 01384 274.56zM96 832h832a32 32 0 110 64H96a32 32 0 110-64zm32-128h768a384 384 0 10-768 0zm447.808-448v-32.32a63.68 63.68 0 00-63.68-63.68 64 64 0 00-64 63.936V256h127.68z"
}, null, -1);
const _hoisted_3$3T = [
  _hoisted_2$44
];
function _sfc_render$36(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4t, _hoisted_3$3T);
}
var dishDot = /* @__PURE__ */ _export_sfc(_sfc_main$36, [["render", _sfc_render$36]]);
const _sfc_main$35 = defineComponent({
  name: "Dish"
});
const _hoisted_1$4s = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$43 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 257.152V192h-96a32 32 0 010-64h256a32 32 0 110 64h-96v65.152A448 448 0 01955.52 768H68.48A448 448 0 01480 257.152zM128 704h768a384 384 0 10-768 0zM96 832h832a32 32 0 110 64H96a32 32 0 110-64z"
}, null, -1);
const _hoisted_3$3S = [
  _hoisted_2$43
];
function _sfc_render$35(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4s, _hoisted_3$3S);
}
var dish = /* @__PURE__ */ _export_sfc(_sfc_main$35, [["render", _sfc_render$35]]);
const _sfc_main$34 = defineComponent({
  name: "DocumentAdd"
});
const _hoisted_1$4r = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$42 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32zm320 512V448h64v128h128v64H544v128h-64V640H352v-64h128z"
}, null, -1);
const _hoisted_3$3R = [
  _hoisted_2$42
];
function _sfc_render$34(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4r, _hoisted_3$3R);
}
var documentAdd = /* @__PURE__ */ _export_sfc(_sfc_main$34, [["render", _sfc_render$34]]);
const _sfc_main$33 = defineComponent({
  name: "DocumentChecked"
});
const _hoisted_1$4q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$41 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M805.504 320L640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32zm318.4 582.144l180.992-180.992L704.64 510.4 478.4 736.64 320 578.304l45.248-45.312L478.4 646.144z"
}, null, -1);
const _hoisted_3$3Q = [
  _hoisted_2$41
];
function _sfc_render$33(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4q, _hoisted_3$3Q);
}
var documentChecked = /* @__PURE__ */ _export_sfc(_sfc_main$33, [["render", _sfc_render$33]]);
const _sfc_main$32 = defineComponent({
  name: "DocumentCopy"
});
const _hoisted_1$4p = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$40 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 320v576h576V320H128zm-32-64h640a32 32 0 0132 32v640a32 32 0 01-32 32H96a32 32 0 01-32-32V288a32 32 0 0132-32zM960 96v704a32 32 0 01-32 32h-96v-64h64V128H384v64h-64V96a32 32 0 0132-32h576a32 32 0 0132 32zM256 672h320v64H256v-64zm0-192h320v64H256v-64z"
}, null, -1);
const _hoisted_3$3P = [
  _hoisted_2$40
];
function _sfc_render$32(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4p, _hoisted_3$3P);
}
var documentCopy = /* @__PURE__ */ _export_sfc(_sfc_main$32, [["render", _sfc_render$32]]);
const _sfc_main$31 = defineComponent({
  name: "DocumentDelete"
});
const _hoisted_1$4o = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3$ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M805.504 320L640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32zm308.992 546.304l-90.496-90.624 45.248-45.248 90.56 90.496 90.496-90.432 45.248 45.248-90.496 90.56 90.496 90.496-45.248 45.248-90.496-90.496-90.56 90.496-45.248-45.248 90.496-90.496z"
}, null, -1);
const _hoisted_3$3O = [
  _hoisted_2$3$
];
function _sfc_render$31(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4o, _hoisted_3$3O);
}
var documentDelete = /* @__PURE__ */ _export_sfc(_sfc_main$31, [["render", _sfc_render$31]]);
const _sfc_main$30 = defineComponent({
  name: "DocumentRemove"
});
const _hoisted_1$4n = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3_ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M805.504 320L640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32zm192 512h320v64H352v-64z"
}, null, -1);
const _hoisted_3$3N = [
  _hoisted_2$3_
];
function _sfc_render$30(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4n, _hoisted_3$3N);
}
var documentRemove = /* @__PURE__ */ _export_sfc(_sfc_main$30, [["render", _sfc_render$30]]);
const _sfc_main$2$ = defineComponent({
  name: "Document"
});
const _hoisted_1$4m = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3Z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1);
const _hoisted_3$3M = [
  _hoisted_2$3Z
];
function _sfc_render$2$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4m, _hoisted_3$3M);
}
var document$1 = /* @__PURE__ */ _export_sfc(_sfc_main$2$, [["render", _sfc_render$2$]]);
const _sfc_main$2_ = defineComponent({
  name: "Download"
});
const _hoisted_1$4l = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3Y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 832h704a32 32 0 110 64H160a32 32 0 110-64zm384-253.696l236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64v450.304z"
}, null, -1);
const _hoisted_3$3L = [
  _hoisted_2$3Y
];
function _sfc_render$2_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4l, _hoisted_3$3L);
}
var download = /* @__PURE__ */ _export_sfc(_sfc_main$2_, [["render", _sfc_render$2_]]);
const _sfc_main$2Z = defineComponent({
  name: "Drizzling"
});
const _hoisted_1$4k = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3X = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M739.328 291.328l-35.2-6.592-12.8-33.408a192.064 192.064 0 00-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 00-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0035.776-380.672zM959.552 480a256 256 0 01-256 256h-400A239.808 239.808 0 0163.744 496.192a240.32 240.32 0 01199.488-236.8 256.128 256.128 0 01487.872-30.976A256.064 256.064 0 01959.552 480zM288 800h64v64h-64v-64zm192 0h64v64h-64v-64zm-96 96h64v64h-64v-64zm192 0h64v64h-64v-64zm96-96h64v64h-64v-64z"
}, null, -1);
const _hoisted_3$3K = [
  _hoisted_2$3X
];
function _sfc_render$2Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4k, _hoisted_3$3K);
}
var drizzling = /* @__PURE__ */ _export_sfc(_sfc_main$2Z, [["render", _sfc_render$2Z]]);
const _sfc_main$2Y = defineComponent({
  name: "Edit"
});
const _hoisted_1$4j = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3W = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M832 512a32 32 0 1164 0v352a32 32 0 01-32 32H160a32 32 0 01-32-32V160a32 32 0 0132-32h352a32 32 0 010 64H192v640h640V512z"
}, null, -1);
const _hoisted_3$3J = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M469.952 554.24l52.8-7.552L847.104 222.4a32 32 0 10-45.248-45.248L477.44 501.44l-7.552 52.8zm422.4-422.4a96 96 0 010 135.808l-331.84 331.84a32 32 0 01-18.112 9.088L436.8 623.68a32 32 0 01-36.224-36.224l15.104-105.6a32 32 0 019.024-18.112l331.904-331.84a96 96 0 01135.744 0z"
}, null, -1);
const _hoisted_4$1j = [
  _hoisted_2$3W,
  _hoisted_3$3J
];
function _sfc_render$2Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4j, _hoisted_4$1j);
}
var edit = /* @__PURE__ */ _export_sfc(_sfc_main$2Y, [["render", _sfc_render$2Y]]);
const _sfc_main$2X = defineComponent({
  name: "ElemeFilled"
});
const _hoisted_1$4i = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3V = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M176 64h672c61.824 0 112 50.176 112 112v672a112 112 0 01-112 112H176A112 112 0 0164 848V176c0-61.824 50.176-112 112-112zm150.528 173.568c-152.896 99.968-196.544 304.064-97.408 456.96a330.688 330.688 0 00456.96 96.64c9.216-5.888 17.6-11.776 25.152-18.56a18.24 18.24 0 004.224-24.32L700.352 724.8a47.552 47.552 0 00-65.536-14.272A234.56 234.56 0 01310.592 641.6C240 533.248 271.104 387.968 379.456 316.48a234.304 234.304 0 01276.352 15.168c1.664.832 2.56 2.56 3.392 4.224 5.888 8.384 3.328 19.328-5.12 25.216L456.832 489.6a47.552 47.552 0 00-14.336 65.472l16 24.384c5.888 8.384 16.768 10.88 25.216 5.056l308.224-199.936a19.584 19.584 0 006.72-23.488v-.896c-4.992-9.216-10.048-17.6-15.104-26.88-99.968-151.168-304.064-194.88-456.96-95.744zM786.88 504.704l-62.208 40.32c-8.32 5.888-10.88 16.768-4.992 25.216L760 632.32c5.888 8.448 16.768 11.008 25.152 5.12l31.104-20.16a55.36 55.36 0 0016-76.48l-20.224-31.04a19.52 19.52 0 00-25.152-5.12z"
}, null, -1);
const _hoisted_3$3I = [
  _hoisted_2$3V
];
function _sfc_render$2X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4i, _hoisted_3$3I);
}
var elemeFilled = /* @__PURE__ */ _export_sfc(_sfc_main$2X, [["render", _sfc_render$2X]]);
const _sfc_main$2W = defineComponent({
  name: "Eleme"
});
const _hoisted_1$4h = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3U = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M300.032 188.8c174.72-113.28 408-63.36 522.24 109.44 5.76 10.56 11.52 20.16 17.28 30.72v.96a22.4 22.4 0 01-7.68 26.88l-352.32 228.48c-9.6 6.72-22.08 3.84-28.8-5.76l-18.24-27.84a54.336 54.336 0 0116.32-74.88l225.6-146.88c9.6-6.72 12.48-19.2 5.76-28.8-.96-1.92-1.92-3.84-3.84-4.8a267.84 267.84 0 00-315.84-17.28c-123.84 81.6-159.36 247.68-78.72 371.52a268.096 268.096 0 00370.56 78.72 54.336 54.336 0 0174.88 16.32l17.28 26.88c5.76 9.6 3.84 21.12-4.8 27.84-8.64 7.68-18.24 14.4-28.8 21.12a377.92 377.92 0 01-522.24-110.4c-113.28-174.72-63.36-408 111.36-522.24zm526.08 305.28a22.336 22.336 0 0128.8 5.76l23.04 35.52a63.232 63.232 0 01-18.24 87.36l-35.52 23.04c-9.6 6.72-22.08 3.84-28.8-5.76l-46.08-71.04c-6.72-9.6-3.84-22.08 5.76-28.8l71.04-46.08z"
}, null, -1);
const _hoisted_3$3H = [
  _hoisted_2$3U
];
function _sfc_render$2W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4h, _hoisted_3$3H);
}
var eleme = /* @__PURE__ */ _export_sfc(_sfc_main$2W, [["render", _sfc_render$2W]]);
const _sfc_main$2V = defineComponent({
  name: "Expand"
});
const _hoisted_1$4g = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3T = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 192h768v128H128V192zm0 256h512v128H128V448zm0 256h768v128H128V704zm576-352l192 160-192 128V352z"
}, null, -1);
const _hoisted_3$3G = [
  _hoisted_2$3T
];
function _sfc_render$2V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4g, _hoisted_3$3G);
}
var expand$1 = /* @__PURE__ */ _export_sfc(_sfc_main$2V, [["render", _sfc_render$2V]]);
const _sfc_main$2U = defineComponent({
  name: "Failed"
});
const _hoisted_1$4f = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3S = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M557.248 608l135.744-135.744-45.248-45.248-135.68 135.744-135.808-135.68-45.248 45.184L466.752 608l-135.68 135.68 45.184 45.312L512 653.248l135.744 135.744 45.248-45.248L557.312 608zM704 192h160v736H160V192h160v64h384v-64zm-320 0V96h256v96H384z"
}, null, -1);
const _hoisted_3$3F = [
  _hoisted_2$3S
];
function _sfc_render$2U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4f, _hoisted_3$3F);
}
var failed = /* @__PURE__ */ _export_sfc(_sfc_main$2U, [["render", _sfc_render$2U]]);
const _sfc_main$2T = defineComponent({
  name: "Female"
});
const _hoisted_1$4e = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 640a256 256 0 100-512 256 256 0 000 512zm0 64a320 320 0 110-640 320 320 0 010 640z"
}, null, -1);
const _hoisted_3$3E = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 640q32 0 32 32v256q0 32-32 32t-32-32V672q0-32 32-32z"
}, null, -1);
const _hoisted_4$1i = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 800h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_5$B = [
  _hoisted_2$3R,
  _hoisted_3$3E,
  _hoisted_4$1i
];
function _sfc_render$2T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4e, _hoisted_5$B);
}
var female = /* @__PURE__ */ _export_sfc(_sfc_main$2T, [["render", _sfc_render$2T]]);
const _sfc_main$2S = defineComponent({
  name: "Files"
});
const _hoisted_1$4d = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3Q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 384v448h768V384H128zm-32-64h832a32 32 0 0132 32v512a32 32 0 01-32 32H96a32 32 0 01-32-32V352a32 32 0 0132-32zM160 192h704v64H160zm96-128h512v64H256z"
}, null, -1);
const _hoisted_3$3D = [
  _hoisted_2$3Q
];
function _sfc_render$2S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4d, _hoisted_3$3D);
}
var files = /* @__PURE__ */ _export_sfc(_sfc_main$2S, [["render", _sfc_render$2S]]);
const _sfc_main$2R = defineComponent({
  name: "Film"
});
const _hoisted_1$4c = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3P = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 160v704h704V160H160zm-32-64h768a32 32 0 0132 32v768a32 32 0 01-32 32H128a32 32 0 01-32-32V128a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$3C = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M320 288V128h64v352h256V128h64v160h160v64H704v128h160v64H704v128h160v64H704v160h-64V544H384v352h-64V736H128v-64h192V544H128v-64h192V352H128v-64h192z"
}, null, -1);
const _hoisted_4$1h = [
  _hoisted_2$3P,
  _hoisted_3$3C
];
function _sfc_render$2R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4c, _hoisted_4$1h);
}
var film = /* @__PURE__ */ _export_sfc(_sfc_main$2R, [["render", _sfc_render$2R]]);
const _sfc_main$2Q = defineComponent({
  name: "Filter"
});
const _hoisted_1$4b = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 523.392V928a32 32 0 0046.336 28.608l192-96A32 32 0 00640 832V523.392l280.768-343.104a32 32 0 10-49.536-40.576l-288 352A32 32 0 00576 512v300.224l-128 64V512a32 32 0 00-7.232-20.288L195.52 192H704a32 32 0 100-64H128a32 32 0 00-24.768 52.288L384 523.392z"
}, null, -1);
const _hoisted_3$3B = [
  _hoisted_2$3O
];
function _sfc_render$2Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4b, _hoisted_3$3B);
}
var filter = /* @__PURE__ */ _export_sfc(_sfc_main$2Q, [["render", _sfc_render$2Q]]);
const _sfc_main$2P = defineComponent({
  name: "Finished"
});
const _hoisted_1$4a = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3N = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M280.768 753.728L691.456 167.04a32 32 0 1152.416 36.672L314.24 817.472a32 32 0 01-45.44 7.296l-230.4-172.8a32 32 0 0138.4-51.2l203.968 152.96zM736 448a32 32 0 110-64h192a32 32 0 110 64H736zM608 640a32 32 0 010-64h319.936a32 32 0 110 64H608zM480 832a32 32 0 110-64h447.936a32 32 0 110 64H480z"
}, null, -1);
const _hoisted_3$3A = [
  _hoisted_2$3N
];
function _sfc_render$2P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4a, _hoisted_3$3A);
}
var finished = /* @__PURE__ */ _export_sfc(_sfc_main$2P, [["render", _sfc_render$2P]]);
const _sfc_main$2O = defineComponent({
  name: "FirstAidKit"
});
const _hoisted_1$49 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3M = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 256a64 64 0 00-64 64v448a64 64 0 0064 64h640a64 64 0 0064-64V320a64 64 0 00-64-64H192zm0-64h640a128 128 0 01128 128v448a128 128 0 01-128 128H192A128 128 0 0164 768V320a128 128 0 01128-128z"
}, null, -1);
const _hoisted_3$3z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 512h96a32 32 0 010 64h-96v96a32 32 0 01-64 0v-96h-96a32 32 0 010-64h96v-96a32 32 0 0164 0v96zM352 128v64h320v-64H352zm-32-64h384a32 32 0 0132 32v128a32 32 0 01-32 32H320a32 32 0 01-32-32V96a32 32 0 0132-32z"
}, null, -1);
const _hoisted_4$1g = [
  _hoisted_2$3M,
  _hoisted_3$3z
];
function _sfc_render$2O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$49, _hoisted_4$1g);
}
var firstAidKit = /* @__PURE__ */ _export_sfc(_sfc_main$2O, [["render", _sfc_render$2O]]);
const _sfc_main$2N = defineComponent({
  name: "Flag"
});
const _hoisted_1$48 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3L = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 128h608L736 384l160 256H288v320h-96V64h96v64z"
}, null, -1);
const _hoisted_3$3y = [
  _hoisted_2$3L
];
function _sfc_render$2N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$48, _hoisted_3$3y);
}
var flag = /* @__PURE__ */ _export_sfc(_sfc_main$2N, [["render", _sfc_render$2N]]);
const _sfc_main$2M = defineComponent({
  name: "Fold"
});
const _hoisted_1$47 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3K = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M896 192H128v128h768V192zm0 256H384v128h512V448zm0 256H128v128h768V704zM320 384L128 512l192 128V384z"
}, null, -1);
const _hoisted_3$3x = [
  _hoisted_2$3K
];
function _sfc_render$2M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$47, _hoisted_3$3x);
}
var fold = /* @__PURE__ */ _export_sfc(_sfc_main$2M, [["render", _sfc_render$2M]]);
const _sfc_main$2L = defineComponent({
  name: "FolderAdd"
});
const _hoisted_1$46 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3J = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0132 32v576a32 32 0 01-32 32H96a32 32 0 01-32-32V160a32 32 0 0132-32zm384 416V416h64v128h128v64H544v128h-64V608H352v-64h128z"
}, null, -1);
const _hoisted_3$3w = [
  _hoisted_2$3J
];
function _sfc_render$2L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$46, _hoisted_3$3w);
}
var folderAdd = /* @__PURE__ */ _export_sfc(_sfc_main$2L, [["render", _sfc_render$2L]]);
const _sfc_main$2K = defineComponent({
  name: "FolderChecked"
});
const _hoisted_1$45 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3I = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0132 32v576a32 32 0 01-32 32H96a32 32 0 01-32-32V160a32 32 0 0132-32zm414.08 502.144l180.992-180.992L736.32 494.4 510.08 720.64l-158.4-158.336 45.248-45.312L510.08 630.144z"
}, null, -1);
const _hoisted_3$3v = [
  _hoisted_2$3I
];
function _sfc_render$2K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$45, _hoisted_3$3v);
}
var folderChecked = /* @__PURE__ */ _export_sfc(_sfc_main$2K, [["render", _sfc_render$2K]]);
const _sfc_main$2J = defineComponent({
  name: "FolderDelete"
});
const _hoisted_1$44 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3H = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0132 32v576a32 32 0 01-32 32H96a32 32 0 01-32-32V160a32 32 0 0132-32zm370.752 448l-90.496-90.496 45.248-45.248L512 530.752l90.496-90.496 45.248 45.248L557.248 576l90.496 90.496-45.248 45.248L512 621.248l-90.496 90.496-45.248-45.248L466.752 576z"
}, null, -1);
const _hoisted_3$3u = [
  _hoisted_2$3H
];
function _sfc_render$2J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$44, _hoisted_3$3u);
}
var folderDelete = /* @__PURE__ */ _export_sfc(_sfc_main$2J, [["render", _sfc_render$2J]]);
const _sfc_main$2I = defineComponent({
  name: "FolderOpened"
});
const _hoisted_1$43 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3G = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M878.08 448H241.92l-96 384h636.16l96-384zM832 384v-64H485.76L357.504 192H128v448l57.92-231.744A32 32 0 01216.96 384H832zm-24.96 512H96a32 32 0 01-32-32V160a32 32 0 0132-32h287.872l128.384 128H864a32 32 0 0132 32v96h23.04a32 32 0 0131.04 39.744l-112 448A32 32 0 01807.04 896z"
}, null, -1);
const _hoisted_3$3t = [
  _hoisted_2$3G
];
function _sfc_render$2I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$43, _hoisted_3$3t);
}
var folderOpened = /* @__PURE__ */ _export_sfc(_sfc_main$2I, [["render", _sfc_render$2I]]);
const _sfc_main$2H = defineComponent({
  name: "FolderRemove"
});
const _hoisted_1$42 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3F = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0132 32v576a32 32 0 01-32 32H96a32 32 0 01-32-32V160a32 32 0 0132-32zm256 416h320v64H352v-64z"
}, null, -1);
const _hoisted_3$3s = [
  _hoisted_2$3F
];
function _sfc_render$2H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$42, _hoisted_3$3s);
}
var folderRemove = /* @__PURE__ */ _export_sfc(_sfc_main$2H, [["render", _sfc_render$2H]]);
const _sfc_main$2G = defineComponent({
  name: "Folder"
});
const _hoisted_1$41 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3E = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0132 32v576a32 32 0 01-32 32H96a32 32 0 01-32-32V160a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$3r = [
  _hoisted_2$3E
];
function _sfc_render$2G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$41, _hoisted_3$3r);
}
var folder = /* @__PURE__ */ _export_sfc(_sfc_main$2G, [["render", _sfc_render$2G]]);
const _sfc_main$2F = defineComponent({
  name: "Food"
});
const _hoisted_1$40 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3D = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 352.576V352a288 288 0 01491.072-204.224 192 192 0 01274.24 204.48 64 64 0 0157.216 74.24C921.6 600.512 850.048 710.656 736 756.992V800a96 96 0 01-96 96H384a96 96 0 01-96-96v-43.008c-114.048-46.336-185.6-156.48-214.528-330.496A64 64 0 01128 352.64zm64-.576h64a160 160 0 01320 0h64a224 224 0 00-448 0zm128 0h192a96 96 0 00-192 0zm439.424 0h68.544A128.256 128.256 0 00704 192c-15.36 0-29.952 2.688-43.52 7.616 11.328 18.176 20.672 37.76 27.84 58.304A64.128 64.128 0 01759.424 352zM672 768H352v32a32 32 0 0032 32h256a32 32 0 0032-32v-32zm-342.528-64h365.056c101.504-32.64 165.76-124.928 192.896-288H136.576c27.136 163.072 91.392 255.36 192.896 288z"
}, null, -1);
const _hoisted_3$3q = [
  _hoisted_2$3D
];
function _sfc_render$2F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$40, _hoisted_3$3q);
}
var food = /* @__PURE__ */ _export_sfc(_sfc_main$2F, [["render", _sfc_render$2F]]);
const _sfc_main$2E = defineComponent({
  name: "Football"
});
const _hoisted_1$3$ = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3C = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 960a448 448 0 110-896 448 448 0 010 896zm0-64a384 384 0 100-768 384 384 0 000 768z"
}, null, -1);
const _hoisted_3$3p = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M186.816 268.288c16-16.384 31.616-31.744 46.976-46.08 17.472 30.656 39.808 58.112 65.984 81.28l-32.512 56.448a385.984 385.984 0 01-80.448-91.648zm653.696-5.312a385.92 385.92 0 01-83.776 96.96l-32.512-56.384a322.923 322.923 0 0068.48-85.76c15.552 14.08 31.488 29.12 47.808 45.184zM465.984 445.248l11.136-63.104a323.584 323.584 0 0069.76 0l11.136 63.104a387.968 387.968 0 01-92.032 0zm-62.72-12.8A381.824 381.824 0 01320 396.544l32-55.424a319.885 319.885 0 0062.464 27.712l-11.2 63.488zm300.8-35.84a381.824 381.824 0 01-83.328 35.84l-11.2-63.552A319.885 319.885 0 00672 341.184l32 55.424zm-520.768 364.8a385.92 385.92 0 0183.968-97.28l32.512 56.32c-26.88 23.936-49.856 52.352-67.52 84.032-16-13.44-32.32-27.712-48.96-43.072zm657.536.128a1442.759 1442.759 0 01-49.024 43.072 321.408 321.408 0 00-67.584-84.16l32.512-56.32c33.216 27.456 61.696 60.352 84.096 97.408zM465.92 578.752a387.968 387.968 0 0192.032 0l-11.136 63.104a323.584 323.584 0 00-69.76 0l-11.136-63.104zm-62.72 12.8l11.2 63.552a319.885 319.885 0 00-62.464 27.712L320 627.392a381.824 381.824 0 0183.264-35.84zm300.8 35.84l-32 55.424a318.272 318.272 0 00-62.528-27.712l11.2-63.488c29.44 8.64 57.28 20.736 83.264 35.776z"
}, null, -1);
const _hoisted_4$1f = [
  _hoisted_2$3C,
  _hoisted_3$3p
];
function _sfc_render$2E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3$, _hoisted_4$1f);
}
var football = /* @__PURE__ */ _export_sfc(_sfc_main$2E, [["render", _sfc_render$2E]]);
const _sfc_main$2D = defineComponent({
  name: "ForkSpoon"
});
const _hoisted_1$3_ = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3B = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 410.304V96a32 32 0 0164 0v314.304a96 96 0 0064-90.56V96a32 32 0 0164 0v223.744a160 160 0 01-128 156.8V928a32 32 0 11-64 0V476.544a160 160 0 01-128-156.8V96a32 32 0 0164 0v223.744a96 96 0 0064 90.56zM672 572.48C581.184 552.128 512 446.848 512 320c0-141.44 85.952-256 192-256s192 114.56 192 256c0 126.848-69.184 232.128-160 252.48V928a32 32 0 11-64 0V572.48zM704 512c66.048 0 128-82.56 128-192s-61.952-192-128-192-128 82.56-128 192 61.952 192 128 192z"
}, null, -1);
const _hoisted_3$3o = [
  _hoisted_2$3B
];
function _sfc_render$2D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3_, _hoisted_3$3o);
}
var forkSpoon = /* @__PURE__ */ _export_sfc(_sfc_main$2D, [["render", _sfc_render$2D]]);
const _sfc_main$2C = defineComponent({
  name: "Fries"
});
const _hoisted_1$3Z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3A = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M608 224v-64a32 32 0 00-64 0v336h26.88A64 64 0 00608 484.096V224zm101.12 160A64 64 0 00672 395.904V384h64V224a32 32 0 10-64 0v160h37.12zm74.88 0a92.928 92.928 0 0191.328 110.08l-60.672 323.584A96 96 0 01720.32 896H303.68a96 96 0 01-94.336-78.336L148.672 494.08A92.928 92.928 0 01240 384h-16V224a96 96 0 01188.608-25.28A95.744 95.744 0 01480 197.44V160a96 96 0 01188.608-25.28A96 96 0 01800 224v160h-16zM670.784 512a128 128 0 01-99.904 48H453.12a128 128 0 01-99.84-48H352v-1.536a128.128 128.128 0 01-9.984-14.976L314.88 448H240a28.928 28.928 0 00-28.48 34.304L241.088 640h541.824l29.568-157.696A28.928 28.928 0 00784 448h-74.88l-27.136 47.488A132.405 132.405 0 01672 510.464V512h-1.216zM480 288a32 32 0 00-64 0v196.096A64 64 0 00453.12 496H480V288zm-128 96V224a32 32 0 00-64 0v160h64-37.12A64 64 0 01352 395.904zm-98.88 320l19.072 101.888A32 32 0 00303.68 832h416.64a32 32 0 0031.488-26.112L770.88 704H253.12z"
}, null, -1);
const _hoisted_3$3n = [
  _hoisted_2$3A
];
function _sfc_render$2C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3Z, _hoisted_3$3n);
}
var fries = /* @__PURE__ */ _export_sfc(_sfc_main$2C, [["render", _sfc_render$2C]]);
const _sfc_main$2B = defineComponent({
  name: "FullScreen"
});
const _hoisted_1$3Y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 96.064l192 .192a32 32 0 010 64l-192-.192V352a32 32 0 01-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1164 0v191.936l192-.192a32 32 0 110 64l-192 .192zM864 96.064V96h64v256a32 32 0 11-64 0V160.064l-192 .192a32 32 0 110-64l192-.192zm0 831.872l-192-.192a32 32 0 010-64l192 .192V672a32 32 0 1164 0v256h-64v-.064z"
}, null, -1);
const _hoisted_3$3m = [
  _hoisted_2$3z
];
function _sfc_render$2B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3Y, _hoisted_3$3m);
}
var fullScreen = /* @__PURE__ */ _export_sfc(_sfc_main$2B, [["render", _sfc_render$2B]]);
const _sfc_main$2A = defineComponent({
  name: "GobletFull"
});
const _hoisted_1$3X = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 320h512c0-78.592-12.608-142.4-36.928-192h-434.24C269.504 192.384 256 256.256 256 320zm503.936 64H264.064a256.128 256.128 0 00495.872 0zM544 638.4V896h96a32 32 0 110 64H384a32 32 0 110-64h96V638.4A320 320 0 01192 320c0-85.632 21.312-170.944 64-256h512c42.688 64.32 64 149.632 64 256a320 320 0 01-288 318.4z"
}, null, -1);
const _hoisted_3$3l = [
  _hoisted_2$3y
];
function _sfc_render$2A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3X, _hoisted_3$3l);
}
var gobletFull = /* @__PURE__ */ _export_sfc(_sfc_main$2A, [["render", _sfc_render$2A]]);
const _sfc_main$2z = defineComponent({
  name: "GobletSquareFull"
});
const _hoisted_1$3W = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3x = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 270.912c10.048 6.72 22.464 14.912 28.992 18.624a220.16 220.16 0 00114.752 30.72c30.592 0 49.408-9.472 91.072-41.152l.64-.448c52.928-40.32 82.368-55.04 132.288-54.656 55.552.448 99.584 20.8 142.72 57.408l1.536 1.28V128H256v142.912zm.96 76.288C266.368 482.176 346.88 575.872 512 576c157.44.064 237.952-85.056 253.248-209.984a952.32 952.32 0 01-40.192-35.712c-32.704-27.776-63.36-41.92-101.888-42.24-31.552-.256-50.624 9.28-93.12 41.6l-.576.448c-52.096 39.616-81.024 54.208-129.792 54.208-54.784 0-100.48-13.376-142.784-37.056zM480 638.848C250.624 623.424 192 442.496 192 319.68V96a32 32 0 0132-32h576a32 32 0 0132 32v224c0 122.816-58.624 303.68-288 318.912V896h96a32 32 0 110 64H384a32 32 0 110-64h96V638.848z"
}, null, -1);
const _hoisted_3$3k = [
  _hoisted_2$3x
];
function _sfc_render$2z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3W, _hoisted_3$3k);
}
var gobletSquareFull = /* @__PURE__ */ _export_sfc(_sfc_main$2z, [["render", _sfc_render$2z]]);
const _sfc_main$2y = defineComponent({
  name: "GobletSquare"
});
const _hoisted_1$3V = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3w = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 638.912V896h96a32 32 0 110 64H384a32 32 0 110-64h96V638.848C250.624 623.424 192 442.496 192 319.68V96a32 32 0 0132-32h576a32 32 0 0132 32v224c0 122.816-58.624 303.68-288 318.912zM256 319.68c0 149.568 80 256.192 256 256.256C688.128 576 768 469.568 768 320V128H256v191.68z"
}, null, -1);
const _hoisted_3$3j = [
  _hoisted_2$3w
];
function _sfc_render$2y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3V, _hoisted_3$3j);
}
var gobletSquare = /* @__PURE__ */ _export_sfc(_sfc_main$2y, [["render", _sfc_render$2y]]);
const _sfc_main$2x = defineComponent({
  name: "Goblet"
});
const _hoisted_1$3U = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3v = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 638.4V896h96a32 32 0 110 64H384a32 32 0 110-64h96V638.4A320 320 0 01192 320c0-85.632 21.312-170.944 64-256h512c42.688 64.32 64 149.632 64 256a320 320 0 01-288 318.4zM256 320a256 256 0 10512 0c0-78.592-12.608-142.4-36.928-192h-434.24C269.504 192.384 256 256.256 256 320z"
}, null, -1);
const _hoisted_3$3i = [
  _hoisted_2$3v
];
function _sfc_render$2x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3U, _hoisted_3$3i);
}
var goblet = /* @__PURE__ */ _export_sfc(_sfc_main$2x, [["render", _sfc_render$2x]]);
const _sfc_main$2w = defineComponent({
  name: "GoodsFilled"
});
const _hoisted_1$3T = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3u = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 352h640l64 544H128l64-544zm128 224h64V448h-64v128zm320 0h64V448h-64v128zM384 288h-64a192 192 0 11384 0h-64a128 128 0 10-256 0z"
}, null, -1);
const _hoisted_3$3h = [
  _hoisted_2$3u
];
function _sfc_render$2w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3T, _hoisted_3$3h);
}
var goodsFilled = /* @__PURE__ */ _export_sfc(_sfc_main$2w, [["render", _sfc_render$2w]]);
const _sfc_main$2v = defineComponent({
  name: "Goods"
});
const _hoisted_1$3S = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3t = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M320 288v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4h131.072a32 32 0 0131.808 28.8l57.6 576a32 32 0 01-31.808 35.2H131.328a32 32 0 01-31.808-35.2l57.6-576a32 32 0 0131.808-28.8H320zm64 0h256v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4zm-64 64H217.92l-51.2 512h690.56l-51.264-512H704v96a32 32 0 11-64 0v-96H384v96a32 32 0 01-64 0v-96z"
}, null, -1);
const _hoisted_3$3g = [
  _hoisted_2$3t
];
function _sfc_render$2v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3S, _hoisted_3$3g);
}
var goods = /* @__PURE__ */ _export_sfc(_sfc_main$2v, [["render", _sfc_render$2v]]);
const _sfc_main$2u = defineComponent({
  name: "Grape"
});
const _hoisted_1$3R = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3s = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 195.2a160 160 0 0196 60.8 160 160 0 11146.24 254.976 160 160 0 01-128 224 160 160 0 11-292.48 0 160 160 0 01-128-224A160 160 0 11384 256a160 160 0 0196-60.8V128h-64a32 32 0 010-64h192a32 32 0 010 64h-64v67.2zM512 448a96 96 0 100-192 96 96 0 000 192zm-256 0a96 96 0 100-192 96 96 0 000 192zm128 224a96 96 0 100-192 96 96 0 000 192zm128 224a96 96 0 100-192 96 96 0 000 192zm128-224a96 96 0 100-192 96 96 0 000 192zm128-224a96 96 0 100-192 96 96 0 000 192z"
}, null, -1);
const _hoisted_3$3f = [
  _hoisted_2$3s
];
function _sfc_render$2u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3R, _hoisted_3$3f);
}
var grape = /* @__PURE__ */ _export_sfc(_sfc_main$2u, [["render", _sfc_render$2u]]);
const _sfc_main$2t = defineComponent({
  name: "Grid"
});
const _hoisted_1$3Q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3r = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"
}, null, -1);
const _hoisted_3$3e = [
  _hoisted_2$3r
];
function _sfc_render$2t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3Q, _hoisted_3$3e);
}
var grid = /* @__PURE__ */ _export_sfc(_sfc_main$2t, [["render", _sfc_render$2t]]);
const _sfc_main$2s = defineComponent({
  name: "Guide"
});
const _hoisted_1$3P = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 608h-64V416h64v192zm0 160v160a32 32 0 01-32 32H416a32 32 0 01-32-32V768h64v128h128V768h64zM384 608V416h64v192h-64zm256-352h-64V128H448v128h-64V96a32 32 0 0132-32h192a32 32 0 0132 32v160z"
}, null, -1);
const _hoisted_3$3d = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M220.8 256l-71.232 80 71.168 80H768V256H220.8zm-14.4-64H800a32 32 0 0132 32v224a32 32 0 01-32 32H206.4a32 32 0 01-23.936-10.752l-99.584-112a32 32 0 010-42.496l99.584-112A32 32 0 01206.4 192zm678.784 496l-71.104 80H266.816V608h547.2l71.168 80zm-56.768-144H234.88a32 32 0 00-32 32v224a32 32 0 0032 32h593.6a32 32 0 0023.936-10.752l99.584-112a32 32 0 000-42.496l-99.584-112A32 32 0 00828.48 544z"
}, null, -1);
const _hoisted_4$1e = [
  _hoisted_2$3q,
  _hoisted_3$3d
];
function _sfc_render$2s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3P, _hoisted_4$1e);
}
var guide = /* @__PURE__ */ _export_sfc(_sfc_main$2s, [["render", _sfc_render$2s]]);
const _sfc_main$2r = defineComponent({
  name: "Headset"
});
const _hoisted_1$3O = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3p = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M896 529.152V512a384 384 0 10-768 0v17.152A128 128 0 01320 640v128a128 128 0 11-256 0V512a448 448 0 11896 0v256a128 128 0 11-256 0V640a128 128 0 01192-110.848zM896 640a64 64 0 00-128 0v128a64 64 0 00128 0V640zm-768 0v128a64 64 0 00128 0V640a64 64 0 10-128 0z"
}, null, -1);
const _hoisted_3$3c = [
  _hoisted_2$3p
];
function _sfc_render$2r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3O, _hoisted_3$3c);
}
var headset = /* @__PURE__ */ _export_sfc(_sfc_main$2r, [["render", _sfc_render$2r]]);
const _sfc_main$2q = defineComponent({
  name: "HelpFilled"
});
const _hoisted_1$3N = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3o = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M926.784 480H701.312A192.512 192.512 0 00544 322.688V97.216A416.064 416.064 0 01926.784 480zm0 64A416.064 416.064 0 01544 926.784V701.312A192.512 192.512 0 00701.312 544h225.472zM97.28 544h225.472A192.512 192.512 0 00480 701.312v225.472A416.064 416.064 0 0197.216 544zm0-64A416.064 416.064 0 01480 97.216v225.472A192.512 192.512 0 00322.688 480H97.216z"
}, null, -1);
const _hoisted_3$3b = [
  _hoisted_2$3o
];
function _sfc_render$2q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3N, _hoisted_3$3b);
}
var helpFilled = /* @__PURE__ */ _export_sfc(_sfc_main$2q, [["render", _sfc_render$2q]]);
const _sfc_main$2p = defineComponent({
  name: "Help"
});
const _hoisted_1$3M = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3n = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M759.936 805.248l-90.944-91.008A254.912 254.912 0 01512 768a254.912 254.912 0 01-156.992-53.76l-90.944 91.008A382.464 382.464 0 00512 896c94.528 0 181.12-34.176 247.936-90.752zm45.312-45.312A382.464 382.464 0 00896 512c0-94.528-34.176-181.12-90.752-247.936l-91.008 90.944C747.904 398.4 768 452.864 768 512c0 59.136-20.096 113.6-53.76 156.992l91.008 90.944zm-45.312-541.184A382.464 382.464 0 00512 128c-94.528 0-181.12 34.176-247.936 90.752l90.944 91.008A254.912 254.912 0 01512 256c59.136 0 113.6 20.096 156.992 53.76l90.944-91.008zm-541.184 45.312A382.464 382.464 0 00128 512c0 94.528 34.176 181.12 90.752 247.936l91.008-90.944A254.912 254.912 0 01256 512c0-59.136 20.096-113.6 53.76-156.992l-91.008-90.944zm417.28 394.496a194.56 194.56 0 0022.528-22.528C686.912 602.56 704 559.232 704 512a191.232 191.232 0 00-67.968-146.56A191.296 191.296 0 00512 320a191.232 191.232 0 00-146.56 67.968C337.088 421.44 320 464.768 320 512a191.232 191.232 0 0067.968 146.56C421.44 686.912 464.768 704 512 704c47.296 0 90.56-17.088 124.032-45.44zM512 960a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3$3a = [
  _hoisted_2$3n
];
function _sfc_render$2p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3M, _hoisted_3$3a);
}
var help = /* @__PURE__ */ _export_sfc(_sfc_main$2p, [["render", _sfc_render$2p]]);
const _sfc_main$2o = defineComponent({
  name: "Histogram"
});
const _hoisted_1$3L = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3m = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M416 896V128h192v768H416zm-288 0V448h192v448H128zm576 0V320h192v576H704z"
}, null, -1);
const _hoisted_3$39 = [
  _hoisted_2$3m
];
function _sfc_render$2o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3L, _hoisted_3$39);
}
var histogram = /* @__PURE__ */ _export_sfc(_sfc_main$2o, [["render", _sfc_render$2o]]);
const _sfc_main$2n = defineComponent({
  name: "HomeFilled"
});
const _hoisted_1$3K = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3l = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 128L128 447.936V896h255.936V640H640v256h255.936V447.936z"
}, null, -1);
const _hoisted_3$38 = [
  _hoisted_2$3l
];
function _sfc_render$2n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3K, _hoisted_3$38);
}
var homeFilled = /* @__PURE__ */ _export_sfc(_sfc_main$2n, [["render", _sfc_render$2n]]);
const _sfc_main$2m = defineComponent({
  name: "HotWater"
});
const _hoisted_1$3J = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3k = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M273.067 477.867h477.866V409.6H273.067v68.267zm0 68.266v51.2A187.733 187.733 0 00460.8 785.067h102.4a187.733 187.733 0 00187.733-187.734v-51.2H273.067zm-34.134-204.8h546.134a34.133 34.133 0 0134.133 34.134v221.866a256 256 0 01-256 256H460.8a256 256 0 01-256-256V375.467a34.133 34.133 0 0134.133-34.134zM512 34.133a34.133 34.133 0 0134.133 34.134v170.666a34.133 34.133 0 01-68.266 0V68.267A34.133 34.133 0 01512 34.133zM375.467 102.4a34.133 34.133 0 0134.133 34.133v102.4a34.133 34.133 0 01-68.267 0v-102.4a34.133 34.133 0 0134.134-34.133zm273.066 0a34.133 34.133 0 0134.134 34.133v102.4a34.133 34.133 0 11-68.267 0v-102.4a34.133 34.133 0 0134.133-34.133zM170.667 921.668h682.666a34.133 34.133 0 110 68.267H170.667a34.133 34.133 0 110-68.267z"
}, null, -1);
const _hoisted_3$37 = [
  _hoisted_2$3k
];
function _sfc_render$2m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3J, _hoisted_3$37);
}
var hotWater = /* @__PURE__ */ _export_sfc(_sfc_main$2m, [["render", _sfc_render$2m]]);
const _sfc_main$2l = defineComponent({
  name: "House"
});
const _hoisted_1$3I = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3j = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 413.952V896h640V413.952L512 147.328 192 413.952zM139.52 374.4l352-293.312a32 32 0 0140.96 0l352 293.312A32 32 0 01896 398.976V928a32 32 0 01-32 32H160a32 32 0 01-32-32V398.976a32 32 0 0111.52-24.576z"
}, null, -1);
const _hoisted_3$36 = [
  _hoisted_2$3j
];
function _sfc_render$2l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3I, _hoisted_3$36);
}
var house = /* @__PURE__ */ _export_sfc(_sfc_main$2l, [["render", _sfc_render$2l]]);
const _sfc_main$2k = defineComponent({
  name: "IceCreamRound"
});
const _hoisted_1$3H = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3i = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M308.352 489.344l226.304 226.304a32 32 0 0045.248 0L783.552 512A192 192 0 10512 240.448L308.352 444.16a32 32 0 000 45.248zm135.744 226.304L308.352 851.392a96 96 0 01-135.744-135.744l135.744-135.744-45.248-45.248a96 96 0 010-135.808L466.752 195.2A256 256 0 01828.8 557.248L625.152 760.96a96 96 0 01-135.808 0l-45.248-45.248zM398.848 670.4L353.6 625.152 217.856 760.896a32 32 0 0045.248 45.248L398.848 670.4zm248.96-384.64a32 32 0 010 45.248L466.624 512a32 32 0 11-45.184-45.248l180.992-181.056a32 32 0 0145.248 0zm90.496 90.496a32 32 0 010 45.248L557.248 602.496A32 32 0 11512 557.248l180.992-180.992a32 32 0 0145.312 0z"
}, null, -1);
const _hoisted_3$35 = [
  _hoisted_2$3i
];
function _sfc_render$2k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3H, _hoisted_3$35);
}
var iceCreamRound = /* @__PURE__ */ _export_sfc(_sfc_main$2k, [["render", _sfc_render$2k]]);
const _sfc_main$2j = defineComponent({
  name: "IceCreamSquare"
});
const _hoisted_1$3G = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3h = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M416 640h256a32 32 0 0032-32V160a32 32 0 00-32-32H352a32 32 0 00-32 32v448a32 32 0 0032 32h64zm192 64v160a96 96 0 01-192 0V704h-64a96 96 0 01-96-96V160a96 96 0 0196-96h320a96 96 0 0196 96v448a96 96 0 01-96 96h-64zm-64 0h-64v160a32 32 0 1064 0V704z"
}, null, -1);
const _hoisted_3$34 = [
  _hoisted_2$3h
];
function _sfc_render$2j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3G, _hoisted_3$34);
}
var iceCreamSquare = /* @__PURE__ */ _export_sfc(_sfc_main$2j, [["render", _sfc_render$2j]]);
const _sfc_main$2i = defineComponent({
  name: "IceCream"
});
const _hoisted_1$3F = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3g = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128.64 448a208 208 0 01193.536-191.552 224 224 0 01445.248 15.488A208.128 208.128 0 01894.784 448H896L548.8 983.68a32 32 0 01-53.248.704L128 448h.64zm64.256 0h286.208a144 144 0 00-286.208 0zm351.36 0h286.272a144 144 0 00-286.272 0zm-294.848 64l271.808 396.608L778.24 512H249.408zM511.68 352.64a207.872 207.872 0 01189.184-96.192 160 160 0 00-314.752 5.632c52.608 12.992 97.28 46.08 125.568 90.56z"
}, null, -1);
const _hoisted_3$33 = [
  _hoisted_2$3g
];
function _sfc_render$2i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3F, _hoisted_3$33);
}
var iceCream = /* @__PURE__ */ _export_sfc(_sfc_main$2i, [["render", _sfc_render$2i]]);
const _sfc_main$2h = defineComponent({
  name: "IceDrink"
});
const _hoisted_1$3E = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3f = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 448v128h239.68l16.064-128H512zm-64 0H256.256l16.064 128H448V448zm64-255.36V384h247.744A256.128 256.128 0 00512 192.64zm-64 8.064A256.448 256.448 0 00264.256 384H448V200.704zm64-72.064A320.128 320.128 0 01825.472 384H896a32 32 0 110 64h-64v1.92l-56.96 454.016A64 64 0 01711.552 960H312.448a64 64 0 01-63.488-56.064L192 449.92V448h-64a32 32 0 010-64h70.528A320.384 320.384 0 01448 135.04V96a96 96 0 0196-96h128a32 32 0 110 64H544a32 32 0 00-32 32v32.64zM743.68 640H280.32l32.128 256h399.104l32.128-256z"
}, null, -1);
const _hoisted_3$32 = [
  _hoisted_2$3f
];
function _sfc_render$2h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3E, _hoisted_3$32);
}
var iceDrink = /* @__PURE__ */ _export_sfc(_sfc_main$2h, [["render", _sfc_render$2h]]);
const _sfc_main$2g = defineComponent({
  name: "IceTea"
});
const _hoisted_1$3D = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3e = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M197.696 259.648a320.128 320.128 0 01628.608 0A96 96 0 01896 352v64a96 96 0 01-71.616 92.864l-49.408 395.072A64 64 0 01711.488 960H312.512a64 64 0 01-63.488-56.064l-49.408-395.072A96 96 0 01128 416v-64a96 96 0 0169.696-92.352zM264.064 256h495.872a256.128 256.128 0 00-495.872 0zm495.424 256H264.512l48 384h398.976l48-384zM224 448h576a32 32 0 0032-32v-64a32 32 0 00-32-32H224a32 32 0 00-32 32v64a32 32 0 0032 32zm160 192h64v64h-64v-64zm192 64h64v64h-64v-64zm-128 64h64v64h-64v-64zm64-192h64v64h-64v-64z"
}, null, -1);
const _hoisted_3$31 = [
  _hoisted_2$3e
];
function _sfc_render$2g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3D, _hoisted_3$31);
}
var iceTea = /* @__PURE__ */ _export_sfc(_sfc_main$2g, [["render", _sfc_render$2g]]);
const _sfc_main$2f = defineComponent({
  name: "InfoFilled"
});
const _hoisted_1$3C = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3d = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896.064A448 448 0 01512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 01-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 017.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
}, null, -1);
const _hoisted_3$30 = [
  _hoisted_2$3d
];
function _sfc_render$2f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3C, _hoisted_3$30);
}
var infoFilled = /* @__PURE__ */ _export_sfc(_sfc_main$2f, [["render", _sfc_render$2f]]);
const _sfc_main$2e = defineComponent({
  name: "Iphone"
});
const _hoisted_1$3B = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3c = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M224 768v96.064a64 64 0 0064 64h448a64 64 0 0064-64V768H224zm0-64h576V160a64 64 0 00-64-64H288a64 64 0 00-64 64v544zm32 288a96 96 0 01-96-96V128a96 96 0 0196-96h512a96 96 0 0196 96v768a96 96 0 01-96 96H256zm304-144a48 48 0 11-96 0 48 48 0 0196 0z"
}, null, -1);
const _hoisted_3$2$ = [
  _hoisted_2$3c
];
function _sfc_render$2e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3B, _hoisted_3$2$);
}
var iphone = /* @__PURE__ */ _export_sfc(_sfc_main$2e, [["render", _sfc_render$2e]]);
const _sfc_main$2d = defineComponent({
  name: "Key"
});
const _hoisted_1$3A = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3b = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M448 456.064V96a32 32 0 0132-32.064L672 64a32 32 0 010 64H512v128h160a32 32 0 010 64H512v128a256 256 0 11-64 8.064zM512 896a192 192 0 100-384 192 192 0 000 384z"
}, null, -1);
const _hoisted_3$2_ = [
  _hoisted_2$3b
];
function _sfc_render$2d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3A, _hoisted_3$2_);
}
var key = /* @__PURE__ */ _export_sfc(_sfc_main$2d, [["render", _sfc_render$2d]]);
const _sfc_main$2c = defineComponent({
  name: "KnifeFork"
});
const _hoisted_1$3z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3a = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 410.56V96a32 32 0 0164 0v314.56A96 96 0 00384 320V96a32 32 0 0164 0v224a160 160 0 01-128 156.8V928a32 32 0 11-64 0V476.8A160 160 0 01128 320V96a32 32 0 0164 0v224a96 96 0 0064 90.56zm384-250.24V544h126.72c-3.328-78.72-12.928-147.968-28.608-207.744-14.336-54.528-46.848-113.344-98.112-175.872zM640 608v320a32 32 0 11-64 0V64h64c85.312 89.472 138.688 174.848 160 256 21.312 81.152 32 177.152 32 288H640z"
}, null, -1);
const _hoisted_3$2Z = [
  _hoisted_2$3a
];
function _sfc_render$2c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3z, _hoisted_3$2Z);
}
var knifeFork = /* @__PURE__ */ _export_sfc(_sfc_main$2c, [["render", _sfc_render$2c]]);
const _sfc_main$2b = defineComponent({
  name: "Lightning"
});
const _hoisted_1$3y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$39 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 671.36v64.128A239.808 239.808 0 0163.744 496.192a240.32 240.32 0 01199.488-236.8 256.128 256.128 0 01487.872-30.976A256.064 256.064 0 01736 734.016v-64.768a192 192 0 003.328-377.92l-35.2-6.592-12.8-33.408a192.064 192.064 0 00-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 00-146.24 173.568c0 91.968 70.464 167.36 160.256 175.232z"
}, null, -1);
const _hoisted_3$2Y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M416 736a32 32 0 01-27.776-47.872l128-224a32 32 0 1155.552 31.744L471.168 672H608a32 32 0 0127.776 47.872l-128 224a32 32 0 11-55.68-31.744L552.96 736H416z"
}, null, -1);
const _hoisted_4$1d = [
  _hoisted_2$39,
  _hoisted_3$2Y
];
function _sfc_render$2b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3y, _hoisted_4$1d);
}
var lightning = /* @__PURE__ */ _export_sfc(_sfc_main$2b, [["render", _sfc_render$2b]]);
const _sfc_main$2a = defineComponent({
  name: "Link"
});
const _hoisted_1$3x = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$38 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M715.648 625.152L670.4 579.904l90.496-90.56c75.008-74.944 85.12-186.368 22.656-248.896-62.528-62.464-173.952-52.352-248.96 22.656L444.16 353.6l-45.248-45.248 90.496-90.496c100.032-99.968 251.968-110.08 339.456-22.656 87.488 87.488 77.312 239.424-22.656 339.456l-90.496 90.496zm-90.496 90.496l-90.496 90.496C434.624 906.112 282.688 916.224 195.2 828.8c-87.488-87.488-77.312-239.424 22.656-339.456l90.496-90.496 45.248 45.248-90.496 90.56c-75.008 74.944-85.12 186.368-22.656 248.896 62.528 62.464 173.952 52.352 248.96-22.656l90.496-90.496 45.248 45.248zm0-362.048l45.248 45.248L398.848 670.4 353.6 625.152 625.152 353.6z"
}, null, -1);
const _hoisted_3$2X = [
  _hoisted_2$38
];
function _sfc_render$2a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3x, _hoisted_3$2X);
}
var link$3 = /* @__PURE__ */ _export_sfc(_sfc_main$2a, [["render", _sfc_render$2a]]);
const _sfc_main$29 = defineComponent({
  name: "List"
});
const _hoisted_1$3w = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$37 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 192h160v736H160V192h160v64h384v-64zM288 512h448v-64H288v64zm0 256h448v-64H288v64zm96-576V96h256v96H384z"
}, null, -1);
const _hoisted_3$2W = [
  _hoisted_2$37
];
function _sfc_render$29(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3w, _hoisted_3$2W);
}
var list = /* @__PURE__ */ _export_sfc(_sfc_main$29, [["render", _sfc_render$29]]);
const _sfc_main$28 = defineComponent({
  name: "Loading"
});
const _hoisted_1$3v = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$36 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0132 32v192a32 32 0 01-64 0V96a32 32 0 0132-32zm0 640a32 32 0 0132 32v192a32 32 0 11-64 0V736a32 32 0 0132-32zm448-192a32 32 0 01-32 32H736a32 32 0 110-64h192a32 32 0 0132 32zm-640 0a32 32 0 01-32 32H96a32 32 0 010-64h192a32 32 0 0132 32zM195.2 195.2a32 32 0 0145.248 0L376.32 331.008a32 32 0 01-45.248 45.248L195.2 240.448a32 32 0 010-45.248zm452.544 452.544a32 32 0 0145.248 0L828.8 783.552a32 32 0 01-45.248 45.248L647.744 692.992a32 32 0 010-45.248zM828.8 195.264a32 32 0 010 45.184L692.992 376.32a32 32 0 01-45.248-45.248l135.808-135.808a32 32 0 0145.248 0zm-452.544 452.48a32 32 0 010 45.248L240.448 828.8a32 32 0 01-45.248-45.248l135.808-135.808a32 32 0 0145.248 0z"
}, null, -1);
const _hoisted_3$2V = [
  _hoisted_2$36
];
function _sfc_render$28(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3v, _hoisted_3$2V);
}
var loading$3 = /* @__PURE__ */ _export_sfc(_sfc_main$28, [["render", _sfc_render$28]]);
const _sfc_main$27 = defineComponent({
  name: "LocationFilled"
});
const _hoisted_1$3u = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$35 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 928c23.936 0 117.504-68.352 192.064-153.152C803.456 661.888 864 535.808 864 416c0-189.632-155.84-320-352-320S160 226.368 160 416c0 120.32 60.544 246.4 159.936 359.232C394.432 859.84 488 928 512 928zm0-435.2a64 64 0 100-128 64 64 0 000 128zm0 140.8a204.8 204.8 0 110-409.6 204.8 204.8 0 010 409.6z"
}, null, -1);
const _hoisted_3$2U = [
  _hoisted_2$35
];
function _sfc_render$27(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3u, _hoisted_3$2U);
}
var locationFilled = /* @__PURE__ */ _export_sfc(_sfc_main$27, [["render", _sfc_render$27]]);
const _sfc_main$26 = defineComponent({
  name: "LocationInformation"
});
const _hoisted_1$3t = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$34 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_3$2T = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 10-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 01704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_4$1c = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 512a96 96 0 100-192 96 96 0 000 192zm0 64a160 160 0 110-320 160 160 0 010 320z"
}, null, -1);
const _hoisted_5$A = [
  _hoisted_2$34,
  _hoisted_3$2T,
  _hoisted_4$1c
];
function _sfc_render$26(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3t, _hoisted_5$A);
}
var locationInformation = /* @__PURE__ */ _export_sfc(_sfc_main$26, [["render", _sfc_render$26]]);
const _sfc_main$25 = defineComponent({
  name: "Location"
});
const _hoisted_1$3s = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$33 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 10-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 01704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_3$2S = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 512a96 96 0 100-192 96 96 0 000 192zm0 64a160 160 0 110-320 160 160 0 010 320z"
}, null, -1);
const _hoisted_4$1b = [
  _hoisted_2$33,
  _hoisted_3$2S
];
function _sfc_render$25(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3s, _hoisted_4$1b);
}
var location$1 = /* @__PURE__ */ _export_sfc(_sfc_main$25, [["render", _sfc_render$25]]);
const _sfc_main$24 = defineComponent({
  name: "Lock"
});
const _hoisted_1$3r = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$32 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M224 448a32 32 0 00-32 32v384a32 32 0 0032 32h576a32 32 0 0032-32V480a32 32 0 00-32-32H224zm0-64h576a96 96 0 0196 96v384a96 96 0 01-96 96H224a96 96 0 01-96-96V480a96 96 0 0196-96z"
}, null, -1);
const _hoisted_3$2R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 544a32 32 0 0132 32v192a32 32 0 11-64 0V576a32 32 0 0132-32zM704 384v-64a192 192 0 10-384 0v64h384zM512 64a256 256 0 01256 256v128H256V320A256 256 0 01512 64z"
}, null, -1);
const _hoisted_4$1a = [
  _hoisted_2$32,
  _hoisted_3$2R
];
function _sfc_render$24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3r, _hoisted_4$1a);
}
var lock = /* @__PURE__ */ _export_sfc(_sfc_main$24, [["render", _sfc_render$24]]);
const _sfc_main$23 = defineComponent({
  name: "Lollipop"
});
const _hoisted_1$3q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$31 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M513.28 448a64 64 0 1176.544 49.728A96 96 0 00768 448h64a160 160 0 01-320 0h1.28zm-126.976-29.696a256 256 0 1043.52-180.48A256 256 0 01832 448h-64a192 192 0 00-381.696-29.696zm105.664 249.472L285.696 874.048a96 96 0 01-135.68-135.744l206.208-206.272a320 320 0 11135.744 135.744zm-54.464-36.032a321.92 321.92 0 01-45.248-45.248L195.2 783.552a32 32 0 1045.248 45.248l197.056-197.12z"
}, null, -1);
const _hoisted_3$2Q = [
  _hoisted_2$31
];
function _sfc_render$23(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3q, _hoisted_3$2Q);
}
var lollipop = /* @__PURE__ */ _export_sfc(_sfc_main$23, [["render", _sfc_render$23]]);
const _sfc_main$22 = defineComponent({
  name: "MagicStick"
});
const _hoisted_1$3p = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$30 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64h64v192h-64V64zm0 576h64v192h-64V640zM160 480v-64h192v64H160zm576 0v-64h192v64H736zM249.856 199.04l45.248-45.184L430.848 289.6 385.6 334.848 249.856 199.104zM657.152 606.4l45.248-45.248 135.744 135.744-45.248 45.248L657.152 606.4zM114.048 923.2L68.8 877.952l316.8-316.8 45.248 45.248-316.8 316.8zM702.4 334.848L657.152 289.6l135.744-135.744 45.248 45.248L702.4 334.848z"
}, null, -1);
const _hoisted_3$2P = [
  _hoisted_2$30
];
function _sfc_render$22(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3p, _hoisted_3$2P);
}
var magicStick = /* @__PURE__ */ _export_sfc(_sfc_main$22, [["render", _sfc_render$22]]);
const _sfc_main$21 = defineComponent({
  name: "Magnet"
});
const _hoisted_1$3o = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2$ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M832 320V192H704v320a192 192 0 11-384 0V192H192v128h128v64H192v128a320 320 0 00640 0V384H704v-64h128zM640 512V128h256v384a384 384 0 11-768 0V128h256v384a128 128 0 10256 0z"
}, null, -1);
const _hoisted_3$2O = [
  _hoisted_2$2$
];
function _sfc_render$21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3o, _hoisted_3$2O);
}
var magnet = /* @__PURE__ */ _export_sfc(_sfc_main$21, [["render", _sfc_render$21]]);
const _sfc_main$20 = defineComponent({
  name: "Male"
});
const _hoisted_1$3n = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2_ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M399.5 849.5a225 225 0 100-450 225 225 0 000 450zm0 56.25a281.25 281.25 0 110-562.5 281.25 281.25 0 010 562.5zM652.625 118.25h225q28.125 0 28.125 28.125T877.625 174.5h-225q-28.125 0-28.125-28.125t28.125-28.125z"
}, null, -1);
const _hoisted_3$2N = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M877.625 118.25q28.125 0 28.125 28.125v225q0 28.125-28.125 28.125T849.5 371.375v-225q0-28.125 28.125-28.125z"
}, null, -1);
const _hoisted_4$19 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M604.813 458.9L565.1 419.131l292.613-292.668 39.825 39.824z"
}, null, -1);
const _hoisted_5$z = [
  _hoisted_2$2_,
  _hoisted_3$2N,
  _hoisted_4$19
];
function _sfc_render$20(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3n, _hoisted_5$z);
}
var male = /* @__PURE__ */ _export_sfc(_sfc_main$20, [["render", _sfc_render$20]]);
const _sfc_main$1$ = defineComponent({
  name: "Management"
});
const _hoisted_1$3m = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2Z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M576 128v288l96-96 96 96V128h128v768H320V128h256zm-448 0h128v768H128V128z"
}, null, -1);
const _hoisted_3$2M = [
  _hoisted_2$2Z
];
function _sfc_render$1$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3m, _hoisted_3$2M);
}
var management = /* @__PURE__ */ _export_sfc(_sfc_main$1$, [["render", _sfc_render$1$]]);
const _sfc_main$1_ = defineComponent({
  name: "MapLocation"
});
const _hoisted_1$3l = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2Y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 10-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 01704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_3$2L = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 448a64 64 0 100-128 64 64 0 000 128zm0 64a128 128 0 110-256 128 128 0 010 256zm345.6 192L960 960H672v-64H352v64H64l102.4-256h691.2zm-68.928 0H235.328l-76.8 192h706.944l-76.8-192z"
}, null, -1);
const _hoisted_4$18 = [
  _hoisted_2$2Y,
  _hoisted_3$2L
];
function _sfc_render$1_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3l, _hoisted_4$18);
}
var mapLocation = /* @__PURE__ */ _export_sfc(_sfc_main$1_, [["render", _sfc_render$1_]]);
const _sfc_main$1Z = defineComponent({
  name: "Medal"
});
const _hoisted_1$3k = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2X = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a256 256 0 100-512 256 256 0 000 512zm0 64a320 320 0 110-640 320 320 0 010 640z"
}, null, -1);
const _hoisted_3$2K = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M576 128H448v200a286.72 286.72 0 0164-8c19.52 0 40.832 2.688 64 8V128zm64 0v219.648c24.448 9.088 50.56 20.416 78.4 33.92L757.44 128H640zm-256 0H266.624l39.04 253.568c27.84-13.504 53.888-24.832 78.336-33.92V128zM229.312 64h565.376a32 32 0 0131.616 36.864L768 480c-113.792-64-199.104-96-256-96-56.896 0-142.208 32-256 96l-58.304-379.136A32 32 0 01229.312 64z"
}, null, -1);
const _hoisted_4$17 = [
  _hoisted_2$2X,
  _hoisted_3$2K
];
function _sfc_render$1Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3k, _hoisted_4$17);
}
var medal = /* @__PURE__ */ _export_sfc(_sfc_main$1Z, [["render", _sfc_render$1Z]]);
const _sfc_main$1Y = defineComponent({
  name: "Menu"
});
const _hoisted_1$3j = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2W = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 448a32 32 0 01-32-32V160.064a32 32 0 0132-32h256a32 32 0 0132 32V416a32 32 0 01-32 32H160zm448 0a32 32 0 01-32-32V160.064a32 32 0 0132-32h255.936a32 32 0 0132 32V416a32 32 0 01-32 32H608zM160 896a32 32 0 01-32-32V608a32 32 0 0132-32h256a32 32 0 0132 32v256a32 32 0 01-32 32H160zm448 0a32 32 0 01-32-32V608a32 32 0 0132-32h255.936a32 32 0 0132 32v256a32 32 0 01-32 32H608z"
}, null, -1);
const _hoisted_3$2J = [
  _hoisted_2$2W
];
function _sfc_render$1Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3j, _hoisted_3$2J);
}
var menu$4 = /* @__PURE__ */ _export_sfc(_sfc_main$1Y, [["render", _sfc_render$1Y]]);
const _sfc_main$1X = defineComponent({
  name: "MessageBox"
});
const _hoisted_1$3i = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2V = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 384h448v64H288v-64zm96-128h256v64H384v-64zM131.456 512H384v128h256V512h252.544L721.856 192H302.144L131.456 512zM896 576H704v128H320V576H128v256h768V576zM275.776 128h472.448a32 32 0 0128.608 17.664l179.84 359.552A32 32 0 01960 519.552V864a32 32 0 01-32 32H96a32 32 0 01-32-32V519.552a32 32 0 013.392-14.336l179.776-359.552A32 32 0 01275.776 128z"
}, null, -1);
const _hoisted_3$2I = [
  _hoisted_2$2V
];
function _sfc_render$1X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3i, _hoisted_3$2I);
}
var messageBox$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1X, [["render", _sfc_render$1X]]);
const _sfc_main$1W = defineComponent({
  name: "Message"
});
const _hoisted_1$3h = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2U = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 224v512a64 64 0 0064 64h640a64 64 0 0064-64V224H128zm0-64h768a64 64 0 0164 64v512a128 128 0 01-128 128H192A128 128 0 0164 736V224a64 64 0 0164-64z"
}, null, -1);
const _hoisted_3$2H = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M904 224L656.512 506.88a192 192 0 01-289.024 0L120 224h784zm-698.944 0l210.56 240.704a128 128 0 00192.704 0L818.944 224H205.056z"
}, null, -1);
const _hoisted_4$16 = [
  _hoisted_2$2U,
  _hoisted_3$2H
];
function _sfc_render$1W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3h, _hoisted_4$16);
}
var message$3 = /* @__PURE__ */ _export_sfc(_sfc_main$1W, [["render", _sfc_render$1W]]);
const _sfc_main$1V = defineComponent({
  name: "Mic"
});
const _hoisted_1$3g = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2T = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 704h160a64 64 0 0064-64v-32h-96a32 32 0 010-64h96v-96h-96a32 32 0 010-64h96v-96h-96a32 32 0 010-64h96v-32a64 64 0 00-64-64H384a64 64 0 00-64 64v32h96a32 32 0 010 64h-96v96h96a32 32 0 010 64h-96v96h96a32 32 0 010 64h-96v32a64 64 0 0064 64h96zm64 64v128h192a32 32 0 110 64H288a32 32 0 110-64h192V768h-96a128 128 0 01-128-128V192A128 128 0 01384 64h256a128 128 0 01128 128v448a128 128 0 01-128 128h-96z"
}, null, -1);
const _hoisted_3$2G = [
  _hoisted_2$2T
];
function _sfc_render$1V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3g, _hoisted_3$2G);
}
var mic = /* @__PURE__ */ _export_sfc(_sfc_main$1V, [["render", _sfc_render$1V]]);
const _sfc_main$1U = defineComponent({
  name: "Microphone"
});
const _hoisted_1$3f = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2S = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 128a128 128 0 00-128 128v256a128 128 0 10256 0V256a128 128 0 00-128-128zm0-64a192 192 0 01192 192v256a192 192 0 11-384 0V256A192 192 0 01512 64zm-32 832v-64a288 288 0 01-288-288v-32a32 32 0 0164 0v32a224 224 0 00224 224h64a224 224 0 00224-224v-32a32 32 0 1164 0v32a288 288 0 01-288 288v64h64a32 32 0 110 64H416a32 32 0 110-64h64z"
}, null, -1);
const _hoisted_3$2F = [
  _hoisted_2$2S
];
function _sfc_render$1U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3f, _hoisted_3$2F);
}
var microphone = /* @__PURE__ */ _export_sfc(_sfc_main$1U, [["render", _sfc_render$1U]]);
const _sfc_main$1T = defineComponent({
  name: "MilkTea"
});
const _hoisted_1$3e = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M416 128V96a96 96 0 0196-96h128a32 32 0 110 64H512a32 32 0 00-32 32v32h320a96 96 0 0111.712 191.296l-39.68 581.056A64 64 0 01708.224 960H315.776a64 64 0 01-63.872-59.648l-39.616-581.056A96 96 0 01224 128h192zM276.48 320l39.296 576h392.448l4.8-70.784a224.064 224.064 0 0130.016-439.808L747.52 320H276.48zM224 256h576a32 32 0 100-64H224a32 32 0 000 64zm493.44 503.872l21.12-309.12a160 160 0 00-21.12 309.12z"
}, null, -1);
const _hoisted_3$2E = [
  _hoisted_2$2R
];
function _sfc_render$1T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3e, _hoisted_3$2E);
}
var milkTea = /* @__PURE__ */ _export_sfc(_sfc_main$1T, [["render", _sfc_render$1T]]);
const _sfc_main$1S = defineComponent({
  name: "Minus"
});
const _hoisted_1$3d = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2Q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 544h768a32 32 0 100-64H128a32 32 0 000 64z"
}, null, -1);
const _hoisted_3$2D = [
  _hoisted_2$2Q
];
function _sfc_render$1S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3d, _hoisted_3$2D);
}
var minus = /* @__PURE__ */ _export_sfc(_sfc_main$1S, [["render", _sfc_render$1S]]);
const _sfc_main$1R = defineComponent({
  name: "Money"
});
const _hoisted_1$3c = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2P = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 640v192h640V384H768v-64h150.976c14.272 0 19.456 1.472 24.64 4.288a29.056 29.056 0 0112.16 12.096c2.752 5.184 4.224 10.368 4.224 24.64v493.952c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 01-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H233.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 01-12.16-12.096c-2.688-5.184-4.224-10.368-4.224-24.576V640h64z"
}, null, -1);
const _hoisted_3$2C = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M768 192H128v448h640V192zm64-22.976v493.952c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 01-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H105.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 01-12.16-12.096C65.536 682.432 64 677.248 64 663.04V169.024c0-14.272 1.472-19.456 4.288-24.64a29.056 29.056 0 0112.096-12.16C85.568 129.536 90.752 128 104.96 128h685.952c14.272 0 19.456 1.472 24.64 4.288a29.056 29.056 0 0112.16 12.096c2.752 5.184 4.224 10.368 4.224 24.64z"
}, null, -1);
const _hoisted_4$15 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M448 576a160 160 0 110-320 160 160 0 010 320zm0-64a96 96 0 100-192 96 96 0 000 192z"
}, null, -1);
const _hoisted_5$y = [
  _hoisted_2$2P,
  _hoisted_3$2C,
  _hoisted_4$15
];
function _sfc_render$1R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3c, _hoisted_5$y);
}
var money = /* @__PURE__ */ _export_sfc(_sfc_main$1R, [["render", _sfc_render$1R]]);
const _sfc_main$1Q = defineComponent({
  name: "Monitor"
});
const _hoisted_1$3b = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 768v128h192a32 32 0 110 64H288a32 32 0 110-64h192V768H192A128 128 0 0164 640V256a128 128 0 01128-128h640a128 128 0 01128 128v384a128 128 0 01-128 128H544zM192 192a64 64 0 00-64 64v384a64 64 0 0064 64h640a64 64 0 0064-64V256a64 64 0 00-64-64H192z"
}, null, -1);
const _hoisted_3$2B = [
  _hoisted_2$2O
];
function _sfc_render$1Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3b, _hoisted_3$2B);
}
var monitor = /* @__PURE__ */ _export_sfc(_sfc_main$1Q, [["render", _sfc_render$1Q]]);
const _sfc_main$1P = defineComponent({
  name: "MoonNight"
});
const _hoisted_1$3a = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2N = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 512a448 448 0 01215.872-383.296A384 384 0 00213.76 640h188.8A448.256 448.256 0 01384 512zM171.136 704a448 448 0 01636.992-575.296A384 384 0 00499.328 704h-328.32z"
}, null, -1);
const _hoisted_3$2A = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M32 640h960q32 0 32 32t-32 32H32q-32 0-32-32t32-32zM160 768h384a32 32 0 110 64H160a32 32 0 110-64zm160 127.68l224 .256a32 32 0 0132 32V928a32 32 0 01-32 32l-224-.384a32 32 0 01-32-32v-.064a32 32 0 0132-32z"
}, null, -1);
const _hoisted_4$14 = [
  _hoisted_2$2N,
  _hoisted_3$2A
];
function _sfc_render$1P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3a, _hoisted_4$14);
}
var moonNight = /* @__PURE__ */ _export_sfc(_sfc_main$1P, [["render", _sfc_render$1P]]);
const _sfc_main$1O = defineComponent({
  name: "Moon"
});
const _hoisted_1$39 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2M = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M240.448 240.448a384 384 0 10559.424 525.696 448 448 0 01-542.016-542.08 390.592 390.592 0 00-17.408 16.384zm181.056 362.048a384 384 0 00525.632 16.384A448 448 0 11405.056 76.8a384 384 0 0016.448 525.696z"
}, null, -1);
const _hoisted_3$2z = [
  _hoisted_2$2M
];
function _sfc_render$1O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$39, _hoisted_3$2z);
}
var moon = /* @__PURE__ */ _export_sfc(_sfc_main$1O, [["render", _sfc_render$1O]]);
const _sfc_main$1N = defineComponent({
  name: "MoreFilled"
});
const _hoisted_1$38 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2L = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M176 416a112 112 0 110 224 112 112 0 010-224zm336 0a112 112 0 110 224 112 112 0 010-224zm336 0a112 112 0 110 224 112 112 0 010-224z"
}, null, -1);
const _hoisted_3$2y = [
  _hoisted_2$2L
];
function _sfc_render$1N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$38, _hoisted_3$2y);
}
var moreFilled = /* @__PURE__ */ _export_sfc(_sfc_main$1N, [["render", _sfc_render$1N]]);
const _sfc_main$1M = defineComponent({
  name: "More"
});
const _hoisted_1$37 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2K = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M176 416a112 112 0 100 224 112 112 0 000-224m0 64a48 48 0 110 96 48 48 0 010-96zm336-64a112 112 0 110 224 112 112 0 010-224zm0 64a48 48 0 100 96 48 48 0 000-96zm336-64a112 112 0 110 224 112 112 0 010-224zm0 64a48 48 0 100 96 48 48 0 000-96z"
}, null, -1);
const _hoisted_3$2x = [
  _hoisted_2$2K
];
function _sfc_render$1M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$37, _hoisted_3$2x);
}
var more = /* @__PURE__ */ _export_sfc(_sfc_main$1M, [["render", _sfc_render$1M]]);
const _sfc_main$1L = defineComponent({
  name: "MostlyCloudy"
});
const _hoisted_1$36 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2J = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M737.216 357.952L704 349.824l-11.776-32a192.064 192.064 0 00-367.424 23.04l-8.96 39.04-39.04 8.96A192.064 192.064 0 00320 768h368a207.808 207.808 0 00207.808-208 208.32 208.32 0 00-158.592-202.048zm15.168-62.208A272.32 272.32 0 01959.744 560a271.808 271.808 0 01-271.552 272H320a256 256 0 01-57.536-505.536 256.128 256.128 0 01489.92-30.72z"
}, null, -1);
const _hoisted_3$2w = [
  _hoisted_2$2J
];
function _sfc_render$1L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$36, _hoisted_3$2w);
}
var mostlyCloudy = /* @__PURE__ */ _export_sfc(_sfc_main$1L, [["render", _sfc_render$1L]]);
const _sfc_main$1K = defineComponent({
  name: "Mouse"
});
const _hoisted_1$35 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2I = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M438.144 256c-68.352 0-92.736 4.672-117.76 18.112-20.096 10.752-35.52 26.176-46.272 46.272C260.672 345.408 256 369.792 256 438.144v275.712c0 68.352 4.672 92.736 18.112 117.76 10.752 20.096 26.176 35.52 46.272 46.272C345.408 891.328 369.792 896 438.144 896h147.712c68.352 0 92.736-4.672 117.76-18.112 20.096-10.752 35.52-26.176 46.272-46.272C763.328 806.592 768 782.208 768 713.856V438.144c0-68.352-4.672-92.736-18.112-117.76a110.464 110.464 0 00-46.272-46.272C678.592 260.672 654.208 256 585.856 256H438.144zm0-64h147.712c85.568 0 116.608 8.96 147.904 25.6 31.36 16.768 55.872 41.344 72.576 72.64C823.104 321.536 832 352.576 832 438.08v275.84c0 85.504-8.96 116.544-25.6 147.84a174.464 174.464 0 01-72.64 72.576C702.464 951.104 671.424 960 585.92 960H438.08c-85.504 0-116.544-8.96-147.84-25.6a174.464 174.464 0 01-72.64-72.704c-16.768-31.296-25.664-62.336-25.664-147.84v-275.84c0-85.504 8.96-116.544 25.6-147.84a174.464 174.464 0 0172.768-72.576c31.232-16.704 62.272-25.6 147.776-25.6z"
}, null, -1);
const _hoisted_3$2v = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 320q32 0 32 32v128q0 32-32 32t-32-32V352q0-32 32-32zM544 224a32 32 0 01-64 0v-64a32 32 0 00-32-32h-96a32 32 0 010-64h96a96 96 0 0196 96v64z"
}, null, -1);
const _hoisted_4$13 = [
  _hoisted_2$2I,
  _hoisted_3$2v
];
function _sfc_render$1K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$35, _hoisted_4$13);
}
var mouse = /* @__PURE__ */ _export_sfc(_sfc_main$1K, [["render", _sfc_render$1K]]);
const _sfc_main$1J = defineComponent({
  name: "Mug"
});
const _hoisted_1$34 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2H = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M736 800V160H160v640a64 64 0 0064 64h448a64 64 0 0064-64zm64-544h63.552a96 96 0 0196 96v224a96 96 0 01-96 96H800v128a128 128 0 01-128 128H224A128 128 0 0196 800V128a32 32 0 0132-32h640a32 32 0 0132 32v128zm0 64v288h63.552a32 32 0 0032-32V352a32 32 0 00-32-32H800z"
}, null, -1);
const _hoisted_3$2u = [
  _hoisted_2$2H
];
function _sfc_render$1J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$34, _hoisted_3$2u);
}
var mug = /* @__PURE__ */ _export_sfc(_sfc_main$1J, [["render", _sfc_render$1J]]);
const _sfc_main$1I = defineComponent({
  name: "MuteNotification"
});
const _hoisted_1$33 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2G = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M241.216 832l63.616-64H768V448c0-42.368-10.24-82.304-28.48-117.504l46.912-47.232C815.36 331.392 832 387.84 832 448v320h96a32 32 0 110 64H241.216zm-90.24 0H96a32 32 0 110-64h96V448a320.128 320.128 0 01256-313.6V128a64 64 0 11128 0v6.4a319.552 319.552 0 01171.648 97.088l-45.184 45.44A256 256 0 00256 448v278.336L151.04 832zM448 896h128a64 64 0 01-128 0z"
}, null, -1);
const _hoisted_3$2t = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M150.72 859.072a32 32 0 01-45.44-45.056l704-708.544a32 32 0 0145.44 45.056l-704 708.544z"
}, null, -1);
const _hoisted_4$12 = [
  _hoisted_2$2G,
  _hoisted_3$2t
];
function _sfc_render$1I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$33, _hoisted_4$12);
}
var muteNotification = /* @__PURE__ */ _export_sfc(_sfc_main$1I, [["render", _sfc_render$1I]]);
const _sfc_main$1H = defineComponent({
  name: "Mute"
});
const _hoisted_1$32 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2F = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M412.16 592.128l-45.44 45.44A191.232 191.232 0 01320 512V256a192 192 0 11384 0v44.352l-64 64V256a128 128 0 10-256 0v256c0 30.336 10.56 58.24 28.16 80.128zm51.968 38.592A128 128 0 00640 512v-57.152l64-64V512a192 192 0 01-287.68 166.528l47.808-47.808zM314.88 779.968l46.144-46.08A222.976 222.976 0 00480 768h64a224 224 0 00224-224v-32a32 32 0 1164 0v32a288 288 0 01-288 288v64h64a32 32 0 110 64H416a32 32 0 110-64h64v-64c-61.44 0-118.4-19.2-165.12-52.032zM266.752 737.6A286.976 286.976 0 01192 544v-32a32 32 0 0164 0v32c0 56.832 21.184 108.8 56.064 148.288L266.752 737.6z"
}, null, -1);
const _hoisted_3$2s = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M150.72 859.072a32 32 0 01-45.44-45.056l704-708.544a32 32 0 0145.44 45.056l-704 708.544z"
}, null, -1);
const _hoisted_4$11 = [
  _hoisted_2$2F,
  _hoisted_3$2s
];
function _sfc_render$1H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$32, _hoisted_4$11);
}
var mute = /* @__PURE__ */ _export_sfc(_sfc_main$1H, [["render", _sfc_render$1H]]);
const _sfc_main$1G = defineComponent({
  name: "NoSmoking"
});
const _hoisted_1$31 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2E = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M440.256 576H256v128h56.256l-64 64H224a32 32 0 01-32-32V544a32 32 0 0132-32h280.256l-64 64zm143.488 128H704V583.744L775.744 512H928a32 32 0 0132 32v192a32 32 0 01-32 32H519.744l64-64zM768 576v128h128V576H768zM738.304 368.448l45.248 45.248-497.856 497.856-45.248-45.248zM256 64h64v320h-64zM128 192h64v192h-64zM64 512h64v256H64z"
}, null, -1);
const _hoisted_3$2r = [
  _hoisted_2$2E
];
function _sfc_render$1G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$31, _hoisted_3$2r);
}
var noSmoking = /* @__PURE__ */ _export_sfc(_sfc_main$1G, [["render", _sfc_render$1G]]);
const _sfc_main$1F = defineComponent({
  name: "Notebook"
});
const _hoisted_1$30 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2D = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 128v768h640V128H192zm-32-64h704a32 32 0 0132 32v832a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$2q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M672 128h64v768h-64zM96 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zM96 384h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zM96 576h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zM96 768h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$10 = [
  _hoisted_2$2D,
  _hoisted_3$2q
];
function _sfc_render$1F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$30, _hoisted_4$10);
}
var notebook = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["render", _sfc_render$1F]]);
const _sfc_main$1E = defineComponent({
  name: "Notification"
});
const _hoisted_1$2$ = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2C = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 128v64H256a64 64 0 00-64 64v512a64 64 0 0064 64h512a64 64 0 0064-64V512h64v256a128 128 0 01-128 128H256a128 128 0 01-128-128V256a128 128 0 01128-128h256z"
}, null, -1);
const _hoisted_3$2p = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M768 384a128 128 0 100-256 128 128 0 000 256zm0 64a192 192 0 110-384 192 192 0 010 384z"
}, null, -1);
const _hoisted_4$$ = [
  _hoisted_2$2C,
  _hoisted_3$2p
];
function _sfc_render$1E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2$, _hoisted_4$$);
}
var notification$3 = /* @__PURE__ */ _export_sfc(_sfc_main$1E, [["render", _sfc_render$1E]]);
const _sfc_main$1D = defineComponent({
  name: "Odometer"
});
const _hoisted_1$2_ = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2B = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3$2o = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 512a320 320 0 11640 0 32 32 0 11-64 0 256 256 0 10-512 0 32 32 0 01-64 0z"
}, null, -1);
const _hoisted_4$_ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M570.432 627.84A96 96 0 11509.568 608l60.992-187.776A32 32 0 11631.424 440l-60.992 187.776zM502.08 734.464a32 32 0 1019.84-60.928 32 32 0 00-19.84 60.928z"
}, null, -1);
const _hoisted_5$x = [
  _hoisted_2$2B,
  _hoisted_3$2o,
  _hoisted_4$_
];
function _sfc_render$1D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2_, _hoisted_5$x);
}
var odometer = /* @__PURE__ */ _export_sfc(_sfc_main$1D, [["render", _sfc_render$1D]]);
const _sfc_main$1C = defineComponent({
  name: "OfficeBuilding"
});
const _hoisted_1$2Z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2A = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 128v704h384V128H192zm-32-64h448a32 32 0 0132 32v768a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$2n = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 256h256v64H256v-64zm0 192h256v64H256v-64zm0 192h256v64H256v-64zm384-128h128v64H640v-64zm0 128h128v64H640v-64zM64 832h896v64H64v-64z"
}, null, -1);
const _hoisted_4$Z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 384v448h192V384H640zm-32-64h256a32 32 0 0132 32v512a32 32 0 01-32 32H608a32 32 0 01-32-32V352a32 32 0 0132-32z"
}, null, -1);
const _hoisted_5$w = [
  _hoisted_2$2A,
  _hoisted_3$2n,
  _hoisted_4$Z
];
function _sfc_render$1C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2Z, _hoisted_5$w);
}
var officeBuilding = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["render", _sfc_render$1C]]);
const _sfc_main$1B = defineComponent({
  name: "Open"
});
const _hoisted_1$2Y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M329.956 257.138a254.862 254.862 0 000 509.724h364.088a254.862 254.862 0 000-509.724H329.956zm0-72.818h364.088a327.68 327.68 0 110 655.36H329.956a327.68 327.68 0 110-655.36z"
}, null, -1);
const _hoisted_3$2m = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M694.044 621.227a109.227 109.227 0 100-218.454 109.227 109.227 0 000 218.454zm0 72.817a182.044 182.044 0 110-364.088 182.044 182.044 0 010 364.088z"
}, null, -1);
const _hoisted_4$Y = [
  _hoisted_2$2z,
  _hoisted_3$2m
];
function _sfc_render$1B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2Y, _hoisted_4$Y);
}
var open = /* @__PURE__ */ _export_sfc(_sfc_main$1B, [["render", _sfc_render$1B]]);
const _sfc_main$1A = defineComponent({
  name: "Operation"
});
const _hoisted_1$2X = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M389.44 768a96.064 96.064 0 01181.12 0H896v64H570.56a96.064 96.064 0 01-181.12 0H128v-64h261.44zm192-288a96.064 96.064 0 01181.12 0H896v64H762.56a96.064 96.064 0 01-181.12 0H128v-64h453.44zm-320-288a96.064 96.064 0 01181.12 0H896v64H442.56a96.064 96.064 0 01-181.12 0H128v-64h133.44z"
}, null, -1);
const _hoisted_3$2l = [
  _hoisted_2$2y
];
function _sfc_render$1A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2X, _hoisted_3$2l);
}
var operation = /* @__PURE__ */ _export_sfc(_sfc_main$1A, [["render", _sfc_render$1A]]);
const _sfc_main$1z = defineComponent({
  name: "Opportunity"
});
const _hoisted_1$2W = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2x = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 960v-64h192.064v64H384zm448-544a350.656 350.656 0 01-128.32 271.424C665.344 719.04 640 763.776 640 813.504V832H320v-14.336c0-48-19.392-95.36-57.216-124.992a351.552 351.552 0 01-128.448-344.256c25.344-136.448 133.888-248.128 269.76-276.48A352.384 352.384 0 01832 416zm-544 32c0-132.288 75.904-224 192-224v-64c-154.432 0-256 122.752-256 288h64z"
}, null, -1);
const _hoisted_3$2k = [
  _hoisted_2$2x
];
function _sfc_render$1z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2W, _hoisted_3$2k);
}
var opportunity = /* @__PURE__ */ _export_sfc(_sfc_main$1z, [["render", _sfc_render$1z]]);
const _sfc_main$1y = defineComponent({
  name: "Orange"
});
const _hoisted_1$2V = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2w = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 894.72a382.336 382.336 0 00215.936-89.472L577.024 622.272c-10.24 6.016-21.248 10.688-33.024 13.696v258.688zm261.248-134.784A382.336 382.336 0 00894.656 544H635.968c-3.008 11.776-7.68 22.848-13.696 33.024l182.976 182.912zM894.656 480a382.336 382.336 0 00-89.408-215.936L622.272 446.976c6.016 10.24 10.688 21.248 13.696 33.024h258.688zm-134.72-261.248A382.336 382.336 0 00544 129.344v258.688c11.776 3.008 22.848 7.68 33.024 13.696l182.912-182.976zM480 129.344a382.336 382.336 0 00-215.936 89.408l182.912 182.976c10.24-6.016 21.248-10.688 33.024-13.696V129.344zm-261.248 134.72A382.336 382.336 0 00129.344 480h258.688c3.008-11.776 7.68-22.848 13.696-33.024L218.752 264.064zM129.344 544a382.336 382.336 0 0089.408 215.936l182.976-182.912A127.232 127.232 0 01388.032 544H129.344zm134.72 261.248A382.336 382.336 0 00480 894.656V635.968a127.232 127.232 0 01-33.024-13.696L264.064 805.248zM512 960a448 448 0 110-896 448 448 0 010 896zm0-384a64 64 0 100-128 64 64 0 000 128z"
}, null, -1);
const _hoisted_3$2j = [
  _hoisted_2$2w
];
function _sfc_render$1y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2V, _hoisted_3$2j);
}
var orange = /* @__PURE__ */ _export_sfc(_sfc_main$1y, [["render", _sfc_render$1y]]);
const _sfc_main$1x = defineComponent({
  name: "Paperclip"
});
const _hoisted_1$2U = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2v = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M602.496 240.448A192 192 0 11874.048 512l-316.8 316.8A256 256 0 01195.2 466.752L602.496 59.456l45.248 45.248L240.448 512A192 192 0 00512 783.552l316.8-316.8a128 128 0 10-181.056-181.056L353.6 579.904a32 32 0 1045.248 45.248l294.144-294.144 45.312 45.248L444.096 670.4a96 96 0 11-135.744-135.744l294.144-294.208z"
}, null, -1);
const _hoisted_3$2i = [
  _hoisted_2$2v
];
function _sfc_render$1x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2U, _hoisted_3$2i);
}
var paperclip = /* @__PURE__ */ _export_sfc(_sfc_main$1x, [["render", _sfc_render$1x]]);
const _sfc_main$1w = defineComponent({
  name: "PartlyCloudy"
});
const _hoisted_1$2T = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2u = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M598.4 895.872H328.192a256 256 0 01-34.496-510.528A352 352 0 11598.4 895.872zm-271.36-64h272.256a288 288 0 10-248.512-417.664L335.04 445.44l-34.816 3.584a192 192 0 0026.88 382.848z"
}, null, -1);
const _hoisted_3$2h = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M139.84 501.888a256 256 0 11417.856-277.12c-17.728 2.176-38.208 8.448-61.504 18.816A192 192 0 10189.12 460.48a6003.84 6003.84 0 00-49.28 41.408z"
}, null, -1);
const _hoisted_4$X = [
  _hoisted_2$2u,
  _hoisted_3$2h
];
function _sfc_render$1w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2T, _hoisted_4$X);
}
var partlyCloudy = /* @__PURE__ */ _export_sfc(_sfc_main$1w, [["render", _sfc_render$1w]]);
const _sfc_main$1v = defineComponent({
  name: "Pear"
});
const _hoisted_1$2S = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2t = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M542.336 258.816a443.255 443.255 0 00-9.024 25.088 32 32 0 11-60.8-20.032l1.088-3.328a162.688 162.688 0 00-122.048 131.392l-17.088 102.72-20.736 15.36C256.192 552.704 224 610.88 224 672c0 120.576 126.4 224 288 224s288-103.424 288-224c0-61.12-32.192-119.296-89.728-161.92l-20.736-15.424-17.088-102.72a162.688 162.688 0 00-130.112-133.12zm-40.128-66.56c7.936-15.552 16.576-30.08 25.92-43.776 23.296-33.92 49.408-59.776 78.528-77.12a32 32 0 1132.704 55.04c-20.544 12.224-40.064 31.552-58.432 58.304a316.608 316.608 0 00-9.792 15.104 226.688 226.688 0 01164.48 181.568l12.8 77.248C819.456 511.36 864 587.392 864 672c0 159.04-157.568 288-352 288S160 831.04 160 672c0-84.608 44.608-160.64 115.584-213.376l12.8-77.248a226.624 226.624 0 01213.76-189.184z"
}, null, -1);
const _hoisted_3$2g = [
  _hoisted_2$2t
];
function _sfc_render$1v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2S, _hoisted_3$2g);
}
var pear = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["render", _sfc_render$1v]]);
const _sfc_main$1u = defineComponent({
  name: "PhoneFilled"
});
const _hoisted_1$2R = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2s = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M199.232 125.568L90.624 379.008a32 32 0 006.784 35.2l512.384 512.384a32 32 0 0035.2 6.784l253.44-108.608a32 32 0 0010.048-52.032L769.6 633.92a32 32 0 00-36.928-5.952l-130.176 65.088-271.488-271.552 65.024-130.176a32 32 0 00-5.952-36.928L251.2 115.52a32 32 0 00-51.968 10.048z"
}, null, -1);
const _hoisted_3$2f = [
  _hoisted_2$2s
];
function _sfc_render$1u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2R, _hoisted_3$2f);
}
var phoneFilled = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["render", _sfc_render$1u]]);
const _sfc_main$1t = defineComponent({
  name: "Phone"
});
const _hoisted_1$2Q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2r = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M79.36 432.256L591.744 944.64a32 32 0 0035.2 6.784l253.44-108.544a32 32 0 009.984-52.032l-153.856-153.92a32 32 0 00-36.928-6.016l-69.888 34.944L358.08 394.24l35.008-69.888a32 32 0 00-5.952-36.928L233.152 133.568a32 32 0 00-52.032 10.048L72.512 397.056a32 32 0 006.784 35.2zm60.48-29.952l81.536-190.08L325.568 316.48l-24.64 49.216-20.608 41.216 32.576 32.64 271.552 271.552 32.64 32.64 41.216-20.672 49.28-24.576 104.192 104.128-190.08 81.472L139.84 402.304zM512 320v-64a256 256 0 01256 256h-64a192 192 0 00-192-192zm0-192V64a448 448 0 01448 448h-64a384 384 0 00-384-384z"
}, null, -1);
const _hoisted_3$2e = [
  _hoisted_2$2r
];
function _sfc_render$1t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2Q, _hoisted_3$2e);
}
var phone = /* @__PURE__ */ _export_sfc(_sfc_main$1t, [["render", _sfc_render$1t]]);
const _sfc_main$1s = defineComponent({
  name: "PictureFilled"
});
const _hoisted_1$2P = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M96 896a32 32 0 01-32-32V160a32 32 0 0132-32h832a32 32 0 0132 32v704a32 32 0 01-32 32H96zm315.52-228.48l-68.928-68.928a32 32 0 00-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 00-49.216 0L458.752 665.408a32 32 0 01-47.232 2.112zM256 384a96 96 0 10192.064-.064A96 96 0 00256 384z"
}, null, -1);
const _hoisted_3$2d = [
  _hoisted_2$2q
];
function _sfc_render$1s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2P, _hoisted_3$2d);
}
var pictureFilled = /* @__PURE__ */ _export_sfc(_sfc_main$1s, [["render", _sfc_render$1s]]);
const _sfc_main$1r = defineComponent({
  name: "PictureRounded"
});
const _hoisted_1$2O = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2p = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 128a384 384 0 100 768 384 384 0 000-768zm0-64a448 448 0 110 896 448 448 0 010-896z"
}, null, -1);
const _hoisted_3$2c = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM214.656 790.656l-45.312-45.312 185.664-185.6a96 96 0 01123.712-10.24l138.24 98.688a32 32 0 0039.872-2.176L906.688 422.4l42.624 47.744L699.52 693.696a96 96 0 01-119.808 6.592l-138.24-98.752a32 32 0 00-41.152 3.456l-185.664 185.6z"
}, null, -1);
const _hoisted_4$W = [
  _hoisted_2$2p,
  _hoisted_3$2c
];
function _sfc_render$1r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2O, _hoisted_4$W);
}
var pictureRounded = /* @__PURE__ */ _export_sfc(_sfc_main$1r, [["render", _sfc_render$1r]]);
const _sfc_main$1q = defineComponent({
  name: "Picture"
});
const _hoisted_1$2N = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2o = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 160v704h704V160H160zm-32-64h768a32 32 0 0132 32v768a32 32 0 01-32 32H128a32 32 0 01-32-32V128a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$2b = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM185.408 876.992l-50.816-38.912L350.72 556.032a96 96 0 01134.592-17.856l1.856 1.472 122.88 99.136a32 32 0 0044.992-4.864l216-269.888 49.92 39.936-215.808 269.824-.256.32a96 96 0 01-135.04 14.464l-122.88-99.072-.64-.512a32 32 0 00-44.8 5.952L185.408 876.992z"
}, null, -1);
const _hoisted_4$V = [
  _hoisted_2$2o,
  _hoisted_3$2b
];
function _sfc_render$1q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2N, _hoisted_4$V);
}
var picture = /* @__PURE__ */ _export_sfc(_sfc_main$1q, [["render", _sfc_render$1q]]);
const _sfc_main$1p = defineComponent({
  name: "PieChart"
});
const _hoisted_1$2M = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2n = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M448 68.48v64.832A384.128 384.128 0 00512 896a384.128 384.128 0 00378.688-320h64.768A448.128 448.128 0 0164 512 448.128 448.128 0 01448 68.48z"
}, null, -1);
const _hoisted_3$2a = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M576 97.28V448h350.72A384.064 384.064 0 00576 97.28zM512 64V33.152A448 448 0 01990.848 512H512V64z"
}, null, -1);
const _hoisted_4$U = [
  _hoisted_2$2n,
  _hoisted_3$2a
];
function _sfc_render$1p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2M, _hoisted_4$U);
}
var pieChart = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["render", _sfc_render$1p]]);
const _sfc_main$1o = defineComponent({
  name: "Place"
});
const _hoisted_1$2L = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2m = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 512a192 192 0 100-384 192 192 0 000 384zm0 64a256 256 0 110-512 256 256 0 010 512z"
}, null, -1);
const _hoisted_3$29 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 512a32 32 0 0132 32v256a32 32 0 11-64 0V544a32 32 0 0132-32z"
}, null, -1);
const _hoisted_4$T = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 649.088v64.96C269.76 732.352 192 771.904 192 800c0 37.696 139.904 96 320 96s320-58.304 320-96c0-28.16-77.76-67.648-192-85.952v-64.96C789.12 671.04 896 730.368 896 800c0 88.32-171.904 160-384 160s-384-71.68-384-160c0-69.696 106.88-128.96 256-150.912z"
}, null, -1);
const _hoisted_5$v = [
  _hoisted_2$2m,
  _hoisted_3$29,
  _hoisted_4$T
];
function _sfc_render$1o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2L, _hoisted_5$v);
}
var place = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["render", _sfc_render$1o]]);
const _sfc_main$1n = defineComponent({
  name: "Platform"
});
const _hoisted_1$2K = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2l = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M448 832v-64h128v64h192v64H256v-64h192zM128 704V128h768v576H128z"
}, null, -1);
const _hoisted_3$28 = [
  _hoisted_2$2l
];
function _sfc_render$1n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2K, _hoisted_3$28);
}
var platform = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["render", _sfc_render$1n]]);
const _sfc_main$1m = defineComponent({
  name: "Plus"
});
const _hoisted_1$2J = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2k = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 480V128a32 32 0 0164 0v352h352a32 32 0 110 64H544v352a32 32 0 11-64 0V544H128a32 32 0 010-64h352z"
}, null, -1);
const _hoisted_3$27 = [
  _hoisted_2$2k
];
function _sfc_render$1m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2J, _hoisted_3$27);
}
var plus = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["render", _sfc_render$1m]]);
const _sfc_main$1l = defineComponent({
  name: "Pointer"
});
const _hoisted_1$2I = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2j = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M511.552 128c-35.584 0-64.384 28.8-64.384 64.448v516.48L274.048 570.88a94.272 94.272 0 00-112.896-3.456 44.416 44.416 0 00-8.96 62.208L332.8 870.4A64 64 0 00384 896h512V575.232a64 64 0 00-45.632-61.312l-205.952-61.76A96 96 0 01576 360.192V192.448C576 156.8 547.2 128 511.552 128zM359.04 556.8l24.128 19.2V192.448a128.448 128.448 0 11256.832 0v167.744a32 32 0 0022.784 30.656l206.016 61.76A128 128 0 01960 575.232V896a64 64 0 01-64 64H384a128 128 0 01-102.4-51.2L101.056 668.032A108.416 108.416 0 01128 512.512a158.272 158.272 0 01185.984 8.32L359.04 556.8z"
}, null, -1);
const _hoisted_3$26 = [
  _hoisted_2$2j
];
function _sfc_render$1l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2I, _hoisted_3$26);
}
var pointer = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["render", _sfc_render$1l]]);
const _sfc_main$1k = defineComponent({
  name: "Position"
});
const _hoisted_1$2H = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2i = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M249.6 417.088l319.744 43.072 39.168 310.272L845.12 178.88 249.6 417.088zm-129.024 47.168a32 32 0 01-7.68-61.44l777.792-311.04a32 32 0 0141.6 41.6l-310.336 775.68a32 32 0 01-61.44-7.808L512 516.992l-391.424-52.736z"
}, null, -1);
const _hoisted_3$25 = [
  _hoisted_2$2i
];
function _sfc_render$1k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2H, _hoisted_3$25);
}
var position = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$1k]]);
const _sfc_main$1j = defineComponent({
  name: "Postcard"
});
const _hoisted_1$2G = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2h = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 224a32 32 0 00-32 32v512a32 32 0 0032 32h704a32 32 0 0032-32V256a32 32 0 00-32-32H160zm0-64h704a96 96 0 0196 96v512a96 96 0 01-96 96H160a96 96 0 01-96-96V256a96 96 0 0196-96z"
}, null, -1);
const _hoisted_3$24 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 320a64 64 0 110 128 64 64 0 010-128zM288 448h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32zM288 576h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$S = [
  _hoisted_2$2h,
  _hoisted_3$24
];
function _sfc_render$1j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2G, _hoisted_4$S);
}
var postcard = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$1j]]);
const _sfc_main$1i = defineComponent({
  name: "Pouring"
});
const _hoisted_1$2F = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2g = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M739.328 291.328l-35.2-6.592-12.8-33.408a192.064 192.064 0 00-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 00-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0035.776-380.672zM959.552 480a256 256 0 01-256 256h-400A239.808 239.808 0 0163.744 496.192a240.32 240.32 0 01199.488-236.8 256.128 256.128 0 01487.872-30.976A256.064 256.064 0 01959.552 480zM224 800a32 32 0 0132 32v96a32 32 0 11-64 0v-96a32 32 0 0132-32zm192 0a32 32 0 0132 32v96a32 32 0 11-64 0v-96a32 32 0 0132-32zm192 0a32 32 0 0132 32v96a32 32 0 11-64 0v-96a32 32 0 0132-32zm192 0a32 32 0 0132 32v96a32 32 0 11-64 0v-96a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$23 = [
  _hoisted_2$2g
];
function _sfc_render$1i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2F, _hoisted_3$23);
}
var pouring = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$1i]]);
const _sfc_main$1h = defineComponent({
  name: "Present"
});
const _hoisted_1$2E = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2f = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 896V640H192v-64h288V320H192v576h288zm64 0h288V320H544v256h288v64H544v256zM128 256h768v672a32 32 0 01-32 32H160a32 32 0 01-32-32V256z"
}, null, -1);
const _hoisted_3$22 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M96 256h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M416 256a64 64 0 100-128 64 64 0 000 128zm0 64a128 128 0 110-256 128 128 0 010 256z"
}, null, -1);
const _hoisted_5$u = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M608 256a64 64 0 100-128 64 64 0 000 128zm0 64a128 128 0 110-256 128 128 0 010 256z"
}, null, -1);
const _hoisted_6$k = [
  _hoisted_2$2f,
  _hoisted_3$22,
  _hoisted_4$R,
  _hoisted_5$u
];
function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2E, _hoisted_6$k);
}
var present = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["render", _sfc_render$1h]]);
const _sfc_main$1g = defineComponent({
  name: "PriceTag"
});
const _hoisted_1$2D = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2e = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M224 318.336V896h576V318.336L552.512 115.84a64 64 0 00-81.024 0L224 318.336zM593.024 66.304l259.2 212.096A32 32 0 01864 303.168V928a32 32 0 01-32 32H192a32 32 0 01-32-32V303.168a32 32 0 0111.712-24.768l259.2-212.096a128 128 0 01162.112 0z"
}, null, -1);
const _hoisted_3$21 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 448a64 64 0 100-128 64 64 0 000 128zm0 64a128 128 0 110-256 128 128 0 010 256z"
}, null, -1);
const _hoisted_4$Q = [
  _hoisted_2$2e,
  _hoisted_3$21
];
function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2D, _hoisted_4$Q);
}
var priceTag = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$1g]]);
const _sfc_main$1f = defineComponent({
  name: "Printer"
});
const _hoisted_1$2C = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2d = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 768H105.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 01-12.16-12.096C65.536 746.432 64 741.248 64 727.04V379.072c0-42.816 4.48-58.304 12.8-73.984 8.384-15.616 20.672-27.904 36.288-36.288 15.68-8.32 31.168-12.8 73.984-12.8H256V64h512v192h68.928c42.816 0 58.304 4.48 73.984 12.8 15.616 8.384 27.904 20.672 36.288 36.288 8.32 15.68 12.8 31.168 12.8 73.984v347.904c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 01-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H768v192H256V768zm64-192v320h384V576H320zm-64 128V512h512v192h128V379.072c0-29.376-1.408-36.48-5.248-43.776a23.296 23.296 0 00-10.048-10.048c-7.232-3.84-14.4-5.248-43.776-5.248H187.072c-29.376 0-36.48 1.408-43.776 5.248a23.296 23.296 0 00-10.048 10.048c-3.84 7.232-5.248 14.4-5.248 43.776V704h128zm64-448h384V128H320v128zm-64 128h64v64h-64v-64zm128 0h64v64h-64v-64z"
}, null, -1);
const _hoisted_3$20 = [
  _hoisted_2$2d
];
function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2C, _hoisted_3$20);
}
var printer = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["render", _sfc_render$1f]]);
const _sfc_main$1e = defineComponent({
  name: "Promotion"
});
const _hoisted_1$2B = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2c = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M64 448l832-320-128 704-446.08-243.328L832 192 242.816 545.472 64 448zm256 512V657.024L512 768 320 960z"
}, null, -1);
const _hoisted_3$1$ = [
  _hoisted_2$2c
];
function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2B, _hoisted_3$1$);
}
var promotion = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$1e]]);
const _sfc_main$1d = defineComponent({
  name: "QuestionFilled"
});
const _hoisted_1$2A = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2b = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 00-38.72 14.784 49.408 49.408 0 00-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 00523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0016.192-38.72 51.968 51.968 0 00-15.488-38.016 55.936 55.936 0 00-39.424-14.784z"
}, null, -1);
const _hoisted_3$1_ = [
  _hoisted_2$2b
];
function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2A, _hoisted_3$1_);
}
var questionFilled = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$1d]]);
const _sfc_main$1c = defineComponent({
  name: "Rank"
});
const _hoisted_1$2z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2a = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M186.496 544l41.408 41.344a32 32 0 11-45.248 45.312l-96-96a32 32 0 010-45.312l96-96a32 32 0 1145.248 45.312L186.496 480h290.816V186.432l-41.472 41.472a32 32 0 11-45.248-45.184l96-96.128a32 32 0 0145.312 0l96 96.064a32 32 0 01-45.248 45.184l-41.344-41.28V480H832l-41.344-41.344a32 32 0 0145.248-45.312l96 96a32 32 0 010 45.312l-96 96a32 32 0 01-45.248-45.312L832 544H541.312v293.44l41.344-41.28a32 32 0 1145.248 45.248l-96 96a32 32 0 01-45.312 0l-96-96a32 32 0 1145.312-45.248l41.408 41.408V544H186.496z"
}, null, -1);
const _hoisted_3$1Z = [
  _hoisted_2$2a
];
function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2z, _hoisted_3$1Z);
}
var rank = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$1c]]);
const _sfc_main$1b = defineComponent({
  name: "ReadingLamp"
});
const _hoisted_1$2y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$29 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 896h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zM307.328 128l-99.52 448h608.384l-99.52-448H307.328zm-25.6-64h460.608a32 32 0 0131.232 25.088l113.792 512A32 32 0 01856.128 640H167.872a32 32 0 01-31.232-38.912l113.792-512A32 32 0 01281.664 64z"
}, null, -1);
const _hoisted_3$1Y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M672 576q32 0 32 32v128q0 32-32 32t-32-32V608q0-32 32-32zM480 575.936h64V960h-64z"
}, null, -1);
const _hoisted_4$P = [
  _hoisted_2$29,
  _hoisted_3$1Y
];
function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2y, _hoisted_4$P);
}
var readingLamp = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$1b]]);
const _sfc_main$1a = defineComponent({
  name: "Reading"
});
const _hoisted_1$2x = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$28 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 863.36l384-54.848v-638.72L525.568 222.72a96 96 0 01-27.136 0L128 169.792v638.72l384 54.848zM137.024 106.432l370.432 52.928a32 32 0 009.088 0l370.432-52.928A64 64 0 01960 169.792v638.72a64 64 0 01-54.976 63.36l-388.48 55.488a32 32 0 01-9.088 0l-388.48-55.488A64 64 0 0164 808.512v-638.72a64 64 0 0173.024-63.36z"
}, null, -1);
const _hoisted_3$1X = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 192h64v704h-64z"
}, null, -1);
const _hoisted_4$O = [
  _hoisted_2$28,
  _hoisted_3$1X
];
function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2x, _hoisted_4$O);
}
var reading = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$1a]]);
const _sfc_main$19 = defineComponent({
  name: "RefreshLeft"
});
const _hoisted_1$2w = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$27 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M289.088 296.704h92.992a32 32 0 010 64H232.96a32 32 0 01-32-32V179.712a32 32 0 0164 0v50.56a384 384 0 01643.84 282.88 384 384 0 01-383.936 384 384 384 0 01-384-384h64a320 320 0 10640 0 320 320 0 00-555.712-216.448z"
}, null, -1);
const _hoisted_3$1W = [
  _hoisted_2$27
];
function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2w, _hoisted_3$1W);
}
var refreshLeft = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$19]]);
const _sfc_main$18 = defineComponent({
  name: "RefreshRight"
});
const _hoisted_1$2v = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$26 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M784.512 230.272v-50.56a32 32 0 1164 0v149.056a32 32 0 01-32 32H667.52a32 32 0 110-64h92.992A320 320 0 10524.8 833.152a320 320 0 00320-320h64a384 384 0 01-384 384 384 384 0 01-384-384 384 384 0 01643.712-282.88z"
}, null, -1);
const _hoisted_3$1V = [
  _hoisted_2$26
];
function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2v, _hoisted_3$1V);
}
var refreshRight = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$18]]);
const _sfc_main$17 = defineComponent({
  name: "Refresh"
});
const _hoisted_1$2u = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$25 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M771.776 794.88A384 384 0 01128 512h64a320 320 0 00555.712 216.448H654.72a32 32 0 110-64h149.056a32 32 0 0132 32v148.928a32 32 0 11-64 0v-50.56zM276.288 295.616h92.992a32 32 0 010 64H220.16a32 32 0 01-32-32V178.56a32 32 0 0164 0v50.56A384 384 0 01896.128 512h-64a320 320 0 00-555.776-216.384z"
}, null, -1);
const _hoisted_3$1U = [
  _hoisted_2$25
];
function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2u, _hoisted_3$1U);
}
var refresh = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$17]]);
const _sfc_main$16 = defineComponent({
  name: "Refrigerator"
});
const _hoisted_1$2t = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$24 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 448h512V160a32 32 0 00-32-32H288a32 32 0 00-32 32v288zm0 64v352a32 32 0 0032 32h448a32 32 0 0032-32V512H256zm32-448h448a96 96 0 0196 96v704a96 96 0 01-96 96H288a96 96 0 01-96-96V160a96 96 0 0196-96zm32 224h64v96h-64v-96zm0 288h64v96h-64v-96z"
}, null, -1);
const _hoisted_3$1T = [
  _hoisted_2$24
];
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2t, _hoisted_3$1T);
}
var refrigerator = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16]]);
const _sfc_main$15 = defineComponent({
  name: "RemoveFilled"
});
const _hoisted_1$2s = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$23 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zM288 512a38.4 38.4 0 0038.4 38.4h371.2a38.4 38.4 0 000-76.8H326.4A38.4 38.4 0 00288 512z"
}, null, -1);
const _hoisted_3$1S = [
  _hoisted_2$23
];
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2s, _hoisted_3$1S);
}
var removeFilled = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$15]]);
const _sfc_main$14 = defineComponent({
  name: "Remove"
});
const _hoisted_1$2r = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$22 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 480h320a32 32 0 110 64H352a32 32 0 010-64z"
}, null, -1);
const _hoisted_3$1R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_4$N = [
  _hoisted_2$22,
  _hoisted_3$1R
];
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2r, _hoisted_4$N);
}
var remove = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$14]]);
const _sfc_main$13 = defineComponent({
  name: "Right"
});
const _hoisted_1$2q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$21 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M754.752 480H160a32 32 0 100 64h594.752L521.344 777.344a32 32 0 0045.312 45.312l288-288a32 32 0 000-45.312l-288-288a32 32 0 10-45.312 45.312L754.752 480z"
}, null, -1);
const _hoisted_3$1Q = [
  _hoisted_2$21
];
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2q, _hoisted_3$1Q);
}
var right = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$13]]);
const _sfc_main$12 = defineComponent({
  name: "ScaleToOriginal"
});
const _hoisted_1$2p = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$20 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M813.176 180.706a60.235 60.235 0 0160.236 60.235v481.883a60.235 60.235 0 01-60.236 60.235H210.824a60.235 60.235 0 01-60.236-60.235V240.94a60.235 60.235 0 0160.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0090.353 240.94v481.883a120.47 120.47 0 00120.47 120.47h602.353a120.47 120.47 0 00120.471-120.47V240.94a120.47 120.47 0 00-120.47-120.47zm-120.47 180.705a30.118 30.118 0 00-30.118 30.118v301.177a30.118 30.118 0 0060.236 0V331.294a30.118 30.118 0 00-30.118-30.118zm-361.412 0a30.118 30.118 0 00-30.118 30.118v301.177a30.118 30.118 0 1060.236 0V331.294a30.118 30.118 0 00-30.118-30.118zM512 361.412a30.118 30.118 0 00-30.118 30.117v30.118a30.118 30.118 0 0060.236 0V391.53A30.118 30.118 0 00512 361.412zM512 512a30.118 30.118 0 00-30.118 30.118v30.117a30.118 30.118 0 0060.236 0v-30.117A30.118 30.118 0 00512 512z"
}, null, -1);
const _hoisted_3$1P = [
  _hoisted_2$20
];
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2p, _hoisted_3$1P);
}
var scaleToOriginal = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$12]]);
const _sfc_main$11 = defineComponent({
  name: "School"
});
const _hoisted_1$2o = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1$ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M224 128v704h576V128H224zm-32-64h640a32 32 0 0132 32v768a32 32 0 01-32 32H192a32 32 0 01-32-32V96a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$1O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M64 832h896v64H64zm256-640h128v96H320z"
}, null, -1);
const _hoisted_4$M = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 832h256v-64a128 128 0 10-256 0v64zm128-256a192 192 0 01192 192v128H320V768a192 192 0 01192-192zM320 384h128v96H320zm256-192h128v96H576zm0 192h128v96H576z"
}, null, -1);
const _hoisted_5$t = [
  _hoisted_2$1$,
  _hoisted_3$1O,
  _hoisted_4$M
];
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2o, _hoisted_5$t);
}
var school = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$11]]);
const _sfc_main$10 = defineComponent({
  name: "Scissor"
});
const _hoisted_1$2n = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1_ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512.064 578.368l-106.88 152.768a160 160 0 11-23.36-78.208L472.96 522.56 196.864 128.256a32 32 0 1152.48-36.736l393.024 561.344a160 160 0 11-23.36 78.208l-106.88-152.704zm54.4-189.248l208.384-297.6a32 32 0 0152.48 36.736l-221.76 316.672-39.04-55.808zm-376.32 425.856a96 96 0 10110.144-157.248 96 96 0 00-110.08 157.248zm643.84 0a96 96 0 10-110.08-157.248 96 96 0 00110.08 157.248z"
}, null, -1);
const _hoisted_3$1N = [
  _hoisted_2$1_
];
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2n, _hoisted_3$1N);
}
var scissor = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$10]]);
const _sfc_main$$ = defineComponent({
  name: "Search"
});
const _hoisted_1$2m = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1Z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M795.904 750.72l124.992 124.928a32 32 0 01-45.248 45.248L750.656 795.904a416 416 0 1145.248-45.248zM480 832a352 352 0 100-704 352 352 0 000 704z"
}, null, -1);
const _hoisted_3$1M = [
  _hoisted_2$1Z
];
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2m, _hoisted_3$1M);
}
var search = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$$]]);
const _sfc_main$_ = defineComponent({
  name: "Select"
});
const _hoisted_1$2l = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1Y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M77.248 415.04a64 64 0 0190.496 0l226.304 226.304L846.528 188.8a64 64 0 1190.56 90.496l-543.04 543.04-316.8-316.8a64 64 0 010-90.496z"
}, null, -1);
const _hoisted_3$1L = [
  _hoisted_2$1Y
];
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2l, _hoisted_3$1L);
}
var select$3 = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$_]]);
const _sfc_main$Z = defineComponent({
  name: "Sell"
});
const _hoisted_1$2k = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1X = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 288h131.072a32 32 0 0131.808 28.8L886.4 512h-64.384l-16-160H704v96a32 32 0 11-64 0v-96H384v96a32 32 0 01-64 0v-96H217.92l-51.2 512H512v64H131.328a32 32 0 01-31.808-35.2l57.6-576a32 32 0 0131.808-28.8H320v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4zm-64 0v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4h256zm201.408 483.84L768 698.496V928a32 32 0 11-64 0V698.496l-73.344 73.344a32 32 0 11-45.248-45.248l128-128a32 32 0 0145.248 0l128 128a32 32 0 11-45.248 45.248z"
}, null, -1);
const _hoisted_3$1K = [
  _hoisted_2$1X
];
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2k, _hoisted_3$1K);
}
var sell = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Z]]);
const _sfc_main$Y = defineComponent({
  name: "SemiSelect"
});
const _hoisted_1$2j = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1W = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 448h768q64 0 64 64t-64 64H128q-64 0-64-64t64-64z"
}, null, -1);
const _hoisted_3$1J = [
  _hoisted_2$1W
];
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2j, _hoisted_3$1J);
}
var semiSelect = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$Y]]);
const _sfc_main$X = defineComponent({
  name: "Service"
});
const _hoisted_1$2i = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1V = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M864 409.6a192 192 0 01-37.888 349.44A256.064 256.064 0 01576 960h-96a32 32 0 110-64h96a192.064 192.064 0 00181.12-128H736a32 32 0 01-32-32V416a32 32 0 0132-32h32c10.368 0 20.544.832 30.528 2.432a288 288 0 00-573.056 0A193.235 193.235 0 01256 384h32a32 32 0 0132 32v320a32 32 0 01-32 32h-32a192 192 0 01-96-358.4 352 352 0 01704 0zM256 448a128 128 0 100 256V448zm640 128a128 128 0 00-128-128v256a128 128 0 00128-128z"
}, null, -1);
const _hoisted_3$1I = [
  _hoisted_2$1V
];
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2i, _hoisted_3$1I);
}
var service$2 = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$X]]);
const _sfc_main$W = defineComponent({
  name: "SetUp"
});
const _hoisted_1$2h = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1U = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M224 160a64 64 0 00-64 64v576a64 64 0 0064 64h576a64 64 0 0064-64V224a64 64 0 00-64-64H224zm0-64h576a128 128 0 01128 128v576a128 128 0 01-128 128H224A128 128 0 0196 800V224A128 128 0 01224 96z"
}, null, -1);
const _hoisted_3$1H = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 416a64 64 0 100-128 64 64 0 000 128zm0 64a128 128 0 110-256 128 128 0 010 256z"
}, null, -1);
const _hoisted_4$L = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 320h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32zM640 736a64 64 0 100-128 64 64 0 000 128zm0 64a128 128 0 110-256 128 128 0 010 256z"
}, null, -1);
const _hoisted_5$s = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 640h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_6$j = [
  _hoisted_2$1U,
  _hoisted_3$1H,
  _hoisted_4$L,
  _hoisted_5$s
];
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2h, _hoisted_6$j);
}
var setUp = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$W]]);
const _sfc_main$V = defineComponent({
  name: "Setting"
});
const _hoisted_1$2g = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1T = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M600.704 64a32 32 0 0130.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0134.432 15.36L944.32 364.8a32 32 0 01-4.032 37.504l-77.12 85.12a357.12 357.12 0 010 49.024l77.12 85.248a32 32 0 014.032 37.504l-88.704 153.6a32 32 0 01-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 01600.704 960H423.296a32 32 0 01-30.464-22.208L357.696 828.48a351.616 351.616 0 01-42.56-24.64l-112.32 24.256a32 32 0 01-34.432-15.36L79.68 659.2a32 32 0 014.032-37.504l77.12-85.248a357.12 357.12 0 010-48.896l-77.12-85.248A32 32 0 0179.68 364.8l88.704-153.6a32 32 0 0134.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 01423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294.113 294.113 0 00-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293.12 293.12 0 000 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294.113 294.113 0 0034.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288.282 288.282 0 0034.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293.12 293.12 0 000-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a287.616 287.616 0 00-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 110 384 192 192 0 010-384zm0 64a128 128 0 100 256 128 128 0 000-256z"
}, null, -1);
const _hoisted_3$1G = [
  _hoisted_2$1T
];
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2g, _hoisted_3$1G);
}
var setting = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$V]]);
const _sfc_main$U = defineComponent({
  name: "Share"
});
const _hoisted_1$2f = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1S = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M679.872 348.8l-301.76 188.608a127.808 127.808 0 015.12 52.16l279.936 104.96a128 128 0 11-22.464 59.904l-279.872-104.96a128 128 0 11-16.64-166.272l301.696-188.608a128 128 0 1133.92 54.272z"
}, null, -1);
const _hoisted_3$1F = [
  _hoisted_2$1S
];
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2f, _hoisted_3$1F);
}
var share = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$U]]);
const _sfc_main$T = defineComponent({
  name: "Ship"
});
const _hoisted_1$2e = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 386.88V448h405.568a32 32 0 0130.72 40.768l-76.48 267.968A192 192 0 01687.168 896H336.832a192 192 0 01-184.64-139.264L75.648 488.768A32 32 0 01106.368 448H448V117.888a32 32 0 0147.36-28.096l13.888 7.616L512 96v2.88l231.68 126.4a32 32 0 01-2.048 57.216L512 386.88zm0-70.272l144.768-65.792L512 171.84v144.768zM512 512H148.864l18.24 64H856.96l18.24-64H512zM185.408 640l28.352 99.2A128 128 0 00336.832 832h350.336a128 128 0 00123.072-92.8l28.352-99.2H185.408z"
}, null, -1);
const _hoisted_3$1E = [
  _hoisted_2$1R
];
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2e, _hoisted_3$1E);
}
var ship = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$T]]);
const _sfc_main$S = defineComponent({
  name: "Shop"
});
const _hoisted_1$2d = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1Q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 704h64v192H256V704h64v64h384v-64zm188.544-152.192C894.528 559.616 896 567.616 896 576a96 96 0 11-192 0 96 96 0 11-192 0 96 96 0 11-192 0 96 96 0 11-192 0c0-8.384 1.408-16.384 3.392-24.192L192 128h640l60.544 423.808z"
}, null, -1);
const _hoisted_3$1D = [
  _hoisted_2$1Q
];
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2d, _hoisted_3$1D);
}
var shop = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$S]]);
const _sfc_main$R = defineComponent({
  name: "ShoppingBag"
});
const _hoisted_1$2c = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1P = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 320v96a32 32 0 01-32 32h-32V320H384v128h-32a32 32 0 01-32-32v-96H192v576h640V320H704zm-384-64a192 192 0 11384 0h160a32 32 0 0132 32v640a32 32 0 01-32 32H160a32 32 0 01-32-32V288a32 32 0 0132-32h160zm64 0h256a128 128 0 10-256 0z"
}, null, -1);
const _hoisted_3$1C = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 704h640v64H192z"
}, null, -1);
const _hoisted_4$K = [
  _hoisted_2$1P,
  _hoisted_3$1C
];
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2c, _hoisted_4$K);
}
var shoppingBag = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$R]]);
const _sfc_main$Q = defineComponent({
  name: "ShoppingCartFull"
});
const _hoisted_1$2b = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M432 928a48 48 0 110-96 48 48 0 010 96zm320 0a48 48 0 110-96 48 48 0 010 96zM96 128a32 32 0 010-64h160a32 32 0 0131.36 25.728L320.64 256H928a32 32 0 0131.296 38.72l-96 448A32 32 0 01832 768H384a32 32 0 01-31.36-25.728L229.76 128H96zm314.24 576h395.904l82.304-384H333.44l76.8 384z"
}, null, -1);
const _hoisted_3$1B = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M699.648 256L608 145.984 516.352 256h183.296zm-140.8-151.04a64 64 0 0198.304 0L836.352 320H379.648l179.2-215.04z"
}, null, -1);
const _hoisted_4$J = [
  _hoisted_2$1O,
  _hoisted_3$1B
];
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2b, _hoisted_4$J);
}
var shoppingCartFull = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$Q]]);
const _sfc_main$P = defineComponent({
  name: "ShoppingCart"
});
const _hoisted_1$2a = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1N = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M432 928a48 48 0 110-96 48 48 0 010 96zm320 0a48 48 0 110-96 48 48 0 010 96zM96 128a32 32 0 010-64h160a32 32 0 0131.36 25.728L320.64 256H928a32 32 0 0131.296 38.72l-96 448A32 32 0 01832 768H384a32 32 0 01-31.36-25.728L229.76 128H96zm314.24 576h395.904l82.304-384H333.44l76.8 384z"
}, null, -1);
const _hoisted_3$1A = [
  _hoisted_2$1N
];
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2a, _hoisted_3$1A);
}
var shoppingCart = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$P]]);
const _sfc_main$O = defineComponent({
  name: "Smoking"
});
const _hoisted_1$29 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1M = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 576v128h640V576H256zm-32-64h704a32 32 0 0132 32v192a32 32 0 01-32 32H224a32 32 0 01-32-32V544a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$1z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 576h64v128h-64zM256 64h64v320h-64zM128 192h64v192h-64zM64 512h64v256H64z"
}, null, -1);
const _hoisted_4$I = [
  _hoisted_2$1M,
  _hoisted_3$1z
];
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$29, _hoisted_4$I);
}
var smoking = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$O]]);
const _sfc_main$N = defineComponent({
  name: "Soccer"
});
const _hoisted_1$28 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1L = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M418.496 871.04L152.256 604.8c-16.512 94.016-2.368 178.624 42.944 224 44.928 44.928 129.344 58.752 223.296 42.24zm72.32-18.176a573.056 573.056 0 00224.832-137.216 573.12 573.12 0 00137.216-224.832L533.888 171.84a578.56 578.56 0 00-227.52 138.496A567.68 567.68 0 00170.432 532.48l320.384 320.384zM871.04 418.496c16.512-93.952 2.688-178.368-42.24-223.296-44.544-44.544-128.704-58.048-222.592-41.536L871.04 418.496zM149.952 874.048c-112.96-112.96-88.832-408.96 111.168-608.96C461.056 65.152 760.96 36.928 874.048 149.952c113.024 113.024 86.784 411.008-113.152 610.944-199.936 199.936-497.92 226.112-610.944 113.152zm452.544-497.792l22.656-22.656a32 32 0 0145.248 45.248l-22.656 22.656 45.248 45.248A32 32 0 11647.744 512l-45.248-45.248L557.248 512l45.248 45.248a32 32 0 11-45.248 45.248L512 557.248l-45.248 45.248L512 647.744a32 32 0 11-45.248 45.248l-45.248-45.248-22.656 22.656a32 32 0 11-45.248-45.248l22.656-22.656-45.248-45.248A32 32 0 11376.256 512l45.248 45.248L466.752 512l-45.248-45.248a32 32 0 1145.248-45.248L512 466.752l45.248-45.248L512 376.256a32 32 0 0145.248-45.248l45.248 45.248z"
}, null, -1);
const _hoisted_3$1y = [
  _hoisted_2$1L
];
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$28, _hoisted_3$1y);
}
var soccer = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$N]]);
const _sfc_main$M = defineComponent({
  name: "SoldOut"
});
const _hoisted_1$27 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1K = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 288h131.072a32 32 0 0131.808 28.8L886.4 512h-64.384l-16-160H704v96a32 32 0 11-64 0v-96H384v96a32 32 0 01-64 0v-96H217.92l-51.2 512H512v64H131.328a32 32 0 01-31.808-35.2l57.6-576a32 32 0 0131.808-28.8H320v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4zm-64 0v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4h256zm201.408 476.16a32 32 0 1145.248 45.184l-128 128a32 32 0 01-45.248 0l-128-128a32 32 0 1145.248-45.248L704 837.504V608a32 32 0 1164 0v229.504l73.408-73.408z"
}, null, -1);
const _hoisted_3$1x = [
  _hoisted_2$1K
];
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$27, _hoisted_3$1x);
}
var soldOut = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$M]]);
const _sfc_main$L = defineComponent({
  name: "SortDown"
});
const _hoisted_1$26 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1J = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M576 96v709.568L333.312 562.816A32 32 0 10288 608l297.408 297.344A32 32 0 00640 882.688V96a32 32 0 00-64 0z"
}, null, -1);
const _hoisted_3$1w = [
  _hoisted_2$1J
];
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$26, _hoisted_3$1w);
}
var sortDown = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$L]]);
const _sfc_main$K = defineComponent({
  name: "SortUp"
});
const _hoisted_1$25 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1I = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 141.248V928a32 32 0 1064 0V218.56l242.688 242.688A32 32 0 10736 416L438.592 118.656A32 32 0 00384 141.248z"
}, null, -1);
const _hoisted_3$1v = [
  _hoisted_2$1I
];
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$25, _hoisted_3$1v);
}
var sortUp = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$K]]);
const _sfc_main$J = defineComponent({
  name: "Sort"
});
const _hoisted_1$24 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1H = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 96a32 32 0 0164 0v786.752a32 32 0 01-54.592 22.656L95.936 608a32 32 0 010-45.312h.128a32 32 0 0145.184 0L384 805.632V96zm192 45.248a32 32 0 0154.592-22.592L928.064 416a32 32 0 010 45.312h-.128a32 32 0 01-45.184 0L640 218.496V928a32 32 0 11-64 0V141.248z"
}, null, -1);
const _hoisted_3$1u = [
  _hoisted_2$1H
];
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$24, _hoisted_3$1u);
}
var sort = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$J]]);
const _sfc_main$I = defineComponent({
  name: "Stamp"
});
const _hoisted_1$23 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1G = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M624 475.968V640h144a128 128 0 01128 128H128a128 128 0 01128-128h144V475.968a192 192 0 11224 0zM128 896v-64h768v64H128z"
}, null, -1);
const _hoisted_3$1t = [
  _hoisted_2$1G
];
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$23, _hoisted_3$1t);
}
var stamp = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$I]]);
const _sfc_main$H = defineComponent({
  name: "StarFilled"
});
const _hoisted_1$22 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1F = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M283.84 867.84L512 747.776l228.16 119.936a6.4 6.4 0 009.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 00-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 00-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 00-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 009.28 6.72z"
}, null, -1);
const _hoisted_3$1s = [
  _hoisted_2$1F
];
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$22, _hoisted_3$1s);
}
var starFilled = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$H]]);
const _sfc_main$G = defineComponent({
  name: "Star"
});
const _hoisted_1$21 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1E = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 747.84l228.16 119.936a6.4 6.4 0 009.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 00-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 00-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 00-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 009.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 01-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 01128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 01126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0139.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 01-102.144 74.24L512 820.096l-198.4 104.32z"
}, null, -1);
const _hoisted_3$1r = [
  _hoisted_2$1E
];
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$21, _hoisted_3$1r);
}
var star = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$G]]);
const _sfc_main$F = defineComponent({
  name: "Stopwatch"
});
const _hoisted_1$20 = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1D = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3$1q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M672 234.88c-39.168 174.464-80 298.624-122.688 372.48-64 110.848-202.624 30.848-138.624-80C453.376 453.44 540.48 355.968 672 234.816z"
}, null, -1);
const _hoisted_4$H = [
  _hoisted_2$1D,
  _hoisted_3$1q
];
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$20, _hoisted_4$H);
}
var stopwatch = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$F]]);
const _sfc_main$E = defineComponent({
  name: "SuccessFilled"
});
const _hoisted_1$1$ = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1C = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm-55.808 536.384l-99.52-99.584a38.4 38.4 0 10-54.336 54.336l126.72 126.72a38.272 38.272 0 0054.336 0l262.4-262.464a38.4 38.4 0 10-54.272-54.336L456.192 600.384z"
}, null, -1);
const _hoisted_3$1p = [
  _hoisted_2$1C
];
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1$, _hoisted_3$1p);
}
var successFilled = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$E]]);
const _sfc_main$D = defineComponent({
  name: "Sugar"
});
const _hoisted_1$1_ = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1B = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M801.728 349.184l4.48 4.48a128 128 0 010 180.992L534.656 806.144a128 128 0 01-181.056 0l-4.48-4.48-19.392 109.696a64 64 0 01-108.288 34.176L78.464 802.56a64 64 0 0134.176-108.288l109.76-19.328-4.544-4.544a128 128 0 010-181.056l271.488-271.488a128 128 0 01181.056 0l4.48 4.48 19.392-109.504a64 64 0 01108.352-34.048l142.592 143.04a64 64 0 01-34.24 108.16l-109.248 19.2zm-548.8 198.72h447.168v2.24l60.8-60.8a63.808 63.808 0 0018.752-44.416h-426.88l-89.664 89.728a64.064 64.064 0 00-10.24 13.248zm0 64c2.752 4.736 6.144 9.152 10.176 13.248l135.744 135.744a64 64 0 0090.496 0L638.4 611.904H252.928zm490.048-230.976L625.152 263.104a64 64 0 00-90.496 0L416.768 380.928h326.208zM123.712 757.312l142.976 142.976 24.32-137.6a25.6 25.6 0 00-29.696-29.632l-137.6 24.256zm633.6-633.344l-24.32 137.472a25.6 25.6 0 0029.632 29.632l137.28-24.064-142.656-143.04z"
}, null, -1);
const _hoisted_3$1o = [
  _hoisted_2$1B
];
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1_, _hoisted_3$1o);
}
var sugar = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$D]]);
const _sfc_main$C = defineComponent({
  name: "Suitcase"
});
const _hoisted_1$1Z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1A = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 384h768v-64a64 64 0 00-64-64H192a64 64 0 00-64 64v64zm0 64v320a64 64 0 0064 64h640a64 64 0 0064-64V448H128zm64-256h640a128 128 0 01128 128v448a128 128 0 01-128 128H192A128 128 0 0164 768V320a128 128 0 01128-128z"
}, null, -1);
const _hoisted_3$1n = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 128v64h256v-64H384zm0-64h256a64 64 0 0164 64v64a64 64 0 01-64 64H384a64 64 0 01-64-64v-64a64 64 0 0164-64z"
}, null, -1);
const _hoisted_4$G = [
  _hoisted_2$1A,
  _hoisted_3$1n
];
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1Z, _hoisted_4$G);
}
var suitcase = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$C]]);
const _sfc_main$B = defineComponent({
  name: "Sunny"
});
const _hoisted_1$1Y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1z = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 704a192 192 0 100-384 192 192 0 000 384zm0 64a256 256 0 110-512 256 256 0 010 512zM512 64a32 32 0 0132 32v64a32 32 0 01-64 0V96a32 32 0 0132-32zm0 768a32 32 0 0132 32v64a32 32 0 11-64 0v-64a32 32 0 0132-32zM195.2 195.2a32 32 0 0145.248 0l45.248 45.248a32 32 0 11-45.248 45.248L195.2 240.448a32 32 0 010-45.248zm543.104 543.104a32 32 0 0145.248 0l45.248 45.248a32 32 0 01-45.248 45.248l-45.248-45.248a32 32 0 010-45.248zM64 512a32 32 0 0132-32h64a32 32 0 010 64H96a32 32 0 01-32-32zm768 0a32 32 0 0132-32h64a32 32 0 110 64h-64a32 32 0 01-32-32zM195.2 828.8a32 32 0 010-45.248l45.248-45.248a32 32 0 0145.248 45.248L240.448 828.8a32 32 0 01-45.248 0zm543.104-543.104a32 32 0 010-45.248l45.248-45.248a32 32 0 0145.248 45.248l-45.248 45.248a32 32 0 01-45.248 0z"
}, null, -1);
const _hoisted_3$1m = [
  _hoisted_2$1z
];
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1Y, _hoisted_3$1m);
}
var sunny = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$B]]);
const _sfc_main$A = defineComponent({
  name: "Sunrise"
});
const _hoisted_1$1X = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M32 768h960a32 32 0 110 64H32a32 32 0 110-64zM161.408 672a352 352 0 01701.184 0h-64.32a288 288 0 00-572.544 0h-64.32zM512 128a32 32 0 0132 32v96a32 32 0 01-64 0v-96a32 32 0 0132-32zm407.296 168.704a32 32 0 010 45.248l-67.84 67.84a32 32 0 11-45.248-45.248l67.84-67.84a32 32 0 0145.248 0zm-814.592 0a32 32 0 0145.248 0l67.84 67.84a32 32 0 11-45.248 45.248l-67.84-67.84a32 32 0 010-45.248z"
}, null, -1);
const _hoisted_3$1l = [
  _hoisted_2$1y
];
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1X, _hoisted_3$1l);
}
var sunrise = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$A]]);
const _sfc_main$z = defineComponent({
  name: "Sunset"
});
const _hoisted_1$1W = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1x = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M82.56 640a448 448 0 11858.88 0h-67.2a384 384 0 10-724.288 0H82.56zM32 704h960q32 0 32 32t-32 32H32q-32 0-32-32t32-32zM288 832h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_3$1k = [
  _hoisted_2$1x
];
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1W, _hoisted_3$1k);
}
var sunset = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$z]]);
const _sfc_main$y = defineComponent({
  name: "SwitchButton"
});
const _hoisted_1$1V = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1w = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M352 159.872V230.4a352 352 0 10320 0v-70.528A416.128 416.128 0 01512 960a416 416 0 01-160-800.128z"
}, null, -1);
const _hoisted_3$1j = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64q32 0 32 32v320q0 32-32 32t-32-32V96q0-32 32-32z"
}, null, -1);
const _hoisted_4$F = [
  _hoisted_2$1w,
  _hoisted_3$1j
];
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1V, _hoisted_4$F);
}
var switchButton = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$y]]);
const _sfc_main$x = defineComponent({
  name: "Switch"
});
const _hoisted_1$1U = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1v = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M118.656 438.656a32 32 0 010-45.248L416 96l4.48-3.776A32 32 0 01461.248 96l3.712 4.48a32.064 32.064 0 01-3.712 40.832L218.56 384H928a32 32 0 110 64H141.248a32 32 0 01-22.592-9.344zM64 608a32 32 0 0132-32h786.752a32 32 0 0122.656 54.592L608 928l-4.48 3.776a32.064 32.064 0 01-40.832-49.024L805.632 640H96a32 32 0 01-32-32z"
}, null, -1);
const _hoisted_3$1i = [
  _hoisted_2$1v
];
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1U, _hoisted_3$1i);
}
var _switch$3 = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$x]]);
const _sfc_main$w = defineComponent({
  name: "TakeawayBox"
});
const _hoisted_1$1T = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1u = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M832 384H192v448h640V384zM96 320h832V128H96v192zm800 64v480a32 32 0 01-32 32H160a32 32 0 01-32-32V384H64a32 32 0 01-32-32V96a32 32 0 0132-32h896a32 32 0 0132 32v256a32 32 0 01-32 32h-64zM416 512h192a32 32 0 010 64H416a32 32 0 010-64z"
}, null, -1);
const _hoisted_3$1h = [
  _hoisted_2$1u
];
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1T, _hoisted_3$1h);
}
var takeawayBox = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$w]]);
const _sfc_main$v = defineComponent({
  name: "Ticket"
});
const _hoisted_1$1S = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1t = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 832H64V640a128 128 0 100-256V192h576v160h64V192h256v192a128 128 0 100 256v192H704V672h-64v160zm0-416v192h64V416h-64z"
}, null, -1);
const _hoisted_3$1g = [
  _hoisted_2$1t
];
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1S, _hoisted_3$1g);
}
var ticket = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v]]);
const _sfc_main$u = defineComponent({
  name: "Tickets"
});
const _hoisted_1$1R = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1s = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M192 128v768h640V128H192zm-32-64h704a32 32 0 0132 32v832a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32zm160 448h384v64H320v-64zm0-192h192v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1);
const _hoisted_3$1f = [
  _hoisted_2$1s
];
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1R, _hoisted_3$1f);
}
var tickets = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u]]);
const _sfc_main$t = defineComponent({
  name: "Timer"
});
const _hoisted_1$1Q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1r = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a320 320 0 100-640 320 320 0 000 640zm0 64a384 384 0 110-768 384 384 0 010 768z"
}, null, -1);
const _hoisted_3$1e = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 320a32 32 0 0132 32l-.512 224a32 32 0 11-64 0L480 352a32 32 0 0132-32z"
}, null, -1);
const _hoisted_4$E = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M448 576a64 64 0 10128 0 64 64 0 10-128 0zM544 128v128h-64V128h-96a32 32 0 010-64h256a32 32 0 110 64h-96z"
}, null, -1);
const _hoisted_5$r = [
  _hoisted_2$1r,
  _hoisted_3$1e,
  _hoisted_4$E
];
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1Q, _hoisted_5$r);
}
var timer = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t]]);
const _sfc_main$s = defineComponent({
  name: "ToiletPaper"
});
const _hoisted_1$1P = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M595.2 128H320a192 192 0 00-192 192v576h384V352c0-90.496 32.448-171.2 83.2-224zM736 64c123.712 0 224 128.96 224 288S859.712 640 736 640H576v320H64V320A256 256 0 01320 64h416zM576 352v224h160c84.352 0 160-97.28 160-224s-75.648-224-160-224-160 97.28-160 224z"
}, null, -1);
const _hoisted_3$1d = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M736 448c-35.328 0-64-43.008-64-96s28.672-96 64-96 64 43.008 64 96-28.672 96-64 96z"
}, null, -1);
const _hoisted_4$D = [
  _hoisted_2$1q,
  _hoisted_3$1d
];
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1P, _hoisted_4$D);
}
var toiletPaper = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s]]);
const _sfc_main$r = defineComponent({
  name: "Tools"
});
const _hoisted_1$1O = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1p = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M764.416 254.72a351.68 351.68 0 0186.336 149.184H960v192.064H850.752a351.68 351.68 0 01-86.336 149.312l54.72 94.72-166.272 96-54.592-94.72a352.64 352.64 0 01-172.48 0L371.136 936l-166.272-96 54.72-94.72a351.68 351.68 0 01-86.336-149.312H64v-192h109.248a351.68 351.68 0 0186.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 01172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 10-384 0 192 192 0 00384 0z"
}, null, -1);
const _hoisted_3$1c = [
  _hoisted_2$1p
];
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1O, _hoisted_3$1c);
}
var tools = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r]]);
const _sfc_main$q = defineComponent({
  name: "TopLeft"
});
const _hoisted_1$1N = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1o = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 256h416a32 32 0 100-64H224a32 32 0 00-32 32v448a32 32 0 0064 0V256z"
}, null, -1);
const _hoisted_3$1b = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M246.656 201.344a32 32 0 00-45.312 45.312l544 544a32 32 0 0045.312-45.312l-544-544z"
}, null, -1);
const _hoisted_4$C = [
  _hoisted_2$1o,
  _hoisted_3$1b
];
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1N, _hoisted_4$C);
}
var topLeft = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q]]);
const _sfc_main$p = defineComponent({
  name: "TopRight"
});
const _hoisted_1$1M = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1n = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M768 256H353.6a32 32 0 110-64H800a32 32 0 0132 32v448a32 32 0 01-64 0V256z"
}, null, -1);
const _hoisted_3$1a = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M777.344 201.344a32 32 0 0145.312 45.312l-544 544a32 32 0 01-45.312-45.312l544-544z"
}, null, -1);
const _hoisted_4$B = [
  _hoisted_2$1n,
  _hoisted_3$1a
];
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1M, _hoisted_4$B);
}
var topRight = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p]]);
const _sfc_main$o = defineComponent({
  name: "Top"
});
const _hoisted_1$1L = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1m = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M572.235 205.282v600.365a30.118 30.118 0 11-60.235 0V205.282L292.382 438.633a28.913 28.913 0 01-42.646 0 33.43 33.43 0 010-45.236l271.058-288.045a28.913 28.913 0 0142.647 0L834.5 393.397a33.43 33.43 0 010 45.176 28.913 28.913 0 01-42.647 0l-219.618-233.23z"
}, null, -1);
const _hoisted_3$19 = [
  _hoisted_2$1m
];
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1L, _hoisted_3$19);
}
var top = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
const _sfc_main$n = defineComponent({
  name: "TrendCharts"
});
const _hoisted_1$1K = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1l = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 896V128h768v768H128zm291.712-327.296l128 102.4 180.16-201.792-47.744-42.624-139.84 156.608-128-102.4-180.16 201.792 47.744 42.624 139.84-156.608zM816 352a48 48 0 10-96 0 48 48 0 0096 0z"
}, null, -1);
const _hoisted_3$18 = [
  _hoisted_2$1l
];
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1K, _hoisted_3$18);
}
var trendCharts = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
const _sfc_main$m = defineComponent({
  name: "Trophy"
});
const _hoisted_1$1J = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1k = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 896V702.08A256.256 256.256 0 01264.064 512h-32.64a96 96 0 01-91.968-68.416L93.632 290.88a76.8 76.8 0 0173.6-98.88H256V96a32 32 0 0132-32h448a32 32 0 0132 32v96h88.768a76.8 76.8 0 0173.6 98.88L884.48 443.52A96 96 0 01792.576 512h-32.64A256.256 256.256 0 01544 702.08V896h128a32 32 0 110 64H352a32 32 0 110-64h128zm224-448V128H320v320a192 192 0 10384 0zm64 0h24.576a32 32 0 0030.656-22.784l45.824-152.768A12.8 12.8 0 00856.768 256H768v192zm-512 0V256h-88.768a12.8 12.8 0 00-12.288 16.448l45.824 152.768A32 32 0 00231.424 448H256z"
}, null, -1);
const _hoisted_3$17 = [
  _hoisted_2$1k
];
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1J, _hoisted_3$17);
}
var trophy = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
const _sfc_main$l = defineComponent({
  name: "TurnOff"
});
const _hoisted_1$1I = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1j = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M329.956 257.138a254.862 254.862 0 000 509.724h364.088a254.862 254.862 0 000-509.724H329.956zm0-72.818h364.088a327.68 327.68 0 110 655.36H329.956a327.68 327.68 0 110-655.36z"
}, null, -1);
const _hoisted_3$16 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M329.956 621.227a109.227 109.227 0 100-218.454 109.227 109.227 0 000 218.454zm0 72.817a182.044 182.044 0 110-364.088 182.044 182.044 0 010 364.088z"
}, null, -1);
const _hoisted_4$A = [
  _hoisted_2$1j,
  _hoisted_3$16
];
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1I, _hoisted_4$A);
}
var turnOff = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
const _sfc_main$k = defineComponent({
  name: "Umbrella"
});
const _hoisted_1$1H = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1i = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M320 768a32 32 0 1164 0 64 64 0 00128 0V512H64a448 448 0 11896 0H576v256a128 128 0 11-256 0zm570.688-320a384.128 384.128 0 00-757.376 0h757.376z"
}, null, -1);
const _hoisted_3$15 = [
  _hoisted_2$1i
];
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1H, _hoisted_3$15);
}
var umbrella = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
const _sfc_main$j = defineComponent({
  name: "Unlock"
});
const _hoisted_1$1G = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1h = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M224 448a32 32 0 00-32 32v384a32 32 0 0032 32h576a32 32 0 0032-32V480a32 32 0 00-32-32H224zm0-64h576a96 96 0 0196 96v384a96 96 0 01-96 96H224a96 96 0 01-96-96V480a96 96 0 0196-96z"
}, null, -1);
const _hoisted_3$14 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 544a32 32 0 0132 32v192a32 32 0 11-64 0V576a32 32 0 0132-32zM690.304 248.704A192.064 192.064 0 00320 320v64h352l96 38.4V448H256V320a256 256 0 01493.76-95.104l-59.456 23.808z"
}, null, -1);
const _hoisted_4$z = [
  _hoisted_2$1h,
  _hoisted_3$14
];
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1G, _hoisted_4$z);
}
var unlock = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
const _sfc_main$i = defineComponent({
  name: "UploadFilled"
});
const _hoisted_1$1F = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1g = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M544 864V672h128L512 480 352 672h128v192H320v-1.6c-5.376.32-10.496 1.6-16 1.6A240 240 0 0164 624c0-123.136 93.12-223.488 212.608-237.248A239.808 239.808 0 01512 192a239.872 239.872 0 01235.456 194.752c119.488 13.76 212.48 114.112 212.48 237.248a240 240 0 01-240 240c-5.376 0-10.56-1.28-16-1.6v1.6H544z"
}, null, -1);
const _hoisted_3$13 = [
  _hoisted_2$1g
];
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1F, _hoisted_3$13);
}
var uploadFilled = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
const _sfc_main$h = defineComponent({
  name: "Upload"
});
const _hoisted_1$1E = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1f = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 832h704a32 32 0 110 64H160a32 32 0 110-64zm384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248L544 253.696z"
}, null, -1);
const _hoisted_3$12 = [
  _hoisted_2$1f
];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1E, _hoisted_3$12);
}
var upload$2 = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
const _sfc_main$g = defineComponent({
  name: "UserFilled"
});
const _hoisted_1$1D = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1e = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 320a224 224 0 10448 0 224 224 0 10-448 0zm544 608H160a32 32 0 01-32-32v-96a160 160 0 01160-160h448a160 160 0 01160 160v96a32 32 0 01-32 32z"
}, null, -1);
const _hoisted_3$11 = [
  _hoisted_2$1e
];
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1D, _hoisted_3$11);
}
var userFilled = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
const _sfc_main$f = defineComponent({
  name: "User"
});
const _hoisted_1$1C = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1d = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 512a192 192 0 100-384 192 192 0 000 384zm0 64a256 256 0 110-512 256 256 0 010 512zm320 320v-96a96 96 0 00-96-96H288a96 96 0 00-96 96v96a32 32 0 11-64 0v-96a160 160 0 01160-160h448a160 160 0 01160 160v96a32 32 0 11-64 0z"
}, null, -1);
const _hoisted_3$10 = [
  _hoisted_2$1d
];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1C, _hoisted_3$10);
}
var user = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
const _sfc_main$e = defineComponent({
  name: "Van"
});
const _hoisted_1$1B = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1c = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128.896 736H96a32 32 0 01-32-32V224a32 32 0 0132-32h576a32 32 0 0132 32v96h164.544a32 32 0 0131.616 27.136l54.144 352A32 32 0 01922.688 736h-91.52a144 144 0 11-286.272 0H415.104a144 144 0 11-286.272 0zm23.36-64a143.872 143.872 0 01239.488 0H568.32c17.088-25.6 42.24-45.376 71.744-55.808V256H128v416h24.256zm655.488 0h77.632l-19.648-128H704v64.896A144 144 0 01807.744 672zm48.128-192l-14.72-96H704v96h151.872zM688 832a80 80 0 100-160 80 80 0 000 160zm-416 0a80 80 0 100-160 80 80 0 000 160z"
}, null, -1);
const _hoisted_3$$ = [
  _hoisted_2$1c
];
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1B, _hoisted_3$$);
}
var van = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
const _sfc_main$d = defineComponent({
  name: "VideoCameraFilled"
});
const _hoisted_1$1A = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1b = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M768 576l192-64v320l-192-64v96a32 32 0 01-32 32H96a32 32 0 01-32-32V480a32 32 0 0132-32h640a32 32 0 0132 32v96zM192 768v64h384v-64H192zm192-480a160 160 0 01320 0 160 160 0 01-320 0zm64 0a96 96 0 10192.064-.064A96 96 0 00448 288zm-320 32a128 128 0 11256.064.064A128 128 0 01128 320zm64 0a64 64 0 10128 0 64 64 0 00-128 0z"
}, null, -1);
const _hoisted_3$_ = [
  _hoisted_2$1b
];
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1A, _hoisted_3$_);
}
var videoCameraFilled = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
const _sfc_main$c = defineComponent({
  name: "VideoCamera"
});
const _hoisted_1$1z = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1a = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 768V256H128v512h576zm64-416l192-96v512l-192-96v128a32 32 0 01-32 32H96a32 32 0 01-32-32V224a32 32 0 0132-32h640a32 32 0 0132 32v128zm0 71.552v176.896l128 64V359.552l-128 64zM192 320h192v64H192v-64z"
}, null, -1);
const _hoisted_3$Z = [
  _hoisted_2$1a
];
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1z, _hoisted_3$Z);
}
var videoCamera = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
const _sfc_main$b = defineComponent({
  name: "VideoPause"
});
const _hoisted_1$1y = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$19 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm0 832a384 384 0 000-768 384 384 0 000 768zm-96-544q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32zm192 0q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32z"
}, null, -1);
const _hoisted_3$Y = [
  _hoisted_2$19
];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1y, _hoisted_3$Y);
}
var videoPause = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
const _sfc_main$a = defineComponent({
  name: "VideoPlay"
});
const _hoisted_1$1x = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$18 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm0 832a384 384 0 000-768 384 384 0 000 768zm-48-247.616L668.608 512 464 375.616v272.768zm10.624-342.656l249.472 166.336a48 48 0 010 79.872L474.624 718.272A48 48 0 01400 678.336V345.6a48 48 0 0174.624-39.936z"
}, null, -1);
const _hoisted_3$X = [
  _hoisted_2$18
];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1x, _hoisted_3$X);
}
var videoPlay = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
const _sfc_main$9 = defineComponent({
  name: "View"
});
const _hoisted_1$1w = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$17 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 110 448 224 224 0 010-448zm0 64a160.192 160.192 0 00-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
}, null, -1);
const _hoisted_3$W = [
  _hoisted_2$17
];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1w, _hoisted_3$W);
}
var view = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
const _sfc_main$8 = defineComponent({
  name: "WalletFilled"
});
const _hoisted_1$1v = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$16 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M688 512a112 112 0 100 224h208v160H128V352h768v160H688zm32 160h-32a48 48 0 010-96h32a48 48 0 010 96zm-80-544l128 160H384l256-160z"
}, null, -1);
const _hoisted_3$V = [
  _hoisted_2$16
];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1v, _hoisted_3$V);
}
var walletFilled = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
const _sfc_main$7 = defineComponent({
  name: "Wallet"
});
const _hoisted_1$1u = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$15 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 288h-64V128H128v704h384v32a32 32 0 0032 32H96a32 32 0 01-32-32V96a32 32 0 0132-32h512a32 32 0 0132 32v192z"
}, null, -1);
const _hoisted_3$U = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 320v512h768V320H128zm-32-64h832a32 32 0 0132 32v576a32 32 0 01-32 32H96a32 32 0 01-32-32V288a32 32 0 0132-32z"
}, null, -1);
const _hoisted_4$y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M704 640a64 64 0 110-128 64 64 0 010 128z"
}, null, -1);
const _hoisted_5$q = [
  _hoisted_2$15,
  _hoisted_3$U,
  _hoisted_4$y
];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1u, _hoisted_5$q);
}
var wallet = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const _sfc_main$6 = defineComponent({
  name: "WarningFilled"
});
const _hoisted_1$1t = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$14 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm0 192a58.432 58.432 0 00-58.24 63.744l23.36 256.384a35.072 35.072 0 0069.76 0l23.296-256.384A58.432 58.432 0 00512 256zm0 512a51.2 51.2 0 100-102.4 51.2 51.2 0 000 102.4z"
}, null, -1);
const _hoisted_3$T = [
  _hoisted_2$14
];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1t, _hoisted_3$T);
}
var warningFilled = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const _sfc_main$5 = defineComponent({
  name: "Warning"
});
const _hoisted_1$1s = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$13 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm0 832a384 384 0 000-768 384 384 0 000 768zm48-176a48 48 0 11-96 0 48 48 0 0196 0zm-48-464a32 32 0 0132 32v288a32 32 0 01-64 0V288a32 32 0 0132-32z"
}, null, -1);
const _hoisted_3$S = [
  _hoisted_2$13
];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1s, _hoisted_3$S);
}
var warning$1 = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const _sfc_main$4 = defineComponent({
  name: "Watch"
});
const _hoisted_1$1r = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$12 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 768a256 256 0 100-512 256 256 0 000 512zm0 64a320 320 0 110-640 320 320 0 010 640z"
}, null, -1);
const _hoisted_3$R = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 352a32 32 0 0132 32v160a32 32 0 01-64 0V384a32 32 0 0132-32z"
}, null, -1);
const _hoisted_4$x = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 512h128q32 0 32 32t-32 32H480q-32 0-32-32t32-32zM608 256V128H416v128h-64V64h320v192h-64zM416 768v128h192V768h64v192H352V768h64z"
}, null, -1);
const _hoisted_5$p = [
  _hoisted_2$12,
  _hoisted_3$R,
  _hoisted_4$x
];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1r, _hoisted_5$p);
}
var watch = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const _sfc_main$3 = defineComponent({
  name: "Watermelon"
});
const _hoisted_1$1q = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$11 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M683.072 600.32l-43.648 162.816-61.824-16.512 53.248-198.528L576 493.248l-158.4 158.4-45.248-45.248 158.4-158.4-55.616-55.616-198.528 53.248-16.512-61.824 162.816-43.648L282.752 200A384 384 0 00824 741.248L683.072 600.32zm231.552 141.056a448 448 0 11-632-632l632 632z"
}, null, -1);
const _hoisted_3$Q = [
  _hoisted_2$11
];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1q, _hoisted_3$Q);
}
var watermelon = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const _sfc_main$2 = defineComponent({
  name: "WindPower"
});
const _hoisted_1$1p = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$10 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 64q32 0 32 32v832q0 32-32 32t-32-32V96q0-32 32-32zM576 418.624l128-11.584V168.96l-128-11.52v261.12zm-64 5.824V151.552L320 134.08V160h-64V64l616.704 56.064A96 96 0 01960 215.68v144.64a96 96 0 01-87.296 95.616L256 512V224h64v217.92l192-17.472zm256-23.232l98.88-8.96A32 32 0 00896 360.32V215.68a32 32 0 00-29.12-31.872l-98.88-8.96v226.368z"
}, null, -1);
const _hoisted_3$P = [
  _hoisted_2$10
];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1p, _hoisted_3$P);
}
var windPower = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1 = defineComponent({
  name: "ZoomIn"
});
const _hoisted_1$1o = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$$ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M795.904 750.72l124.992 124.928a32 32 0 01-45.248 45.248L750.656 795.904a416 416 0 1145.248-45.248zM480 832a352 352 0 100-704 352 352 0 000 704zm-32-384v-96a32 32 0 0164 0v96h96a32 32 0 010 64h-96v96a32 32 0 01-64 0v-96h-96a32 32 0 010-64h96z"
}, null, -1);
const _hoisted_3$O = [
  _hoisted_2$$
];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1o, _hoisted_3$O);
}
var zoomIn = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const _sfc_main = defineComponent({
  name: "ZoomOut"
});
const _hoisted_1$1n = {
  class: "icon",
  width: "200",
  height: "200",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$_ = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M795.904 750.72l124.992 124.928a32 32 0 01-45.248 45.248L750.656 795.904a416 416 0 1145.248-45.248zM480 832a352 352 0 100-704 352 352 0 000 704zM352 448h256a32 32 0 010 64H352a32 32 0 010-64z"
}, null, -1);
const _hoisted_3$N = [
  _hoisted_2$_
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1n, _hoisted_3$N);
}
var zoomOut = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
var es = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  AddLocation: addLocation,
  Aim: aim,
  AlarmClock: alarmClock,
  Apple: apple,
  ArrowDownBold: arrowDownBold,
  ArrowDown: arrowDown,
  ArrowLeftBold: arrowLeftBold,
  ArrowLeft: arrowLeft,
  ArrowRightBold: arrowRightBold,
  ArrowRight: arrowRight,
  ArrowUpBold: arrowUpBold,
  ArrowUp: arrowUp,
  Avatar: avatar$3,
  Back: back,
  Baseball: baseball,
  Basketball: basketball,
  BellFilled: bellFilled,
  Bell: bell,
  Bicycle: bicycle,
  BottomLeft: bottomLeft,
  BottomRight: bottomRight,
  Bottom: bottom,
  Bowl: bowl,
  Box: box,
  Briefcase: briefcase,
  BrushFilled: brushFilled,
  Brush: brush,
  Burger: burger,
  Calendar: calendar$3,
  CameraFilled: cameraFilled,
  Camera: camera,
  CaretBottom: caretBottom,
  CaretLeft: caretLeft,
  CaretRight: caretRight,
  CaretTop: caretTop,
  Cellphone: cellphone,
  ChatDotRound: chatDotRound,
  ChatDotSquare: chatDotSquare,
  ChatLineRound: chatLineRound,
  ChatLineSquare: chatLineSquare,
  ChatRound: chatRound,
  ChatSquare: chatSquare,
  Check: check,
  Checked: checked,
  Cherry: cherry,
  Chicken: chicken,
  CircleCheckFilled: circleCheckFilled,
  CircleCheck: circleCheck,
  CircleCloseFilled: circleCloseFilled,
  CircleClose: circleClose,
  CirclePlusFilled: circlePlusFilled,
  CirclePlus: circlePlus,
  Clock: clock,
  CloseBold: closeBold,
  Close: close,
  Cloudy: cloudy,
  CoffeeCup: coffeeCup,
  Coffee: coffee,
  Coin: coin,
  ColdDrink: coldDrink,
  CollectionTag: collectionTag,
  Collection: collection,
  Comment: comment,
  Compass: compass,
  Connection: connection,
  Coordinate: coordinate,
  CopyDocument: copyDocument,
  Cpu: cpu,
  CreditCard: creditCard,
  Crop: crop,
  DArrowLeft: dArrowLeft,
  DArrowRight: dArrowRight,
  DCaret: dCaret,
  DataAnalysis: dataAnalysis,
  DataBoard: dataBoard,
  DataLine: dataLine,
  DeleteFilled: deleteFilled,
  DeleteLocation: deleteLocation,
  Delete: _delete,
  Dessert: dessert,
  Discount: discount,
  DishDot: dishDot,
  Dish: dish,
  DocumentAdd: documentAdd,
  DocumentChecked: documentChecked,
  DocumentCopy: documentCopy,
  DocumentDelete: documentDelete,
  DocumentRemove: documentRemove,
  Document: document$1,
  Download: download,
  Drizzling: drizzling,
  Edit: edit,
  ElemeFilled: elemeFilled,
  Eleme: eleme,
  Expand: expand$1,
  Failed: failed,
  Female: female,
  Files: files,
  Film: film,
  Filter: filter,
  Finished: finished,
  FirstAidKit: firstAidKit,
  Flag: flag,
  Fold: fold,
  FolderAdd: folderAdd,
  FolderChecked: folderChecked,
  FolderDelete: folderDelete,
  FolderOpened: folderOpened,
  FolderRemove: folderRemove,
  Folder: folder,
  Food: food,
  Football: football,
  ForkSpoon: forkSpoon,
  Fries: fries,
  FullScreen: fullScreen,
  GobletFull: gobletFull,
  GobletSquareFull: gobletSquareFull,
  GobletSquare: gobletSquare,
  Goblet: goblet,
  GoodsFilled: goodsFilled,
  Goods: goods,
  Grape: grape,
  Grid: grid,
  Guide: guide,
  Headset: headset,
  HelpFilled: helpFilled,
  Help: help,
  Histogram: histogram,
  HomeFilled: homeFilled,
  HotWater: hotWater,
  House: house,
  IceCreamRound: iceCreamRound,
  IceCreamSquare: iceCreamSquare,
  IceCream: iceCream,
  IceDrink: iceDrink,
  IceTea: iceTea,
  InfoFilled: infoFilled,
  Iphone: iphone,
  Key: key,
  KnifeFork: knifeFork,
  Lightning: lightning,
  Link: link$3,
  List: list,
  Loading: loading$3,
  LocationFilled: locationFilled,
  LocationInformation: locationInformation,
  Location: location$1,
  Lock: lock,
  Lollipop: lollipop,
  MagicStick: magicStick,
  Magnet: magnet,
  Male: male,
  Management: management,
  MapLocation: mapLocation,
  Medal: medal,
  Menu: menu$4,
  MessageBox: messageBox$2,
  Message: message$3,
  Mic: mic,
  Microphone: microphone,
  MilkTea: milkTea,
  Minus: minus,
  Money: money,
  Monitor: monitor,
  MoonNight: moonNight,
  Moon: moon,
  MoreFilled: moreFilled,
  More: more,
  MostlyCloudy: mostlyCloudy,
  Mouse: mouse,
  Mug: mug,
  MuteNotification: muteNotification,
  Mute: mute,
  NoSmoking: noSmoking,
  Notebook: notebook,
  Notification: notification$3,
  Odometer: odometer,
  OfficeBuilding: officeBuilding,
  Open: open,
  Operation: operation,
  Opportunity: opportunity,
  Orange: orange,
  Paperclip: paperclip,
  PartlyCloudy: partlyCloudy,
  Pear: pear,
  PhoneFilled: phoneFilled,
  Phone: phone,
  PictureFilled: pictureFilled,
  PictureRounded: pictureRounded,
  Picture: picture,
  PieChart: pieChart,
  Place: place,
  Platform: platform,
  Plus: plus,
  Pointer: pointer,
  Position: position,
  Postcard: postcard,
  Pouring: pouring,
  Present: present,
  PriceTag: priceTag,
  Printer: printer,
  Promotion: promotion,
  QuestionFilled: questionFilled,
  Rank: rank,
  ReadingLamp: readingLamp,
  Reading: reading,
  RefreshLeft: refreshLeft,
  RefreshRight: refreshRight,
  Refresh: refresh,
  Refrigerator: refrigerator,
  RemoveFilled: removeFilled,
  Remove: remove,
  Right: right,
  ScaleToOriginal: scaleToOriginal,
  School: school,
  Scissor: scissor,
  Search: search,
  Select: select$3,
  Sell: sell,
  SemiSelect: semiSelect,
  Service: service$2,
  SetUp: setUp,
  Setting: setting,
  Share: share,
  Ship: ship,
  Shop: shop,
  ShoppingBag: shoppingBag,
  ShoppingCartFull: shoppingCartFull,
  ShoppingCart: shoppingCart,
  Smoking: smoking,
  Soccer: soccer,
  SoldOut: soldOut,
  SortDown: sortDown,
  SortUp: sortUp,
  Sort: sort,
  Stamp: stamp,
  StarFilled: starFilled,
  Star: star,
  Stopwatch: stopwatch,
  SuccessFilled: successFilled,
  Sugar: sugar,
  Suitcase: suitcase,
  Sunny: sunny,
  Sunrise: sunrise,
  Sunset: sunset,
  SwitchButton: switchButton,
  Switch: _switch$3,
  TakeawayBox: takeawayBox,
  Ticket: ticket,
  Tickets: tickets,
  Timer: timer,
  ToiletPaper: toiletPaper,
  Tools: tools,
  TopLeft: topLeft,
  TopRight: topRight,
  Top: top,
  TrendCharts: trendCharts,
  Trophy: trophy,
  TurnOff: turnOff,
  Umbrella: umbrella,
  Unlock: unlock,
  UploadFilled: uploadFilled,
  Upload: upload$2,
  UserFilled: userFilled,
  User: user,
  Van: van,
  VideoCameraFilled: videoCameraFilled,
  VideoCamera: videoCamera,
  VideoPause: videoPause,
  VideoPlay: videoPlay,
  View: view,
  WalletFilled: walletFilled,
  Wallet: wallet,
  WarningFilled: warningFilled,
  Warning: warning$1,
  Watch: watch,
  Watermelon: watermelon,
  WindPower: windPower,
  ZoomIn: zoomIn,
  ZoomOut: zoomOut
});
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(es);
Object.defineProperty(icon$2, "__esModule", { value: true });
var iconsVue$7 = require$$3;
var props$H = props$N;
const iconPropType = props$H.definePropType([String, Object]);
const CloseComponents = {
  Close: iconsVue$7.Close
};
const TypeComponents = {
  Close: iconsVue$7.Close,
  SuccessFilled: iconsVue$7.SuccessFilled,
  InfoFilled: iconsVue$7.InfoFilled,
  WarningFilled: iconsVue$7.WarningFilled,
  CircleCloseFilled: iconsVue$7.CircleCloseFilled
};
const TypeComponentsMap = {
  success: iconsVue$7.SuccessFilled,
  warning: iconsVue$7.WarningFilled,
  error: iconsVue$7.CircleCloseFilled,
  info: iconsVue$7.InfoFilled
};
const ValidateComponentsMap = {
  validating: iconsVue$7.Loading,
  success: iconsVue$7.CircleCheck,
  error: iconsVue$7.CircleClose
};
icon$2.CloseComponents = CloseComponents;
icon$2.TypeComponents = TypeComponents;
icon$2.TypeComponentsMap = TypeComponentsMap;
icon$2.ValidateComponentsMap = ValidateComponentsMap;
icon$2.iconPropType = iconPropType;
var alert$1 = {};
Object.defineProperty(alert$1, "__esModule", { value: true });
var icon$1 = icon$2;
var props$G = props$N;
const alertProps = props$G.buildProps({
  title: {
    type: String,
    default: ""
  },
  description: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: props$G.keyOf(icon$1.TypeComponentsMap),
    default: "info"
  },
  closable: {
    type: Boolean,
    default: true
  },
  closeText: {
    type: String,
    default: ""
  },
  showIcon: Boolean,
  center: Boolean,
  effect: {
    type: String,
    values: ["light", "dark"],
    default: "light"
  }
});
const alertEmits = {
  close: (evt) => evt instanceof MouseEvent
};
alert$1.alertEmits = alertEmits;
alert$1.alertProps = alertProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var icon3 = icon$2;
  var alert3 = alert$1;
  var script2 = vue2.defineComponent({
    name: "ElAlert",
    components: __spreadValues({
      ElIcon: index2.ElIcon
    }, icon3.TypeComponents),
    props: alert3.alertProps,
    emits: alert3.alertEmits,
    setup(props2, { emit, slots }) {
      const visible = vue2.ref(true);
      const typeClass = vue2.computed(() => `el-alert--${props2.type}`);
      const iconComponent = vue2.computed(() => icon3.TypeComponentsMap[props2.type] || icon3.TypeComponentsMap["info"]);
      const isBigIcon = vue2.computed(() => props2.description || slots.default ? "is-big" : "");
      const isBoldTitle = vue2.computed(() => props2.description || slots.default ? "is-bold" : "");
      const close2 = (evt) => {
        visible.value = false;
        emit("close", evt);
      };
      return {
        visible,
        typeClass,
        iconComponent,
        isBigIcon,
        isBoldTitle,
        close: close2
      };
    }
  });
  exports["default"] = script2;
})(alert_vue_vue_type_script_lang);
var alert_vue_vue_type_template_id_1755b449_lang = {};
Object.defineProperty(alert_vue_vue_type_template_id_1755b449_lang, "__esModule", { value: true });
var vue$2l = require$$0$1;
const _hoisted_1$1m = { class: "el-alert__content" };
const _hoisted_2$Z = {
  key: 1,
  class: "el-alert__description"
};
function render$1P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$2l.resolveComponent("el-icon");
  const _component_close = vue$2l.resolveComponent("close");
  return vue$2l.openBlock(), vue$2l.createBlock(vue$2l.Transition, { name: "el-alert-fade" }, {
    default: vue$2l.withCtx(() => [
      vue$2l.withDirectives(vue$2l.createElementVNode("div", {
        class: vue$2l.normalizeClass(["el-alert", [_ctx.typeClass, _ctx.center ? "is-center" : "", "is-" + _ctx.effect]]),
        role: "alert"
      }, [
        _ctx.showIcon && _ctx.iconComponent ? (vue$2l.openBlock(), vue$2l.createBlock(_component_el_icon, {
          key: 0,
          class: vue$2l.normalizeClass(["el-alert__icon", _ctx.isBigIcon])
        }, {
          default: vue$2l.withCtx(() => [
            (vue$2l.openBlock(), vue$2l.createBlock(vue$2l.resolveDynamicComponent(_ctx.iconComponent)))
          ]),
          _: 1
        }, 8, ["class"])) : vue$2l.createCommentVNode("v-if", true),
        vue$2l.createElementVNode("div", _hoisted_1$1m, [
          _ctx.title || _ctx.$slots.title ? (vue$2l.openBlock(), vue$2l.createElementBlock("span", {
            key: 0,
            class: vue$2l.normalizeClass(["el-alert__title", [_ctx.isBoldTitle]])
          }, [
            vue$2l.renderSlot(_ctx.$slots, "title", {}, () => [
              vue$2l.createTextVNode(vue$2l.toDisplayString(_ctx.title), 1)
            ])
          ], 2)) : vue$2l.createCommentVNode("v-if", true),
          _ctx.$slots.default || _ctx.description ? (vue$2l.openBlock(), vue$2l.createElementBlock("p", _hoisted_2$Z, [
            vue$2l.renderSlot(_ctx.$slots, "default", {}, () => [
              vue$2l.createTextVNode(vue$2l.toDisplayString(_ctx.description), 1)
            ])
          ])) : vue$2l.createCommentVNode("v-if", true),
          _ctx.closable ? (vue$2l.openBlock(), vue$2l.createElementBlock(vue$2l.Fragment, { key: 2 }, [
            _ctx.closeText ? (vue$2l.openBlock(), vue$2l.createElementBlock("div", {
              key: 0,
              class: "el-alert__closebtn is-customed",
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.close && _ctx.close(...args))
            }, vue$2l.toDisplayString(_ctx.closeText), 1)) : (vue$2l.openBlock(), vue$2l.createBlock(_component_el_icon, {
              key: 1,
              class: "el-alert__closebtn",
              onClick: _ctx.close
            }, {
              default: vue$2l.withCtx(() => [
                vue$2l.createVNode(_component_close)
              ]),
              _: 1
            }, 8, ["onClick"]))
          ], 2112)) : vue$2l.createCommentVNode("v-if", true)
        ])
      ], 2), [
        [vue$2l.vShow, _ctx.visible]
      ])
    ]),
    _: 3
  });
}
alert_vue_vue_type_template_id_1755b449_lang.render = render$1P;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var alert_vue_vue_type_script_lang$1 = alert_vue_vue_type_script_lang;
  var alert_vue_vue_type_template_id_1755b449_lang$1 = alert_vue_vue_type_template_id_1755b449_lang;
  alert_vue_vue_type_script_lang$1["default"].render = alert_vue_vue_type_template_id_1755b449_lang$1.render;
  alert_vue_vue_type_script_lang$1["default"].__file = "packages/components/alert/src/alert.vue";
  exports["default"] = alert_vue_vue_type_script_lang$1["default"];
})(alert2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var alert3 = alert$1;
  var alert_vue_vue_type_script_lang$1 = alert_vue_vue_type_script_lang;
  const ElAlert = withInstall2.withInstall(alert_vue_vue_type_script_lang$1["default"]);
  exports.alertEmits = alert3.alertEmits;
  exports.alertProps = alert3.alertProps;
  exports.ElAlert = ElAlert;
  exports["default"] = ElAlert;
})(alert$2);
var autocomplete = {};
var src$g = {};
var index_vue_vue_type_script_lang$d = {};
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string3) {
  var index2 = string3.length;
  while (index2-- && reWhitespace.test(string3.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$8 = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$8(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$8(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var isObject$7 = isObject_1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce$4(func, wait, options) {
  var lastArgs, lastThis, maxWait, result3, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject$7(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result3 = func.apply(thisArg, args);
    return result3;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result3;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result3;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result3 : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result3;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$4;
var input$2 = {};
var input2 = {};
var input_vue_vue_type_script_lang = {};
var isDef$2 = {};
Object.defineProperty(isDef$2, "__esModule", { value: true });
function isKorean(text) {
  const reg = /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi;
  return reg.test(text);
}
isDef$2.isKorean = isKorean;
var calcTextareaHeight$1 = {};
Object.defineProperty(calcTextareaHeight$1, "__esModule", { value: true });
var util$h = util$l;
let hiddenTextarea = void 0;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue("box-sizing");
  const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
  return { contextStyle, paddingSize, borderSize, boxSizing };
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
  var _a;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    document.body.appendChild(hiddenTextarea);
  }
  const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
  let height = hiddenTextarea.scrollHeight;
  const result3 = {};
  if (boxSizing === "border-box") {
    height = height + borderSize;
  } else if (boxSizing === "content-box") {
    height = height - paddingSize;
  }
  hiddenTextarea.value = "";
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
  if (util$h.isNumber(minRows)) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result3.minHeight = `${minHeight}px`;
  }
  if (util$h.isNumber(maxRows)) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result3.height = `${height}px`;
  (_a = hiddenTextarea.parentNode) == null ? void 0 : _a.removeChild(hiddenTextarea);
  hiddenTextarea = void 0;
  return result3;
}
calcTextareaHeight$1.calcTextareaHeight = calcTextareaHeight;
var input$1 = {};
Object.defineProperty(input$1, "__esModule", { value: true });
var shared$d = require$$1$1;
var props$F = props$N;
var constants$d = constants$f;
var index$1i = useCommonProps;
const inputProps = props$F.buildProps({
  size: index$1i.useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: props$F.definePropType(void 0),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: props$F.definePropType([Boolean, Object]),
    default: false
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  placeholder: {
    type: String
  },
  form: {
    type: String,
    default: ""
  },
  readonly: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  showPassword: {
    type: Boolean,
    default: false
  },
  showWordLimit: {
    type: Boolean,
    default: false
  },
  suffixIcon: {
    type: props$F.definePropType([String, Object]),
    default: ""
  },
  prefixIcon: {
    type: props$F.definePropType([String, Object]),
    default: ""
  },
  label: {
    type: String
  },
  tabindex: {
    type: [Number, String]
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  inputStyle: {
    type: props$F.definePropType([Object, Array, String]),
    default: () => props$F.mutable({})
  }
});
const inputEmits = {
  [constants$d.UPDATE_MODEL_EVENT]: (value) => shared$d.isString(value),
  input: (value) => shared$d.isString(value),
  change: (value) => shared$d.isString(value),
  focus: (evt) => evt instanceof FocusEvent,
  blur: (evt) => evt instanceof FocusEvent,
  clear: () => true,
  mouseleave: (evt) => evt instanceof MouseEvent,
  mouseenter: (evt) => evt instanceof MouseEvent,
  keydown: (evt) => evt instanceof KeyboardEvent,
  compositionstart: (evt) => evt instanceof CompositionEvent,
  compositionupdate: (evt) => evt instanceof CompositionEvent,
  compositionend: (evt) => evt instanceof CompositionEvent
};
input$1.inputEmits = inputEmits;
input$1.inputProps = inputProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var icon3 = icon$2;
  var constants2 = constants$f;
  var isServer2 = isServer$8;
  var isDef2 = isDef$2;
  var calcTextareaHeight2 = calcTextareaHeight$1;
  var input3 = input$1;
  var index$110 = useAttrs$1;
  var index$22 = useFormItem$1;
  var index$32 = useCommonProps;
  var shared2 = require$$1$1;
  const PENDANT_MAP = {
    suffix: "append",
    prefix: "prepend"
  };
  var script2 = vue2.defineComponent({
    name: "ElInput",
    components: { ElIcon: index2.ElIcon, CircleClose: iconsVue2.CircleClose, IconView: iconsVue2.View },
    inheritAttrs: false,
    props: input3.inputProps,
    emits: input3.inputEmits,
    setup(props2, { slots, emit, attrs: rawAttrs }) {
      const instance = vue2.getCurrentInstance();
      const attrs = index$110.useAttrs();
      const { form: form2, formItem: formItem2 } = index$22.useFormItem();
      const inputSize = index$32.useSize();
      const inputDisabled = index$32.useDisabled();
      const input4 = vue2.ref();
      const textarea = vue2.ref();
      const focused = vue2.ref(false);
      const hovering = vue2.ref(false);
      const isComposing = vue2.ref(false);
      const passwordVisible = vue2.ref(false);
      const _textareaCalcStyle = vue2.shallowRef(props2.inputStyle);
      const inputOrTextarea = vue2.computed(() => input4.value || textarea.value);
      const needStatusIcon = vue2.computed(() => {
        var _a;
        return (_a = form2 == null ? void 0 : form2.statusIcon) != null ? _a : false;
      });
      const validateState = vue2.computed(() => (formItem2 == null ? void 0 : formItem2.validateState) || "");
      const validateIcon = vue2.computed(() => icon3.ValidateComponentsMap[validateState.value]);
      const containerStyle = vue2.computed(() => rawAttrs.style);
      const computedTextareaStyle = vue2.computed(() => [
        props2.inputStyle,
        _textareaCalcStyle.value,
        { resize: props2.resize }
      ]);
      const nativeInputValue = vue2.computed(() => props2.modelValue === null || props2.modelValue === void 0 ? "" : String(props2.modelValue));
      const showClear = vue2.computed(() => props2.clearable && !inputDisabled.value && !props2.readonly && !!nativeInputValue.value && (focused.value || hovering.value));
      const showPwdVisible = vue2.computed(() => props2.showPassword && !inputDisabled.value && !props2.readonly && (!!nativeInputValue.value || focused.value));
      const isWordLimitVisible = vue2.computed(() => props2.showWordLimit && !!attrs.value.maxlength && (props2.type === "text" || props2.type === "textarea") && !inputDisabled.value && !props2.readonly && !props2.showPassword);
      const textLength = vue2.computed(() => Array.from(nativeInputValue.value).length);
      const inputExceed = vue2.computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
      const resizeTextarea = () => {
        const { type: type4, autosize } = props2;
        if (isServer2["default"] || type4 !== "textarea")
          return;
        if (autosize) {
          const minRows = shared2.isObject(autosize) ? autosize.minRows : void 0;
          const maxRows = shared2.isObject(autosize) ? autosize.maxRows : void 0;
          _textareaCalcStyle.value = __spreadValues({}, calcTextareaHeight2.calcTextareaHeight(textarea.value, minRows, maxRows));
        } else {
          _textareaCalcStyle.value = {
            minHeight: calcTextareaHeight2.calcTextareaHeight(textarea.value).minHeight
          };
        }
      };
      const setNativeInputValue = () => {
        const input22 = inputOrTextarea.value;
        if (!input22 || input22.value === nativeInputValue.value)
          return;
        input22.value = nativeInputValue.value;
      };
      const calcIconOffset = (place2) => {
        const { el } = instance.vnode;
        if (!el)
          return;
        const elList = Array.from(el.querySelectorAll(`.el-input__${place2}`));
        const target2 = elList.find((item2) => item2.parentNode === el);
        if (!target2)
          return;
        const pendant = PENDANT_MAP[place2];
        if (slots[pendant]) {
          target2.style.transform = `translateX(${place2 === "suffix" ? "-" : ""}${el.querySelector(`.el-input-group__${pendant}`).offsetWidth}px)`;
        } else {
          target2.removeAttribute("style");
        }
      };
      const updateIconOffset = () => {
        calcIconOffset("prefix");
        calcIconOffset("suffix");
      };
      const handleInput = (event) => {
        const { value } = event.target;
        if (isComposing.value)
          return;
        if (value === nativeInputValue.value)
          return;
        emit(constants2.UPDATE_MODEL_EVENT, value);
        emit("input", value);
        vue2.nextTick(setNativeInputValue);
      };
      const handleChange = (event) => {
        emit("change", event.target.value);
      };
      const focus = () => {
        vue2.nextTick(() => {
          var _a;
          (_a = inputOrTextarea.value) == null ? void 0 : _a.focus();
        });
      };
      const blur = () => {
        var _a;
        (_a = inputOrTextarea.value) == null ? void 0 : _a.blur();
      };
      const handleFocus = (event) => {
        focused.value = true;
        emit("focus", event);
      };
      const handleBlur = (event) => {
        var _a;
        focused.value = false;
        emit("blur", event);
        if (props2.validateEvent) {
          (_a = formItem2 == null ? void 0 : formItem2.validate) == null ? void 0 : _a.call(formItem2, "blur");
        }
      };
      const select2 = () => {
        var _a;
        (_a = inputOrTextarea.value) == null ? void 0 : _a.select();
      };
      const handleCompositionStart = (event) => {
        emit("compositionstart", event);
        isComposing.value = true;
      };
      const handleCompositionUpdate = (event) => {
        var _a;
        emit("compositionupdate", event);
        const text = (_a = event.target) == null ? void 0 : _a.value;
        const lastCharacter = text[text.length - 1] || "";
        isComposing.value = !isDef2.isKorean(lastCharacter);
      };
      const handleCompositionEnd = (event) => {
        emit("compositionend", event);
        if (isComposing.value) {
          isComposing.value = false;
          handleInput(event);
        }
      };
      const clear2 = () => {
        emit(constants2.UPDATE_MODEL_EVENT, "");
        emit("change", "");
        emit("clear");
        emit("input", "");
      };
      const handlePasswordVisible = () => {
        passwordVisible.value = !passwordVisible.value;
        focus();
      };
      const suffixVisible = vue2.computed(() => !!slots.suffix || !!props2.suffixIcon || showClear.value || props2.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
      vue2.watch(() => props2.modelValue, () => {
        var _a;
        vue2.nextTick(resizeTextarea);
        if (props2.validateEvent) {
          (_a = formItem2 == null ? void 0 : formItem2.validate) == null ? void 0 : _a.call(formItem2, "change");
        }
      });
      vue2.watch(nativeInputValue, () => setNativeInputValue());
      vue2.watch(() => props2.type, () => {
        vue2.nextTick(() => {
          setNativeInputValue();
          resizeTextarea();
          updateIconOffset();
        });
      });
      vue2.onMounted(() => {
        setNativeInputValue();
        updateIconOffset();
        vue2.nextTick(resizeTextarea);
      });
      vue2.onUpdated(() => {
        vue2.nextTick(updateIconOffset);
      });
      const onMouseLeave = (evt) => {
        hovering.value = false;
        emit("mouseleave", evt);
      };
      const onMouseEnter = (evt) => {
        hovering.value = true;
        emit("mouseenter", evt);
      };
      const handleKeydown = (evt) => {
        emit("keydown", evt);
      };
      return {
        input: input4,
        textarea,
        attrs,
        inputSize,
        validateState,
        validateIcon,
        containerStyle,
        computedTextareaStyle,
        inputDisabled,
        showClear,
        showPwdVisible,
        isWordLimitVisible,
        textLength,
        hovering,
        inputExceed,
        passwordVisible,
        inputOrTextarea,
        suffixVisible,
        resizeTextarea,
        handleInput,
        handleChange,
        handleFocus,
        handleBlur,
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd,
        handlePasswordVisible,
        clear: clear2,
        select: select2,
        focus,
        blur,
        onMouseLeave,
        onMouseEnter,
        handleKeydown
      };
    }
  });
  exports["default"] = script2;
})(input_vue_vue_type_script_lang);
var input_vue_vue_type_template_id_3290dcb6_lang = {};
Object.defineProperty(input_vue_vue_type_template_id_3290dcb6_lang, "__esModule", { value: true });
var vue$2k = require$$0$1;
const _hoisted_1$1l = {
  key: 0,
  class: "el-input-group__prepend"
};
const _hoisted_2$Y = ["type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"];
const _hoisted_3$M = {
  key: 1,
  class: "el-input__prefix"
};
const _hoisted_4$w = { class: "el-input__prefix-inner" };
const _hoisted_5$o = {
  key: 2,
  class: "el-input__suffix"
};
const _hoisted_6$i = { class: "el-input__suffix-inner" };
const _hoisted_7$c = {
  key: 3,
  class: "el-input__count"
};
const _hoisted_8$b = { class: "el-input__count-inner" };
const _hoisted_9$8 = {
  key: 3,
  class: "el-input-group__append"
};
const _hoisted_10$8 = ["tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
const _hoisted_11$4 = {
  key: 0,
  class: "el-input__count"
};
function render$1O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$2k.resolveComponent("el-icon");
  const _component_circle_close = vue$2k.resolveComponent("circle-close");
  const _component_icon_view = vue$2k.resolveComponent("icon-view");
  return vue$2k.withDirectives((vue$2k.openBlock(), vue$2k.createElementBlock("div", {
    class: vue$2k.normalizeClass([
      _ctx.type === "textarea" ? "el-textarea" : "el-input",
      _ctx.inputSize ? "el-input--" + _ctx.inputSize : "",
      {
        "is-disabled": _ctx.inputDisabled,
        "is-exceed": _ctx.inputExceed,
        "el-input-group": _ctx.$slots.prepend || _ctx.$slots.append,
        "el-input-group--append": _ctx.$slots.append,
        "el-input-group--prepend": _ctx.$slots.prepend,
        "el-input--prefix": _ctx.$slots.prefix || _ctx.prefixIcon,
        "el-input--suffix": _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
        "el-input--suffix--password-clear": _ctx.clearable && _ctx.showPassword
      },
      _ctx.$attrs.class
    ]),
    style: vue$2k.normalizeStyle(_ctx.containerStyle),
    onMouseenter: _cache[17] || (_cache[17] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[18] || (_cache[18] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    vue$2k.createCommentVNode(" input "),
    _ctx.type !== "textarea" ? (vue$2k.openBlock(), vue$2k.createElementBlock(vue$2k.Fragment, { key: 0 }, [
      vue$2k.createCommentVNode(" prepend slot "),
      _ctx.$slots.prepend ? (vue$2k.openBlock(), vue$2k.createElementBlock("div", _hoisted_1$1l, [
        vue$2k.renderSlot(_ctx.$slots, "prepend")
      ])) : vue$2k.createCommentVNode("v-if", true),
      vue$2k.createElementVNode("input", vue$2k.mergeProps({
        ref: "input",
        class: "el-input__inner"
      }, _ctx.attrs, {
        type: _ctx.showPassword ? _ctx.passwordVisible ? "text" : "password" : _ctx.type,
        disabled: _ctx.inputDisabled,
        readonly: _ctx.readonly,
        autocomplete: _ctx.autocomplete,
        tabindex: _ctx.tabindex,
        "aria-label": _ctx.label,
        placeholder: _ctx.placeholder,
        style: _ctx.inputStyle,
        onCompositionstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
        onCompositionupdate: _cache[1] || (_cache[1] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
        onCompositionend: _cache[2] || (_cache[2] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
        onInput: _cache[3] || (_cache[3] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
        onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
        onChange: _cache[6] || (_cache[6] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onKeydown: _cache[7] || (_cache[7] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }), null, 16, _hoisted_2$Y),
      vue$2k.createCommentVNode(" prefix slot "),
      _ctx.$slots.prefix || _ctx.prefixIcon ? (vue$2k.openBlock(), vue$2k.createElementBlock("span", _hoisted_3$M, [
        vue$2k.createElementVNode("span", _hoisted_4$w, [
          vue$2k.renderSlot(_ctx.$slots, "prefix"),
          _ctx.prefixIcon ? (vue$2k.openBlock(), vue$2k.createBlock(_component_el_icon, {
            key: 0,
            class: "el-input__icon"
          }, {
            default: vue$2k.withCtx(() => [
              (vue$2k.openBlock(), vue$2k.createBlock(vue$2k.resolveDynamicComponent(_ctx.prefixIcon)))
            ]),
            _: 1
          })) : vue$2k.createCommentVNode("v-if", true)
        ])
      ])) : vue$2k.createCommentVNode("v-if", true),
      vue$2k.createCommentVNode(" suffix slot "),
      _ctx.suffixVisible ? (vue$2k.openBlock(), vue$2k.createElementBlock("span", _hoisted_5$o, [
        vue$2k.createElementVNode("span", _hoisted_6$i, [
          !_ctx.showClear || !_ctx.showPwdVisible || !_ctx.isWordLimitVisible ? (vue$2k.openBlock(), vue$2k.createElementBlock(vue$2k.Fragment, { key: 0 }, [
            vue$2k.renderSlot(_ctx.$slots, "suffix"),
            _ctx.suffixIcon ? (vue$2k.openBlock(), vue$2k.createBlock(_component_el_icon, {
              key: 0,
              class: "el-input__icon"
            }, {
              default: vue$2k.withCtx(() => [
                (vue$2k.openBlock(), vue$2k.createBlock(vue$2k.resolveDynamicComponent(_ctx.suffixIcon)))
              ]),
              _: 1
            })) : vue$2k.createCommentVNode("v-if", true)
          ], 64)) : vue$2k.createCommentVNode("v-if", true),
          _ctx.showClear ? (vue$2k.openBlock(), vue$2k.createBlock(_component_el_icon, {
            key: 1,
            class: "el-input__icon el-input__clear",
            onMousedown: _cache[8] || (_cache[8] = vue$2k.withModifiers(() => {
            }, ["prevent"])),
            onClick: _ctx.clear
          }, {
            default: vue$2k.withCtx(() => [
              vue$2k.createVNode(_component_circle_close)
            ]),
            _: 1
          }, 8, ["onClick"])) : vue$2k.createCommentVNode("v-if", true),
          _ctx.showPwdVisible ? (vue$2k.openBlock(), vue$2k.createBlock(_component_el_icon, {
            key: 2,
            class: "el-input__icon el-input__clear",
            onClick: _ctx.handlePasswordVisible
          }, {
            default: vue$2k.withCtx(() => [
              vue$2k.createVNode(_component_icon_view)
            ]),
            _: 1
          }, 8, ["onClick"])) : vue$2k.createCommentVNode("v-if", true),
          _ctx.isWordLimitVisible ? (vue$2k.openBlock(), vue$2k.createElementBlock("span", _hoisted_7$c, [
            vue$2k.createElementVNode("span", _hoisted_8$b, vue$2k.toDisplayString(_ctx.textLength) + " / " + vue$2k.toDisplayString(_ctx.attrs.maxlength), 1)
          ])) : vue$2k.createCommentVNode("v-if", true)
        ]),
        _ctx.validateState && _ctx.validateIcon ? (vue$2k.openBlock(), vue$2k.createBlock(_component_el_icon, {
          key: 0,
          class: "el-input__icon el-input__validateIcon"
        }, {
          default: vue$2k.withCtx(() => [
            (vue$2k.openBlock(), vue$2k.createBlock(vue$2k.resolveDynamicComponent(_ctx.validateIcon)))
          ]),
          _: 1
        })) : vue$2k.createCommentVNode("v-if", true)
      ])) : vue$2k.createCommentVNode("v-if", true),
      vue$2k.createCommentVNode(" append slot "),
      _ctx.$slots.append ? (vue$2k.openBlock(), vue$2k.createElementBlock("div", _hoisted_9$8, [
        vue$2k.renderSlot(_ctx.$slots, "append")
      ])) : vue$2k.createCommentVNode("v-if", true)
    ], 64)) : (vue$2k.openBlock(), vue$2k.createElementBlock(vue$2k.Fragment, { key: 1 }, [
      vue$2k.createCommentVNode(" textarea "),
      vue$2k.createElementVNode("textarea", vue$2k.mergeProps({
        ref: "textarea",
        class: "el-textarea__inner"
      }, _ctx.attrs, {
        tabindex: _ctx.tabindex,
        disabled: _ctx.inputDisabled,
        readonly: _ctx.readonly,
        autocomplete: _ctx.autocomplete,
        style: _ctx.computedTextareaStyle,
        "aria-label": _ctx.label,
        placeholder: _ctx.placeholder,
        onCompositionstart: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
        onCompositionupdate: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
        onCompositionend: _cache[11] || (_cache[11] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
        onInput: _cache[12] || (_cache[12] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
        onFocus: _cache[13] || (_cache[13] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onBlur: _cache[14] || (_cache[14] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
        onChange: _cache[15] || (_cache[15] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onKeydown: _cache[16] || (_cache[16] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }), null, 16, _hoisted_10$8),
      _ctx.isWordLimitVisible ? (vue$2k.openBlock(), vue$2k.createElementBlock("span", _hoisted_11$4, vue$2k.toDisplayString(_ctx.textLength) + " / " + vue$2k.toDisplayString(_ctx.attrs.maxlength), 1)) : vue$2k.createCommentVNode("v-if", true)
    ], 64))
  ], 38)), [
    [vue$2k.vShow, _ctx.type !== "hidden"]
  ]);
}
input_vue_vue_type_template_id_3290dcb6_lang.render = render$1O;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var input_vue_vue_type_script_lang$1 = input_vue_vue_type_script_lang;
  var input_vue_vue_type_template_id_3290dcb6_lang$1 = input_vue_vue_type_template_id_3290dcb6_lang;
  input_vue_vue_type_script_lang$1["default"].render = input_vue_vue_type_template_id_3290dcb6_lang$1.render;
  input_vue_vue_type_script_lang$1["default"].__file = "packages/components/input/src/input.vue";
  exports["default"] = input_vue_vue_type_script_lang$1["default"];
})(input2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var input3 = input$1;
  var input_vue_vue_type_script_lang$1 = input_vue_vue_type_script_lang;
  const ElInput = withInstall2.withInstall(input_vue_vue_type_script_lang$1["default"]);
  exports.inputEmits = input3.inputEmits;
  exports.inputProps = input3.inputProps;
  exports.ElInput = ElInput;
  exports["default"] = ElInput;
})(input$2);
var scrollbar$3 = {};
var scrollbar2 = {};
var scrollbar_vue_vue_type_script_lang = {};
var bar2 = {};
var bar_vue_vue_type_script_lang = {};
var util$g = {};
Object.defineProperty(util$g, "__esModule", { value: true });
const BAR_MAP = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
};
const renderThumbStyle$1 = ({ move, size: size2, bar: bar3 }) => ({
  [bar3.size]: size2,
  transform: `translate${bar3.axis}(${move}%)`
});
util$g.BAR_MAP = BAR_MAP;
util$g.renderThumbStyle = renderThumbStyle$1;
var bar$1 = {};
Object.defineProperty(bar$1, "__esModule", { value: true });
var props$E = props$N;
const barProps = props$E.buildProps({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: true
  },
  always: Boolean
});
bar$1.barProps = barProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var error2 = error$5;
  var util2 = util$g;
  var bar3 = bar$1;
  var scrollbar3 = scrollbar$4;
  const COMPONENT_NAME = "Bar";
  var script2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    props: bar3.barProps,
    setup(props2) {
      const scrollbar$12 = vue2.inject(scrollbar3.scrollbarContextKey);
      if (!scrollbar$12)
        error2.throwError(COMPONENT_NAME, "can not inject scrollbar context");
      const instance = vue2.ref();
      const thumb = vue2.ref();
      const barStore = vue2.ref({});
      const visible = vue2.ref(false);
      let cursorDown = false;
      let cursorLeave = false;
      let onselectstartStore = null;
      const bar4 = vue2.computed(() => util2.BAR_MAP[props2.vertical ? "vertical" : "horizontal"]);
      const thumbStyle = vue2.computed(() => util2.renderThumbStyle({
        size: props2.size,
        move: props2.move,
        bar: bar4.value
      }));
      const offsetRatio = vue2.computed(() => instance.value[bar4.value.offset] ** 2 / scrollbar$12.wrapElement[bar4.value.scrollSize] / props2.ratio / thumb.value[bar4.value.offset]);
      const clickThumbHandler = (e) => {
        var _a;
        e.stopPropagation();
        if (e.ctrlKey || [1, 2].includes(e.button))
          return;
        (_a = window.getSelection()) == null ? void 0 : _a.removeAllRanges();
        startDrag(e);
        const el = e.currentTarget;
        if (!el)
          return;
        barStore.value[bar4.value.axis] = el[bar4.value.offset] - (e[bar4.value.client] - el.getBoundingClientRect()[bar4.value.direction]);
      };
      const clickTrackHandler = (e) => {
        if (!thumb.value || !instance.value || !scrollbar$12.wrapElement)
          return;
        const offset2 = Math.abs(e.target.getBoundingClientRect()[bar4.value.direction] - e[bar4.value.client]);
        const thumbHalf = thumb.value[bar4.value.offset] / 2;
        const thumbPositionPercentage = (offset2 - thumbHalf) * 100 * offsetRatio.value / instance.value[bar4.value.offset];
        scrollbar$12.wrapElement[bar4.value.scroll] = thumbPositionPercentage * scrollbar$12.wrapElement[bar4.value.scrollSize] / 100;
      };
      const startDrag = (e) => {
        e.stopImmediatePropagation();
        cursorDown = true;
        document.addEventListener("mousemove", mouseMoveDocumentHandler);
        document.addEventListener("mouseup", mouseUpDocumentHandler);
        onselectstartStore = document.onselectstart;
        document.onselectstart = () => false;
      };
      const mouseMoveDocumentHandler = (e) => {
        if (!instance.value || !thumb.value)
          return;
        if (cursorDown === false)
          return;
        const prevPage = barStore.value[bar4.value.axis];
        if (!prevPage)
          return;
        const offset2 = (instance.value.getBoundingClientRect()[bar4.value.direction] - e[bar4.value.client]) * -1;
        const thumbClickPosition = thumb.value[bar4.value.offset] - prevPage;
        const thumbPositionPercentage = (offset2 - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar4.value.offset];
        scrollbar$12.wrapElement[bar4.value.scroll] = thumbPositionPercentage * scrollbar$12.wrapElement[bar4.value.scrollSize] / 100;
      };
      const mouseUpDocumentHandler = () => {
        cursorDown = false;
        barStore.value[bar4.value.axis] = 0;
        document.removeEventListener("mousemove", mouseMoveDocumentHandler);
        document.removeEventListener("mouseup", mouseUpDocumentHandler);
        document.onselectstart = onselectstartStore;
        if (cursorLeave)
          visible.value = false;
      };
      const mouseMoveScrollbarHandler = () => {
        cursorLeave = false;
        visible.value = !!props2.size;
      };
      const mouseLeaveScrollbarHandler = () => {
        cursorLeave = true;
        visible.value = cursorDown;
      };
      vue2.onBeforeUnmount(() => document.removeEventListener("mouseup", mouseUpDocumentHandler));
      core2.useEventListener(vue2.toRef(scrollbar$12, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
      core2.useEventListener(vue2.toRef(scrollbar$12, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
      return {
        instance,
        thumb,
        bar: bar4,
        thumbStyle,
        visible,
        clickTrackHandler,
        clickThumbHandler
      };
    }
  });
  exports["default"] = script2;
})(bar_vue_vue_type_script_lang);
var bar_vue_vue_type_template_id_2f63f10a_lang = {};
Object.defineProperty(bar_vue_vue_type_template_id_2f63f10a_lang, "__esModule", { value: true });
var vue$2j = require$$0$1;
function render$1N(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$2j.openBlock(), vue$2j.createBlock(vue$2j.Transition, { name: "el-scrollbar-fade" }, {
    default: vue$2j.withCtx(() => [
      vue$2j.withDirectives(vue$2j.createElementVNode("div", {
        ref: "instance",
        class: vue$2j.normalizeClass(["el-scrollbar__bar", "is-" + _ctx.bar.key]),
        onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.clickTrackHandler && _ctx.clickTrackHandler(...args))
      }, [
        vue$2j.createElementVNode("div", {
          ref: "thumb",
          class: "el-scrollbar__thumb",
          style: vue$2j.normalizeStyle(_ctx.thumbStyle),
          onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.clickThumbHandler && _ctx.clickThumbHandler(...args))
        }, null, 36)
      ], 34), [
        [vue$2j.vShow, _ctx.always || _ctx.visible]
      ])
    ]),
    _: 1
  });
}
bar_vue_vue_type_template_id_2f63f10a_lang.render = render$1N;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bar_vue_vue_type_script_lang$1 = bar_vue_vue_type_script_lang;
  var bar_vue_vue_type_template_id_2f63f10a_lang$1 = bar_vue_vue_type_template_id_2f63f10a_lang;
  bar_vue_vue_type_script_lang$1["default"].render = bar_vue_vue_type_template_id_2f63f10a_lang$1.render;
  bar_vue_vue_type_script_lang$1["default"].__file = "packages/components/scrollbar/src/bar.vue";
  exports["default"] = bar_vue_vue_type_script_lang$1["default"];
})(bar2);
var scrollbar$2 = {};
Object.defineProperty(scrollbar$2, "__esModule", { value: true });
var props$D = props$N;
var util$f = util$l;
const scrollbarProps = props$D.buildProps({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: false
  },
  wrapStyle: {
    type: props$D.definePropType([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: {
    type: Boolean,
    default: false
  },
  minSize: {
    type: Number,
    default: 20
  }
});
const scrollbarEmits = {
  scroll: ({
    scrollTop,
    scrollLeft
  }) => util$f.isNumber(scrollTop) && util$f.isNumber(scrollLeft)
};
scrollbar$2.scrollbarEmits = scrollbarEmits;
scrollbar$2.scrollbarProps = scrollbarProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var util2 = util$l;
  var error2 = error$5;
  var scrollbar3 = scrollbar$2;
  var bar_vue_vue_type_script_lang$1 = bar_vue_vue_type_script_lang;
  var scrollbar$12 = scrollbar$4;
  var script2 = vue2.defineComponent({
    name: "ElScrollbar",
    components: {
      Bar: bar_vue_vue_type_script_lang$1["default"]
    },
    props: scrollbar3.scrollbarProps,
    emits: scrollbar3.scrollbarEmits,
    setup(props2, { emit }) {
      let stopResizeObserver = void 0;
      let stopResizeListener = void 0;
      const scrollbar$ = vue2.ref();
      const wrap$ = vue2.ref();
      const resize$ = vue2.ref();
      const sizeWidth = vue2.ref("0");
      const sizeHeight = vue2.ref("0");
      const moveX = vue2.ref(0);
      const moveY = vue2.ref(0);
      const ratioY = vue2.ref(1);
      const ratioX = vue2.ref(1);
      const SCOPE2 = "ElScrollbar";
      const GAP = 4;
      const style = vue2.computed(() => {
        const style2 = {};
        if (props2.height)
          style2.height = util2.addUnit(props2.height);
        if (props2.maxHeight)
          style2.maxHeight = util2.addUnit(props2.maxHeight);
        return [props2.wrapStyle, style2];
      });
      const handleScroll = () => {
        if (wrap$.value) {
          const offsetHeight = wrap$.value.offsetHeight - GAP;
          const offsetWidth = wrap$.value.offsetWidth - GAP;
          moveY.value = wrap$.value.scrollTop * 100 / offsetHeight * ratioY.value;
          moveX.value = wrap$.value.scrollLeft * 100 / offsetWidth * ratioX.value;
          emit("scroll", {
            scrollTop: wrap$.value.scrollTop,
            scrollLeft: wrap$.value.scrollLeft
          });
        }
      };
      const setScrollTop = (value) => {
        if (!util2.isNumber(value)) {
          error2.debugWarn(SCOPE2, "value must be a number");
          return;
        }
        wrap$.value.scrollTop = value;
      };
      const setScrollLeft = (value) => {
        if (!util2.isNumber(value)) {
          error2.debugWarn(SCOPE2, "value must be a number");
          return;
        }
        wrap$.value.scrollLeft = value;
      };
      const update3 = () => {
        if (!wrap$.value)
          return;
        const offsetHeight = wrap$.value.offsetHeight - GAP;
        const offsetWidth = wrap$.value.offsetWidth - GAP;
        const originalHeight = offsetHeight ** 2 / wrap$.value.scrollHeight;
        const originalWidth = offsetWidth ** 2 / wrap$.value.scrollWidth;
        const height = Math.max(originalHeight, props2.minSize);
        const width = Math.max(originalWidth, props2.minSize);
        ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
        ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
        sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
        sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
      };
      vue2.watch(() => props2.noresize, (noresize) => {
        if (noresize) {
          stopResizeObserver == null ? void 0 : stopResizeObserver();
          stopResizeListener == null ? void 0 : stopResizeListener();
        } else {
          ({ stop: stopResizeObserver } = core2.useResizeObserver(resize$, update3));
          stopResizeListener = core2.useEventListener("resize", update3);
        }
      }, { immediate: true });
      vue2.provide(scrollbar$12.scrollbarContextKey, vue2.reactive({
        scrollbarElement: scrollbar$,
        wrapElement: wrap$
      }));
      vue2.onMounted(() => {
        if (!props2.native)
          vue2.nextTick(() => update3());
      });
      return {
        scrollbar$,
        wrap$,
        resize$,
        moveX,
        moveY,
        ratioX,
        ratioY,
        sizeWidth,
        sizeHeight,
        style,
        update: update3,
        handleScroll,
        setScrollTop,
        setScrollLeft
      };
    }
  });
  exports["default"] = script2;
})(scrollbar_vue_vue_type_script_lang);
var scrollbar_vue_vue_type_template_id_303f965d_lang = {};
Object.defineProperty(scrollbar_vue_vue_type_template_id_303f965d_lang, "__esModule", { value: true });
var vue$2i = require$$0$1;
const _hoisted_1$1k = {
  ref: "scrollbar$",
  class: "el-scrollbar"
};
function render$1M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_bar = vue$2i.resolveComponent("bar");
  return vue$2i.openBlock(), vue$2i.createElementBlock("div", _hoisted_1$1k, [
    vue$2i.createElementVNode("div", {
      ref: "wrap$",
      class: vue$2i.normalizeClass([
        _ctx.wrapClass,
        "el-scrollbar__wrap",
        _ctx.native ? "" : "el-scrollbar__wrap--hidden-default"
      ]),
      style: vue$2i.normalizeStyle(_ctx.style),
      onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.handleScroll && _ctx.handleScroll(...args))
    }, [
      (vue$2i.openBlock(), vue$2i.createBlock(vue$2i.resolveDynamicComponent(_ctx.tag), {
        ref: "resize$",
        class: vue$2i.normalizeClass(["el-scrollbar__view", _ctx.viewClass]),
        style: vue$2i.normalizeStyle(_ctx.viewStyle)
      }, {
        default: vue$2i.withCtx(() => [
          vue$2i.renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]))
    ], 38),
    !_ctx.native ? (vue$2i.openBlock(), vue$2i.createElementBlock(vue$2i.Fragment, { key: 0 }, [
      vue$2i.createVNode(_component_bar, {
        move: _ctx.moveX,
        ratio: _ctx.ratioX,
        size: _ctx.sizeWidth,
        always: _ctx.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      vue$2i.createVNode(_component_bar, {
        move: _ctx.moveY,
        ratio: _ctx.ratioY,
        size: _ctx.sizeHeight,
        vertical: "",
        always: _ctx.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64)) : vue$2i.createCommentVNode("v-if", true)
  ], 512);
}
scrollbar_vue_vue_type_template_id_303f965d_lang.render = render$1M;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var scrollbar_vue_vue_type_script_lang$1 = scrollbar_vue_vue_type_script_lang;
  var scrollbar_vue_vue_type_template_id_303f965d_lang$1 = scrollbar_vue_vue_type_template_id_303f965d_lang;
  scrollbar_vue_vue_type_script_lang$1["default"].render = scrollbar_vue_vue_type_template_id_303f965d_lang$1.render;
  scrollbar_vue_vue_type_script_lang$1["default"].__file = "packages/components/scrollbar/src/scrollbar.vue";
  exports["default"] = scrollbar_vue_vue_type_script_lang$1["default"];
})(scrollbar2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var util2 = util$g;
  var scrollbar3 = scrollbar$2;
  var bar3 = bar$1;
  var scrollbar_vue_vue_type_script_lang$1 = scrollbar_vue_vue_type_script_lang;
  const ElScrollbar = withInstall2.withInstall(scrollbar_vue_vue_type_script_lang$1["default"]);
  exports.BAR_MAP = util2.BAR_MAP;
  exports.renderThumbStyle = util2.renderThumbStyle;
  exports.scrollbarEmits = scrollbar3.scrollbarEmits;
  exports.scrollbarProps = scrollbar3.scrollbarProps;
  exports.barProps = bar3.barProps;
  exports.ElScrollbar = ElScrollbar;
  exports["default"] = ElScrollbar;
})(scrollbar$3);
var popper$3 = {};
var src$f = {};
var index_vue_vue_type_script_lang$c = {};
var usePopper = {};
var popperOptions = {};
var buildModifiers = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function buildModifier2(props2, externalModifiers = []) {
    const { arrow: arrow2, arrowOffset, offset: offset2, gpuAcceleration, fallbackPlacements } = props2;
    const modifiers = [
      {
        name: "offset",
        options: {
          offset: [0, offset2 != null ? offset2 : 12]
        }
      },
      {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      },
      {
        name: "flip",
        options: {
          padding: 5,
          fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
        }
      },
      {
        name: "computeStyles",
        options: {
          gpuAcceleration,
          adaptive: gpuAcceleration
        }
      }
    ];
    if (arrow2) {
      modifiers.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: arrowOffset != null ? arrowOffset : 5
        }
      });
    }
    modifiers.push(...externalModifiers);
    return modifiers;
  }
  exports["default"] = buildModifier2;
})(buildModifiers);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var buildModifiers$1 = buildModifiers;
  function usePopperOptions2(props2, state) {
    return vue2.computed(() => {
      var _a;
      return __spreadProps(__spreadValues({
        placement: props2.placement
      }, props2.popperOptions), {
        modifiers: buildModifiers$1["default"]({
          arrow: state.arrow.value,
          arrowOffset: props2.arrowOffset,
          offset: props2.offset,
          gpuAcceleration: props2.gpuAcceleration,
          fallbackPlacements: props2.fallbackPlacements
        }, (_a = props2.popperOptions) == null ? void 0 : _a.modifiers)
      });
    });
  }
  exports["default"] = usePopperOptions2;
})(popperOptions);
var defaults$d = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var Effect2 = /* @__PURE__ */ ((Effect22) => {
    Effect22["DARK"] = "dark";
    Effect22["LIGHT"] = "light";
    return Effect22;
  })(Effect2 || {});
  const DEFAULT_FALLBACK_PLACEMENTS2 = [];
  var popperDefaultProps = {
    arrowOffset: {
      type: Number,
      default: 5
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    autoClose: {
      type: Number,
      default: 0
    },
    boundariesPadding: {
      type: Number,
      default: 0
    },
    content: {
      type: String,
      default: ""
    },
    class: {
      type: String,
      default: ""
    },
    style: Object,
    hideAfter: {
      type: Number,
      default: 200
    },
    cutoff: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    effect: {
      type: String,
      default: "dark"
    },
    enterable: {
      type: Boolean,
      default: true
    },
    manualMode: {
      type: Boolean,
      default: false
    },
    showAfter: {
      type: Number,
      default: 0
    },
    offset: {
      type: Number,
      default: 12
    },
    placement: {
      type: String,
      default: "bottom"
    },
    popperClass: {
      type: String,
      default: ""
    },
    pure: {
      type: Boolean,
      default: false
    },
    popperOptions: {
      type: Object,
      default: () => null
    },
    showArrow: {
      type: Boolean,
      default: true
    },
    strategy: {
      type: String,
      default: "fixed"
    },
    transition: {
      type: String,
      default: "el-fade-in-linear"
    },
    trigger: {
      type: [String, Array],
      default: "hover"
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    stopPopperMouseEvent: {
      type: Boolean,
      default: true
    },
    gpuAcceleration: {
      type: Boolean,
      default: true
    },
    fallbackPlacements: {
      type: Array,
      default: DEFAULT_FALLBACK_PLACEMENTS2
    }
  };
  exports.Effect = Effect2;
  exports["default"] = popperDefaultProps;
})(defaults$d);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = require$$1;
  var util2 = util$l;
  var popupManager2 = popupManager$3;
  var popperOptions$1 = popperOptions;
  var defaults2 = defaults$d;
  var shared2 = require$$1$1;
  const DEFAULT_TRIGGER2 = ["hover"];
  const UPDATE_VISIBLE_EVENT2 = "update:visible";
  function usePopper2(props2, { emit }) {
    const arrowRef = vue2.ref(null);
    const triggerRef2 = vue2.ref(null);
    const popperRef = vue2.ref(null);
    const popperId = `el-popper-${util2.generateId()}`;
    let popperInstance = null;
    let showTimer = null;
    let hideTimer = null;
    let triggerFocused = false;
    const isManualMode = () => props2.manualMode || props2.trigger === "manual";
    const popperStyle = vue2.ref({ zIndex: popupManager2["default"].nextZIndex() });
    const popperOptions$1$1 = popperOptions$1["default"](props2, {
      arrow: arrowRef
    });
    const state = vue2.reactive({
      visible: !!props2.visible
    });
    const visibility = vue2.computed({
      get() {
        if (props2.disabled) {
          return false;
        } else {
          return util2.isBool(props2.visible) ? props2.visible : state.visible;
        }
      },
      set(val) {
        if (isManualMode())
          return;
        util2.isBool(props2.visible) ? emit(UPDATE_VISIBLE_EVENT2, val) : state.visible = val;
      }
    });
    function _show() {
      if (props2.autoClose > 0) {
        hideTimer = window.setTimeout(() => {
          _hide();
        }, props2.autoClose);
      }
      visibility.value = true;
    }
    function _hide() {
      visibility.value = false;
    }
    function clearTimers() {
      clearTimeout(showTimer);
      clearTimeout(hideTimer);
    }
    const show = () => {
      if (isManualMode() || props2.disabled)
        return;
      clearTimers();
      if (props2.showAfter === 0) {
        _show();
      } else {
        showTimer = window.setTimeout(() => {
          _show();
        }, props2.showAfter);
      }
    };
    const hide2 = () => {
      if (isManualMode())
        return;
      clearTimers();
      if (props2.hideAfter > 0) {
        hideTimer = window.setTimeout(() => {
          close2();
        }, props2.hideAfter);
      } else {
        close2();
      }
    };
    const close2 = () => {
      _hide();
      if (props2.disabled) {
        doDestroy(true);
      }
    };
    function onPopperMouseEnter() {
      if (props2.enterable && props2.trigger !== "click") {
        clearTimeout(hideTimer);
      }
    }
    function onPopperMouseLeave() {
      const { trigger: trigger2 } = props2;
      const shouldPrevent = shared2.isString(trigger2) && (trigger2 === "click" || trigger2 === "focus") || trigger2.length === 1 && (trigger2[0] === "click" || trigger2[0] === "focus");
      if (shouldPrevent)
        return;
      hide2();
    }
    function initializePopper() {
      if (!vue2.unref(visibility)) {
        return;
      }
      const unwrappedTrigger = vue2.unref(triggerRef2);
      const _trigger = util2.isHTMLElement(unwrappedTrigger) ? unwrappedTrigger : unwrappedTrigger.$el;
      popperInstance = core2.createPopper(_trigger, vue2.unref(popperRef), vue2.unref(popperOptions$1$1));
      popperInstance.update();
    }
    function doDestroy(forceDestroy) {
      if (!popperInstance || vue2.unref(visibility) && !forceDestroy)
        return;
      detachPopper();
    }
    function detachPopper() {
      var _a;
      (_a = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a.call(popperInstance);
      popperInstance = null;
    }
    const events = {};
    function update3() {
      if (!vue2.unref(visibility)) {
        return;
      }
      if (popperInstance) {
        popperInstance.update();
      } else {
        initializePopper();
      }
    }
    function onVisibilityChange(toState) {
      if (toState) {
        popperStyle.value.zIndex = popupManager2["default"].nextZIndex();
        initializePopper();
      }
    }
    if (!isManualMode()) {
      const toggleState = () => {
        if (vue2.unref(visibility)) {
          hide2();
        } else {
          show();
        }
      };
      const popperEventsHandler = (e) => {
        e.stopPropagation();
        switch (e.type) {
          case "click": {
            if (triggerFocused) {
              triggerFocused = false;
            } else {
              toggleState();
            }
            break;
          }
          case "mouseenter": {
            show();
            break;
          }
          case "mouseleave": {
            hide2();
            break;
          }
          case "focus": {
            triggerFocused = true;
            show();
            break;
          }
          case "blur": {
            triggerFocused = false;
            hide2();
            break;
          }
        }
      };
      const triggerEventsMap = {
        click: ["onClick"],
        hover: ["onMouseenter", "onMouseleave"],
        focus: ["onFocus", "onBlur"]
      };
      const mapEvents = (t) => {
        triggerEventsMap[t].forEach((event) => {
          events[event] = popperEventsHandler;
        });
      };
      if (shared2.isArray(props2.trigger)) {
        Object.values(props2.trigger).forEach(mapEvents);
      } else {
        mapEvents(props2.trigger);
      }
    }
    vue2.watch(popperOptions$1$1, (val) => {
      if (!popperInstance)
        return;
      popperInstance.setOptions(val);
      popperInstance.update();
    });
    vue2.watch(visibility, onVisibilityChange);
    return {
      update: update3,
      doDestroy,
      show,
      hide: hide2,
      onPopperMouseEnter,
      onPopperMouseLeave,
      onAfterEnter: () => {
        emit("after-enter");
      },
      onAfterLeave: () => {
        detachPopper();
        emit("after-leave");
      },
      onBeforeEnter: () => {
        emit("before-enter");
      },
      onBeforeLeave: () => {
        emit("before-leave");
      },
      initializePopper,
      isManualMode,
      arrowRef,
      events,
      popperId,
      popperInstance,
      popperRef,
      popperStyle,
      triggerRef: triggerRef2,
      visibility
    };
  }
  exports.Effect = defaults2.Effect;
  exports.DEFAULT_TRIGGER = DEFAULT_TRIGGER2;
  exports.UPDATE_VISIBLE_EVENT = UPDATE_VISIBLE_EVENT2;
  exports["default"] = usePopper2;
})(usePopper);
var renderers = {};
var popper$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var dom2 = dom$8;
  function renderPopper2(props2, children) {
    const {
      effect: effect2,
      name,
      stopPopperMouseEvent,
      popperClass,
      popperStyle,
      popperRef,
      pure,
      popperId,
      visibility,
      onMouseenter,
      onMouseleave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave
    } = props2;
    const kls = [popperClass, "el-popper", `is-${effect2}`, pure ? "is-pure" : ""];
    const mouseUpAndDown = stopPopperMouseEvent ? dom2.stop : shared2.NOOP;
    return vue2.h(vue2.Transition, {
      name,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave
    }, {
      default: vue2.withCtx(() => [
        vue2.withDirectives(vue2.h("div", {
          "aria-hidden": String(!visibility),
          class: kls,
          style: popperStyle != null ? popperStyle : {},
          id: popperId,
          ref: popperRef != null ? popperRef : "popperRef",
          role: "tooltip",
          onMouseenter,
          onMouseleave,
          onClick: dom2.stop,
          onMousedown: mouseUpAndDown,
          onMouseup: mouseUpAndDown
        }, children), [[vue2.vShow, visibility]])
      ])
    });
  }
  exports["default"] = renderPopper2;
})(popper$2);
var trigger$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var error2 = error$5;
  var vnode2 = vnode$1;
  function renderTrigger2(trigger2, extraProps) {
    const firstElement = vnode2.getFirstValidNode(trigger2, 1);
    if (!firstElement)
      error2.throwError("renderTrigger", "trigger expects single rooted node");
    return vue2.cloneVNode(firstElement, extraProps, true);
  }
  exports["default"] = renderTrigger2;
})(trigger$2);
var arrow$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  function renderArrow2(showArrow) {
    return showArrow ? vue2.h("div", {
      ref: "arrowRef",
      class: "el-popper__arrow",
      "data-popper-arrow": ""
    }, null) : vue2.h(vue2.Comment, null, "");
  }
  exports["default"] = renderArrow2;
})(arrow$2);
Object.defineProperty(renderers, "__esModule", { value: true });
var popper$1 = popper$2;
var trigger$1 = trigger$2;
var arrow$1 = arrow$2;
renderers.renderPopper = popper$1["default"];
renderers.renderTrigger = trigger$1["default"];
renderers.renderArrow = arrow$1["default"];
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var error2 = error$5;
  var index2 = usePopper;
  var defaults2 = defaults$d;
  var arrow2 = arrow$2;
  var popper2 = popper$2;
  var trigger2 = trigger$2;
  var index$110 = clickOutside;
  const compName = "ElPopper";
  const UPDATE_VISIBLE_EVENT2 = "update:visible";
  var script2 = vue2.defineComponent({
    name: compName,
    props: defaults2["default"],
    emits: [
      UPDATE_VISIBLE_EVENT2,
      "after-enter",
      "after-leave",
      "before-enter",
      "before-leave"
    ],
    setup(props2, ctx) {
      if (!ctx.slots.trigger) {
        error2.throwError(compName, "Trigger must be provided");
      }
      const popperStates = index2["default"](props2, ctx);
      const forceDestroy = () => popperStates.doDestroy(true);
      vue2.onMounted(popperStates.initializePopper);
      vue2.onBeforeUnmount(forceDestroy);
      vue2.onActivated(popperStates.initializePopper);
      vue2.onDeactivated(forceDestroy);
      return popperStates;
    },
    render() {
      var _a;
      const {
        $slots,
        appendToBody,
        class: kls,
        style,
        effect: effect2,
        hide: hide2,
        onPopperMouseEnter,
        onPopperMouseLeave,
        onAfterEnter,
        onAfterLeave,
        onBeforeEnter,
        onBeforeLeave,
        popperClass,
        popperId,
        popperStyle,
        pure,
        showArrow,
        transition,
        visibility,
        stopPopperMouseEvent
      } = this;
      const isManual = this.isManualMode();
      const arrow$12 = arrow2["default"](showArrow);
      const popper$12 = popper2["default"]({
        effect: effect2,
        name: transition,
        popperClass,
        popperId,
        popperStyle,
        pure,
        stopPopperMouseEvent,
        onMouseenter: onPopperMouseEnter,
        onMouseleave: onPopperMouseLeave,
        onAfterEnter,
        onAfterLeave,
        onBeforeEnter,
        onBeforeLeave,
        visibility
      }, [
        vue2.renderSlot($slots, "default", {}, () => {
          return [vue2.toDisplayString(this.content)];
        }),
        arrow$12
      ]);
      const _t = (_a = $slots.trigger) == null ? void 0 : _a.call($slots);
      const triggerProps = __spreadValues({
        "aria-describedby": popperId,
        class: kls,
        style,
        ref: "triggerRef"
      }, this.events);
      const trigger$12 = isManual ? trigger2["default"](_t, triggerProps) : vue2.withDirectives(trigger2["default"](_t, triggerProps), [[index$110["default"], hide2]]);
      return vue2.h(vue2.Fragment, null, [
        trigger$12,
        vue2.h(vue2.Teleport, {
          to: "body",
          disabled: !appendToBody
        }, [popper$12])
      ]);
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$c);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$c;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/popper/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$f);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var defaults2 = defaults$d;
  var index2 = usePopper;
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$c;
  var popper2 = popper$2;
  var trigger2 = trigger$2;
  var arrow2 = arrow$2;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  const _Popper2 = index_vue_vue_type_script_lang2["default"];
  const ElPopper = _Popper2;
  exports.Effect = defaults2.Effect;
  exports.popperDefaultProps = defaults2["default"];
  exports.usePopper = index2["default"];
  exports.renderPopper = popper2["default"];
  exports.renderTrigger = trigger2["default"];
  exports.renderArrow = arrow2["default"];
  exports.ElPopper = ElPopper;
  exports["default"] = _Popper2;
})(popper$3);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var debounce2 = debounce_1;
  var util2 = util$l;
  var constants2 = constants$f;
  var error2 = error$5;
  var index$110 = input$2;
  var index$22 = scrollbar$3;
  var index2 = popper$3;
  var index$32 = icon$4;
  var iconsVue2 = require$$3;
  var index$42 = clickOutside;
  var index$52 = useAttrs$1;
  var defaults2 = defaults$d;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var debounce__default2 = /* @__PURE__ */ _interopDefaultLegacy2(debounce2);
  var script2 = vue2.defineComponent({
    name: "ElAutocomplete",
    components: {
      ElPopper: index2["default"],
      ElInput: index$110.ElInput,
      ElScrollbar: index$22.ElScrollbar,
      ElIcon: index$32.ElIcon,
      Loading: iconsVue2.Loading
    },
    directives: {
      clickoutside: index$42["default"]
    },
    inheritAttrs: false,
    props: {
      valueKey: {
        type: String,
        default: "value"
      },
      modelValue: {
        type: [String, Number],
        default: ""
      },
      debounce: {
        type: Number,
        default: 300
      },
      placement: {
        type: String,
        validator: (val) => {
          return [
            "top",
            "top-start",
            "top-end",
            "bottom",
            "bottom-start",
            "bottom-end"
          ].includes(val);
        },
        default: "bottom-start"
      },
      fetchSuggestions: {
        type: Function,
        default: shared2.NOOP
      },
      popperClass: {
        type: String,
        default: ""
      },
      triggerOnFocus: {
        type: Boolean,
        default: true
      },
      selectWhenUnmatched: {
        type: Boolean,
        default: false
      },
      hideLoading: {
        type: Boolean,
        default: false
      },
      popperAppendToBody: {
        type: Boolean,
        default: true
      },
      highlightFirstItem: {
        type: Boolean,
        default: false
      }
    },
    emits: [
      constants2.UPDATE_MODEL_EVENT,
      "input",
      "change",
      "focus",
      "blur",
      "clear",
      "select"
    ],
    setup(props2, ctx) {
      const attrs = index$52.useAttrs();
      const suggestions = vue2.ref([]);
      const highlightedIndex = vue2.ref(-1);
      const dropdownWidth = vue2.ref("");
      const activated = vue2.ref(false);
      const suggestionDisabled = vue2.ref(false);
      const loading2 = vue2.ref(false);
      const inputRef = vue2.ref(null);
      const regionRef = vue2.ref(null);
      const popper2 = vue2.ref(null);
      const id = vue2.computed(() => {
        return `el-autocomplete-${util2.generateId()}`;
      });
      const suggestionVisible = vue2.computed(() => {
        const isValidData = shared2.isArray(suggestions.value) && suggestions.value.length > 0;
        return (isValidData || loading2.value) && activated.value;
      });
      const suggestionLoading = vue2.computed(() => {
        return !props2.hideLoading && loading2.value;
      });
      const updatePopperPosition = () => {
        vue2.nextTick(popper2.value.update);
      };
      vue2.watch(suggestionVisible, () => {
        dropdownWidth.value = `${inputRef.value.$el.offsetWidth}px`;
      });
      vue2.onMounted(() => {
        inputRef.value.inputOrTextarea.setAttribute("role", "textbox");
        inputRef.value.inputOrTextarea.setAttribute("aria-autocomplete", "list");
        inputRef.value.inputOrTextarea.setAttribute("aria-controls", "id");
        inputRef.value.inputOrTextarea.setAttribute("aria-activedescendant", `${id.value}-item-${highlightedIndex.value}`);
        const $ul = regionRef.value.querySelector(".el-autocomplete-suggestion__list");
        $ul.setAttribute("role", "listbox");
        $ul.setAttribute("id", id.value);
      });
      vue2.onUpdated(updatePopperPosition);
      const getData = (queryString) => {
        if (suggestionDisabled.value) {
          return;
        }
        loading2.value = true;
        updatePopperPosition();
        props2.fetchSuggestions(queryString, (suggestionsArg) => {
          loading2.value = false;
          if (suggestionDisabled.value) {
            return;
          }
          if (shared2.isArray(suggestionsArg)) {
            suggestions.value = suggestionsArg;
            highlightedIndex.value = props2.highlightFirstItem ? 0 : -1;
          } else {
            error2.throwError("ElAutocomplete", "autocomplete suggestions must be an array");
          }
        });
      };
      const debouncedGetData = debounce__default2["default"](getData, props2.debounce);
      const handleInput = (value) => {
        ctx.emit("input", value);
        ctx.emit(constants2.UPDATE_MODEL_EVENT, value);
        suggestionDisabled.value = false;
        if (!props2.triggerOnFocus && !value) {
          suggestionDisabled.value = true;
          suggestions.value = [];
          return;
        }
        debouncedGetData(value);
      };
      const handleChange = (value) => {
        ctx.emit("change", value);
      };
      const handleFocus = (e) => {
        activated.value = true;
        ctx.emit("focus", e);
        if (props2.triggerOnFocus) {
          debouncedGetData(props2.modelValue);
        }
      };
      const handleBlur = (e) => {
        ctx.emit("blur", e);
      };
      const handleClear = () => {
        activated.value = false;
        ctx.emit(constants2.UPDATE_MODEL_EVENT, "");
        ctx.emit("clear");
      };
      const handleKeyEnter = () => {
        if (suggestionVisible.value && highlightedIndex.value >= 0 && highlightedIndex.value < suggestions.value.length) {
          select2(suggestions.value[highlightedIndex.value]);
        } else if (props2.selectWhenUnmatched) {
          ctx.emit("select", { value: props2.modelValue });
          vue2.nextTick(() => {
            suggestions.value = [];
            highlightedIndex.value = -1;
          });
        }
      };
      const close2 = () => {
        activated.value = false;
      };
      const focus = () => {
        inputRef.value.focus();
      };
      const select2 = (item2) => {
        ctx.emit("input", item2[props2.valueKey]);
        ctx.emit(constants2.UPDATE_MODEL_EVENT, item2[props2.valueKey]);
        ctx.emit("select", item2);
        vue2.nextTick(() => {
          suggestions.value = [];
          highlightedIndex.value = -1;
        });
      };
      const highlight = (index3) => {
        if (!suggestionVisible.value || loading2.value) {
          return;
        }
        if (index3 < 0) {
          highlightedIndex.value = -1;
          return;
        }
        if (index3 >= suggestions.value.length) {
          index3 = suggestions.value.length - 1;
        }
        const suggestion = regionRef.value.querySelector(".el-autocomplete-suggestion__wrap");
        const suggestionList = suggestion.querySelectorAll(".el-autocomplete-suggestion__list li");
        const highlightItem = suggestionList[index3];
        const scrollTop = suggestion.scrollTop;
        const { offsetTop, scrollHeight } = highlightItem;
        if (offsetTop + scrollHeight > scrollTop + suggestion.clientHeight) {
          suggestion.scrollTop += scrollHeight;
        }
        if (offsetTop < scrollTop) {
          suggestion.scrollTop -= scrollHeight;
        }
        highlightedIndex.value = index3;
        inputRef.value.inputOrTextarea.setAttribute("aria-activedescendant", `${id.value}-item-${highlightedIndex.value}`);
      };
      return {
        Effect: defaults2.Effect,
        attrs,
        suggestions,
        highlightedIndex,
        dropdownWidth,
        activated,
        suggestionDisabled,
        loading: loading2,
        inputRef,
        regionRef,
        popper: popper2,
        id,
        suggestionVisible,
        suggestionLoading,
        getData,
        handleInput,
        handleChange,
        handleFocus,
        handleBlur,
        handleClear,
        handleKeyEnter,
        close: close2,
        focus,
        select: select2,
        highlight
      };
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$d);
var index_vue_vue_type_template_id_2f09f285_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_2f09f285_lang, "__esModule", { value: true });
var vue$2h = require$$0$1;
const _hoisted_1$1j = ["aria-expanded", "aria-owns"];
const _hoisted_2$X = { key: 0 };
const _hoisted_3$L = ["id", "aria-selected", "onClick"];
function render$1L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = vue$2h.resolveComponent("el-input");
  const _component_loading = vue$2h.resolveComponent("loading");
  const _component_el_icon = vue$2h.resolveComponent("el-icon");
  const _component_el_scrollbar = vue$2h.resolveComponent("el-scrollbar");
  const _component_el_popper = vue$2h.resolveComponent("el-popper");
  const _directive_clickoutside = vue$2h.resolveDirective("clickoutside");
  return vue$2h.openBlock(), vue$2h.createBlock(_component_el_popper, {
    ref: "popper",
    visible: _ctx.suggestionVisible,
    "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => _ctx.suggestionVisible = $event),
    placement: _ctx.placement,
    "fallback-placements": ["bottom-start", "top-start"],
    "popper-class": `el-autocomplete__popper ${_ctx.popperClass}`,
    "append-to-body": _ctx.popperAppendToBody,
    pure: "",
    "manual-mode": "",
    effect: _ctx.Effect.LIGHT,
    trigger: "click",
    transition: "el-zoom-in-top",
    "gpu-acceleration": false
  }, {
    trigger: vue$2h.withCtx(() => [
      vue$2h.withDirectives(vue$2h.createElementVNode("div", {
        class: vue$2h.normalizeClass(["el-autocomplete", _ctx.$attrs.class]),
        style: vue$2h.normalizeStyle(_ctx.$attrs.style),
        role: "combobox",
        "aria-haspopup": "listbox",
        "aria-expanded": _ctx.suggestionVisible,
        "aria-owns": _ctx.id
      }, [
        vue$2h.createVNode(_component_el_input, vue$2h.mergeProps({ ref: "inputRef" }, _ctx.attrs, {
          "model-value": _ctx.modelValue,
          onInput: _ctx.handleInput,
          onChange: _ctx.handleChange,
          onFocus: _ctx.handleFocus,
          onBlur: _ctx.handleBlur,
          onClear: _ctx.handleClear,
          onKeydown: [
            _cache[0] || (_cache[0] = vue$2h.withKeys(vue$2h.withModifiers(($event) => _ctx.highlight(_ctx.highlightedIndex - 1), ["prevent"]), ["up"])),
            _cache[1] || (_cache[1] = vue$2h.withKeys(vue$2h.withModifiers(($event) => _ctx.highlight(_ctx.highlightedIndex + 1), ["prevent"]), ["down"])),
            vue$2h.withKeys(_ctx.handleKeyEnter, ["enter"]),
            vue$2h.withKeys(_ctx.close, ["tab"])
          ]
        }), vue$2h.createSlots({ _: 2 }, [
          _ctx.$slots.prepend ? {
            name: "prepend",
            fn: vue$2h.withCtx(() => [
              vue$2h.renderSlot(_ctx.$slots, "prepend")
            ])
          } : void 0,
          _ctx.$slots.append ? {
            name: "append",
            fn: vue$2h.withCtx(() => [
              vue$2h.renderSlot(_ctx.$slots, "append")
            ])
          } : void 0,
          _ctx.$slots.prefix ? {
            name: "prefix",
            fn: vue$2h.withCtx(() => [
              vue$2h.renderSlot(_ctx.$slots, "prefix")
            ])
          } : void 0,
          _ctx.$slots.suffix ? {
            name: "suffix",
            fn: vue$2h.withCtx(() => [
              vue$2h.renderSlot(_ctx.$slots, "suffix")
            ])
          } : void 0
        ]), 1040, ["model-value", "onInput", "onChange", "onFocus", "onBlur", "onClear", "onKeydown"])
      ], 14, _hoisted_1$1j), [
        [_directive_clickoutside, _ctx.close]
      ])
    ]),
    default: vue$2h.withCtx(() => [
      vue$2h.createElementVNode("div", {
        ref: "regionRef",
        class: vue$2h.normalizeClass([
          "el-autocomplete-suggestion",
          _ctx.suggestionLoading && "is-loading"
        ]),
        style: vue$2h.normalizeStyle({ minWidth: _ctx.dropdownWidth, outline: "none" }),
        role: "region"
      }, [
        vue$2h.createVNode(_component_el_scrollbar, {
          tag: "ul",
          "wrap-class": "el-autocomplete-suggestion__wrap",
          "view-class": "el-autocomplete-suggestion__list"
        }, {
          default: vue$2h.withCtx(() => [
            _ctx.suggestionLoading ? (vue$2h.openBlock(), vue$2h.createElementBlock("li", _hoisted_2$X, [
              vue$2h.createVNode(_component_el_icon, { class: "is-loading" }, {
                default: vue$2h.withCtx(() => [
                  vue$2h.createVNode(_component_loading)
                ]),
                _: 1
              })
            ])) : (vue$2h.openBlock(true), vue$2h.createElementBlock(vue$2h.Fragment, { key: 1 }, vue$2h.renderList(_ctx.suggestions, (item2, index2) => {
              return vue$2h.openBlock(), vue$2h.createElementBlock("li", {
                id: `${_ctx.id}-item-${index2}`,
                key: index2,
                class: vue$2h.normalizeClass({ highlighted: _ctx.highlightedIndex === index2 }),
                role: "option",
                "aria-selected": _ctx.highlightedIndex === index2,
                onClick: ($event) => _ctx.select(item2)
              }, [
                vue$2h.renderSlot(_ctx.$slots, "default", { item: item2 }, () => [
                  vue$2h.createTextVNode(vue$2h.toDisplayString(item2[_ctx.valueKey]), 1)
                ])
              ], 10, _hoisted_3$L);
            }), 128))
          ]),
          _: 3
        })
      ], 6)
    ]),
    _: 3
  }, 8, ["visible", "placement", "popper-class", "append-to-body", "effect"]);
}
index_vue_vue_type_template_id_2f09f285_lang.render = render$1L;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$d;
  var index_vue_vue_type_template_id_2f09f285_lang$1 = index_vue_vue_type_template_id_2f09f285_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_2f09f285_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/autocomplete/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$g);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$d;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  const _Autocomplete = index_vue_vue_type_script_lang2["default"];
  const ElAutocomplete = _Autocomplete;
  exports.ElAutocomplete = ElAutocomplete;
  exports["default"] = _Autocomplete;
})(autocomplete);
var avatar$2 = {};
var avatar2 = {};
var avatar_vue_vue_type_script_lang = {};
var avatar$1 = {};
Object.defineProperty(avatar$1, "__esModule", { value: true });
var props$C = props$N;
const avatarProps = props$C.buildProps({
  size: {
    type: [Number, String],
    values: ["large", "medium", "small"],
    default: "large",
    validator: (val) => typeof val === "number"
  },
  shape: {
    type: String,
    values: ["circle", "square"],
    default: "circle"
  },
  icon: {
    type: props$C.definePropType([String, Object])
  },
  src: {
    type: String,
    default: ""
  },
  alt: String,
  srcSet: String,
  fit: {
    type: props$C.definePropType(String),
    default: "cover"
  }
});
const avatarEmits = {
  error: (evt) => evt instanceof Event
};
avatar$1.avatarEmits = avatarEmits;
avatar$1.avatarProps = avatarProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var avatar3 = avatar$1;
  var script2 = vue2.defineComponent({
    name: "ElAvatar",
    components: {
      ElIcon: index2.ElIcon
    },
    props: avatar3.avatarProps,
    emits: avatar3.avatarEmits,
    setup(props2, { emit }) {
      const hasLoadError = vue2.ref(false);
      const avatarClass = vue2.computed(() => {
        const { size: size2, icon: icon3, shape } = props2;
        const classList = ["el-avatar"];
        if (size2 && typeof size2 === "string")
          classList.push(`el-avatar--${size2}`);
        if (icon3)
          classList.push("el-avatar--icon");
        if (shape)
          classList.push(`el-avatar--${shape}`);
        return classList;
      });
      const sizeStyle = vue2.computed(() => {
        const { size: size2 } = props2;
        return typeof size2 === "number" ? {
          height: `${size2}px`,
          width: `${size2}px`,
          lineHeight: `${size2}px`
        } : {};
      });
      const fitStyle = vue2.computed(() => ({
        objectFit: props2.fit
      }));
      vue2.watch(() => props2.src, () => hasLoadError.value = false);
      function handleError2(e) {
        hasLoadError.value = true;
        emit("error", e);
      }
      return {
        hasLoadError,
        avatarClass,
        sizeStyle,
        fitStyle,
        handleError: handleError2
      };
    }
  });
  exports["default"] = script2;
})(avatar_vue_vue_type_script_lang);
var avatar_vue_vue_type_template_id_46e3f365_lang = {};
Object.defineProperty(avatar_vue_vue_type_template_id_46e3f365_lang, "__esModule", { value: true });
var vue$2g = require$$0$1;
const _hoisted_1$1i = ["src", "alt", "srcset"];
function render$1K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$2g.resolveComponent("el-icon");
  return vue$2g.openBlock(), vue$2g.createElementBlock("span", {
    class: vue$2g.normalizeClass(_ctx.avatarClass),
    style: vue$2g.normalizeStyle(_ctx.sizeStyle)
  }, [
    (_ctx.src || _ctx.srcSet) && !_ctx.hasLoadError ? (vue$2g.openBlock(), vue$2g.createElementBlock("img", {
      key: 0,
      src: _ctx.src,
      alt: _ctx.alt,
      srcset: _ctx.srcSet,
      style: vue$2g.normalizeStyle(_ctx.fitStyle),
      onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args))
    }, null, 44, _hoisted_1$1i)) : _ctx.icon ? (vue$2g.openBlock(), vue$2g.createBlock(_component_el_icon, { key: 1 }, {
      default: vue$2g.withCtx(() => [
        (vue$2g.openBlock(), vue$2g.createBlock(vue$2g.resolveDynamicComponent(_ctx.icon)))
      ]),
      _: 1
    })) : vue$2g.renderSlot(_ctx.$slots, "default", { key: 2 })
  ], 6);
}
avatar_vue_vue_type_template_id_46e3f365_lang.render = render$1K;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var avatar_vue_vue_type_script_lang$1 = avatar_vue_vue_type_script_lang;
  var avatar_vue_vue_type_template_id_46e3f365_lang$1 = avatar_vue_vue_type_template_id_46e3f365_lang;
  avatar_vue_vue_type_script_lang$1["default"].render = avatar_vue_vue_type_template_id_46e3f365_lang$1.render;
  avatar_vue_vue_type_script_lang$1["default"].__file = "packages/components/avatar/src/avatar.vue";
  exports["default"] = avatar_vue_vue_type_script_lang$1["default"];
})(avatar2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var avatar3 = avatar$1;
  var avatar_vue_vue_type_script_lang$1 = avatar_vue_vue_type_script_lang;
  const ElAvatar = withInstall2.withInstall(avatar_vue_vue_type_script_lang$1["default"]);
  exports.avatarEmits = avatar3.avatarEmits;
  exports.avatarProps = avatar3.avatarProps;
  exports.ElAvatar = ElAvatar;
  exports["default"] = ElAvatar;
})(avatar$2);
var backtop$2 = {};
var backtop2 = {};
var backtop_vue_vue_type_script_lang = {};
var animation = {};
Object.defineProperty(animation, "__esModule", { value: true });
const cubic = (value) => Math.pow(value, 3);
const easeInOutCubic = (value) => value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2;
animation.cubic = cubic;
animation.easeInOutCubic = easeInOutCubic;
var backtop$1 = {};
Object.defineProperty(backtop$1, "__esModule", { value: true });
const backtopProps = {
  visibilityHeight: {
    type: Number,
    default: 200
  },
  target: {
    type: String,
    default: ""
  },
  right: {
    type: Number,
    default: 40
  },
  bottom: {
    type: Number,
    default: 40
  }
};
const backtopEmits = {
  click: (evt) => evt instanceof MouseEvent
};
backtop$1.backtopEmits = backtopEmits;
backtop$1.backtopProps = backtopProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var index2 = icon$4;
  var animation$1 = animation;
  var error2 = error$5;
  var iconsVue2 = require$$3;
  var backtop3 = backtop$1;
  const COMPONENT_NAME = "ElBacktop";
  var script2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    components: {
      ElIcon: index2.ElIcon,
      CaretTop: iconsVue2.CaretTop
    },
    props: backtop3.backtopProps,
    emits: backtop3.backtopEmits,
    setup(props2, { emit }) {
      const el = vue2.shallowRef(document.documentElement);
      const container2 = vue2.shallowRef(document);
      const visible = vue2.ref(false);
      const styleBottom = vue2.computed(() => `${props2.bottom}px`);
      const styleRight = vue2.computed(() => `${props2.right}px`);
      const scrollToTop = () => {
        if (!el.value)
          return;
        const beginTime = Date.now();
        const beginValue = el.value.scrollTop;
        const frameFunc = () => {
          if (!el.value)
            return;
          const progress3 = (Date.now() - beginTime) / 500;
          if (progress3 < 1) {
            el.value.scrollTop = beginValue * (1 - animation$1.easeInOutCubic(progress3));
            requestAnimationFrame(frameFunc);
          } else {
            el.value.scrollTop = 0;
          }
        };
        requestAnimationFrame(frameFunc);
      };
      const handleScroll = () => {
        if (el.value)
          visible.value = el.value.scrollTop >= props2.visibilityHeight;
      };
      const handleClick = (event) => {
        scrollToTop();
        emit("click", event);
      };
      const handleScrollThrottled = core2.useThrottleFn(handleScroll, 300);
      vue2.onMounted(() => {
        var _a;
        if (props2.target) {
          el.value = (_a = document.querySelector(props2.target)) != null ? _a : void 0;
          if (!el.value) {
            error2.throwError(COMPONENT_NAME, `target is not existed: ${props2.target}`);
          }
          container2.value = el.value;
        }
        core2.useEventListener(container2, "scroll", handleScrollThrottled);
      });
      return {
        visible,
        styleBottom,
        styleRight,
        handleClick
      };
    }
  });
  exports["default"] = script2;
})(backtop_vue_vue_type_script_lang);
var backtop_vue_vue_type_template_id_63a7fea6_lang = {};
Object.defineProperty(backtop_vue_vue_type_template_id_63a7fea6_lang, "__esModule", { value: true });
var vue$2f = require$$0$1;
function render$1J(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_caret_top = vue$2f.resolveComponent("caret-top");
  const _component_el_icon = vue$2f.resolveComponent("el-icon");
  return vue$2f.openBlock(), vue$2f.createBlock(vue$2f.Transition, { name: "el-fade-in" }, {
    default: vue$2f.withCtx(() => [
      _ctx.visible ? (vue$2f.openBlock(), vue$2f.createElementBlock("div", {
        key: 0,
        style: vue$2f.normalizeStyle({
          right: _ctx.styleRight,
          bottom: _ctx.styleBottom
        }),
        class: "el-backtop",
        onClick: _cache[0] || (_cache[0] = vue$2f.withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"]))
      }, [
        vue$2f.renderSlot(_ctx.$slots, "default", {}, () => [
          vue$2f.createVNode(_component_el_icon, { class: "el-backtop__icon" }, {
            default: vue$2f.withCtx(() => [
              vue$2f.createVNode(_component_caret_top)
            ]),
            _: 1
          })
        ])
      ], 4)) : vue$2f.createCommentVNode("v-if", true)
    ]),
    _: 3
  });
}
backtop_vue_vue_type_template_id_63a7fea6_lang.render = render$1J;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var backtop_vue_vue_type_script_lang$1 = backtop_vue_vue_type_script_lang;
  var backtop_vue_vue_type_template_id_63a7fea6_lang$1 = backtop_vue_vue_type_template_id_63a7fea6_lang;
  backtop_vue_vue_type_script_lang$1["default"].render = backtop_vue_vue_type_template_id_63a7fea6_lang$1.render;
  backtop_vue_vue_type_script_lang$1["default"].__file = "packages/components/backtop/src/backtop.vue";
  exports["default"] = backtop_vue_vue_type_script_lang$1["default"];
})(backtop2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var backtop3 = backtop$1;
  var backtop_vue_vue_type_script_lang$1 = backtop_vue_vue_type_script_lang;
  const ElBacktop = withInstall2.withInstall(backtop_vue_vue_type_script_lang$1["default"]);
  exports.backtopEmits = backtop3.backtopEmits;
  exports.backtopProps = backtop3.backtopProps;
  exports.ElBacktop = ElBacktop;
  exports["default"] = ElBacktop;
})(backtop$2);
var badge$2 = {};
var badge2 = {};
var badge_vue_vue_type_script_lang = {};
var badge$1 = {};
Object.defineProperty(badge$1, "__esModule", { value: true });
var props$B = props$N;
const badgeProps = props$B.buildProps({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
});
badge$1.badgeProps = badgeProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var badge3 = badge$1;
  var script2 = vue2.defineComponent({
    name: "ElBadge",
    props: badge3.badgeProps,
    setup(props2) {
      const content = vue2.computed(() => {
        if (props2.isDot)
          return "";
        if (typeof props2.value === "number" && typeof props2.max === "number") {
          return props2.max < props2.value ? `${props2.max}+` : `${props2.value}`;
        }
        return `${props2.value}`;
      });
      return {
        content
      };
    }
  });
  exports["default"] = script2;
})(badge_vue_vue_type_script_lang);
var badge_vue_vue_type_template_id_020a5517_lang = {};
Object.defineProperty(badge_vue_vue_type_template_id_020a5517_lang, "__esModule", { value: true });
var vue$2e = require$$0$1;
const _hoisted_1$1h = { class: "el-badge" };
const _hoisted_2$W = ["textContent"];
function render$1I(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$2e.openBlock(), vue$2e.createElementBlock("div", _hoisted_1$1h, [
    vue$2e.renderSlot(_ctx.$slots, "default"),
    vue$2e.createVNode(vue$2e.Transition, { name: "el-zoom-in-center" }, {
      default: vue$2e.withCtx(() => [
        vue$2e.withDirectives(vue$2e.createElementVNode("sup", {
          class: vue$2e.normalizeClass(["el-badge__content", [
            "el-badge__content--" + _ctx.type,
            {
              "is-fixed": _ctx.$slots.default,
              "is-dot": _ctx.isDot
            }
          ]]),
          textContent: vue$2e.toDisplayString(_ctx.content)
        }, null, 10, _hoisted_2$W), [
          [vue$2e.vShow, !_ctx.hidden && (_ctx.content || _ctx.content === "0" || _ctx.isDot)]
        ])
      ]),
      _: 1
    })
  ]);
}
badge_vue_vue_type_template_id_020a5517_lang.render = render$1I;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var badge_vue_vue_type_script_lang$1 = badge_vue_vue_type_script_lang;
  var badge_vue_vue_type_template_id_020a5517_lang$1 = badge_vue_vue_type_template_id_020a5517_lang;
  badge_vue_vue_type_script_lang$1["default"].render = badge_vue_vue_type_template_id_020a5517_lang$1.render;
  badge_vue_vue_type_script_lang$1["default"].__file = "packages/components/badge/src/badge.vue";
  exports["default"] = badge_vue_vue_type_script_lang$1["default"];
})(badge2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var badge3 = badge$1;
  var badge_vue_vue_type_script_lang$1 = badge_vue_vue_type_script_lang;
  const ElBadge = withInstall2.withInstall(badge_vue_vue_type_script_lang$1["default"]);
  exports.badgeProps = badge3.badgeProps;
  exports.ElBadge = ElBadge;
  exports["default"] = ElBadge;
})(badge$2);
var breadcrumb$2 = {};
var breadcrumb2 = {};
var breadcrumb_vue_vue_type_script_lang = {};
var breadcrumb$1 = {};
Object.defineProperty(breadcrumb$1, "__esModule", { value: true });
var props$A = props$N;
const breadcrumbProps = props$A.buildProps({
  separator: {
    type: String,
    default: "/"
  },
  separatorIcon: {
    type: props$A.definePropType([String, Object]),
    default: ""
  }
});
breadcrumb$1.breadcrumbProps = breadcrumbProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var breadcrumb3 = breadcrumb$1;
  var breadcrumb$1$1 = breadcrumb$3;
  var script2 = vue2.defineComponent({
    name: "ElBreadcrumb",
    props: breadcrumb3.breadcrumbProps,
    setup(props2) {
      const breadcrumb4 = vue2.ref();
      vue2.provide(breadcrumb$1$1.elBreadcrumbKey, props2);
      vue2.onMounted(() => {
        const items = breadcrumb4.value.querySelectorAll(".el-breadcrumb__item");
        if (items.length) {
          items[items.length - 1].setAttribute("aria-current", "page");
        }
      });
      return {
        breadcrumb: breadcrumb4
      };
    }
  });
  exports["default"] = script2;
})(breadcrumb_vue_vue_type_script_lang);
var breadcrumb_vue_vue_type_template_id_b67a42b6_lang = {};
Object.defineProperty(breadcrumb_vue_vue_type_template_id_b67a42b6_lang, "__esModule", { value: true });
var vue$2d = require$$0$1;
const _hoisted_1$1g = {
  ref: "breadcrumb",
  class: "el-breadcrumb",
  "aria-label": "Breadcrumb",
  role: "navigation"
};
function render$1H(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$2d.openBlock(), vue$2d.createElementBlock("div", _hoisted_1$1g, [
    vue$2d.renderSlot(_ctx.$slots, "default")
  ], 512);
}
breadcrumb_vue_vue_type_template_id_b67a42b6_lang.render = render$1H;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var breadcrumb_vue_vue_type_script_lang$1 = breadcrumb_vue_vue_type_script_lang;
  var breadcrumb_vue_vue_type_template_id_b67a42b6_lang$1 = breadcrumb_vue_vue_type_template_id_b67a42b6_lang;
  breadcrumb_vue_vue_type_script_lang$1["default"].render = breadcrumb_vue_vue_type_template_id_b67a42b6_lang$1.render;
  breadcrumb_vue_vue_type_script_lang$1["default"].__file = "packages/components/breadcrumb/src/breadcrumb.vue";
  exports["default"] = breadcrumb_vue_vue_type_script_lang$1["default"];
})(breadcrumb2);
var breadcrumbItem2 = {};
var breadcrumbItem_vue_vue_type_script_lang = {};
var breadcrumbItem$1 = {};
Object.defineProperty(breadcrumbItem$1, "__esModule", { value: true });
var props$z = props$N;
const breadcrumbItemProps = props$z.buildProps({
  to: {
    type: props$z.definePropType([String, Object]),
    default: ""
  },
  replace: {
    type: Boolean,
    default: false
  }
});
breadcrumbItem$1.breadcrumbItemProps = breadcrumbItemProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var breadcrumbItem3 = breadcrumbItem$1;
  var breadcrumb3 = breadcrumb$3;
  const COMPONENT_NAME = "ElBreadcrumbItem";
  var script2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    components: {
      ElIcon: index2.ElIcon
    },
    props: breadcrumbItem3.breadcrumbItemProps,
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const router = instance.appContext.config.globalProperties.$router;
      const parent = vue2.inject(breadcrumb3.elBreadcrumbKey, void 0);
      const link3 = vue2.ref();
      vue2.onMounted(() => {
        link3.value.setAttribute("role", "link");
        link3.value.addEventListener("click", () => {
          if (!props2.to || !router)
            return;
          props2.replace ? router.replace(props2.to) : router.push(props2.to);
        });
      });
      return {
        link: link3,
        separator: parent == null ? void 0 : parent.separator,
        separatorIcon: parent == null ? void 0 : parent.separatorIcon
      };
    }
  });
  exports["default"] = script2;
})(breadcrumbItem_vue_vue_type_script_lang);
var breadcrumbItem_vue_vue_type_template_id_2f37792a_lang = {};
Object.defineProperty(breadcrumbItem_vue_vue_type_template_id_2f37792a_lang, "__esModule", { value: true });
var vue$2c = require$$0$1;
const _hoisted_1$1f = { class: "el-breadcrumb__item" };
const _hoisted_2$V = {
  key: 1,
  class: "el-breadcrumb__separator",
  role: "presentation"
};
function render$1G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$2c.resolveComponent("el-icon");
  return vue$2c.openBlock(), vue$2c.createElementBlock("span", _hoisted_1$1f, [
    vue$2c.createElementVNode("span", {
      ref: "link",
      class: vue$2c.normalizeClass(["el-breadcrumb__inner", _ctx.to ? "is-link" : ""]),
      role: "link"
    }, [
      vue$2c.renderSlot(_ctx.$slots, "default")
    ], 2),
    _ctx.separatorIcon ? (vue$2c.openBlock(), vue$2c.createBlock(_component_el_icon, {
      key: 0,
      class: "el-breadcrumb__separator"
    }, {
      default: vue$2c.withCtx(() => [
        (vue$2c.openBlock(), vue$2c.createBlock(vue$2c.resolveDynamicComponent(_ctx.separatorIcon)))
      ]),
      _: 1
    })) : (vue$2c.openBlock(), vue$2c.createElementBlock("span", _hoisted_2$V, vue$2c.toDisplayString(_ctx.separator), 1))
  ]);
}
breadcrumbItem_vue_vue_type_template_id_2f37792a_lang.render = render$1G;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var breadcrumbItem_vue_vue_type_script_lang$1 = breadcrumbItem_vue_vue_type_script_lang;
  var breadcrumbItem_vue_vue_type_template_id_2f37792a_lang$1 = breadcrumbItem_vue_vue_type_template_id_2f37792a_lang;
  breadcrumbItem_vue_vue_type_script_lang$1["default"].render = breadcrumbItem_vue_vue_type_template_id_2f37792a_lang$1.render;
  breadcrumbItem_vue_vue_type_script_lang$1["default"].__file = "packages/components/breadcrumb/src/breadcrumb-item.vue";
  exports["default"] = breadcrumbItem_vue_vue_type_script_lang$1["default"];
})(breadcrumbItem2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var breadcrumb3 = breadcrumb$1;
  var breadcrumbItem3 = breadcrumbItem$1;
  var breadcrumb_vue_vue_type_script_lang$1 = breadcrumb_vue_vue_type_script_lang;
  var breadcrumbItem_vue_vue_type_script_lang$1 = breadcrumbItem_vue_vue_type_script_lang;
  const ElBreadcrumb = withInstall2.withInstall(breadcrumb_vue_vue_type_script_lang$1["default"], {
    BreadcrumbItem: breadcrumbItem_vue_vue_type_script_lang$1["default"]
  });
  const ElBreadcrumbItem = withInstall2.withNoopInstall(breadcrumbItem_vue_vue_type_script_lang$1["default"]);
  exports.breadcrumbProps = breadcrumb3.breadcrumbProps;
  exports.breadcrumbItemProps = breadcrumbItem3.breadcrumbItemProps;
  exports.ElBreadcrumb = ElBreadcrumb;
  exports.ElBreadcrumbItem = ElBreadcrumbItem;
  exports["default"] = ElBreadcrumb;
})(breadcrumb$2);
var button$5 = {};
var button2 = {};
var button_vue_vue_type_script_lang$1 = {};
var color$1 = {};
Object.defineProperty(color$1, "__esModule", { value: true });
function calcColorChannels(c2) {
  let rawColor = c2.trim().replace("#", "");
  if (/^[0-9a-fA-F]{3}$/.test(rawColor)) {
    rawColor = rawColor[0].repeat(2) + rawColor[1].repeat(2) + rawColor[2].repeat(2);
  }
  if (/^[0-9a-fA-F]{6}$/.test(rawColor)) {
    return {
      red: parseInt(rawColor.slice(0, 2), 16),
      green: parseInt(rawColor.slice(2, 4), 16),
      blue: parseInt(rawColor.slice(4, 6), 16)
    };
  }
  return {
    red: 255,
    green: 255,
    blue: 255
  };
}
function mixColor(color2, percent = 0.2) {
  let { red, green, blue } = calcColorChannels(color2);
  if (percent > 0) {
    red *= 1 - percent;
    green *= 1 - percent;
    blue *= 1 - percent;
  } else {
    const value = Math.abs(percent);
    red += (255 - red) * Math.abs(percent);
    green += (255 - green) * value;
    blue += (255 - blue) * value;
  }
  return `rgb(${Math.round(red)}, ${Math.round(green)}, ${Math.round(blue)})`;
}
function lighten(color2, percent = 0.2) {
  return mixColor(color2, -percent);
}
function darken(color2, percent = 0.2) {
  return mixColor(color2, percent);
}
color$1.calcColorChannels = calcColorChannels;
color$1.darken = darken;
color$1.lighten = lighten;
color$1.mixColor = mixColor;
var button$4 = {};
Object.defineProperty(button$4, "__esModule", { value: true });
var props$y = props$N;
var index$1h = useCommonProps;
const buttonType = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
];
const buttonSize = ["", "large", "medium", "small", "mini"];
const buttonNativeType = ["button", "submit", "reset"];
const buttonProps = props$y.buildProps({
  size: index$1h.useSizeProp,
  disabled: Boolean,
  type: {
    type: String,
    values: buttonType,
    default: ""
  },
  icon: {
    type: props$y.definePropType([String, Object]),
    default: ""
  },
  nativeType: {
    type: String,
    values: buttonNativeType,
    default: "button"
  },
  loading: Boolean,
  plain: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  }
});
const buttonEmits = {
  click: (evt) => evt instanceof MouseEvent
};
button$4.buttonEmits = buttonEmits;
button$4.buttonNativeType = buttonNativeType;
button$4.buttonProps = buttonProps;
button$4.buttonSize = buttonSize;
button$4.buttonType = buttonType;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var color2 = color$1;
  var button3 = button$4;
  var button$12 = button$6;
  var index$110 = useGlobalConfig$1;
  var index$22 = useFormItem$1;
  var index$32 = useCommonProps;
  var script2 = vue2.defineComponent({
    name: "ElButton",
    components: {
      ElIcon: index2.ElIcon,
      Loading: iconsVue2.Loading
    },
    props: button3.buttonProps,
    emits: button3.buttonEmits,
    setup(props2, { emit, slots }) {
      const buttonRef = vue2.ref();
      const buttonGroupContext = vue2.inject(button$12.buttonGroupContextKey, void 0);
      const globalConfig = index$110.useGlobalConfig("button");
      const autoInsertSpace = vue2.computed(() => {
        var _a, _b, _c;
        return (_c = (_b = props2.autoInsertSpace) != null ? _b : (_a = globalConfig.value) == null ? void 0 : _a.autoInsertSpace) != null ? _c : false;
      });
      const shouldAddSpace = vue2.computed(() => {
        var _a;
        const defaultSlot = (_a = slots.default) == null ? void 0 : _a.call(slots);
        if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
          const slot = defaultSlot[0];
          if ((slot == null ? void 0 : slot.type) === vue2.Text) {
            const text = slot.children;
            return /^\p{Unified_Ideograph}{2}$/u.test(text);
          }
        }
        return false;
      });
      const { form: form2 } = index$22.useFormItem();
      const buttonSize2 = index$32.useSize(vue2.computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
      const buttonDisabled = index$32.useDisabled();
      const buttonType2 = vue2.computed(() => props2.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "default");
      const typeColor = vue2.computed(() => core2.useCssVar(`--el-color-${props2.type}`).value);
      const buttonStyle = vue2.computed(() => {
        let styles = {};
        const buttonColor = props2.color || typeColor.value;
        if (buttonColor) {
          const darkenBgColor = color2.darken(buttonColor, 0.1);
          if (props2.plain) {
            styles = {
              "--el-button-bg-color": color2.lighten(buttonColor, 0.9),
              "--el-button-text-color": buttonColor,
              "--el-button-hover-text-color": "var(--el-color-white)",
              "--el-button-hover-bg-color": buttonColor,
              "--el-button-hover-border-color": buttonColor,
              "--el-button-active-bg-color": darkenBgColor,
              "--el-button-active-text-color": "var(--el-color-white)",
              "--el-button-active-border-color": darkenBgColor
            };
          } else {
            const lightenBgColor = color2.lighten(buttonColor);
            styles = {
              "--el-button-bg-color": buttonColor,
              "--el-button-border-color": buttonColor,
              "--el-button-hover-bg-color": lightenBgColor,
              "--el-button-hover-border-color": lightenBgColor,
              "--el-button-active-bg-color": darkenBgColor,
              "--el-button-active-border-color": darkenBgColor
            };
          }
          if (buttonDisabled.value) {
            const disabledButtonColor = color2.lighten(buttonColor, 0.5);
            styles["--el-button-disabled-bg-color"] = disabledButtonColor;
            styles["--el-button-disabled-border-color"] = disabledButtonColor;
          }
        }
        return styles;
      });
      const handleClick = (evt) => {
        if (props2.nativeType === "reset") {
          form2 == null ? void 0 : form2.resetFields();
        }
        emit("click", evt);
      };
      return {
        buttonRef,
        buttonStyle,
        buttonSize: buttonSize2,
        buttonType: buttonType2,
        buttonDisabled,
        shouldAddSpace,
        handleClick
      };
    }
  });
  exports["default"] = script2;
})(button_vue_vue_type_script_lang$1);
var button_vue_vue_type_template_id_802c5c76_lang = {};
Object.defineProperty(button_vue_vue_type_template_id_802c5c76_lang, "__esModule", { value: true });
var vue$2b = require$$0$1;
const _hoisted_1$1e = ["disabled", "autofocus", "type"];
function render$1F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_loading = vue$2b.resolveComponent("loading");
  const _component_el_icon = vue$2b.resolveComponent("el-icon");
  return vue$2b.openBlock(), vue$2b.createElementBlock("button", {
    ref: "buttonRef",
    class: vue$2b.normalizeClass([
      "el-button",
      _ctx.buttonType ? "el-button--" + _ctx.buttonType : "",
      _ctx.buttonSize ? "el-button--" + _ctx.buttonSize : "",
      {
        "is-disabled": _ctx.buttonDisabled,
        "is-loading": _ctx.loading,
        "is-plain": _ctx.plain,
        "is-round": _ctx.round,
        "is-circle": _ctx.circle
      }
    ]),
    disabled: _ctx.buttonDisabled || _ctx.loading,
    autofocus: _ctx.autofocus,
    type: _ctx.nativeType,
    style: vue$2b.normalizeStyle(_ctx.buttonStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.loading ? (vue$2b.openBlock(), vue$2b.createBlock(_component_el_icon, {
      key: 0,
      class: "is-loading"
    }, {
      default: vue$2b.withCtx(() => [
        vue$2b.createVNode(_component_loading)
      ]),
      _: 1
    })) : _ctx.icon ? (vue$2b.openBlock(), vue$2b.createBlock(_component_el_icon, { key: 1 }, {
      default: vue$2b.withCtx(() => [
        (vue$2b.openBlock(), vue$2b.createBlock(vue$2b.resolveDynamicComponent(_ctx.icon)))
      ]),
      _: 1
    })) : vue$2b.createCommentVNode("v-if", true),
    _ctx.$slots.default ? (vue$2b.openBlock(), vue$2b.createElementBlock("span", {
      key: 2,
      class: vue$2b.normalizeClass({ "el-button__text--expand": _ctx.shouldAddSpace })
    }, [
      vue$2b.renderSlot(_ctx.$slots, "default")
    ], 2)) : vue$2b.createCommentVNode("v-if", true)
  ], 14, _hoisted_1$1e);
}
button_vue_vue_type_template_id_802c5c76_lang.render = render$1F;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var button_vue_vue_type_script_lang2 = button_vue_vue_type_script_lang$1;
  var button_vue_vue_type_template_id_802c5c76_lang$1 = button_vue_vue_type_template_id_802c5c76_lang;
  button_vue_vue_type_script_lang2["default"].render = button_vue_vue_type_template_id_802c5c76_lang$1.render;
  button_vue_vue_type_script_lang2["default"].__file = "packages/components/button/src/button.vue";
  exports["default"] = button_vue_vue_type_script_lang2["default"];
})(button2);
var buttonGroup2 = {};
var buttonGroup_vue_vue_type_script_lang = {};
var buttonGroup = {};
Object.defineProperty(buttonGroup, "__esModule", { value: true });
var button$3 = button$4;
const buttonGroupProps = {
  size: button$3.buttonProps.size,
  type: button$3.buttonProps.type
};
buttonGroup.buttonGroupProps = buttonGroupProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var buttonGroup$1 = buttonGroup;
  var button3 = button$6;
  var script2 = vue2.defineComponent({
    name: "ElButtonGroup",
    props: buttonGroup$1.buttonGroupProps,
    setup(props2) {
      vue2.provide(button3.buttonGroupContextKey, vue2.reactive({
        size: vue2.toRef(props2, "size"),
        type: vue2.toRef(props2, "type")
      }));
    }
  });
  exports["default"] = script2;
})(buttonGroup_vue_vue_type_script_lang);
var buttonGroup_vue_vue_type_template_id_1bab7d77_lang = {};
Object.defineProperty(buttonGroup_vue_vue_type_template_id_1bab7d77_lang, "__esModule", { value: true });
var vue$2a = require$$0$1;
const _hoisted_1$1d = { class: "el-button-group" };
function render$1E(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$2a.openBlock(), vue$2a.createElementBlock("div", _hoisted_1$1d, [
    vue$2a.renderSlot(_ctx.$slots, "default")
  ]);
}
buttonGroup_vue_vue_type_template_id_1bab7d77_lang.render = render$1E;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var buttonGroup_vue_vue_type_script_lang$1 = buttonGroup_vue_vue_type_script_lang;
  var buttonGroup_vue_vue_type_template_id_1bab7d77_lang$1 = buttonGroup_vue_vue_type_template_id_1bab7d77_lang;
  buttonGroup_vue_vue_type_script_lang$1["default"].render = buttonGroup_vue_vue_type_template_id_1bab7d77_lang$1.render;
  buttonGroup_vue_vue_type_script_lang$1["default"].__file = "packages/components/button/src/button-group.vue";
  exports["default"] = buttonGroup_vue_vue_type_script_lang$1["default"];
})(buttonGroup2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var button3 = button$4;
  var button_vue_vue_type_script_lang2 = button_vue_vue_type_script_lang$1;
  var buttonGroup_vue_vue_type_script_lang$1 = buttonGroup_vue_vue_type_script_lang;
  const ElButton = withInstall2.withInstall(button_vue_vue_type_script_lang2["default"], {
    ButtonGroup: buttonGroup_vue_vue_type_script_lang$1["default"]
  });
  const ElButtonGroup = withInstall2.withNoopInstall(buttonGroup_vue_vue_type_script_lang$1["default"]);
  exports.buttonEmits = button3.buttonEmits;
  exports.buttonNativeType = button3.buttonNativeType;
  exports.buttonProps = button3.buttonProps;
  exports.buttonSize = button3.buttonSize;
  exports.buttonType = button3.buttonType;
  exports.ElButton = ElButton;
  exports.ElButtonGroup = ElButtonGroup;
  exports["default"] = ElButton;
})(button$5);
var calendar$2 = {};
var calendar2 = {};
var calendar_vue_vue_type_script_lang = {};
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", $ = "Invalid Date", l2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m2 = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, g = { s: m2, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date())
        return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f2), s3 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s3 ? -1 : 1), f2);
      return +(-(r2 + (n2 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === void 0;
    } }, D2 = "en", v2 = {};
    v2[D2] = M2;
    var p2 = function(t2) {
      return t2 instanceof _2;
    }, S2 = function(t2, e2, n2) {
      var r2;
      if (!t2)
        return D2;
      if (typeof t2 == "string")
        v2[t2] && (r2 = t2), e2 && (v2[t2] = e2, r2 = t2);
      else {
        var i2 = t2.name;
        v2[i2] = t2, r2 = i2;
      }
      return !n2 && r2 && (D2 = r2), r2 || !n2 && D2;
    }, w2 = function(t2, e2) {
      if (p2(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _2(n2);
    }, O2 = g;
    O2.l = S2, O2.i = p2, O2.w = function(t2, e2) {
      return w2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _2 = function() {
      function M3(t2) {
        this.$L = S2(t2.locale, null, true), this.parse(t2);
      }
      var m3 = M3.prototype;
      return m3.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (e2 === null)
            return new Date(NaN);
          if (O2.u(e2))
            return new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match(l2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m3.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m3.$utils = function() {
        return O2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === $);
      }, m3.isSame = function(t2, e2) {
        var n2 = w2(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m3.isAfter = function(t2, e2) {
        return w2(t2) < this.startOf(e2);
      }, m3.isBefore = function(t2, e2) {
        return this.endOf(e2) < w2(t2);
      }, m3.$g = function(t2, e2, n2) {
        return O2.u(t2) ? this[e2] : this.set(n2, t2);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O2.u(e2) || e2, h3 = O2.p(t2), $2 = function(t3, e3) {
          var i2 = O2.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a2);
        }, l3 = function(t3, e3) {
          return O2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M4 = this.$M, m4 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c2:
            return r2 ? $2(1, 0) : $2(31, 11);
          case f2:
            return r2 ? $2(1, M4) : $2(0, M4 + 1);
          case o2:
            var D3 = this.$locale().weekStart || 0, v3 = (y2 < D3 ? y2 + 7 : y2) - D3;
            return $2(r2 ? m4 - v3 : m4 + (6 - v3), M4);
          case a2:
          case d2:
            return l3(g2 + "Hours", 0);
          case u2:
            return l3(g2 + "Minutes", 1);
          case s2:
            return l3(g2 + "Seconds", 2);
          case i:
            return l3(g2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m3.$set = function(t2, e2) {
        var n2, o3 = O2.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a2] = h3 + "Date", n2[d2] = h3 + "Date", n2[f2] = h3 + "Month", n2[c2] = h3 + "FullYear", n2[u2] = h3 + "Hours", n2[s2] = h3 + "Minutes", n2[i] = h3 + "Seconds", n2[r] = h3 + "Milliseconds", n2)[o3], l3 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
        if (o3 === f2 || o3 === c2) {
          var y2 = this.clone().set(d2, 1);
          y2.$d[$2](l3), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          $2 && this.$d[$2](l3);
        return this.init(), this;
      }, m3.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m3.get = function(t2) {
        return this[O2.p(t2)]();
      }, m3.add = function(r2, h3) {
        var d3, $2 = this;
        r2 = Number(r2);
        var l3 = O2.p(h3), y2 = function(t2) {
          var e2 = w2($2);
          return O2.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
        };
        if (l3 === f2)
          return this.set(f2, this.$M + r2);
        if (l3 === c2)
          return this.set(c2, this.$y + r2);
        if (l3 === a2)
          return y2(1);
        if (l3 === o2)
          return y2(7);
        var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n, d3[i] = t, d3)[l3] || 1, m4 = this.$d.getTime() + r2 * M4;
        return O2.w(m4, this);
      }, m3.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m3.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || $;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n2.weekdays, f3 = n2.months, h3 = function(t3, n3, i3, s4) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].substr(0, s4);
        }, c3 = function(t3) {
          return O2.s(s3 % 12 || 12, t3, "0");
        }, d3 = n2.meridiem || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, l3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n2.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n2.weekdaysMin, this.$W, o3, 2), ddd: h3(n2.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y, function(t3, e3) {
          return e3 || l3[t3] || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r2, d3, $2) {
        var l3, y2 = O2.p(d3), M4 = w2(r2), m4 = (M4.utcOffset() - this.utcOffset()) * e, g2 = this - M4, D3 = O2.m(this, M4);
        return D3 = (l3 = {}, l3[c2] = D3 / 12, l3[f2] = D3, l3[h2] = D3 / 3, l3[o2] = (g2 - m4) / 6048e5, l3[a2] = (g2 - m4) / 864e5, l3[u2] = g2 / n, l3[s2] = g2 / e, l3[i] = g2 / t, l3)[y2] || g2, $2 ? D3 : O2.a(D3);
      }, m3.daysInMonth = function() {
        return this.endOf(f2).$D;
      }, m3.$locale = function() {
        return v2[this.$L];
      }, m3.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S2(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m3.clone = function() {
        return O2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), b2 = _2.prototype;
    return w2.prototype = b2, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t2) {
      b2[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w2.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _2, w2), t2.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t2) {
      return w2(1e3 * t2);
    }, w2.en = v2[D2], w2.Ls = v2, w2.p = {}, w2;
  });
})(dayjs_min);
var dateTable2 = {};
var dateTable_vue_vue_type_script_lang = {};
var localeData = { exports: {} };
(function(module, exports) {
  !function(n, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    return function(n, e, t) {
      var r = e.prototype, o2 = function(n2) {
        return n2 && (n2.indexOf ? n2 : n2.s);
      }, u2 = function(n2, e2, t2, r2, u3) {
        var i2 = n2.name ? n2 : n2.$locale(), a3 = o2(i2[e2]), s3 = o2(i2[t2]), f2 = a3 || s3.map(function(n3) {
          return n3.substr(0, r2);
        });
        if (!u3)
          return f2;
        var d2 = i2.weekStart;
        return f2.map(function(n3, e3) {
          return f2[(e3 + (d2 || 0)) % 7];
        });
      }, i = function() {
        return t.Ls[t.locale()];
      }, a2 = function(n2, e2) {
        return n2.formats[e2] || function(n3) {
          return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
            return e3 || t2.slice(1);
          });
        }(n2.formats[e2.toUpperCase()]);
      }, s2 = function() {
        var n2 = this;
        return { months: function(e2) {
          return e2 ? e2.format("MMMM") : u2(n2, "months");
        }, monthsShort: function(e2) {
          return e2 ? e2.format("MMM") : u2(n2, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return n2.$locale().weekStart || 0;
        }, weekdays: function(e2) {
          return e2 ? e2.format("dddd") : u2(n2, "weekdays");
        }, weekdaysMin: function(e2) {
          return e2 ? e2.format("dd") : u2(n2, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(e2) {
          return e2 ? e2.format("ddd") : u2(n2, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(e2) {
          return a2(n2.$locale(), e2);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r.localeData = function() {
        return s2.bind(this)();
      }, t.localeData = function() {
        var n2 = i();
        return { firstDayOfWeek: function() {
          return n2.weekStart || 0;
        }, weekdays: function() {
          return t.weekdays();
        }, weekdaysShort: function() {
          return t.weekdaysShort();
        }, weekdaysMin: function() {
          return t.weekdaysMin();
        }, months: function() {
          return t.months();
        }, monthsShort: function() {
          return t.monthsShort();
        }, longDateFormat: function(e2) {
          return a2(n2, e2);
        }, meridiem: n2.meridiem, ordinal: n2.ordinal };
      }, t.months = function() {
        return u2(i(), "months");
      }, t.monthsShort = function() {
        return u2(i(), "monthsShort", "months", 3);
      }, t.weekdays = function(n2) {
        return u2(i(), "weekdays", null, null, n2);
      }, t.weekdaysShort = function(n2) {
        return u2(i(), "weekdaysShort", "weekdays", 3, n2);
      }, t.weekdaysMin = function(n2) {
        return u2(i(), "weekdaysMin", "weekdays", 2, n2);
      };
    };
  });
})(localeData);
var timePicker$1 = {};
var timePicker = {};
var customParseFormat = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, e = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^\s\d-_:/()]+/, o2 = {}, s2 = function(t2) {
      return (t2 = +t2) + (t2 > 68 ? 1900 : 2e3);
    };
    var a2 = function(t2) {
      return function(e2) {
        this[t2] = +e2;
      };
    }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(t2) {
      (this.zone || (this.zone = {})).offset = function(t3) {
        if (!t3)
          return 0;
        if (t3 === "Z")
          return 0;
        var e2 = t3.match(/([+-]|\d\d)/g), n2 = 60 * e2[1] + (+e2[2] || 0);
        return n2 === 0 ? 0 : e2[0] === "+" ? -n2 : n2;
      }(t2);
    }], u2 = function(t2) {
      var e2 = o2[t2];
      return e2 && (e2.indexOf ? e2 : e2.s.concat(e2.f));
    }, h2 = function(t2, e2) {
      var n2, r2 = o2.meridiem;
      if (r2) {
        for (var i2 = 1; i2 <= 24; i2 += 1)
          if (t2.indexOf(r2(i2, 0, e2)) > -1) {
            n2 = i2 > 12;
            break;
          }
      } else
        n2 = t2 === (e2 ? "pm" : "PM");
      return n2;
    }, d2 = { A: [i, function(t2) {
      this.afternoon = h2(t2, false);
    }], a: [i, function(t2) {
      this.afternoon = h2(t2, true);
    }], S: [/\d/, function(t2) {
      this.milliseconds = 100 * +t2;
    }], SS: [n, function(t2) {
      this.milliseconds = 10 * +t2;
    }], SSS: [/\d{3}/, function(t2) {
      this.milliseconds = +t2;
    }], s: [r, a2("seconds")], ss: [r, a2("seconds")], m: [r, a2("minutes")], mm: [r, a2("minutes")], H: [r, a2("hours")], h: [r, a2("hours")], HH: [r, a2("hours")], hh: [r, a2("hours")], D: [r, a2("day")], DD: [n, a2("day")], Do: [i, function(t2) {
      var e2 = o2.ordinal, n2 = t2.match(/\d+/);
      if (this.day = n2[0], e2)
        for (var r2 = 1; r2 <= 31; r2 += 1)
          e2(r2).replace(/\[|\]/g, "") === t2 && (this.day = r2);
    }], M: [r, a2("month")], MM: [n, a2("month")], MMM: [i, function(t2) {
      var e2 = u2("months"), n2 = (u2("monthsShort") || e2.map(function(t3) {
        return t3.substr(0, 3);
      })).indexOf(t2) + 1;
      if (n2 < 1)
        throw new Error();
      this.month = n2 % 12 || n2;
    }], MMMM: [i, function(t2) {
      var e2 = u2("months").indexOf(t2) + 1;
      if (e2 < 1)
        throw new Error();
      this.month = e2 % 12 || e2;
    }], Y: [/[+-]?\d+/, a2("year")], YY: [n, function(t2) {
      this.year = s2(t2);
    }], YYYY: [/\d{4}/, a2("year")], Z: f2, ZZ: f2 };
    function c2(n2) {
      var r2, i2;
      r2 = n2, i2 = o2 && o2.formats;
      for (var s3 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(e2, n3, r3) {
        var o3 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || t[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(t2, e3, n4) {
          return e3 || n4.slice(1);
        });
      })).match(e), a3 = s3.length, f3 = 0; f3 < a3; f3 += 1) {
        var u3 = s3[f3], h3 = d2[u3], c3 = h3 && h3[0], l2 = h3 && h3[1];
        s3[f3] = l2 ? { regex: c3, parser: l2 } : u3.replace(/^\[|\]$/g, "");
      }
      return function(t2) {
        for (var e2 = {}, n3 = 0, r3 = 0; n3 < a3; n3 += 1) {
          var i3 = s3[n3];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var o3 = i3.regex, f4 = i3.parser, u4 = t2.substr(r3), h4 = o3.exec(u4)[0];
            f4.call(e2, h4), t2 = t2.replace(h4, "");
          }
        }
        return function(t3) {
          var e3 = t3.afternoon;
          if (e3 !== void 0) {
            var n4 = t3.hours;
            e3 ? n4 < 12 && (t3.hours += 12) : n4 === 12 && (t3.hours = 0), delete t3.afternoon;
          }
        }(e2), e2;
      };
    }
    return function(t2, e2, n2) {
      n2.p.customParseFormat = true, t2 && t2.parseTwoDigitYear && (s2 = t2.parseTwoDigitYear);
      var r2 = e2.prototype, i2 = r2.parse;
      r2.parse = function(t3) {
        var e3 = t3.date, r3 = t3.utc, s3 = t3.args;
        this.$u = r3;
        var a3 = s3[1];
        if (typeof a3 == "string") {
          var f3 = s3[2] === true, u3 = s3[3] === true, h3 = f3 || u3, d3 = s3[2];
          u3 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n2.Ls[d3]), this.$d = function(t4, e4, n3) {
            try {
              if (["x", "X"].indexOf(e4) > -1)
                return new Date((e4 === "X" ? 1e3 : 1) * t4);
              var r4 = c2(e4)(t4), i3 = r4.year, o3 = r4.month, s4 = r4.day, a4 = r4.hours, f4 = r4.minutes, u4 = r4.seconds, h4 = r4.milliseconds, d4 = r4.zone, l3 = new Date(), m3 = s4 || (i3 || o3 ? 1 : l3.getDate()), M3 = i3 || l3.getFullYear(), Y = 0;
              i3 && !o3 || (Y = o3 > 0 ? o3 - 1 : l3.getMonth());
              var p2 = a4 || 0, v2 = f4 || 0, D2 = u4 || 0, g = h4 || 0;
              return d4 ? new Date(Date.UTC(M3, Y, m3, p2, v2, D2, g + 60 * d4.offset * 1e3)) : n3 ? new Date(Date.UTC(M3, Y, m3, p2, v2, D2, g)) : new Date(M3, Y, m3, p2, v2, D2, g);
            } catch (t5) {
              return new Date("");
            }
          }(e3, a3, r3), this.init(), d3 && d3 !== true && (this.$L = this.locale(d3).$L), h3 && e3 != this.format(a3) && (this.$d = new Date("")), o2 = {};
        } else if (a3 instanceof Array)
          for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
            s3[1] = a3[m2 - 1];
            var M2 = n2.apply(this, s3);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m2 === l2 && (this.$d = new Date(""));
          }
        else
          i2.call(this, t3);
      };
    };
  });
})(customParseFormat);
var constant$3 = {};
Object.defineProperty(constant$3, "__esModule", { value: true });
const DEFAULT_FORMATS_TIME = "HH:mm:ss";
const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
const DEFAULT_FORMATS_DATEPICKER = {
  date: DEFAULT_FORMATS_DATE,
  week: "gggg[w]ww",
  year: "YYYY",
  month: "YYYY-MM",
  datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
  monthrange: "YYYY-MM",
  daterange: DEFAULT_FORMATS_DATE,
  datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
};
constant$3.DEFAULT_FORMATS_DATE = DEFAULT_FORMATS_DATE;
constant$3.DEFAULT_FORMATS_DATEPICKER = DEFAULT_FORMATS_DATEPICKER;
constant$3.DEFAULT_FORMATS_TIME = DEFAULT_FORMATS_TIME;
var picker = {};
var picker_vue_vue_type_script_lang$1 = {};
var baseIsEqual = _baseIsEqual;
function isEqual$2(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual$2;
var props$x = {};
var validators$6 = {};
Object.defineProperty(validators$6, "__esModule", { value: true });
var util$e = util$l;
const isValidWidthUnit = (val) => {
  if (util$e.isNumber(val)) {
    return true;
  } else {
    return ["px", "rem", "em", "vw", "%", "vmin", "vmax"].some((unit) => val.endsWith(unit)) || val.startsWith("calc");
  }
};
const isValidComponentSize = (val) => ["", "large", "medium", "small", "mini"].includes(val);
const isValidDatePickType = (val) => [
  "year",
  "month",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange"
].includes(val);
validators$6.isValidComponentSize = isValidComponentSize;
validators$6.isValidDatePickType = isValidDatePickType;
validators$6.isValidWidthUnit = isValidWidthUnit;
Object.defineProperty(props$x, "__esModule", { value: true });
var validators$5 = validators$6;
var iconsVue$6 = require$$3;
const timePickerDefaultProps = {
  name: {
    type: [Array, String],
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: {
    type: String
  },
  valueFormat: {
    type: String
  },
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: [String, Object],
    default: iconsVue$6.CircleClose
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: [String, Object],
    default: ""
  },
  size: {
    type: String,
    validator: validators$5.isValidComponentSize
  },
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  modelValue: {
    type: [Date, Array, String],
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: [Date, Array]
  },
  defaultTime: {
    type: [Date, Array]
  },
  isRange: {
    type: Boolean,
    default: false
  },
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  },
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: {
    type: Boolean,
    default: false
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean
};
props$x.timePickerDefaultProps = timePickerDefaultProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var isEqual2 = isEqual_1;
  var index2 = input$2;
  var index$22 = icon$4;
  var index$110 = popper$3;
  var aria2 = aria$5;
  var util2 = util$l;
  var iconsVue2 = require$$3;
  var props2 = props$x;
  var index$32 = clickOutside;
  var index$42 = useLocale$1;
  var form2 = form$7;
  var index$52 = useCommonProps;
  var defaults2 = defaults$d;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var isEqual__default2 = /* @__PURE__ */ _interopDefaultLegacy2(isEqual2);
  const dateEquals = function(a2, b2) {
    const aIsDate = a2 instanceof Date;
    const bIsDate = b2 instanceof Date;
    if (aIsDate && bIsDate) {
      return a2.getTime() === b2.getTime();
    }
    if (!aIsDate && !bIsDate) {
      return a2 === b2;
    }
    return false;
  };
  const valueEquals = function(a2, b2) {
    const aIsArray = a2 instanceof Array;
    const bIsArray = b2 instanceof Array;
    if (aIsArray && bIsArray) {
      if (a2.length !== b2.length) {
        return false;
      }
      return a2.every((item2, index3) => dateEquals(item2, b2[index3]));
    }
    if (!aIsArray && !bIsArray) {
      return dateEquals(a2, b2);
    }
    return false;
  };
  const parser = function(date4, format2, lang) {
    const day = util2.isEmpty(format2) ? dayjs__default["default"](date4).locale(lang) : dayjs__default["default"](date4, format2).locale(lang);
    return day.isValid() ? day : void 0;
  };
  const formatter = function(date4, format2, lang) {
    return util2.isEmpty(format2) ? date4 : dayjs__default["default"](date4).locale(lang).format(format2);
  };
  var script2 = vue2.defineComponent({
    name: "Picker",
    components: {
      ElInput: index2.ElInput,
      ElPopper: index$110["default"],
      ElIcon: index$22.ElIcon
    },
    directives: { clickoutside: index$32["default"] },
    props: props2.timePickerDefaultProps,
    emits: ["update:modelValue", "change", "focus", "blur", "calendar-change"],
    setup(props3, ctx) {
      const { lang } = index$42.useLocale();
      const elForm = vue2.inject(form2.elFormKey, {});
      const elFormItem = vue2.inject(form2.elFormItemKey, {});
      const elPopperOptions = vue2.inject("ElPopperOptions", {});
      const refPopper = vue2.ref(null);
      const pickerVisible = vue2.ref(false);
      const pickerActualVisible = vue2.ref(false);
      const valueOnOpen = vue2.ref(null);
      vue2.watch(pickerVisible, (val) => {
        var _a;
        if (!val) {
          userInput.value = null;
          vue2.nextTick(() => {
            emitChange(props3.modelValue);
          });
          ctx.emit("blur");
          blurInput();
          props3.validateEvent && ((_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "blur"));
        } else {
          valueOnOpen.value = props3.modelValue;
        }
      });
      const emitChange = (val, isClear) => {
        var _a;
        if (isClear || !valueEquals(val, valueOnOpen.value)) {
          ctx.emit("change", val);
          props3.validateEvent && ((_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change"));
        }
      };
      const emitInput = (val) => {
        if (!valueEquals(props3.modelValue, val)) {
          let formatValue;
          if (Array.isArray(val)) {
            formatValue = val.map((_2) => formatter(_2, props3.valueFormat, lang.value));
          } else if (val) {
            formatValue = formatter(val, props3.valueFormat, lang.value);
          }
          ctx.emit("update:modelValue", val ? formatValue : val, lang.value);
        }
      };
      const refInput = vue2.computed(() => {
        if (refPopper.value.triggerRef) {
          const _r = isRangeInput.value ? refPopper.value.triggerRef : refPopper.value.triggerRef.$el;
          return [].slice.call(_r.querySelectorAll("input"));
        }
        return [];
      });
      const setSelectionRange = (start2, end2, pos) => {
        const _inputs = refInput.value;
        if (!_inputs.length)
          return;
        if (!pos || pos === "min") {
          _inputs[0].setSelectionRange(start2, end2);
          _inputs[0].focus();
        } else if (pos === "max") {
          _inputs[1].setSelectionRange(start2, end2);
          _inputs[1].focus();
        }
      };
      const onPick = (date4 = "", visible = false) => {
        pickerVisible.value = visible;
        let result3;
        if (Array.isArray(date4)) {
          result3 = date4.map((_2) => _2.toDate());
        } else {
          result3 = date4 ? date4.toDate() : date4;
        }
        userInput.value = null;
        emitInput(result3);
      };
      const handleFocus = (e) => {
        if (props3.readonly || pickerDisabled.value || pickerVisible.value)
          return;
        pickerVisible.value = true;
        ctx.emit("focus", e);
      };
      const handleBlur = () => {
        pickerVisible.value = false;
        blurInput();
      };
      const pickerDisabled = vue2.computed(() => {
        return props3.disabled || elForm.disabled;
      });
      const parsedValue = vue2.computed(() => {
        let result3;
        if (valueIsEmpty.value) {
          if (pickerOptions.value.getDefaultValue) {
            result3 = pickerOptions.value.getDefaultValue();
          }
        } else {
          if (Array.isArray(props3.modelValue)) {
            result3 = props3.modelValue.map((_2) => parser(_2, props3.valueFormat, lang.value));
          } else {
            result3 = parser(props3.modelValue, props3.valueFormat, lang.value);
          }
        }
        if (pickerOptions.value.getRangeAvailableTime) {
          const availableResult = pickerOptions.value.getRangeAvailableTime(result3);
          if (!isEqual__default2["default"](availableResult, result3)) {
            result3 = availableResult;
            emitInput(Array.isArray(result3) ? result3.map((_2) => _2.toDate()) : result3.toDate());
          }
        }
        if (Array.isArray(result3) && result3.some((_2) => !_2)) {
          result3 = [];
        }
        return result3;
      });
      const displayValue = vue2.computed(() => {
        if (!pickerOptions.value.panelReady)
          return;
        const formattedValue = formatDayjsToString(parsedValue.value);
        if (Array.isArray(userInput.value)) {
          return [
            userInput.value[0] || formattedValue && formattedValue[0] || "",
            userInput.value[1] || formattedValue && formattedValue[1] || ""
          ];
        } else if (userInput.value !== null) {
          return userInput.value;
        }
        if (!isTimePicker.value && valueIsEmpty.value)
          return;
        if (!pickerVisible.value && valueIsEmpty.value)
          return;
        if (formattedValue) {
          return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
        }
        return "";
      });
      const isTimeLikePicker = vue2.computed(() => props3.type.includes("time"));
      const isTimePicker = vue2.computed(() => props3.type.startsWith("time"));
      const isDatesPicker = vue2.computed(() => props3.type === "dates");
      const triggerIcon = vue2.computed(() => props3.prefixIcon || (isTimeLikePicker.value ? iconsVue2.Clock : iconsVue2.Calendar));
      const showClose = vue2.ref(false);
      const onClearIconClick = (event) => {
        if (props3.readonly || pickerDisabled.value)
          return;
        if (showClose.value) {
          event.stopPropagation();
          emitInput(null);
          emitChange(null, true);
          showClose.value = false;
          pickerVisible.value = false;
          pickerOptions.value.handleClear && pickerOptions.value.handleClear();
        }
      };
      const valueIsEmpty = vue2.computed(() => {
        return !props3.modelValue || Array.isArray(props3.modelValue) && !props3.modelValue.length;
      });
      const onMouseEnter = () => {
        if (props3.readonly || pickerDisabled.value)
          return;
        if (!valueIsEmpty.value && props3.clearable) {
          showClose.value = true;
        }
      };
      const onMouseLeave = () => {
        showClose.value = false;
      };
      const isRangeInput = vue2.computed(() => {
        return props3.type.indexOf("range") > -1;
      });
      const pickerSize = index$52.useSize();
      const popperPaneRef = vue2.computed(() => {
        var _a;
        return (_a = refPopper.value) == null ? void 0 : _a.popperRef;
      });
      const onClickOutside = () => {
        if (!pickerVisible.value)
          return;
        pickerVisible.value = false;
      };
      const userInput = vue2.ref(null);
      const handleChange = () => {
        if (userInput.value) {
          const value = parseUserInputToDayjs(displayValue.value);
          if (value) {
            if (isValidValue(value)) {
              emitInput(Array.isArray(value) ? value.map((_2) => _2.toDate()) : value.toDate());
              userInput.value = null;
            }
          }
        }
        if (userInput.value === "") {
          emitInput(null);
          emitChange(null);
          userInput.value = null;
        }
      };
      const blurInput = () => {
        refInput.value.forEach((input3) => input3.blur());
      };
      const parseUserInputToDayjs = (value) => {
        if (!value)
          return null;
        return pickerOptions.value.parseUserInput(value);
      };
      const formatDayjsToString = (value) => {
        if (!value)
          return null;
        return pickerOptions.value.formatToString(value);
      };
      const isValidValue = (value) => {
        return pickerOptions.value.isValidValue(value);
      };
      const handleKeydown = (event) => {
        const code2 = event.code;
        if (code2 === aria2.EVENT_CODE.esc) {
          pickerVisible.value = false;
          event.stopPropagation();
          return;
        }
        if (code2 === aria2.EVENT_CODE.tab) {
          if (!isRangeInput.value) {
            handleChange();
            pickerVisible.value = false;
            event.stopPropagation();
          } else {
            setTimeout(() => {
              if (refInput.value.indexOf(document.activeElement) === -1) {
                pickerVisible.value = false;
                blurInput();
              }
            }, 0);
          }
          return;
        }
        if (code2 === aria2.EVENT_CODE.enter || code2 === aria2.EVENT_CODE.numpadEnter) {
          if (userInput.value === null || userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
            handleChange();
            pickerVisible.value = false;
          }
          event.stopPropagation();
          return;
        }
        if (userInput.value) {
          event.stopPropagation();
          return;
        }
        if (pickerOptions.value.handleKeydown) {
          pickerOptions.value.handleKeydown(event);
        }
      };
      const onUserInput = (e) => {
        userInput.value = e;
      };
      const handleStartInput = (event) => {
        if (userInput.value) {
          userInput.value = [event.target.value, userInput.value[1]];
        } else {
          userInput.value = [event.target.value, null];
        }
      };
      const handleEndInput = (event) => {
        if (userInput.value) {
          userInput.value = [userInput.value[0], event.target.value];
        } else {
          userInput.value = [null, event.target.value];
        }
      };
      const handleStartChange = () => {
        const value = parseUserInputToDayjs(userInput.value && userInput.value[0]);
        if (value && value.isValid()) {
          userInput.value = [formatDayjsToString(value), displayValue.value[1]];
          const newValue = [value, parsedValue.value && parsedValue.value[1]];
          if (isValidValue(newValue)) {
            emitInput(newValue);
            userInput.value = null;
          }
        }
      };
      const handleEndChange = () => {
        const value = parseUserInputToDayjs(userInput.value && userInput.value[1]);
        if (value && value.isValid()) {
          userInput.value = [displayValue.value[0], formatDayjsToString(value)];
          const newValue = [parsedValue.value && parsedValue.value[0], value];
          if (isValidValue(newValue)) {
            emitInput(newValue);
            userInput.value = null;
          }
        }
      };
      const pickerOptions = vue2.ref({});
      const onSetPickerOption = (e) => {
        pickerOptions.value[e[0]] = e[1];
        pickerOptions.value.panelReady = true;
      };
      const onCalendarChange = (e) => {
        ctx.emit("calendar-change", e);
      };
      vue2.provide("EP_PICKER_BASE", {
        props: props3
      });
      return {
        Effect: defaults2.Effect,
        elPopperOptions,
        isDatesPicker,
        handleEndChange,
        handleStartChange,
        handleStartInput,
        handleEndInput,
        onUserInput,
        handleChange,
        handleKeydown,
        popperPaneRef,
        onClickOutside,
        pickerSize,
        isRangeInput,
        onMouseLeave,
        onMouseEnter,
        onClearIconClick,
        showClose,
        triggerIcon,
        onPick,
        handleFocus,
        handleBlur,
        pickerVisible,
        pickerActualVisible,
        displayValue,
        parsedValue,
        setSelectionRange,
        refPopper,
        pickerDisabled,
        onSetPickerOption,
        onCalendarChange
      };
    }
  });
  exports["default"] = script2;
})(picker_vue_vue_type_script_lang$1);
var picker_vue_vue_type_template_id_1d54be91_lang = {};
Object.defineProperty(picker_vue_vue_type_template_id_1d54be91_lang, "__esModule", { value: true });
var vue$29 = require$$0$1;
const _hoisted_1$1c = ["name", "placeholder", "value", "disabled", "readonly"];
const _hoisted_2$U = { class: "el-range-separator" };
const _hoisted_3$K = ["name", "placeholder", "value", "disabled", "readonly"];
function render$1D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$29.resolveComponent("el-icon");
  const _component_el_input = vue$29.resolveComponent("el-input");
  const _component_el_popper = vue$29.resolveComponent("el-popper");
  const _directive_clickoutside = vue$29.resolveDirective("clickoutside");
  return vue$29.openBlock(), vue$29.createBlock(_component_el_popper, vue$29.mergeProps({
    ref: "refPopper",
    visible: _ctx.pickerVisible,
    "onUpdate:visible": _cache[15] || (_cache[15] = ($event) => _ctx.pickerVisible = $event),
    "manual-mode": "",
    effect: _ctx.Effect.LIGHT,
    pure: "",
    trigger: "click"
  }, _ctx.$attrs, {
    "popper-class": `el-picker__popper ${_ctx.popperClass}`,
    "popper-options": _ctx.elPopperOptions,
    "fallback-placements": ["bottom", "top", "right", "left"],
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    "stop-popper-mouse-event": false,
    "append-to-body": "",
    onBeforeEnter: _cache[16] || (_cache[16] = ($event) => _ctx.pickerActualVisible = true),
    onAfterLeave: _cache[17] || (_cache[17] = ($event) => _ctx.pickerActualVisible = false)
  }), {
    trigger: vue$29.withCtx(() => [
      !_ctx.isRangeInput ? vue$29.withDirectives((vue$29.openBlock(), vue$29.createBlock(_component_el_input, {
        key: 0,
        "model-value": _ctx.displayValue,
        name: _ctx.name,
        size: _ctx.pickerSize,
        disabled: _ctx.pickerDisabled,
        placeholder: _ctx.placeholder,
        class: vue$29.normalizeClass(["el-date-editor", "el-date-editor--" + _ctx.type]),
        readonly: !_ctx.editable || _ctx.readonly || _ctx.isDatesPicker || _ctx.type === "week",
        onInput: _ctx.onUserInput,
        onFocus: _ctx.handleFocus,
        onKeydown: _ctx.handleKeydown,
        onChange: _ctx.handleChange,
        onMouseenter: _ctx.onMouseEnter,
        onMouseleave: _ctx.onMouseLeave
      }, {
        prefix: vue$29.withCtx(() => [
          _ctx.triggerIcon ? (vue$29.openBlock(), vue$29.createBlock(_component_el_icon, {
            key: 0,
            class: "el-input__icon",
            onClick: _ctx.handleFocus
          }, {
            default: vue$29.withCtx(() => [
              (vue$29.openBlock(), vue$29.createBlock(vue$29.resolveDynamicComponent(_ctx.triggerIcon)))
            ]),
            _: 1
          }, 8, ["onClick"])) : vue$29.createCommentVNode("v-if", true)
        ]),
        suffix: vue$29.withCtx(() => [
          _ctx.showClose && _ctx.clearIcon ? (vue$29.openBlock(), vue$29.createBlock(_component_el_icon, {
            key: 0,
            class: "el-input__icon clear-icon",
            onClick: _ctx.onClearIconClick
          }, {
            default: vue$29.withCtx(() => [
              (vue$29.openBlock(), vue$29.createBlock(vue$29.resolveDynamicComponent(_ctx.clearIcon)))
            ]),
            _: 1
          }, 8, ["onClick"])) : vue$29.createCommentVNode("v-if", true)
        ]),
        _: 1
      }, 8, ["model-value", "name", "size", "disabled", "placeholder", "class", "readonly", "onInput", "onFocus", "onKeydown", "onChange", "onMouseenter", "onMouseleave"])), [
        [_directive_clickoutside, _ctx.onClickOutside, _ctx.popperPaneRef]
      ]) : vue$29.withDirectives((vue$29.openBlock(), vue$29.createElementBlock("div", {
        key: 1,
        class: vue$29.normalizeClass(["el-date-editor el-range-editor el-input__inner", [
          "el-date-editor--" + _ctx.type,
          _ctx.pickerSize ? `el-range-editor--${_ctx.pickerSize}` : "",
          _ctx.pickerDisabled ? "is-disabled" : "",
          _ctx.pickerVisible ? "is-active" : ""
        ]]),
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onMouseenter: _cache[7] || (_cache[7] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[8] || (_cache[8] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onKeydown: _cache[9] || (_cache[9] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }, [
        _ctx.triggerIcon ? (vue$29.openBlock(), vue$29.createBlock(_component_el_icon, {
          key: 0,
          class: "el-input__icon el-range__icon",
          onClick: _ctx.handleFocus
        }, {
          default: vue$29.withCtx(() => [
            (vue$29.openBlock(), vue$29.createBlock(vue$29.resolveDynamicComponent(_ctx.triggerIcon)))
          ]),
          _: 1
        }, 8, ["onClick"])) : vue$29.createCommentVNode("v-if", true),
        vue$29.createElementVNode("input", {
          autocomplete: "off",
          name: _ctx.name && _ctx.name[0],
          placeholder: _ctx.startPlaceholder,
          value: _ctx.displayValue && _ctx.displayValue[0],
          disabled: _ctx.pickerDisabled,
          readonly: !_ctx.editable || _ctx.readonly,
          class: "el-range-input",
          onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleStartInput && _ctx.handleStartInput(...args)),
          onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleStartChange && _ctx.handleStartChange(...args)),
          onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args))
        }, null, 40, _hoisted_1$1c),
        vue$29.renderSlot(_ctx.$slots, "range-separator", {}, () => [
          vue$29.createElementVNode("span", _hoisted_2$U, vue$29.toDisplayString(_ctx.rangeSeparator), 1)
        ]),
        vue$29.createElementVNode("input", {
          autocomplete: "off",
          name: _ctx.name && _ctx.name[1],
          placeholder: _ctx.endPlaceholder,
          value: _ctx.displayValue && _ctx.displayValue[1],
          disabled: _ctx.pickerDisabled,
          readonly: !_ctx.editable || _ctx.readonly,
          class: "el-range-input",
          onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
          onInput: _cache[4] || (_cache[4] = (...args) => _ctx.handleEndInput && _ctx.handleEndInput(...args)),
          onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleEndChange && _ctx.handleEndChange(...args))
        }, null, 40, _hoisted_3$K),
        _ctx.clearIcon ? (vue$29.openBlock(), vue$29.createBlock(_component_el_icon, {
          key: 1,
          class: vue$29.normalizeClass(["el-input__icon el-range__close-icon", {
            "el-range__close-icon--hidden": !_ctx.showClose
          }]),
          onClick: _ctx.onClearIconClick
        }, {
          default: vue$29.withCtx(() => [
            (vue$29.openBlock(), vue$29.createBlock(vue$29.resolveDynamicComponent(_ctx.clearIcon)))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : vue$29.createCommentVNode("v-if", true)
      ], 34)), [
        [_directive_clickoutside, _ctx.onClickOutside, _ctx.popperPaneRef]
      ])
    ]),
    default: vue$29.withCtx(() => [
      vue$29.renderSlot(_ctx.$slots, "default", {
        visible: _ctx.pickerVisible,
        actualVisible: _ctx.pickerActualVisible,
        parsedValue: _ctx.parsedValue,
        format: _ctx.format,
        unlinkPanels: _ctx.unlinkPanels,
        type: _ctx.type,
        defaultValue: _ctx.defaultValue,
        onPick: _cache[10] || (_cache[10] = (...args) => _ctx.onPick && _ctx.onPick(...args)),
        onSelectRange: _cache[11] || (_cache[11] = (...args) => _ctx.setSelectionRange && _ctx.setSelectionRange(...args)),
        onSetPickerOption: _cache[12] || (_cache[12] = (...args) => _ctx.onSetPickerOption && _ctx.onSetPickerOption(...args)),
        onCalendarChange: _cache[13] || (_cache[13] = (...args) => _ctx.onCalendarChange && _ctx.onCalendarChange(...args)),
        onMousedown: _cache[14] || (_cache[14] = vue$29.withModifiers(() => {
        }, ["stop"]))
      })
    ]),
    _: 3
  }, 16, ["visible", "effect", "popper-class", "popper-options"]);
}
picker_vue_vue_type_template_id_1d54be91_lang.render = render$1D;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var picker_vue_vue_type_script_lang2 = picker_vue_vue_type_script_lang$1;
  var picker_vue_vue_type_template_id_1d54be91_lang$1 = picker_vue_vue_type_template_id_1d54be91_lang;
  picker_vue_vue_type_script_lang2["default"].render = picker_vue_vue_type_template_id_1d54be91_lang$1.render;
  picker_vue_vue_type_script_lang2["default"].__file = "packages/components/time-picker/src/common/picker.vue";
  exports["default"] = picker_vue_vue_type_script_lang2["default"];
})(picker);
var panelTimePick = {};
var panelTimePick_vue_vue_type_script_lang$1 = {};
var basicTimeSpinner = {};
var basicTimeSpinner_vue_vue_type_script_lang = {};
var useTimePicker = {};
Object.defineProperty(useTimePicker, "__esModule", { value: true });
var vue$28 = require$$0$1;
const makeList = (total2, method4, methodFunc) => {
  const arr = [];
  const disabledArr = method4 && methodFunc();
  for (let i = 0; i < total2; i++) {
    arr[i] = disabledArr ? disabledArr.includes(i) : false;
  }
  return arr;
};
const makeAvailableArr = (list2) => {
  return list2.map((_2, index2) => !_2 ? index2 : _2).filter((_2) => _2 !== true);
};
const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
  const getHoursList = (role, compare) => {
    return makeList(24, disabledHours, () => disabledHours(role, compare));
  };
  const getMinutesList = (hour, role, compare) => {
    return makeList(60, disabledMinutes, () => disabledMinutes(hour, role, compare));
  };
  const getSecondsList = (hour, minute, role, compare) => {
    return makeList(60, disabledSeconds, () => disabledSeconds(hour, minute, role, compare));
  };
  return {
    getHoursList,
    getMinutesList,
    getSecondsList
  };
};
const getAvailableArrs = (disabledHours, disabledMinutes, disabledSeconds) => {
  const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
  const getAvailableHours = (role, compare) => {
    return makeAvailableArr(getHoursList(role, compare));
  };
  const getAvailableMinutes = (hour, role, compare) => {
    return makeAvailableArr(getMinutesList(hour, role, compare));
  };
  const getAvailableSeconds = (hour, minute, role, compare) => {
    return makeAvailableArr(getSecondsList(hour, minute, role, compare));
  };
  return {
    getAvailableHours,
    getAvailableMinutes,
    getAvailableSeconds
  };
};
const useOldValue = (props2) => {
  const oldValue = vue$28.ref(props2.parsedValue);
  vue$28.watch(() => props2.visible, (val) => {
    if (!val) {
      oldValue.value = props2.parsedValue;
    }
  });
  return oldValue;
};
useTimePicker.getAvailableArrs = getAvailableArrs;
useTimePicker.getTimeLists = getTimeLists;
useTimePicker.useOldValue = useOldValue;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var debounce2 = debounce_1;
  var index$110 = scrollbar$3;
  var index$22 = icon$4;
  var iconsVue2 = require$$3;
  var useTimePicker$1 = useTimePicker;
  var index2 = repeatClick;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var debounce__default2 = /* @__PURE__ */ _interopDefaultLegacy2(debounce2);
  var script2 = vue2.defineComponent({
    directives: {
      repeatClick: index2["default"]
    },
    components: {
      ElScrollbar: index$110.ElScrollbar,
      ElIcon: index$22.ElIcon,
      ArrowUp: iconsVue2.ArrowUp,
      ArrowDown: iconsVue2.ArrowDown
    },
    props: {
      role: {
        type: String,
        required: true
      },
      spinnerDate: {
        type: Object,
        required: true
      },
      showSeconds: {
        type: Boolean,
        default: true
      },
      arrowControl: Boolean,
      amPmMode: {
        type: String,
        default: ""
      },
      disabledHours: {
        type: Function
      },
      disabledMinutes: {
        type: Function
      },
      disabledSeconds: {
        type: Function
      }
    },
    emits: ["change", "select-range", "set-option"],
    setup(props2, ctx) {
      let isScrolling = false;
      const debouncedResetScroll = debounce__default2["default"]((type4) => {
        isScrolling = false;
        adjustCurrentSpinner(type4);
      }, 200);
      const currentScrollbar = vue2.ref(null);
      const listHoursRef = vue2.ref(null);
      const listMinutesRef = vue2.ref(null);
      const listSecondsRef = vue2.ref(null);
      const listRefsMap = {
        hours: listHoursRef,
        minutes: listMinutesRef,
        seconds: listSecondsRef
      };
      const spinnerItems = vue2.computed(() => {
        const arr = ["hours", "minutes", "seconds"];
        return props2.showSeconds ? arr : arr.slice(0, 2);
      });
      const hours = vue2.computed(() => {
        return props2.spinnerDate.hour();
      });
      const minutes = vue2.computed(() => {
        return props2.spinnerDate.minute();
      });
      const seconds = vue2.computed(() => {
        return props2.spinnerDate.second();
      });
      const timePartsMap = vue2.computed(() => ({
        hours,
        minutes,
        seconds
      }));
      const hoursList = vue2.computed(() => {
        return getHoursList(props2.role);
      });
      const minutesList = vue2.computed(() => {
        return getMinutesList(hours.value, props2.role);
      });
      const secondsList = vue2.computed(() => {
        return getSecondsList(hours.value, minutes.value, props2.role);
      });
      const listMap = vue2.computed(() => ({
        hours: hoursList,
        minutes: minutesList,
        seconds: secondsList
      }));
      const arrowHourList = vue2.computed(() => {
        const hour = hours.value;
        return [
          hour > 0 ? hour - 1 : void 0,
          hour,
          hour < 23 ? hour + 1 : void 0
        ];
      });
      const arrowMinuteList = vue2.computed(() => {
        const minute = minutes.value;
        return [
          minute > 0 ? minute - 1 : void 0,
          minute,
          minute < 59 ? minute + 1 : void 0
        ];
      });
      const arrowSecondList = vue2.computed(() => {
        const second = seconds.value;
        return [
          second > 0 ? second - 1 : void 0,
          second,
          second < 59 ? second + 1 : void 0
        ];
      });
      const arrowListMap = vue2.computed(() => ({
        hours: arrowHourList,
        minutes: arrowMinuteList,
        seconds: arrowSecondList
      }));
      const getAmPmFlag = (hour) => {
        const shouldShowAmPm = !!props2.amPmMode;
        if (!shouldShowAmPm)
          return "";
        const isCapital = props2.amPmMode === "A";
        let content = hour < 12 ? " am" : " pm";
        if (isCapital)
          content = content.toUpperCase();
        return content;
      };
      const emitSelectRange = (type4) => {
        if (type4 === "hours") {
          ctx.emit("select-range", 0, 2);
        } else if (type4 === "minutes") {
          ctx.emit("select-range", 3, 5);
        } else if (type4 === "seconds") {
          ctx.emit("select-range", 6, 8);
        }
        currentScrollbar.value = type4;
      };
      const adjustCurrentSpinner = (type4) => {
        adjustSpinner(type4, timePartsMap.value[type4].value);
      };
      const adjustSpinners = () => {
        adjustCurrentSpinner("hours");
        adjustCurrentSpinner("minutes");
        adjustCurrentSpinner("seconds");
      };
      const adjustSpinner = (type4, value) => {
        if (props2.arrowControl)
          return;
        const el = listRefsMap[type4];
        if (el.value) {
          el.value.$el.querySelector(".el-scrollbar__wrap").scrollTop = Math.max(0, value * typeItemHeight(type4));
        }
      };
      const typeItemHeight = (type4) => {
        const el = listRefsMap[type4];
        return el.value.$el.querySelector("li").offsetHeight;
      };
      const onIncreaseClick = () => {
        scrollDown(1);
      };
      const onDecreaseClick = () => {
        scrollDown(-1);
      };
      const scrollDown = (step) => {
        if (!currentScrollbar.value) {
          emitSelectRange("hours");
        }
        const label = currentScrollbar.value;
        let now2 = timePartsMap.value[label].value;
        const total2 = currentScrollbar.value === "hours" ? 24 : 60;
        now2 = (now2 + step + total2) % total2;
        modifyDateField(label, now2);
        adjustSpinner(label, now2);
        vue2.nextTick(() => emitSelectRange(currentScrollbar.value));
      };
      const modifyDateField = (type4, value) => {
        const list2 = listMap.value[type4].value;
        const isDisabled = list2[value];
        if (isDisabled)
          return;
        switch (type4) {
          case "hours":
            ctx.emit("change", props2.spinnerDate.hour(value).minute(minutes.value).second(seconds.value));
            break;
          case "minutes":
            ctx.emit("change", props2.spinnerDate.hour(hours.value).minute(value).second(seconds.value));
            break;
          case "seconds":
            ctx.emit("change", props2.spinnerDate.hour(hours.value).minute(minutes.value).second(value));
            break;
        }
      };
      const handleClick = (type4, { value, disabled }) => {
        if (!disabled) {
          modifyDateField(type4, value);
          emitSelectRange(type4);
          adjustSpinner(type4, value);
        }
      };
      const handleScroll = (type4) => {
        isScrolling = true;
        debouncedResetScroll(type4);
        const value = Math.min(Math.round((listRefsMap[type4].value.$el.querySelector(".el-scrollbar__wrap").scrollTop - (scrollBarHeight(type4) * 0.5 - 10) / typeItemHeight(type4) + 3) / typeItemHeight(type4)), type4 === "hours" ? 23 : 59);
        modifyDateField(type4, value);
      };
      const scrollBarHeight = (type4) => {
        return listRefsMap[type4].value.$el.offsetHeight;
      };
      const bindScrollEvent = () => {
        const bindFuntion = (type4) => {
          if (listRefsMap[type4].value) {
            listRefsMap[type4].value.$el.querySelector(".el-scrollbar__wrap").onscroll = () => {
              handleScroll(type4);
            };
          }
        };
        bindFuntion("hours");
        bindFuntion("minutes");
        bindFuntion("seconds");
      };
      vue2.onMounted(() => {
        vue2.nextTick(() => {
          !props2.arrowControl && bindScrollEvent();
          adjustSpinners();
          if (props2.role === "start")
            emitSelectRange("hours");
        });
      });
      const getRefId = (item2) => {
        return `list${item2.charAt(0).toUpperCase() + item2.slice(1)}Ref`;
      };
      ctx.emit("set-option", [`${props2.role}_scrollDown`, scrollDown]);
      ctx.emit("set-option", [`${props2.role}_emitSelectRange`, emitSelectRange]);
      const { getHoursList, getMinutesList, getSecondsList } = useTimePicker$1.getTimeLists(props2.disabledHours, props2.disabledMinutes, props2.disabledSeconds);
      vue2.watch(() => props2.spinnerDate, () => {
        if (isScrolling)
          return;
        adjustSpinners();
      });
      return {
        getRefId,
        spinnerItems,
        currentScrollbar,
        hours,
        minutes,
        seconds,
        hoursList,
        minutesList,
        arrowHourList,
        arrowMinuteList,
        arrowSecondList,
        getAmPmFlag,
        emitSelectRange,
        adjustCurrentSpinner,
        typeItemHeight,
        listHoursRef,
        listMinutesRef,
        listSecondsRef,
        onIncreaseClick,
        onDecreaseClick,
        handleClick,
        secondsList,
        timePartsMap,
        arrowListMap,
        listMap
      };
    }
  });
  exports["default"] = script2;
})(basicTimeSpinner_vue_vue_type_script_lang);
var basicTimeSpinner_vue_vue_type_template_id_4fb3c576_lang = {};
Object.defineProperty(basicTimeSpinner_vue_vue_type_template_id_4fb3c576_lang, "__esModule", { value: true });
var vue$27 = require$$0$1;
const _hoisted_1$1b = ["onClick"];
const _hoisted_2$T = ["onMouseenter"];
const _hoisted_3$J = { class: "el-time-spinner__list" };
function render$1C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = vue$27.resolveComponent("el-scrollbar");
  const _component_arrow_up = vue$27.resolveComponent("arrow-up");
  const _component_el_icon = vue$27.resolveComponent("el-icon");
  const _component_arrow_down = vue$27.resolveComponent("arrow-down");
  const _directive_repeat_click = vue$27.resolveDirective("repeat-click");
  return vue$27.openBlock(), vue$27.createElementBlock("div", {
    class: vue$27.normalizeClass(["el-time-spinner", { "has-seconds": _ctx.showSeconds }])
  }, [
    !_ctx.arrowControl ? (vue$27.openBlock(true), vue$27.createElementBlock(vue$27.Fragment, { key: 0 }, vue$27.renderList(_ctx.spinnerItems, (item2) => {
      return vue$27.openBlock(), vue$27.createBlock(_component_el_scrollbar, {
        key: item2,
        ref: _ctx.getRefId(item2),
        class: "el-time-spinner__wrapper",
        "wrap-style": "max-height: inherit;",
        "view-class": "el-time-spinner__list",
        noresize: "",
        tag: "ul",
        onMouseenter: ($event) => _ctx.emitSelectRange(item2),
        onMousemove: ($event) => _ctx.adjustCurrentSpinner(item2)
      }, {
        default: vue$27.withCtx(() => [
          (vue$27.openBlock(true), vue$27.createElementBlock(vue$27.Fragment, null, vue$27.renderList(_ctx.listMap[item2].value, (disabled, key2) => {
            return vue$27.openBlock(), vue$27.createElementBlock("li", {
              key: key2,
              class: vue$27.normalizeClass(["el-time-spinner__item", { active: key2 === _ctx.timePartsMap[item2].value, disabled }]),
              onClick: ($event) => _ctx.handleClick(item2, { value: key2, disabled })
            }, [
              item2 === "hours" ? (vue$27.openBlock(), vue$27.createElementBlock(vue$27.Fragment, { key: 0 }, [
                vue$27.createTextVNode(vue$27.toDisplayString(("0" + (_ctx.amPmMode ? key2 % 12 || 12 : key2)).slice(-2)) + vue$27.toDisplayString(_ctx.getAmPmFlag(key2)), 1)
              ], 2112)) : (vue$27.openBlock(), vue$27.createElementBlock(vue$27.Fragment, { key: 1 }, [
                vue$27.createTextVNode(vue$27.toDisplayString(("0" + key2).slice(-2)), 1)
              ], 2112))
            ], 10, _hoisted_1$1b);
          }), 128))
        ]),
        _: 2
      }, 1032, ["onMouseenter", "onMousemove"]);
    }), 128)) : vue$27.createCommentVNode("v-if", true),
    _ctx.arrowControl ? (vue$27.openBlock(true), vue$27.createElementBlock(vue$27.Fragment, { key: 1 }, vue$27.renderList(_ctx.spinnerItems, (item2) => {
      return vue$27.openBlock(), vue$27.createElementBlock("div", {
        key: item2,
        class: "el-time-spinner__wrapper is-arrow",
        onMouseenter: ($event) => _ctx.emitSelectRange(item2)
      }, [
        vue$27.withDirectives(vue$27.createVNode(_component_el_icon, { class: "el-time-spinner__arrow arrow-up" }, {
          default: vue$27.withCtx(() => [
            vue$27.createVNode(_component_arrow_up)
          ]),
          _: 1
        }, 512), [
          [_directive_repeat_click, _ctx.onDecreaseClick]
        ]),
        vue$27.withDirectives(vue$27.createVNode(_component_el_icon, { class: "el-time-spinner__arrow arrow-down" }, {
          default: vue$27.withCtx(() => [
            vue$27.createVNode(_component_arrow_down)
          ]),
          _: 1
        }, 512), [
          [_directive_repeat_click, _ctx.onIncreaseClick]
        ]),
        vue$27.createElementVNode("ul", _hoisted_3$J, [
          (vue$27.openBlock(true), vue$27.createElementBlock(vue$27.Fragment, null, vue$27.renderList(_ctx.arrowListMap[item2].value, (time, key2) => {
            return vue$27.openBlock(), vue$27.createElementBlock("li", {
              key: key2,
              class: vue$27.normalizeClass(["el-time-spinner__item", {
                active: time === _ctx.timePartsMap[item2].value,
                disabled: _ctx.listMap[item2].value[time]
              }])
            }, [
              time ? (vue$27.openBlock(), vue$27.createElementBlock(vue$27.Fragment, { key: 0 }, [
                item2 === "hours" ? (vue$27.openBlock(), vue$27.createElementBlock(vue$27.Fragment, { key: 0 }, [
                  vue$27.createTextVNode(vue$27.toDisplayString(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + vue$27.toDisplayString(_ctx.getAmPmFlag(time)), 1)
                ], 2112)) : (vue$27.openBlock(), vue$27.createElementBlock(vue$27.Fragment, { key: 1 }, [
                  vue$27.createTextVNode(vue$27.toDisplayString(("0" + time).slice(-2)), 1)
                ], 2112))
              ], 2112)) : vue$27.createCommentVNode("v-if", true)
            ], 2);
          }), 128))
        ])
      ], 40, _hoisted_2$T);
    }), 128)) : vue$27.createCommentVNode("v-if", true)
  ], 2);
}
basicTimeSpinner_vue_vue_type_template_id_4fb3c576_lang.render = render$1C;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var basicTimeSpinner_vue_vue_type_script_lang$1 = basicTimeSpinner_vue_vue_type_script_lang;
  var basicTimeSpinner_vue_vue_type_template_id_4fb3c576_lang$1 = basicTimeSpinner_vue_vue_type_template_id_4fb3c576_lang;
  basicTimeSpinner_vue_vue_type_script_lang$1["default"].render = basicTimeSpinner_vue_vue_type_template_id_4fb3c576_lang$1.render;
  basicTimeSpinner_vue_vue_type_script_lang$1["default"].__file = "packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue";
  exports["default"] = basicTimeSpinner_vue_vue_type_script_lang$1["default"];
})(basicTimeSpinner);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var aria2 = aria$5;
  var useTimePicker$1 = useTimePicker;
  var basicTimeSpinner_vue_vue_type_script_lang$1 = basicTimeSpinner_vue_vue_type_script_lang;
  var index2 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var script2 = vue2.defineComponent({
    components: {
      TimeSpinner: basicTimeSpinner_vue_vue_type_script_lang$1["default"]
    },
    props: {
      visible: Boolean,
      actualVisible: {
        type: Boolean,
        default: void 0
      },
      datetimeRole: {
        type: String
      },
      parsedValue: {
        type: [Object, String]
      },
      format: {
        type: String,
        default: ""
      }
    },
    emits: ["pick", "select-range", "set-picker-option"],
    setup(props2, ctx) {
      const { t, lang } = index2.useLocale();
      const selectionRange = vue2.ref([0, 2]);
      const oldValue = useTimePicker$1.useOldValue(props2);
      const transitionName = vue2.computed(() => {
        return props2.actualVisible === void 0 ? "el-zoom-in-top" : "";
      });
      const showSeconds = vue2.computed(() => {
        return props2.format.includes("ss");
      });
      const amPmMode = vue2.computed(() => {
        if (props2.format.includes("A"))
          return "A";
        if (props2.format.includes("a"))
          return "a";
        return "";
      });
      const isValidValue = (_date) => {
        const parsedDate = dayjs__default["default"](_date).locale(lang.value);
        const result3 = getRangeAvailableTime(parsedDate);
        return parsedDate.isSame(result3);
      };
      const handleCancel = () => {
        ctx.emit("pick", oldValue.value, false);
      };
      const handleConfirm = (visible = false, first = false) => {
        if (first)
          return;
        ctx.emit("pick", props2.parsedValue, visible);
      };
      const handleChange = (_date) => {
        if (!props2.visible) {
          return;
        }
        const result3 = getRangeAvailableTime(_date).millisecond(0);
        ctx.emit("pick", result3, true);
      };
      const setSelectionRange = (start2, end2) => {
        ctx.emit("select-range", start2, end2);
        selectionRange.value = [start2, end2];
      };
      const changeSelectionRange = (step) => {
        const list2 = [0, 3].concat(showSeconds.value ? [6] : []);
        const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
        const index3 = list2.indexOf(selectionRange.value[0]);
        const next2 = (index3 + step + list2.length) % list2.length;
        timePickerOptions["start_emitSelectRange"](mapping[next2]);
      };
      const handleKeydown = (event) => {
        const code2 = event.code;
        if (code2 === aria2.EVENT_CODE.left || code2 === aria2.EVENT_CODE.right) {
          const step = code2 === aria2.EVENT_CODE.left ? -1 : 1;
          changeSelectionRange(step);
          event.preventDefault();
          return;
        }
        if (code2 === aria2.EVENT_CODE.up || code2 === aria2.EVENT_CODE.down) {
          const step = code2 === aria2.EVENT_CODE.up ? -1 : 1;
          timePickerOptions["start_scrollDown"](step);
          event.preventDefault();
          return;
        }
      };
      const getRangeAvailableTime = (date4) => {
        const availableMap = {
          hour: getAvailableHours,
          minute: getAvailableMinutes,
          second: getAvailableSeconds
        };
        let result3 = date4;
        ["hour", "minute", "second"].forEach((_2) => {
          if (availableMap[_2]) {
            let availableArr;
            const method4 = availableMap[_2];
            if (_2 === "minute") {
              availableArr = method4(result3.hour(), props2.datetimeRole);
            } else if (_2 === "second") {
              availableArr = method4(result3.hour(), result3.minute(), props2.datetimeRole);
            } else {
              availableArr = method4(props2.datetimeRole);
            }
            if (availableArr && availableArr.length && !availableArr.includes(result3[_2]())) {
              result3 = result3[_2](availableArr[0]);
            }
          }
        });
        return result3;
      };
      const parseUserInput = (value) => {
        if (!value)
          return null;
        return dayjs__default["default"](value, props2.format).locale(lang.value);
      };
      const formatToString = (value) => {
        if (!value)
          return null;
        return value.format(props2.format);
      };
      const getDefaultValue = () => {
        return dayjs__default["default"](defaultValue).locale(lang.value);
      };
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
      ctx.emit("set-picker-option", [
        "getRangeAvailableTime",
        getRangeAvailableTime
      ]);
      ctx.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
      const timePickerOptions = {};
      const onSetOption = (e) => {
        timePickerOptions[e[0]] = e[1];
      };
      const pickerBase = vue2.inject("EP_PICKER_BASE");
      const {
        arrowControl,
        disabledHours,
        disabledMinutes,
        disabledSeconds,
        defaultValue
      } = pickerBase.props;
      const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = useTimePicker$1.getAvailableArrs(disabledHours, disabledMinutes, disabledSeconds);
      return {
        transitionName,
        arrowControl,
        onSetOption,
        t,
        handleConfirm,
        handleChange,
        setSelectionRange,
        amPmMode,
        showSeconds,
        handleCancel,
        disabledHours,
        disabledMinutes,
        disabledSeconds
      };
    }
  });
  exports["default"] = script2;
})(panelTimePick_vue_vue_type_script_lang$1);
var panelTimePick_vue_vue_type_template_id_3b3cfa6a_lang = {};
Object.defineProperty(panelTimePick_vue_vue_type_template_id_3b3cfa6a_lang, "__esModule", { value: true });
var vue$26 = require$$0$1;
const _hoisted_1$1a = {
  key: 0,
  class: "el-time-panel"
};
const _hoisted_2$S = { class: "el-time-panel__footer" };
function render$1B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_time_spinner = vue$26.resolveComponent("time-spinner");
  return vue$26.openBlock(), vue$26.createBlock(vue$26.Transition, { name: _ctx.transitionName }, {
    default: vue$26.withCtx(() => [
      _ctx.actualVisible || _ctx.visible ? (vue$26.openBlock(), vue$26.createElementBlock("div", _hoisted_1$1a, [
        vue$26.createElementVNode("div", {
          class: vue$26.normalizeClass(["el-time-panel__content", { "has-seconds": _ctx.showSeconds }])
        }, [
          vue$26.createVNode(_component_time_spinner, {
            ref: "spinner",
            role: _ctx.datetimeRole || "start",
            "arrow-control": _ctx.arrowControl,
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "spinner-date": _ctx.parsedValue,
            "disabled-hours": _ctx.disabledHours,
            "disabled-minutes": _ctx.disabledMinutes,
            "disabled-seconds": _ctx.disabledSeconds,
            onChange: _ctx.handleChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setSelectionRange
          }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2),
        vue$26.createElementVNode("div", _hoisted_2$S, [
          vue$26.createElementVNode("button", {
            type: "button",
            class: "el-time-panel__btn cancel",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
          }, vue$26.toDisplayString(_ctx.t("el.datepicker.cancel")), 1),
          vue$26.createElementVNode("button", {
            type: "button",
            class: "el-time-panel__btn confirm",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleConfirm())
          }, vue$26.toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ])
      ])) : vue$26.createCommentVNode("v-if", true)
    ]),
    _: 1
  }, 8, ["name"]);
}
panelTimePick_vue_vue_type_template_id_3b3cfa6a_lang.render = render$1B;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var panelTimePick_vue_vue_type_script_lang2 = panelTimePick_vue_vue_type_script_lang$1;
  var panelTimePick_vue_vue_type_template_id_3b3cfa6a_lang$1 = panelTimePick_vue_vue_type_template_id_3b3cfa6a_lang;
  panelTimePick_vue_vue_type_script_lang2["default"].render = panelTimePick_vue_vue_type_template_id_3b3cfa6a_lang$1.render;
  panelTimePick_vue_vue_type_script_lang2["default"].__file = "packages/components/time-picker/src/time-picker-com/panel-time-pick.vue";
  exports["default"] = panelTimePick_vue_vue_type_script_lang2["default"];
})(panelTimePick);
var panelTimeRange = {};
var panelTimeRange_vue_vue_type_script_lang = {};
var Symbol$2 = _Symbol, isArguments = isArguments_1, isArray$3 = isArray_1;
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush$1 = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array4, depth, predicate, isStrict, result3) {
  var index2 = -1, length = array4.length;
  predicate || (predicate = isFlattenable);
  result3 || (result3 = []);
  while (++index2 < length) {
    var value = array4[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result3);
      } else {
        arrayPush$1(result3, value);
      }
    } else if (!isStrict) {
      result3[result3.length] = value;
    }
  }
  return result3;
}
var _baseFlatten = baseFlatten$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
function apply$2(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$2;
var apply$1 = _apply;
var nativeMax = Math.max;
function overRest$1(func, start2, transform2) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array4 = Array(length);
    while (++index2 < length) {
      array4[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform2(array4);
    return apply$1(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$2(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$2;
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var constant$1 = constant_1, defineProperty$1 = _defineProperty, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty$1 ? identity$1 : function(func, string3) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$1(string3),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp2 = nativeNow(), remaining = HOT_SPAN - (stamp2 - lastCalled);
    lastCalled = stamp2;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start2) {
  return setToString(overRest(func, start2, identity), func + "");
}
var _baseRest = baseRest$1;
function baseFindIndex$1(array4, predicate, fromIndex, fromRight) {
  var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$1;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array4, value, fromIndex) {
  var index2 = fromIndex - 1, length = array4.length;
  while (++index2 < length) {
    if (array4[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(array4, value, fromIndex) {
  return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$1;
var baseIndexOf = _baseIndexOf;
function arrayIncludes$1(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  return !!length && baseIndexOf(array4, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1;
function arrayIncludesWith$1(array4, value, comparator) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (comparator(value, array4[index2])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$1;
function noop$2() {
}
var noop_1 = noop$2;
var Set$1 = _Set, noop$1 = noop_1, setToArray$1 = _setToArray;
var INFINITY = 1 / 0;
var createSet$1 = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY) ? noop$1 : function(values) {
  return new Set$1(values);
};
var _createSet = createSet$1;
var SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray;
var LARGE_ARRAY_SIZE = 200;
function baseUniq$1(array4, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length = array4.length, isCommon = true, result3 = [], seen = result3;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee ? null : createSet(array4);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result3;
  }
  outer:
    while (++index2 < length) {
      var value = array4[index2], computed2 = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed2) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed2);
        }
        result3.push(value);
      } else if (!includes(seen, computed2, comparator)) {
        if (seen !== result3) {
          seen.push(computed2);
        }
        result3.push(value);
      }
    }
  return result3;
}
var _baseUniq = baseUniq$1;
var isArrayLike$1 = isArrayLike_1, isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$2(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var baseFlatten = _baseFlatten, baseRest = _baseRest, baseUniq = _baseUniq, isArrayLikeObject = isArrayLikeObject_1;
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
var union_1 = union;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var union2 = union_1;
  var aria2 = aria$5;
  var useTimePicker$1 = useTimePicker;
  var basicTimeSpinner_vue_vue_type_script_lang$1 = basicTimeSpinner_vue_vue_type_script_lang;
  var index2 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var union__default = /* @__PURE__ */ _interopDefaultLegacy2(union2);
  const makeSelectRange = (start2, end2) => {
    const result3 = [];
    for (let i = start2; i <= end2; i++) {
      result3.push(i);
    }
    return result3;
  };
  var script2 = vue2.defineComponent({
    components: { TimeSpinner: basicTimeSpinner_vue_vue_type_script_lang$1["default"] },
    props: {
      visible: Boolean,
      actualVisible: Boolean,
      parsedValue: {
        type: [Array]
      },
      format: {
        type: String,
        default: ""
      }
    },
    emits: ["pick", "select-range", "set-picker-option"],
    setup(props2, ctx) {
      const { t, lang } = index2.useLocale();
      const minDate = vue2.computed(() => props2.parsedValue[0]);
      const maxDate = vue2.computed(() => props2.parsedValue[1]);
      const oldValue = useTimePicker$1.useOldValue(props2);
      const handleCancel = () => {
        ctx.emit("pick", oldValue.value, null);
      };
      const showSeconds = vue2.computed(() => {
        return props2.format.includes("ss");
      });
      const amPmMode = vue2.computed(() => {
        if (props2.format.includes("A"))
          return "A";
        if (props2.format.includes("a"))
          return "a";
        return "";
      });
      const minSelectableRange = vue2.ref([]);
      const maxSelectableRange = vue2.ref([]);
      const handleConfirm = (visible = false) => {
        ctx.emit("pick", [minDate.value, maxDate.value], visible);
      };
      const handleMinChange = (date4) => {
        handleChange(date4.millisecond(0), maxDate.value);
      };
      const handleMaxChange = (date4) => {
        handleChange(minDate.value, date4.millisecond(0));
      };
      const isValidValue = (_date) => {
        const parsedDate = _date.map((_2) => dayjs__default["default"](_2).locale(lang.value));
        const result3 = getRangeAvailableTime(parsedDate);
        return parsedDate[0].isSame(result3[0]) && parsedDate[1].isSame(result3[1]);
      };
      const handleChange = (_minDate, _maxDate) => {
        ctx.emit("pick", [_minDate, _maxDate], true);
      };
      const btnConfirmDisabled = vue2.computed(() => {
        return minDate.value > maxDate.value;
      });
      const selectionRange = vue2.ref([0, 2]);
      const setMinSelectionRange = (start2, end2) => {
        ctx.emit("select-range", start2, end2, "min");
        selectionRange.value = [start2, end2];
      };
      const offset2 = vue2.computed(() => showSeconds.value ? 11 : 8);
      const setMaxSelectionRange = (start2, end2) => {
        ctx.emit("select-range", start2, end2, "max");
        selectionRange.value = [start2 + offset2.value, end2 + offset2.value];
      };
      const changeSelectionRange = (step) => {
        const list2 = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
        const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
        const index3 = list2.indexOf(selectionRange.value[0]);
        const next2 = (index3 + step + list2.length) % list2.length;
        const half = list2.length / 2;
        if (next2 < half) {
          timePickerOptions["start_emitSelectRange"](mapping[next2]);
        } else {
          timePickerOptions["end_emitSelectRange"](mapping[next2 - half]);
        }
      };
      const handleKeydown = (event) => {
        const code2 = event.code;
        if (code2 === aria2.EVENT_CODE.left || code2 === aria2.EVENT_CODE.right) {
          const step = code2 === aria2.EVENT_CODE.left ? -1 : 1;
          changeSelectionRange(step);
          event.preventDefault();
          return;
        }
        if (code2 === aria2.EVENT_CODE.up || code2 === aria2.EVENT_CODE.down) {
          const step = code2 === aria2.EVENT_CODE.up ? -1 : 1;
          const role = selectionRange.value[0] < offset2.value ? "start" : "end";
          timePickerOptions[`${role}_scrollDown`](step);
          event.preventDefault();
          return;
        }
      };
      const disabledHours_ = (role, compare) => {
        const defaultDisable = disabledHours ? disabledHours(role) : [];
        const isStart = role === "start";
        const compareDate = compare || (isStart ? maxDate.value : minDate.value);
        const compareHour = compareDate.hour();
        const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
        return union__default["default"](defaultDisable, nextDisable);
      };
      const disabledMinutes_ = (hour, role, compare) => {
        const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
        const isStart = role === "start";
        const compareDate = compare || (isStart ? maxDate.value : minDate.value);
        const compareHour = compareDate.hour();
        if (hour !== compareHour) {
          return defaultDisable;
        }
        const compareMinute = compareDate.minute();
        const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
        return union__default["default"](defaultDisable, nextDisable);
      };
      const disabledSeconds_ = (hour, minute, role, compare) => {
        const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
        const isStart = role === "start";
        const compareDate = compare || (isStart ? maxDate.value : minDate.value);
        const compareHour = compareDate.hour();
        const compareMinute = compareDate.minute();
        if (hour !== compareHour || minute !== compareMinute) {
          return defaultDisable;
        }
        const compareSecond = compareDate.second();
        const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
        return union__default["default"](defaultDisable, nextDisable);
      };
      const getRangeAvailableTime = (dates) => {
        return dates.map((_2, index3) => getRangeAvailableTimeEach(dates[0], dates[1], index3 === 0 ? "start" : "end"));
      };
      const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = useTimePicker$1.getAvailableArrs(disabledHours_, disabledMinutes_, disabledSeconds_);
      const getRangeAvailableTimeEach = (startDate, endDate, role) => {
        const availableMap = {
          hour: getAvailableHours,
          minute: getAvailableMinutes,
          second: getAvailableSeconds
        };
        const isStart = role === "start";
        let result3 = isStart ? startDate : endDate;
        const compareDate = isStart ? endDate : startDate;
        ["hour", "minute", "second"].forEach((_2) => {
          if (availableMap[_2]) {
            let availableArr;
            const method4 = availableMap[_2];
            if (_2 === "minute") {
              availableArr = method4(result3.hour(), role, compareDate);
            } else if (_2 === "second") {
              availableArr = method4(result3.hour(), result3.minute(), role, compareDate);
            } else {
              availableArr = method4(role, compareDate);
            }
            if (availableArr && availableArr.length && !availableArr.includes(result3[_2]())) {
              const pos = isStart ? 0 : availableArr.length - 1;
              result3 = result3[_2](availableArr[pos]);
            }
          }
        });
        return result3;
      };
      const parseUserInput = (value) => {
        if (!value)
          return null;
        if (Array.isArray(value)) {
          return value.map((_2) => dayjs__default["default"](_2, props2.format).locale(lang.value));
        }
        return dayjs__default["default"](value, props2.format).locale(lang.value);
      };
      const formatToString = (value) => {
        if (!value)
          return null;
        if (Array.isArray(value)) {
          return value.map((_2) => _2.format(props2.format));
        }
        return value.format(props2.format);
      };
      const getDefaultValue = () => {
        if (Array.isArray(defaultValue)) {
          return defaultValue.map((_2) => dayjs__default["default"](_2).locale(lang.value));
        }
        const defaultDay = dayjs__default["default"](defaultValue).locale(lang.value);
        return [defaultDay, defaultDay.add(60, "m")];
      };
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
      ctx.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
      ctx.emit("set-picker-option", [
        "getRangeAvailableTime",
        getRangeAvailableTime
      ]);
      const timePickerOptions = {};
      const onSetOption = (e) => {
        timePickerOptions[e[0]] = e[1];
      };
      const pickerBase = vue2.inject("EP_PICKER_BASE");
      const {
        arrowControl,
        disabledHours,
        disabledMinutes,
        disabledSeconds,
        defaultValue
      } = pickerBase.props;
      return {
        arrowControl,
        onSetOption,
        setMaxSelectionRange,
        setMinSelectionRange,
        btnConfirmDisabled,
        handleCancel,
        handleConfirm,
        t,
        showSeconds,
        minDate,
        maxDate,
        amPmMode,
        handleMinChange,
        handleMaxChange,
        minSelectableRange,
        maxSelectableRange,
        disabledHours_,
        disabledMinutes_,
        disabledSeconds_
      };
    }
  });
  exports["default"] = script2;
})(panelTimeRange_vue_vue_type_script_lang);
var panelTimeRange_vue_vue_type_template_id_57d94b44_lang = {};
Object.defineProperty(panelTimeRange_vue_vue_type_template_id_57d94b44_lang, "__esModule", { value: true });
var vue$25 = require$$0$1;
const _hoisted_1$19 = {
  key: 0,
  class: "el-time-range-picker el-picker-panel"
};
const _hoisted_2$R = { class: "el-time-range-picker__content" };
const _hoisted_3$I = { class: "el-time-range-picker__cell" };
const _hoisted_4$v = { class: "el-time-range-picker__header" };
const _hoisted_5$n = { class: "el-time-range-picker__cell" };
const _hoisted_6$h = { class: "el-time-range-picker__header" };
const _hoisted_7$b = { class: "el-time-panel__footer" };
const _hoisted_8$a = ["disabled"];
function render$1A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_time_spinner = vue$25.resolveComponent("time-spinner");
  return _ctx.actualVisible ? (vue$25.openBlock(), vue$25.createElementBlock("div", _hoisted_1$19, [
    vue$25.createElementVNode("div", _hoisted_2$R, [
      vue$25.createElementVNode("div", _hoisted_3$I, [
        vue$25.createElementVNode("div", _hoisted_4$v, vue$25.toDisplayString(_ctx.t("el.datepicker.startTime")), 1),
        vue$25.createElementVNode("div", {
          class: vue$25.normalizeClass([{ "has-seconds": _ctx.showSeconds, "is-arrow": _ctx.arrowControl }, "el-time-range-picker__body el-time-panel__content"])
        }, [
          vue$25.createVNode(_component_time_spinner, {
            ref: "minSpinner",
            role: "start",
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "arrow-control": _ctx.arrowControl,
            "spinner-date": _ctx.minDate,
            "disabled-hours": _ctx.disabledHours_,
            "disabled-minutes": _ctx.disabledMinutes_,
            "disabled-seconds": _ctx.disabledSeconds_,
            onChange: _ctx.handleMinChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setMinSelectionRange
          }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2)
      ]),
      vue$25.createElementVNode("div", _hoisted_5$n, [
        vue$25.createElementVNode("div", _hoisted_6$h, vue$25.toDisplayString(_ctx.t("el.datepicker.endTime")), 1),
        vue$25.createElementVNode("div", {
          class: vue$25.normalizeClass([{ "has-seconds": _ctx.showSeconds, "is-arrow": _ctx.arrowControl }, "el-time-range-picker__body el-time-panel__content"])
        }, [
          vue$25.createVNode(_component_time_spinner, {
            ref: "maxSpinner",
            role: "end",
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "arrow-control": _ctx.arrowControl,
            "spinner-date": _ctx.maxDate,
            "disabled-hours": _ctx.disabledHours_,
            "disabled-minutes": _ctx.disabledMinutes_,
            "disabled-seconds": _ctx.disabledSeconds_,
            onChange: _ctx.handleMaxChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setMaxSelectionRange
          }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2)
      ])
    ]),
    vue$25.createElementVNode("div", _hoisted_7$b, [
      vue$25.createElementVNode("button", {
        type: "button",
        class: "el-time-panel__btn cancel",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleCancel())
      }, vue$25.toDisplayString(_ctx.t("el.datepicker.cancel")), 1),
      vue$25.createElementVNode("button", {
        type: "button",
        class: "el-time-panel__btn confirm",
        disabled: _ctx.btnConfirmDisabled,
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleConfirm())
      }, vue$25.toDisplayString(_ctx.t("el.datepicker.confirm")), 9, _hoisted_8$a)
    ])
  ])) : vue$25.createCommentVNode("v-if", true);
}
panelTimeRange_vue_vue_type_template_id_57d94b44_lang.render = render$1A;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var panelTimeRange_vue_vue_type_script_lang$1 = panelTimeRange_vue_vue_type_script_lang;
  var panelTimeRange_vue_vue_type_template_id_57d94b44_lang$1 = panelTimeRange_vue_vue_type_template_id_57d94b44_lang;
  panelTimeRange_vue_vue_type_script_lang$1["default"].render = panelTimeRange_vue_vue_type_template_id_57d94b44_lang$1.render;
  panelTimeRange_vue_vue_type_script_lang$1["default"].__file = "packages/components/time-picker/src/time-picker-com/panel-time-range.vue";
  exports["default"] = panelTimeRange_vue_vue_type_script_lang$1["default"];
})(panelTimeRange);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var customParseFormat$1 = customParseFormat.exports;
  var constant2 = constant$3;
  var props2 = props$x;
  var panelTimeRange_vue_vue_type_script_lang$1 = panelTimeRange_vue_vue_type_script_lang;
  var panelTimePick_vue_vue_type_script_lang2 = panelTimePick_vue_vue_type_script_lang$1;
  var picker_vue_vue_type_script_lang2 = picker_vue_vue_type_script_lang$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var customParseFormat__default = /* @__PURE__ */ _interopDefaultLegacy2(customParseFormat$1);
  dayjs__default["default"].extend(customParseFormat__default["default"]);
  var TimePicker = vue2.defineComponent({
    name: "ElTimePicker",
    install: null,
    props: __spreadProps(__spreadValues({}, props2.timePickerDefaultProps), {
      isRange: {
        type: Boolean,
        default: false
      }
    }),
    emits: ["update:modelValue"],
    setup(props3, ctx) {
      const commonPicker = vue2.ref(null);
      const type4 = props3.isRange ? "timerange" : "time";
      const panel = props3.isRange ? panelTimeRange_vue_vue_type_script_lang$1["default"] : panelTimePick_vue_vue_type_script_lang2["default"];
      const refProps = __spreadProps(__spreadValues({}, props3), {
        focus: () => {
          var _a;
          (_a = commonPicker.value) == null ? void 0 : _a.handleFocus();
        },
        blur: () => {
          var _a;
          (_a = commonPicker.value) == null ? void 0 : _a.handleBlur();
        }
      });
      vue2.provide("ElPopperOptions", props3.popperOptions);
      ctx.expose(refProps);
      return () => {
        var _a;
        const format2 = (_a = props3.format) != null ? _a : constant2.DEFAULT_FORMATS_TIME;
        return vue2.h(picker_vue_vue_type_script_lang2["default"], __spreadProps(__spreadValues({}, props3), {
          format: format2,
          type: type4,
          ref: commonPicker,
          "onUpdate:modelValue": (value) => ctx.emit("update:modelValue", value)
        }), {
          default: (scopedProps) => vue2.h(panel, scopedProps)
        });
      };
    }
  });
  exports["default"] = TimePicker;
})(timePicker);
var dateUtils$1 = {};
Object.defineProperty(dateUtils$1, "__esModule", { value: true });
const rangeArr = (n) => Array.from(Array(n).keys());
const extractDateFormat = (format2) => {
  return format2.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
};
const extractTimeFormat = (format2) => {
  return format2.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
};
dateUtils$1.extractDateFormat = extractDateFormat;
dateUtils$1.extractTimeFormat = extractTimeFormat;
dateUtils$1.rangeArr = rangeArr;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var timePicker$12 = timePicker;
  var dateUtils2 = dateUtils$1;
  var constant2 = constant$3;
  var props2 = props$x;
  var picker_vue_vue_type_script_lang2 = picker_vue_vue_type_script_lang$1;
  var panelTimePick_vue_vue_type_script_lang2 = panelTimePick_vue_vue_type_script_lang$1;
  const _TimePicker = timePicker$12["default"];
  _TimePicker.install = (app) => {
    app.component(_TimePicker.name, _TimePicker);
  };
  const ElTimePicker = _TimePicker;
  exports.extractDateFormat = dateUtils2.extractDateFormat;
  exports.extractTimeFormat = dateUtils2.extractTimeFormat;
  exports.rangeArr = dateUtils2.rangeArr;
  exports.DEFAULT_FORMATS_DATE = constant2.DEFAULT_FORMATS_DATE;
  exports.DEFAULT_FORMATS_DATEPICKER = constant2.DEFAULT_FORMATS_DATEPICKER;
  exports.DEFAULT_FORMATS_TIME = constant2.DEFAULT_FORMATS_TIME;
  exports.timePickerDefaultProps = props2.timePickerDefaultProps;
  exports.CommonPicker = picker_vue_vue_type_script_lang2["default"];
  exports.TimePickPanel = panelTimePick_vue_vue_type_script_lang2["default"];
  exports.ElTimePicker = ElTimePicker;
  exports["default"] = _TimePicker;
})(timePicker$1);
var dateTable = {};
Object.defineProperty(dateTable, "__esModule", { value: true });
var props$w = props$N;
var shared$c = require$$1$1;
const dateTableProps = props$w.buildProps({
  selectedDay: {
    type: props$w.definePropType(Object)
  },
  range: {
    type: props$w.definePropType(Array)
  },
  date: {
    type: props$w.definePropType(Object),
    required: true
  },
  hideHeader: {
    type: Boolean
  }
});
const dateTableEmits = {
  pick: (value) => shared$c.isObject(value)
};
dateTable.dateTableEmits = dateTableEmits;
dateTable.dateTableProps = dateTableProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var localeData$1 = localeData.exports;
  var dateTable$1 = dateTable;
  var dateUtils2 = dateUtils$1;
  var index2 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var localeData__default = /* @__PURE__ */ _interopDefaultLegacy2(localeData$1);
  dayjs__default["default"].extend(localeData__default["default"]);
  const WEEK_DAYS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
  const getPrevMonthLastDays = (date4, count) => {
    const lastDay = date4.subtract(1, "month").endOf("month").date();
    return dateUtils2.rangeArr(count).map((_2, index3) => lastDay - (count - index3 - 1));
  };
  const getMonthDays = (date4) => {
    const days = date4.daysInMonth();
    return dateUtils2.rangeArr(days).map((_2, index3) => index3 + 1);
  };
  const toNestedArr = (days) => dateUtils2.rangeArr(days.length / 7).map((index3) => {
    const start2 = index3 * 7;
    return days.slice(start2, start2 + 7);
  });
  var script2 = vue2.defineComponent({
    props: dateTable$1.dateTableProps,
    emits: dateTable$1.dateTableEmits,
    setup(props2, { emit }) {
      const { t, lang } = index2.useLocale();
      const now2 = dayjs__default["default"]().locale(lang.value);
      const firstDayOfWeek = now2.$locale().weekStart || 0;
      const isInRange = vue2.computed(() => !!props2.range && !!props2.range.length);
      const rows = vue2.computed(() => {
        let days = [];
        if (isInRange.value) {
          const [start2, end2] = props2.range;
          const currentMonthRange = dateUtils2.rangeArr(end2.date() - start2.date() + 1).map((index3) => ({
            text: start2.date() + index3,
            type: "current"
          }));
          let remaining = currentMonthRange.length % 7;
          remaining = remaining === 0 ? 0 : 7 - remaining;
          const nextMonthRange = dateUtils2.rangeArr(remaining).map((_2, index3) => ({
            text: index3 + 1,
            type: "next"
          }));
          days = currentMonthRange.concat(nextMonthRange);
        } else {
          const firstDay = props2.date.startOf("month").day() || 7;
          const prevMonthDays = getPrevMonthLastDays(props2.date, firstDay - firstDayOfWeek).map((day) => ({
            text: day,
            type: "prev"
          }));
          const currentMonthDays = getMonthDays(props2.date).map((day) => ({
            text: day,
            type: "current"
          }));
          days = [...prevMonthDays, ...currentMonthDays];
          const nextMonthDays = dateUtils2.rangeArr(42 - days.length).map((_2, index3) => ({
            text: index3 + 1,
            type: "next"
          }));
          days = days.concat(nextMonthDays);
        }
        return toNestedArr(days);
      });
      const weekDays = vue2.computed(() => {
        const start2 = firstDayOfWeek;
        if (start2 === 0) {
          return WEEK_DAYS.map((_2) => t(`el.datepicker.weeks.${_2}`));
        } else {
          return WEEK_DAYS.slice(start2).concat(WEEK_DAYS.slice(0, start2)).map((_2) => t(`el.datepicker.weeks.${_2}`));
        }
      });
      const getFormattedDate = (day, type4) => {
        switch (type4) {
          case "prev":
            return props2.date.startOf("month").subtract(1, "month").date(day);
          case "next":
            return props2.date.startOf("month").add(1, "month").date(day);
          case "current":
            return props2.date.date(day);
        }
      };
      const getCellClass = ({ text, type: type4 }) => {
        const classes = [type4];
        if (type4 === "current") {
          const date4 = getFormattedDate(text, type4);
          if (date4.isSame(props2.selectedDay, "day")) {
            classes.push("is-selected");
          }
          if (date4.isSame(now2, "day")) {
            classes.push("is-today");
          }
        }
        return classes;
      };
      const handlePickDay = ({ text, type: type4 }) => {
        const date4 = getFormattedDate(text, type4);
        emit("pick", date4);
      };
      const getSlotData = ({ text, type: type4 }) => {
        const day = getFormattedDate(text, type4);
        return {
          isSelected: day.isSame(props2.selectedDay),
          type: `${type4}-month`,
          day: day.format("YYYY-MM-DD"),
          date: day.toDate()
        };
      };
      return {
        isInRange,
        weekDays,
        rows,
        getCellClass,
        handlePickDay,
        getSlotData
      };
    }
  });
  exports["default"] = script2;
  exports.getMonthDays = getMonthDays;
  exports.getPrevMonthLastDays = getPrevMonthLastDays;
})(dateTable_vue_vue_type_script_lang);
var dateTable_vue_vue_type_template_id_297fdb36_lang = {};
Object.defineProperty(dateTable_vue_vue_type_template_id_297fdb36_lang, "__esModule", { value: true });
var vue$24 = require$$0$1;
const _hoisted_1$18 = { key: 0 };
const _hoisted_2$Q = ["onClick"];
const _hoisted_3$H = { class: "el-calendar-day" };
function render$1z(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$24.openBlock(), vue$24.createElementBlock("table", {
    class: vue$24.normalizeClass({
      "el-calendar-table": true,
      "is-range": _ctx.isInRange
    }),
    cellspacing: "0",
    cellpadding: "0"
  }, [
    !_ctx.hideHeader ? (vue$24.openBlock(), vue$24.createElementBlock("thead", _hoisted_1$18, [
      (vue$24.openBlock(true), vue$24.createElementBlock(vue$24.Fragment, null, vue$24.renderList(_ctx.weekDays, (day) => {
        return vue$24.openBlock(), vue$24.createElementBlock("th", { key: day }, vue$24.toDisplayString(day), 1);
      }), 128))
    ])) : vue$24.createCommentVNode("v-if", true),
    vue$24.createElementVNode("tbody", null, [
      (vue$24.openBlock(true), vue$24.createElementBlock(vue$24.Fragment, null, vue$24.renderList(_ctx.rows, (row2, index2) => {
        return vue$24.openBlock(), vue$24.createElementBlock("tr", {
          key: index2,
          class: vue$24.normalizeClass({
            "el-calendar-table__row": true,
            "el-calendar-table__row--hide-border": index2 === 0 && _ctx.hideHeader
          })
        }, [
          (vue$24.openBlock(true), vue$24.createElementBlock(vue$24.Fragment, null, vue$24.renderList(row2, (cell, key2) => {
            return vue$24.openBlock(), vue$24.createElementBlock("td", {
              key: key2,
              class: vue$24.normalizeClass(_ctx.getCellClass(cell)),
              onClick: ($event) => _ctx.handlePickDay(cell)
            }, [
              vue$24.createElementVNode("div", _hoisted_3$H, [
                vue$24.renderSlot(_ctx.$slots, "dateCell", {
                  data: _ctx.getSlotData(cell)
                }, () => [
                  vue$24.createElementVNode("span", null, vue$24.toDisplayString(cell.text), 1)
                ])
              ])
            ], 10, _hoisted_2$Q);
          }), 128))
        ], 2);
      }), 128))
    ])
  ], 2);
}
dateTable_vue_vue_type_template_id_297fdb36_lang.render = render$1z;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dateTable_vue_vue_type_script_lang$1 = dateTable_vue_vue_type_script_lang;
  var dateTable_vue_vue_type_template_id_297fdb36_lang$1 = dateTable_vue_vue_type_template_id_297fdb36_lang;
  dateTable_vue_vue_type_script_lang$1["default"].render = dateTable_vue_vue_type_template_id_297fdb36_lang$1.render;
  dateTable_vue_vue_type_script_lang$1["default"].__file = "packages/components/calendar/src/date-table.vue";
  exports["default"] = dateTable_vue_vue_type_script_lang$1["default"];
  exports.getMonthDays = dateTable_vue_vue_type_script_lang$1.getMonthDays;
  exports.getPrevMonthLastDays = dateTable_vue_vue_type_script_lang$1.getPrevMonthLastDays;
})(dateTable2);
var calendar$1 = {};
Object.defineProperty(calendar$1, "__esModule", { value: true });
var props$v = props$N;
var constants$c = constants$f;
const calendarProps = props$v.buildProps({
  modelValue: {
    type: Date
  },
  range: {
    type: props$v.definePropType(Array),
    validator: (range3) => Array.isArray(range3) && range3.length === 2 && range3.every((item2) => item2 instanceof Date)
  }
});
const calendarEmits = {
  [constants$c.UPDATE_MODEL_EVENT]: (value) => value instanceof Date,
  input: (value) => value instanceof Date
};
calendar$1.calendarEmits = calendarEmits;
calendar$1.calendarProps = calendarProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var index2 = button$5;
  var error2 = error$5;
  var calendar3 = calendar$1;
  var dateTable_vue_vue_type_script_lang$1 = dateTable_vue_vue_type_script_lang;
  var index$110 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var script2 = vue2.defineComponent({
    name: "ElCalendar",
    components: {
      DateTable: dateTable_vue_vue_type_script_lang$1["default"],
      ElButton: index2.ElButton,
      ElButtonGroup: index2.ElButtonGroup
    },
    props: calendar3.calendarProps,
    emits: calendar3.calendarEmits,
    setup(props2, { emit }) {
      const { t, lang } = index$110.useLocale();
      const selectedDay = vue2.ref();
      const now2 = dayjs__default["default"]().locale(lang.value);
      const prevMonthDayjs = vue2.computed(() => {
        return date4.value.subtract(1, "month");
      });
      const curMonthDatePrefix = vue2.computed(() => {
        return dayjs__default["default"](date4.value).locale(lang.value).format("YYYY-MM");
      });
      const nextMonthDayjs = vue2.computed(() => {
        return date4.value.add(1, "month");
      });
      const prevYearDayjs = vue2.computed(() => {
        return date4.value.subtract(1, "year");
      });
      const nextYearDayjs = vue2.computed(() => {
        return date4.value.add(1, "year");
      });
      const i18nDate = vue2.computed(() => {
        const pickedMonth = `el.datepicker.month${date4.value.format("M")}`;
        return `${date4.value.year()} ${t("el.datepicker.year")} ${t(pickedMonth)}`;
      });
      const realSelectedDay = vue2.computed({
        get() {
          if (!props2.modelValue)
            return selectedDay.value;
          return date4.value;
        },
        set(val) {
          if (!val)
            return;
          selectedDay.value = val;
          const result3 = val.toDate();
          emit("input", result3);
          emit("update:modelValue", result3);
        }
      });
      const date4 = vue2.computed(() => {
        if (!props2.modelValue) {
          if (realSelectedDay.value) {
            return realSelectedDay.value;
          } else if (validatedRange.value.length) {
            return validatedRange.value[0][0];
          }
          return now2;
        } else {
          return dayjs__default["default"](props2.modelValue).locale(lang.value);
        }
      });
      const calculateValidatedDateRange = (startDayjs, endDayjs) => {
        const firstDay = startDayjs.startOf("week");
        const lastDay = endDayjs.endOf("week");
        const firstMonth = firstDay.get("month");
        const lastMonth = lastDay.get("month");
        if (firstMonth === lastMonth) {
          return [[firstDay, lastDay]];
        } else if (firstMonth + 1 === lastMonth) {
          const firstMonthLastDay = firstDay.endOf("month");
          const lastMonthFirstDay = lastDay.startOf("month");
          const isSameWeek = firstMonthLastDay.isSame(lastMonthFirstDay, "week");
          const lastMonthStartDay = isSameWeek ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
          return [
            [firstDay, firstMonthLastDay],
            [lastMonthStartDay.startOf("week"), lastDay]
          ];
        } else if (firstMonth + 2 === lastMonth) {
          const firstMonthLastDay = firstDay.endOf("month");
          const secondMonthFirstDay = firstDay.add(1, "month").startOf("month");
          const secondMonthStartDay = firstMonthLastDay.isSame(secondMonthFirstDay, "week") ? secondMonthFirstDay.add(1, "week") : secondMonthFirstDay;
          const secondMonthLastDay = secondMonthStartDay.endOf("month");
          const lastMonthFirstDay = lastDay.startOf("month");
          const lastMonthStartDay = secondMonthLastDay.isSame(lastMonthFirstDay, "week") ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
          return [
            [firstDay, firstMonthLastDay],
            [secondMonthStartDay.startOf("week"), secondMonthLastDay],
            [lastMonthStartDay.startOf("week"), lastDay]
          ];
        } else {
          error2.debugWarn("ElCalendar", "start time and end time interval must not exceed two months");
          return [];
        }
      };
      const validatedRange = vue2.computed(() => {
        if (!props2.range)
          return [];
        const rangeArrDayjs = props2.range.map((_2) => dayjs__default["default"](_2).locale(lang.value));
        const [startDayjs, endDayjs] = rangeArrDayjs;
        if (startDayjs.isAfter(endDayjs)) {
          error2.debugWarn("ElCalendar", "end time should be greater than start time");
          return [];
        }
        if (startDayjs.isSame(endDayjs, "month")) {
          return calculateValidatedDateRange(startDayjs, endDayjs);
        } else {
          if (startDayjs.add(1, "month").month() !== endDayjs.month()) {
            error2.debugWarn("ElCalendar", "start time and end time interval must not exceed two months");
            return [];
          }
          return calculateValidatedDateRange(startDayjs, endDayjs);
        }
      });
      const pickDay = (day) => {
        realSelectedDay.value = day;
      };
      const selectDate = (type4) => {
        let day;
        if (type4 === "prev-month") {
          day = prevMonthDayjs.value;
        } else if (type4 === "next-month") {
          day = nextMonthDayjs.value;
        } else if (type4 === "prev-year") {
          day = prevYearDayjs.value;
        } else if (type4 === "next-year") {
          day = nextYearDayjs.value;
        } else {
          day = now2;
        }
        if (day.isSame(date4.value, "day"))
          return;
        pickDay(day);
      };
      return {
        selectedDay,
        curMonthDatePrefix,
        i18nDate,
        realSelectedDay,
        date: date4,
        validatedRange,
        pickDay,
        selectDate,
        t
      };
    }
  });
  exports["default"] = script2;
})(calendar_vue_vue_type_script_lang);
var calendar_vue_vue_type_template_id_76705c76_lang = {};
Object.defineProperty(calendar_vue_vue_type_template_id_76705c76_lang, "__esModule", { value: true });
var vue$23 = require$$0$1;
const _hoisted_1$17 = { class: "el-calendar" };
const _hoisted_2$P = { class: "el-calendar__header" };
const _hoisted_3$G = { class: "el-calendar__title" };
const _hoisted_4$u = {
  key: 0,
  class: "el-calendar__button-group"
};
const _hoisted_5$m = {
  key: 0,
  class: "el-calendar__body"
};
const _hoisted_6$g = {
  key: 1,
  class: "el-calendar__body"
};
function render$1y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = vue$23.resolveComponent("el-button");
  const _component_el_button_group = vue$23.resolveComponent("el-button-group");
  const _component_date_table = vue$23.resolveComponent("date-table");
  return vue$23.openBlock(), vue$23.createElementBlock("div", _hoisted_1$17, [
    vue$23.createElementVNode("div", _hoisted_2$P, [
      vue$23.renderSlot(_ctx.$slots, "header", { date: _ctx.i18nDate }, () => [
        vue$23.createElementVNode("div", _hoisted_3$G, vue$23.toDisplayString(_ctx.i18nDate), 1),
        _ctx.validatedRange.length === 0 ? (vue$23.openBlock(), vue$23.createElementBlock("div", _hoisted_4$u, [
          vue$23.createVNode(_component_el_button_group, null, {
            default: vue$23.withCtx(() => [
              vue$23.createVNode(_component_el_button, {
                size: "mini",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.selectDate("prev-month"))
              }, {
                default: vue$23.withCtx(() => [
                  vue$23.createTextVNode(vue$23.toDisplayString(_ctx.t("el.datepicker.prevMonth")), 1)
                ]),
                _: 1
              }),
              vue$23.createVNode(_component_el_button, {
                size: "mini",
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.selectDate("today"))
              }, {
                default: vue$23.withCtx(() => [
                  vue$23.createTextVNode(vue$23.toDisplayString(_ctx.t("el.datepicker.today")), 1)
                ]),
                _: 1
              }),
              vue$23.createVNode(_component_el_button, {
                size: "mini",
                onClick: _cache[2] || (_cache[2] = ($event) => _ctx.selectDate("next-month"))
              }, {
                default: vue$23.withCtx(() => [
                  vue$23.createTextVNode(vue$23.toDisplayString(_ctx.t("el.datepicker.nextMonth")), 1)
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ])) : vue$23.createCommentVNode("v-if", true)
      ])
    ]),
    _ctx.validatedRange.length === 0 ? (vue$23.openBlock(), vue$23.createElementBlock("div", _hoisted_5$m, [
      vue$23.createVNode(_component_date_table, {
        date: _ctx.date,
        "selected-day": _ctx.realSelectedDay,
        onPick: _ctx.pickDay
      }, vue$23.createSlots({ _: 2 }, [
        _ctx.$slots.dateCell ? {
          name: "dateCell",
          fn: vue$23.withCtx((data2) => [
            vue$23.renderSlot(_ctx.$slots, "dateCell", vue$23.normalizeProps(vue$23.guardReactiveProps(data2)))
          ])
        } : void 0
      ]), 1032, ["date", "selected-day", "onPick"])
    ])) : (vue$23.openBlock(), vue$23.createElementBlock("div", _hoisted_6$g, [
      (vue$23.openBlock(true), vue$23.createElementBlock(vue$23.Fragment, null, vue$23.renderList(_ctx.validatedRange, (range_, index2) => {
        return vue$23.openBlock(), vue$23.createBlock(_component_date_table, {
          key: index2,
          date: range_[0],
          "selected-day": _ctx.realSelectedDay,
          range: range_,
          "hide-header": index2 !== 0,
          onPick: _ctx.pickDay
        }, vue$23.createSlots({ _: 2 }, [
          _ctx.$slots.dateCell ? {
            name: "dateCell",
            fn: vue$23.withCtx((data2) => [
              vue$23.renderSlot(_ctx.$slots, "dateCell", vue$23.normalizeProps(vue$23.guardReactiveProps(data2)))
            ])
          } : void 0
        ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]);
      }), 128))
    ]))
  ]);
}
calendar_vue_vue_type_template_id_76705c76_lang.render = render$1y;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var calendar_vue_vue_type_script_lang$1 = calendar_vue_vue_type_script_lang;
  var calendar_vue_vue_type_template_id_76705c76_lang$1 = calendar_vue_vue_type_template_id_76705c76_lang;
  calendar_vue_vue_type_script_lang$1["default"].render = calendar_vue_vue_type_template_id_76705c76_lang$1.render;
  calendar_vue_vue_type_script_lang$1["default"].__file = "packages/components/calendar/src/calendar.vue";
  exports["default"] = calendar_vue_vue_type_script_lang$1["default"];
})(calendar2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var calendar3 = calendar$1;
  var calendar_vue_vue_type_script_lang$1 = calendar_vue_vue_type_script_lang;
  const ElCalendar = withInstall2.withInstall(calendar_vue_vue_type_script_lang$1["default"]);
  exports.calendarEmits = calendar3.calendarEmits;
  exports.calendarProps = calendar3.calendarProps;
  exports.ElCalendar = ElCalendar;
  exports["default"] = ElCalendar;
})(calendar$2);
var card$2 = {};
var card2 = {};
var card_vue_vue_type_script_lang = {};
var card$1 = {};
Object.defineProperty(card$1, "__esModule", { value: true });
var props$u = props$N;
const cardProps = props$u.buildProps({
  header: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: props$u.definePropType([String, Object, Array]),
    default: ""
  },
  shadow: {
    type: String,
    default: ""
  }
});
card$1.cardProps = cardProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var card3 = card$1;
  var script2 = vue2.defineComponent({
    name: "ElCard",
    props: card3.cardProps
  });
  exports["default"] = script2;
})(card_vue_vue_type_script_lang);
var card_vue_vue_type_template_id_7a6bdf05_lang = {};
Object.defineProperty(card_vue_vue_type_template_id_7a6bdf05_lang, "__esModule", { value: true });
var vue$22 = require$$0$1;
const _hoisted_1$16 = {
  key: 0,
  class: "el-card__header"
};
function render$1x(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$22.openBlock(), vue$22.createElementBlock("div", {
    class: vue$22.normalizeClass(["el-card", _ctx.shadow ? "is-" + _ctx.shadow + "-shadow" : "is-always-shadow"])
  }, [
    _ctx.$slots.header || _ctx.header ? (vue$22.openBlock(), vue$22.createElementBlock("div", _hoisted_1$16, [
      vue$22.renderSlot(_ctx.$slots, "header", {}, () => [
        vue$22.createTextVNode(vue$22.toDisplayString(_ctx.header), 1)
      ])
    ])) : vue$22.createCommentVNode("v-if", true),
    vue$22.createElementVNode("div", {
      class: "el-card__body",
      style: vue$22.normalizeStyle(_ctx.bodyStyle)
    }, [
      vue$22.renderSlot(_ctx.$slots, "default")
    ], 4)
  ], 2);
}
card_vue_vue_type_template_id_7a6bdf05_lang.render = render$1x;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var card_vue_vue_type_script_lang$1 = card_vue_vue_type_script_lang;
  var card_vue_vue_type_template_id_7a6bdf05_lang$1 = card_vue_vue_type_template_id_7a6bdf05_lang;
  card_vue_vue_type_script_lang$1["default"].render = card_vue_vue_type_template_id_7a6bdf05_lang$1.render;
  card_vue_vue_type_script_lang$1["default"].__file = "packages/components/card/src/card.vue";
  exports["default"] = card_vue_vue_type_script_lang$1["default"];
})(card2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var card3 = card$1;
  var card_vue_vue_type_script_lang$1 = card_vue_vue_type_script_lang;
  const ElCard = withInstall2.withInstall(card_vue_vue_type_script_lang$1["default"]);
  exports.cardProps = card3.cardProps;
  exports.ElCard = ElCard;
  exports["default"] = ElCard;
})(card$2);
var carousel = {};
var main$1 = {};
var main_vue_vue_type_script_lang$1 = {};
var debounce$3 = debounce_1, isObject$6 = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject$6(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce$3(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var throttle2 = throttle_1;
  var resizeEvent$1 = resizeEvent;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var error2 = error$5;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var throttle__default = /* @__PURE__ */ _interopDefaultLegacy2(throttle2);
  var script2 = vue2.defineComponent({
    name: "ElCarousel",
    components: {
      ElIcon: index2.ElIcon,
      ArrowLeft: iconsVue2.ArrowLeft,
      ArrowRight: iconsVue2.ArrowRight
    },
    props: {
      initialIndex: {
        type: Number,
        default: 0
      },
      height: { type: String, default: "" },
      trigger: {
        type: String,
        default: "hover"
      },
      autoplay: {
        type: Boolean,
        default: true
      },
      interval: {
        type: Number,
        default: 3e3
      },
      indicatorPosition: { type: String, default: "" },
      indicator: {
        type: Boolean,
        default: true
      },
      arrow: {
        type: String,
        default: "hover"
      },
      type: { type: String, default: "" },
      loop: {
        type: Boolean,
        default: true
      },
      direction: {
        type: String,
        default: "horizontal",
        validator(val) {
          return ["horizontal", "vertical"].includes(val);
        }
      },
      pauseOnHover: {
        type: Boolean,
        default: true
      }
    },
    emits: ["change"],
    setup(props2, { emit }) {
      const data2 = vue2.reactive({
        activeIndex: -1,
        containerWidth: 0,
        timer: null,
        hover: false
      });
      const root2 = vue2.ref(null);
      const items = vue2.ref([]);
      const arrowDisplay = vue2.computed(() => props2.arrow !== "never" && props2.direction !== "vertical");
      const hasLabel = vue2.computed(() => {
        return items.value.some((item2) => item2.label.toString().length > 0);
      });
      const carouselClasses = vue2.computed(() => {
        const classes = ["el-carousel", `el-carousel--${props2.direction}`];
        if (props2.type === "card") {
          classes.push("el-carousel--card");
        }
        return classes;
      });
      const indicatorsClasses = vue2.computed(() => {
        const classes = [
          "el-carousel__indicators",
          `el-carousel__indicators--${props2.direction}`
        ];
        if (hasLabel.value) {
          classes.push("el-carousel__indicators--labels");
        }
        if (props2.indicatorPosition === "outside" || props2.type === "card") {
          classes.push("el-carousel__indicators--outside");
        }
        return classes;
      });
      const throttledArrowClick = throttle__default["default"]((index3) => {
        setActiveItem(index3);
      }, 300, { trailing: true });
      const throttledIndicatorHover = throttle__default["default"]((index3) => {
        handleIndicatorHover(index3);
      }, 300);
      function pauseTimer() {
        if (data2.timer) {
          clearInterval(data2.timer);
          data2.timer = null;
        }
      }
      function startTimer() {
        if (props2.interval <= 0 || !props2.autoplay || data2.timer)
          return;
        data2.timer = setInterval(() => playSlides(), props2.interval);
      }
      const playSlides = () => {
        if (data2.activeIndex < items.value.length - 1) {
          data2.activeIndex = data2.activeIndex + 1;
        } else if (props2.loop) {
          data2.activeIndex = 0;
        }
      };
      function setActiveItem(index3) {
        if (typeof index3 === "string") {
          const filteredItems = items.value.filter((item2) => item2.name === index3);
          if (filteredItems.length > 0) {
            index3 = items.value.indexOf(filteredItems[0]);
          }
        }
        index3 = Number(index3);
        if (isNaN(index3) || index3 !== Math.floor(index3)) {
          error2.debugWarn("Carousel", "index must be an integer.");
          return;
        }
        const length = items.value.length;
        const oldIndex = data2.activeIndex;
        if (index3 < 0) {
          data2.activeIndex = props2.loop ? length - 1 : 0;
        } else if (index3 >= length) {
          data2.activeIndex = props2.loop ? 0 : length - 1;
        } else {
          data2.activeIndex = index3;
        }
        if (oldIndex === data2.activeIndex) {
          resetItemPosition(oldIndex);
        }
      }
      function resetItemPosition(oldIndex) {
        items.value.forEach((item2, index3) => {
          item2.translateItem(index3, data2.activeIndex, oldIndex);
        });
      }
      function addItem(item2) {
        items.value.push(item2);
      }
      function removeItem(uid2) {
        const index3 = items.value.findIndex((item2) => item2.uid === uid2);
        if (index3 !== -1) {
          items.value.splice(index3, 1);
          if (data2.activeIndex === index3)
            next2();
        }
      }
      function itemInStage(item2, index3) {
        const length = items.value.length;
        if (index3 === length - 1 && item2.inStage && items.value[0].active || item2.inStage && items.value[index3 + 1] && items.value[index3 + 1].active) {
          return "left";
        } else if (index3 === 0 && item2.inStage && items.value[length - 1].active || item2.inStage && items.value[index3 - 1] && items.value[index3 - 1].active) {
          return "right";
        }
        return false;
      }
      function handleMouseEnter() {
        data2.hover = true;
        if (props2.pauseOnHover) {
          pauseTimer();
        }
      }
      function handleMouseLeave() {
        data2.hover = false;
        startTimer();
      }
      function handleButtonEnter(arrow2) {
        if (props2.direction === "vertical")
          return;
        items.value.forEach((item2, index3) => {
          if (arrow2 === itemInStage(item2, index3)) {
            item2.hover = true;
          }
        });
      }
      function handleButtonLeave() {
        if (props2.direction === "vertical")
          return;
        items.value.forEach((item2) => {
          item2.hover = false;
        });
      }
      function handleIndicatorClick(index3) {
        data2.activeIndex = index3;
      }
      function handleIndicatorHover(index3) {
        if (props2.trigger === "hover" && index3 !== data2.activeIndex) {
          data2.activeIndex = index3;
        }
      }
      function prev2() {
        setActiveItem(data2.activeIndex - 1);
      }
      function next2() {
        setActiveItem(data2.activeIndex + 1);
      }
      vue2.watch(() => data2.activeIndex, (current2, prev22) => {
        resetItemPosition(prev22);
        if (prev22 > -1) {
          emit("change", current2, prev22);
        }
      });
      vue2.watch(() => props2.autoplay, (current2) => {
        current2 ? startTimer() : pauseTimer();
      });
      vue2.watch(() => props2.loop, () => {
        setActiveItem(data2.activeIndex);
      });
      vue2.onMounted(() => {
        vue2.nextTick(() => {
          resizeEvent$1.addResizeListener(root2.value, resetItemPosition);
          if (props2.initialIndex < items.value.length && props2.initialIndex >= 0) {
            data2.activeIndex = props2.initialIndex;
          }
          startTimer();
        });
      });
      vue2.onBeforeUnmount(() => {
        if (root2.value)
          resizeEvent$1.removeResizeListener(root2.value, resetItemPosition);
        pauseTimer();
      });
      vue2.provide("injectCarouselScope", {
        root: root2,
        direction: props2.direction,
        type: props2.type,
        items,
        loop: props2.loop,
        addItem,
        removeItem,
        setActiveItem
      });
      return {
        data: data2,
        props: props2,
        items,
        arrowDisplay,
        carouselClasses,
        indicatorsClasses,
        hasLabel,
        handleMouseEnter,
        handleMouseLeave,
        handleIndicatorClick,
        throttledArrowClick,
        throttledIndicatorHover,
        handleButtonEnter,
        handleButtonLeave,
        prev: prev2,
        next: next2,
        setActiveItem,
        root: root2
      };
    }
  });
  exports["default"] = script2;
})(main_vue_vue_type_script_lang$1);
var main_vue_vue_type_template_id_1303d144_lang = {};
Object.defineProperty(main_vue_vue_type_template_id_1303d144_lang, "__esModule", { value: true });
var vue$21 = require$$0$1;
const _hoisted_1$15 = ["onMouseenter", "onClick"];
const _hoisted_2$O = { class: "el-carousel__button" };
const _hoisted_3$F = { key: 0 };
function render$1w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_left = vue$21.resolveComponent("arrow-left");
  const _component_el_icon = vue$21.resolveComponent("el-icon");
  const _component_arrow_right = vue$21.resolveComponent("arrow-right");
  return vue$21.openBlock(), vue$21.createElementBlock("div", {
    ref: "root",
    class: vue$21.normalizeClass(_ctx.carouselClasses),
    onMouseenter: _cache[6] || (_cache[6] = vue$21.withModifiers((...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args), ["stop"])),
    onMouseleave: _cache[7] || (_cache[7] = vue$21.withModifiers((...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args), ["stop"]))
  }, [
    vue$21.createElementVNode("div", {
      class: "el-carousel__container",
      style: vue$21.normalizeStyle({ height: _ctx.height })
    }, [
      _ctx.arrowDisplay ? (vue$21.openBlock(), vue$21.createBlock(vue$21.Transition, {
        key: 0,
        name: "carousel-arrow-left"
      }, {
        default: vue$21.withCtx(() => [
          vue$21.withDirectives(vue$21.createElementVNode("button", {
            type: "button",
            class: "el-carousel__arrow el-carousel__arrow--left",
            onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.handleButtonEnter("left")),
            onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.handleButtonLeave && _ctx.handleButtonLeave(...args)),
            onClick: _cache[2] || (_cache[2] = vue$21.withModifiers(($event) => _ctx.throttledArrowClick(_ctx.data.activeIndex - 1), ["stop"]))
          }, [
            vue$21.createVNode(_component_el_icon, null, {
              default: vue$21.withCtx(() => [
                vue$21.createVNode(_component_arrow_left)
              ]),
              _: 1
            })
          ], 544), [
            [
              vue$21.vShow,
              (_ctx.arrow === "always" || _ctx.data.hover) && (_ctx.props.loop || _ctx.data.activeIndex > 0)
            ]
          ])
        ]),
        _: 1
      })) : vue$21.createCommentVNode("v-if", true),
      _ctx.arrowDisplay ? (vue$21.openBlock(), vue$21.createBlock(vue$21.Transition, {
        key: 1,
        name: "carousel-arrow-right"
      }, {
        default: vue$21.withCtx(() => [
          vue$21.withDirectives(vue$21.createElementVNode("button", {
            type: "button",
            class: "el-carousel__arrow el-carousel__arrow--right",
            onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.handleButtonEnter("right")),
            onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.handleButtonLeave && _ctx.handleButtonLeave(...args)),
            onClick: _cache[5] || (_cache[5] = vue$21.withModifiers(($event) => _ctx.throttledArrowClick(_ctx.data.activeIndex + 1), ["stop"]))
          }, [
            vue$21.createVNode(_component_el_icon, null, {
              default: vue$21.withCtx(() => [
                vue$21.createVNode(_component_arrow_right)
              ]),
              _: 1
            })
          ], 544), [
            [
              vue$21.vShow,
              (_ctx.arrow === "always" || _ctx.data.hover) && (_ctx.props.loop || _ctx.data.activeIndex < _ctx.items.length - 1)
            ]
          ])
        ]),
        _: 1
      })) : vue$21.createCommentVNode("v-if", true),
      vue$21.renderSlot(_ctx.$slots, "default")
    ], 4),
    _ctx.indicatorPosition !== "none" ? (vue$21.openBlock(), vue$21.createElementBlock("ul", {
      key: 0,
      class: vue$21.normalizeClass(_ctx.indicatorsClasses)
    }, [
      (vue$21.openBlock(true), vue$21.createElementBlock(vue$21.Fragment, null, vue$21.renderList(_ctx.items, (item2, index2) => {
        return vue$21.openBlock(), vue$21.createElementBlock("li", {
          key: index2,
          class: vue$21.normalizeClass([
            "el-carousel__indicator",
            "el-carousel__indicator--" + _ctx.direction,
            { "is-active": index2 === _ctx.data.activeIndex }
          ]),
          onMouseenter: ($event) => _ctx.throttledIndicatorHover(index2),
          onClick: vue$21.withModifiers(($event) => _ctx.handleIndicatorClick(index2), ["stop"])
        }, [
          vue$21.createElementVNode("button", _hoisted_2$O, [
            _ctx.hasLabel ? (vue$21.openBlock(), vue$21.createElementBlock("span", _hoisted_3$F, vue$21.toDisplayString(item2.label), 1)) : vue$21.createCommentVNode("v-if", true)
          ])
        ], 42, _hoisted_1$15);
      }), 128))
    ], 2)) : vue$21.createCommentVNode("v-if", true)
  ], 34);
}
main_vue_vue_type_template_id_1303d144_lang.render = render$1w;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var main_vue_vue_type_script_lang2 = main_vue_vue_type_script_lang$1;
  var main_vue_vue_type_template_id_1303d144_lang$1 = main_vue_vue_type_template_id_1303d144_lang;
  main_vue_vue_type_script_lang2["default"].render = main_vue_vue_type_template_id_1303d144_lang$1.render;
  main_vue_vue_type_script_lang2["default"].__file = "packages/components/carousel/src/main.vue";
  exports["default"] = main_vue_vue_type_script_lang2["default"];
})(main$1);
var item$3 = {};
var item_vue_vue_type_script_lang$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$l;
  var error2 = error$5;
  const CARD_SCALE = 0.83;
  var script2 = vue2.defineComponent({
    name: "ElCarouselItem",
    props: {
      name: { type: String, default: "" },
      label: {
        type: [String, Number],
        default: ""
      }
    },
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const data2 = vue2.reactive({
        hover: false,
        translate: 0,
        scale: 1,
        active: false,
        ready: false,
        inStage: false,
        animating: false
      });
      const injectCarouselScope = vue2.inject("injectCarouselScope");
      const parentDirection = vue2.computed(() => {
        return injectCarouselScope.direction;
      });
      const itemStyle = vue2.computed(() => {
        const translateType = parentDirection.value === "vertical" ? "translateY" : "translateX";
        const value = `${translateType}(${data2.translate}px) scale(${data2.scale})`;
        const style = {
          transform: value
        };
        return util2.autoprefixer(style);
      });
      function processIndex(index2, activeIndex, length) {
        if (activeIndex === 0 && index2 === length - 1) {
          return -1;
        } else if (activeIndex === length - 1 && index2 === 0) {
          return length;
        } else if (index2 < activeIndex - 1 && activeIndex - index2 >= length / 2) {
          return length + 1;
        } else if (index2 > activeIndex + 1 && index2 - activeIndex >= length / 2) {
          return -2;
        }
        return index2;
      }
      function calcCardTranslate(index2, activeIndex) {
        var _a;
        const parentWidth = ((_a = injectCarouselScope.root.value) == null ? void 0 : _a.offsetWidth) || 0;
        if (data2.inStage) {
          return parentWidth * ((2 - CARD_SCALE) * (index2 - activeIndex) + 1) / 4;
        } else if (index2 < activeIndex) {
          return -(1 + CARD_SCALE) * parentWidth / 4;
        } else {
          return (3 + CARD_SCALE) * parentWidth / 4;
        }
      }
      function calcTranslate(index2, activeIndex, isVertical) {
        var _a, _b;
        const distance = (isVertical ? (_a = injectCarouselScope.root.value) == null ? void 0 : _a.offsetHeight : (_b = injectCarouselScope.root.value) == null ? void 0 : _b.offsetWidth) || 0;
        return distance * (index2 - activeIndex);
      }
      const translateItem = (index2, activeIndex, oldIndex) => {
        const parentType = injectCarouselScope.type;
        const length = injectCarouselScope.items.value.length;
        if (parentType !== "card" && oldIndex !== void 0) {
          data2.animating = index2 === activeIndex || index2 === oldIndex;
        }
        if (index2 !== activeIndex && length > 2 && injectCarouselScope.loop) {
          index2 = processIndex(index2, activeIndex, length);
        }
        if (parentType === "card") {
          if (parentDirection.value === "vertical") {
            error2.debugWarn("Carousel", "vertical direction is not supported in card mode");
          }
          data2.inStage = Math.round(Math.abs(index2 - activeIndex)) <= 1;
          data2.active = index2 === activeIndex;
          data2.translate = calcCardTranslate(index2, activeIndex);
          data2.scale = data2.active ? 1 : CARD_SCALE;
        } else {
          data2.active = index2 === activeIndex;
          const isVertical = parentDirection.value === "vertical";
          data2.translate = calcTranslate(index2, activeIndex, isVertical);
        }
        data2.ready = true;
      };
      function handleItemClick() {
        if (injectCarouselScope && injectCarouselScope.type === "card") {
          const index2 = injectCarouselScope.items.value.map((d2) => d2.uid).indexOf(instance.uid);
          injectCarouselScope.setActiveItem(index2);
        }
      }
      vue2.onMounted(() => {
        if (injectCarouselScope.addItem) {
          injectCarouselScope.addItem(__spreadProps(__spreadValues(__spreadValues({
            uid: instance.uid
          }, props2), vue2.toRefs(data2)), {
            translateItem
          }));
        }
      });
      vue2.onUnmounted(() => {
        if (injectCarouselScope.removeItem) {
          injectCarouselScope.removeItem(instance.uid);
        }
      });
      return {
        data: data2,
        itemStyle,
        translateItem,
        type: injectCarouselScope.type,
        handleItemClick
      };
    }
  });
  exports["default"] = script2;
})(item_vue_vue_type_script_lang$3);
var item_vue_vue_type_template_id_3d2e4fb8_lang = {};
Object.defineProperty(item_vue_vue_type_template_id_3d2e4fb8_lang, "__esModule", { value: true });
var vue$20 = require$$0$1;
const _hoisted_1$14 = {
  key: 0,
  class: "el-carousel__mask"
};
function render$1v(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$20.withDirectives((vue$20.openBlock(), vue$20.createElementBlock("div", {
    class: vue$20.normalizeClass(["el-carousel__item", {
      "is-active": _ctx.data.active,
      "el-carousel__item--card": _ctx.type === "card",
      "is-in-stage": _ctx.data.inStage,
      "is-hover": _ctx.data.hover,
      "is-animating": _ctx.data.animating
    }]),
    style: vue$20.normalizeStyle(_ctx.itemStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleItemClick && _ctx.handleItemClick(...args))
  }, [
    _ctx.type === "card" ? vue$20.withDirectives((vue$20.openBlock(), vue$20.createElementBlock("div", _hoisted_1$14, null, 512)), [
      [vue$20.vShow, !_ctx.data.active]
    ]) : vue$20.createCommentVNode("v-if", true),
    vue$20.renderSlot(_ctx.$slots, "default")
  ], 6)), [
    [vue$20.vShow, _ctx.data.ready]
  ]);
}
item_vue_vue_type_template_id_3d2e4fb8_lang.render = render$1v;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var item_vue_vue_type_script_lang2 = item_vue_vue_type_script_lang$3;
  var item_vue_vue_type_template_id_3d2e4fb8_lang$1 = item_vue_vue_type_template_id_3d2e4fb8_lang;
  item_vue_vue_type_script_lang2["default"].render = item_vue_vue_type_template_id_3d2e4fb8_lang$1.render;
  item_vue_vue_type_script_lang2["default"].__file = "packages/components/carousel/src/item.vue";
  exports["default"] = item_vue_vue_type_script_lang2["default"];
})(item$3);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var main_vue_vue_type_script_lang2 = main_vue_vue_type_script_lang$1;
  var item_vue_vue_type_script_lang2 = item_vue_vue_type_script_lang$3;
  const ElCarousel = withInstall2.withInstall(main_vue_vue_type_script_lang2["default"], {
    CarouselItem: item_vue_vue_type_script_lang2["default"]
  });
  const ElCarouselItem = withInstall2.withNoopInstall(item_vue_vue_type_script_lang2["default"]);
  exports.ElCarousel = ElCarousel;
  exports.ElCarouselItem = ElCarouselItem;
  exports["default"] = ElCarousel;
})(carousel);
var cascader = {};
var src$e = {};
var index_vue_vue_type_script_lang$b = {};
var cascaderPanel = {};
var src$d = {};
var index_vue_vue_type_script_lang$a = {};
var scrollIntoView$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var isServer2 = isServer$8;
  function scrollIntoView2(container2, selected) {
    if (isServer2["default"])
      return;
    if (!selected) {
      container2.scrollTop = 0;
      return;
    }
    const offsetParents = [];
    let pointer2 = selected.offsetParent;
    while (pointer2 !== null && container2 !== pointer2 && container2.contains(pointer2)) {
      offsetParents.push(pointer2);
      pointer2 = pointer2.offsetParent;
    }
    const top2 = selected.offsetTop + offsetParents.reduce((prev2, curr) => prev2 + curr.offsetTop, 0);
    const bottom2 = top2 + selected.offsetHeight;
    const viewRectTop = container2.scrollTop;
    const viewRectBottom = viewRectTop + container2.clientHeight;
    if (top2 < viewRectTop) {
      container2.scrollTop = top2;
    } else if (bottom2 > viewRectBottom) {
      container2.scrollTop = bottom2 - container2.clientHeight;
    }
  }
  exports["default"] = scrollIntoView2;
})(scrollIntoView$1);
var menu$3 = {};
var menu_vue_vue_type_script_lang = {};
var node2 = {};
var node_vue_vue_type_script_lang = {};
var checkbox$1 = {};
var checkbox = {};
var checkbox_vue_vue_type_script_lang = {};
var useCheckbox$1 = {};
Object.defineProperty(useCheckbox$1, "__esModule", { value: true });
var vue$1$ = require$$0$1;
var shared$b = require$$1$1;
var constants$b = constants$f;
var form$4 = form$7;
var index$1g = useCommonProps;
const useCheckboxProps = {
  modelValue: {
    type: [Boolean, Number, String],
    default: () => void 0
  },
  label: {
    type: [String, Boolean, Number, Object]
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  tabindex: [String, Number],
  size: String
};
const useCheckboxGroup = () => {
  const elForm = vue$1$.inject(form$4.elFormKey, {});
  const elFormItem = vue$1$.inject(form$4.elFormItemKey, {});
  const checkboxGroup2 = vue$1$.inject("CheckboxGroup", {});
  const isGroup = vue$1$.computed(() => checkboxGroup2 && (checkboxGroup2 == null ? void 0 : checkboxGroup2.name) === "ElCheckboxGroup");
  const elFormItemSize = vue$1$.computed(() => {
    return elFormItem.size;
  });
  return {
    isGroup,
    checkboxGroup: checkboxGroup2,
    elForm,
    elFormItemSize,
    elFormItem
  };
};
const useModel = (props2) => {
  const selfModel = vue$1$.ref(false);
  const { emit } = vue$1$.getCurrentInstance();
  const { isGroup, checkboxGroup: checkboxGroup2 } = useCheckboxGroup();
  const isLimitExceeded = vue$1$.ref(false);
  const model = vue$1$.computed({
    get() {
      var _a, _b;
      return isGroup.value ? (_a = checkboxGroup2.modelValue) == null ? void 0 : _a.value : (_b = props2.modelValue) != null ? _b : selfModel.value;
    },
    set(val) {
      var _a;
      if (isGroup.value && Array.isArray(val)) {
        isLimitExceeded.value = checkboxGroup2.max !== void 0 && val.length > checkboxGroup2.max.value;
        isLimitExceeded.value === false && ((_a = checkboxGroup2 == null ? void 0 : checkboxGroup2.changeEvent) == null ? void 0 : _a.call(checkboxGroup2, val));
      } else {
        emit(constants$b.UPDATE_MODEL_EVENT, val);
        selfModel.value = val;
      }
    }
  });
  return {
    model,
    isLimitExceeded
  };
};
const useCheckboxStatus = (props2, { model }) => {
  const { isGroup, checkboxGroup: checkboxGroup2 } = useCheckboxGroup();
  const focus = vue$1$.ref(false);
  const size2 = index$1g.useSize(checkboxGroup2 == null ? void 0 : checkboxGroup2.checkboxGroupSize, { prop: true });
  const isChecked = vue$1$.computed(() => {
    const value = model.value;
    if (shared$b.toTypeString(value) === "[object Boolean]") {
      return value;
    } else if (Array.isArray(value)) {
      return value.includes(props2.label);
    } else if (value !== null && value !== void 0) {
      return value === props2.trueLabel;
    } else {
      return !!value;
    }
  });
  const checkboxSize = index$1g.useSize(vue$1$.computed(() => {
    var _a;
    return isGroup.value ? (_a = checkboxGroup2 == null ? void 0 : checkboxGroup2.checkboxGroupSize) == null ? void 0 : _a.value : void 0;
  }));
  return {
    isChecked,
    focus,
    size: size2,
    checkboxSize
  };
};
const useDisabled = (props2, {
  model,
  isChecked
}) => {
  const { elForm, isGroup, checkboxGroup: checkboxGroup2 } = useCheckboxGroup();
  const isLimitDisabled = vue$1$.computed(() => {
    var _a, _b;
    const max2 = (_a = checkboxGroup2.max) == null ? void 0 : _a.value;
    const min2 = (_b = checkboxGroup2.min) == null ? void 0 : _b.value;
    return !!(max2 || min2) && model.value.length >= max2 && !isChecked.value || model.value.length <= min2 && isChecked.value;
  });
  const isDisabled = vue$1$.computed(() => {
    var _a;
    const disabled = props2.disabled || elForm.disabled;
    return isGroup.value ? ((_a = checkboxGroup2.disabled) == null ? void 0 : _a.value) || disabled || isLimitDisabled.value : props2.disabled || elForm.disabled;
  });
  return {
    isDisabled,
    isLimitDisabled
  };
};
const setStoreValue = (props2, { model }) => {
  function addToStore() {
    if (Array.isArray(model.value) && !model.value.includes(props2.label)) {
      model.value.push(props2.label);
    } else {
      model.value = props2.trueLabel || true;
    }
  }
  props2.checked && addToStore();
};
const useEvent = (props2, { isLimitExceeded }) => {
  const { elFormItem } = useCheckboxGroup();
  const { emit } = vue$1$.getCurrentInstance();
  function handleChange(e) {
    var _a, _b;
    if (isLimitExceeded.value)
      return;
    const target2 = e.target;
    const value = target2.checked ? (_a = props2.trueLabel) != null ? _a : true : (_b = props2.falseLabel) != null ? _b : false;
    emit("change", value, e);
  }
  vue$1$.watch(() => props2.modelValue, () => {
    var _a;
    (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change");
  });
  return {
    handleChange
  };
};
const useCheckbox = (props2) => {
  const { model, isLimitExceeded } = useModel(props2);
  const { focus, size: size2, isChecked, checkboxSize } = useCheckboxStatus(props2, {
    model
  });
  const { isDisabled } = useDisabled(props2, { model, isChecked });
  const { handleChange } = useEvent(props2, { isLimitExceeded });
  setStoreValue(props2, { model });
  return {
    isChecked,
    isDisabled,
    checkboxSize,
    model,
    handleChange,
    focus,
    size: size2
  };
};
useCheckbox$1.useCheckbox = useCheckbox;
useCheckbox$1.useCheckboxGroup = useCheckboxGroup;
useCheckbox$1.useCheckboxProps = useCheckboxProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var constants2 = constants$f;
  var validators2 = validators$6;
  var useCheckbox2 = useCheckbox$1;
  var script2 = vue2.defineComponent({
    name: "ElCheckbox",
    props: {
      modelValue: {
        type: [Boolean, Number, String],
        default: () => void 0
      },
      label: {
        type: [String, Boolean, Number, Object]
      },
      indeterminate: Boolean,
      disabled: Boolean,
      checked: Boolean,
      name: {
        type: String,
        default: void 0
      },
      trueLabel: {
        type: [String, Number],
        default: void 0
      },
      falseLabel: {
        type: [String, Number],
        default: void 0
      },
      id: {
        type: String,
        default: void 0
      },
      controls: {
        type: String,
        default: void 0
      },
      border: Boolean,
      size: {
        type: String,
        validator: validators2.isValidComponentSize
      },
      tabindex: [String, Number]
    },
    emits: [constants2.UPDATE_MODEL_EVENT, "change"],
    setup(props2) {
      return useCheckbox2.useCheckbox(props2);
    }
  });
  exports["default"] = script2;
})(checkbox_vue_vue_type_script_lang);
var checkbox_vue_vue_type_template_id_2c9881e5_lang = {};
Object.defineProperty(checkbox_vue_vue_type_template_id_2c9881e5_lang, "__esModule", { value: true });
var vue$1_ = require$$0$1;
const _hoisted_1$13 = ["id", "aria-controls"];
const _hoisted_2$N = ["tabindex", "role", "aria-checked"];
const _hoisted_3$E = /* @__PURE__ */ vue$1_.createElementVNode("span", { class: "el-checkbox__inner" }, null, -1);
const _hoisted_4$t = ["aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
const _hoisted_5$l = ["aria-hidden", "disabled", "value", "name", "tabindex"];
const _hoisted_6$f = {
  key: 0,
  class: "el-checkbox__label"
};
function render$1u(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1_.openBlock(), vue$1_.createElementBlock("label", {
    id: _ctx.id,
    class: vue$1_.normalizeClass(["el-checkbox", [
      _ctx.checkboxSize ? "el-checkbox--" + _ctx.checkboxSize : "",
      { "is-disabled": _ctx.isDisabled },
      { "is-bordered": _ctx.border },
      { "is-checked": _ctx.isChecked }
    ]]),
    "aria-controls": _ctx.indeterminate ? _ctx.controls : null
  }, [
    vue$1_.createElementVNode("span", {
      class: vue$1_.normalizeClass(["el-checkbox__input", {
        "is-disabled": _ctx.isDisabled,
        "is-checked": _ctx.isChecked,
        "is-indeterminate": _ctx.indeterminate,
        "is-focus": _ctx.focus
      }]),
      tabindex: _ctx.indeterminate ? 0 : void 0,
      role: _ctx.indeterminate ? "checkbox" : void 0,
      "aria-checked": _ctx.indeterminate ? "mixed" : false
    }, [
      _hoisted_3$E,
      _ctx.trueLabel || _ctx.falseLabel ? vue$1_.withDirectives((vue$1_.openBlock(), vue$1_.createElementBlock("input", {
        key: 0,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
        class: "el-checkbox__original",
        type: "checkbox",
        "aria-hidden": _ctx.indeterminate ? "true" : "false",
        name: _ctx.name,
        tabindex: _ctx.tabindex,
        disabled: _ctx.isDisabled,
        "true-value": _ctx.trueLabel,
        "false-value": _ctx.falseLabel,
        onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.focus = true),
        onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focus = false)
      }, null, 40, _hoisted_4$t)), [
        [vue$1_.vModelCheckbox, _ctx.model]
      ]) : vue$1_.withDirectives((vue$1_.openBlock(), vue$1_.createElementBlock("input", {
        key: 1,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.model = $event),
        class: "el-checkbox__original",
        type: "checkbox",
        "aria-hidden": _ctx.indeterminate ? "true" : "false",
        disabled: _ctx.isDisabled,
        value: _ctx.label,
        name: _ctx.name,
        tabindex: _ctx.tabindex,
        onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onFocus: _cache[6] || (_cache[6] = ($event) => _ctx.focus = true),
        onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.focus = false)
      }, null, 40, _hoisted_5$l)), [
        [vue$1_.vModelCheckbox, _ctx.model]
      ])
    ], 10, _hoisted_2$N),
    _ctx.$slots.default || _ctx.label ? (vue$1_.openBlock(), vue$1_.createElementBlock("span", _hoisted_6$f, [
      vue$1_.renderSlot(_ctx.$slots, "default"),
      !_ctx.$slots.default ? (vue$1_.openBlock(), vue$1_.createElementBlock(vue$1_.Fragment, { key: 0 }, [
        vue$1_.createTextVNode(vue$1_.toDisplayString(_ctx.label), 1)
      ], 2112)) : vue$1_.createCommentVNode("v-if", true)
    ])) : vue$1_.createCommentVNode("v-if", true)
  ], 10, _hoisted_1$13);
}
checkbox_vue_vue_type_template_id_2c9881e5_lang.render = render$1u;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var checkbox_vue_vue_type_script_lang$1 = checkbox_vue_vue_type_script_lang;
  var checkbox_vue_vue_type_template_id_2c9881e5_lang$1 = checkbox_vue_vue_type_template_id_2c9881e5_lang;
  checkbox_vue_vue_type_script_lang$1["default"].render = checkbox_vue_vue_type_template_id_2c9881e5_lang$1.render;
  checkbox_vue_vue_type_script_lang$1["default"].__file = "packages/components/checkbox/src/checkbox.vue";
  exports["default"] = checkbox_vue_vue_type_script_lang$1["default"];
})(checkbox);
var checkboxButton = {};
var checkboxButton_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var constants2 = constants$f;
  var useCheckbox2 = useCheckbox$1;
  var script2 = vue2.defineComponent({
    name: "ElCheckboxButton",
    props: useCheckbox2.useCheckboxProps,
    emits: [constants2.UPDATE_MODEL_EVENT, "change"],
    setup(props2) {
      const { focus, isChecked, isDisabled, size: size2, model, handleChange } = useCheckbox2.useCheckbox(props2);
      const { checkboxGroup: checkboxGroup2 } = useCheckbox2.useCheckboxGroup();
      const activeStyle = vue2.computed(() => {
        var _a, _b, _c, _d;
        const fillValue = (_b = (_a = checkboxGroup2 == null ? void 0 : checkboxGroup2.fill) == null ? void 0 : _a.value) != null ? _b : "";
        return {
          backgroundColor: fillValue,
          borderColor: fillValue,
          color: (_d = (_c = checkboxGroup2 == null ? void 0 : checkboxGroup2.textColor) == null ? void 0 : _c.value) != null ? _d : "",
          boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : null
        };
      });
      return {
        focus,
        isChecked,
        isDisabled,
        model,
        handleChange,
        activeStyle,
        size: size2
      };
    }
  });
  exports["default"] = script2;
})(checkboxButton_vue_vue_type_script_lang);
var checkboxButton_vue_vue_type_template_id_f839a66c_lang = {};
Object.defineProperty(checkboxButton_vue_vue_type_template_id_f839a66c_lang, "__esModule", { value: true });
var vue$1Z = require$$0$1;
const _hoisted_1$12 = ["aria-checked", "aria-disabled"];
const _hoisted_2$M = ["name", "tabindex", "disabled", "true-value", "false-value"];
const _hoisted_3$D = ["name", "tabindex", "disabled", "value"];
function render$1t(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1Z.openBlock(), vue$1Z.createElementBlock("label", {
    class: vue$1Z.normalizeClass(["el-checkbox-button", [
      _ctx.size ? "el-checkbox-button--" + _ctx.size : "",
      { "is-disabled": _ctx.isDisabled },
      { "is-checked": _ctx.isChecked },
      { "is-focus": _ctx.focus }
    ]]),
    role: "checkbox",
    "aria-checked": _ctx.isChecked,
    "aria-disabled": _ctx.isDisabled
  }, [
    _ctx.trueLabel || _ctx.falseLabel ? vue$1Z.withDirectives((vue$1Z.openBlock(), vue$1Z.createElementBlock("input", {
      key: 0,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
      class: "el-checkbox-button__original",
      type: "checkbox",
      name: _ctx.name,
      tabindex: _ctx.tabindex,
      disabled: _ctx.isDisabled,
      "true-value": _ctx.trueLabel,
      "false-value": _ctx.falseLabel,
      onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.focus = true),
      onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_2$M)), [
      [vue$1Z.vModelCheckbox, _ctx.model]
    ]) : vue$1Z.withDirectives((vue$1Z.openBlock(), vue$1Z.createElementBlock("input", {
      key: 1,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.model = $event),
      class: "el-checkbox-button__original",
      type: "checkbox",
      name: _ctx.name,
      tabindex: _ctx.tabindex,
      disabled: _ctx.isDisabled,
      value: _ctx.label,
      onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[6] || (_cache[6] = ($event) => _ctx.focus = true),
      onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_3$D)), [
      [vue$1Z.vModelCheckbox, _ctx.model]
    ]),
    _ctx.$slots.default || _ctx.label ? (vue$1Z.openBlock(), vue$1Z.createElementBlock("span", {
      key: 2,
      class: "el-checkbox-button__inner",
      style: vue$1Z.normalizeStyle(_ctx.isChecked ? _ctx.activeStyle : null)
    }, [
      vue$1Z.renderSlot(_ctx.$slots, "default", {}, () => [
        vue$1Z.createTextVNode(vue$1Z.toDisplayString(_ctx.label), 1)
      ])
    ], 4)) : vue$1Z.createCommentVNode("v-if", true)
  ], 10, _hoisted_1$12);
}
checkboxButton_vue_vue_type_template_id_f839a66c_lang.render = render$1t;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var checkboxButton_vue_vue_type_script_lang$1 = checkboxButton_vue_vue_type_script_lang;
  var checkboxButton_vue_vue_type_template_id_f839a66c_lang$1 = checkboxButton_vue_vue_type_template_id_f839a66c_lang;
  checkboxButton_vue_vue_type_script_lang$1["default"].render = checkboxButton_vue_vue_type_template_id_f839a66c_lang$1.render;
  checkboxButton_vue_vue_type_script_lang$1["default"].__file = "packages/components/checkbox/src/checkbox-button.vue";
  exports["default"] = checkboxButton_vue_vue_type_script_lang$1["default"];
})(checkboxButton);
var checkboxGroup = {};
var checkboxGroup_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var constants2 = constants$f;
  var validators2 = validators$6;
  var useCheckbox2 = useCheckbox$1;
  var index2 = useCommonProps;
  var script2 = vue2.defineComponent({
    name: "ElCheckboxGroup",
    props: {
      modelValue: {
        type: [Object, Boolean, Array],
        default: () => void 0
      },
      disabled: Boolean,
      min: {
        type: Number,
        default: void 0
      },
      max: {
        type: Number,
        default: void 0
      },
      size: {
        type: String,
        validator: validators2.isValidComponentSize
      },
      fill: {
        type: String,
        default: void 0
      },
      textColor: {
        type: String,
        default: void 0
      }
    },
    emits: [constants2.UPDATE_MODEL_EVENT, "change"],
    setup(props2, ctx) {
      const { elFormItem } = useCheckbox2.useCheckboxGroup();
      const checkboxGroupSize = index2.useSize();
      const changeEvent = (value) => {
        ctx.emit(constants2.UPDATE_MODEL_EVENT, value);
        vue2.nextTick(() => {
          ctx.emit("change", value);
        });
      };
      const modelValue = vue2.computed({
        get() {
          return props2.modelValue;
        },
        set(val) {
          changeEvent(val);
        }
      });
      vue2.provide("CheckboxGroup", __spreadProps(__spreadValues({
        name: "ElCheckboxGroup",
        modelValue
      }, vue2.toRefs(props2)), {
        checkboxGroupSize,
        changeEvent
      }));
      vue2.watch(() => props2.modelValue, () => {
        var _a;
        (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change");
      });
    }
  });
  exports["default"] = script2;
})(checkboxGroup_vue_vue_type_script_lang);
var checkboxGroup_vue_vue_type_template_id_9944d4d2_lang = {};
Object.defineProperty(checkboxGroup_vue_vue_type_template_id_9944d4d2_lang, "__esModule", { value: true });
var vue$1Y = require$$0$1;
const _hoisted_1$11 = {
  class: "el-checkbox-group",
  role: "group",
  "aria-label": "checkbox-group"
};
function render$1s(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1Y.openBlock(), vue$1Y.createElementBlock("div", _hoisted_1$11, [
    vue$1Y.renderSlot(_ctx.$slots, "default")
  ]);
}
checkboxGroup_vue_vue_type_template_id_9944d4d2_lang.render = render$1s;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var checkboxGroup_vue_vue_type_script_lang$1 = checkboxGroup_vue_vue_type_script_lang;
  var checkboxGroup_vue_vue_type_template_id_9944d4d2_lang$1 = checkboxGroup_vue_vue_type_template_id_9944d4d2_lang;
  checkboxGroup_vue_vue_type_script_lang$1["default"].render = checkboxGroup_vue_vue_type_template_id_9944d4d2_lang$1.render;
  checkboxGroup_vue_vue_type_script_lang$1["default"].__file = "packages/components/checkbox/src/checkbox-group.vue";
  exports["default"] = checkboxGroup_vue_vue_type_script_lang$1["default"];
})(checkboxGroup);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var checkbox_vue_vue_type_script_lang$1 = checkbox_vue_vue_type_script_lang;
  var checkboxButton_vue_vue_type_script_lang$1 = checkboxButton_vue_vue_type_script_lang;
  var checkboxGroup_vue_vue_type_script_lang$1 = checkboxGroup_vue_vue_type_script_lang;
  const ElCheckbox = withInstall2.withInstall(checkbox_vue_vue_type_script_lang$1["default"], {
    CheckboxButton: checkboxButton_vue_vue_type_script_lang$1["default"],
    CheckboxGroup: checkboxGroup_vue_vue_type_script_lang$1["default"]
  });
  const ElCheckboxButton = withInstall2.withNoopInstall(checkboxButton_vue_vue_type_script_lang$1["default"]);
  const ElCheckboxGroup = withInstall2.withNoopInstall(checkboxGroup_vue_vue_type_script_lang$1["default"]);
  exports.ElCheckbox = ElCheckbox;
  exports.ElCheckboxButton = ElCheckboxButton;
  exports.ElCheckboxGroup = ElCheckboxGroup;
  exports["default"] = ElCheckbox;
})(checkbox$1);
var radio$5 = {};
var radio2 = {};
var radio_vue_vue_type_script_lang = {};
var radio$4 = {};
Object.defineProperty(radio$4, "__esModule", { value: true });
var vue$1X = require$$0$1;
var props$t = props$N;
var constants$a = constants$f;
var util$d = util$l;
var index$1f = useCommonProps;
var shared$a = require$$1$1;
var radio$3 = radio$6;
const radioPropsBase = props$t.buildProps({
  size: index$1f.useSizeProp,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
});
const radioProps = props$t.buildProps(__spreadProps(__spreadValues({}, radioPropsBase), {
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}));
const radioEmits = {
  [constants$a.UPDATE_MODEL_EVENT]: (val) => shared$a.isString(val) || util$d.isNumber(val) || util$d.isBool(val),
  change: (val) => shared$a.isString(val) || util$d.isNumber(val) || util$d.isBool(val)
};
const useRadio = (props2, emit) => {
  const radioRef = vue$1X.ref();
  const radioGroup3 = vue$1X.inject(radio$3.radioGroupKey, void 0);
  const isGroup = vue$1X.computed(() => !!radioGroup3);
  const modelValue = vue$1X.computed({
    get() {
      return isGroup.value ? radioGroup3.modelValue : props2.modelValue;
    },
    set(val) {
      if (isGroup.value) {
        radioGroup3.changeEvent(val);
      } else {
        emit(constants$a.UPDATE_MODEL_EVENT, val);
      }
      radioRef.value.checked = props2.modelValue === props2.label;
    }
  });
  const size2 = index$1f.useSize(vue$1X.computed(() => radioGroup3 == null ? void 0 : radioGroup3.size));
  const disabled = index$1f.useDisabled(vue$1X.computed(() => radioGroup3 == null ? void 0 : radioGroup3.disabled));
  const focus = vue$1X.ref(false);
  const tabIndex = vue$1X.computed(() => {
    return disabled.value || isGroup.value && modelValue.value !== props2.label ? -1 : 0;
  });
  return {
    radioRef,
    isGroup,
    radioGroup: radioGroup3,
    focus,
    size: size2,
    disabled,
    tabIndex,
    modelValue
  };
};
radio$4.radioEmits = radioEmits;
radio$4.radioProps = radioProps;
radio$4.radioPropsBase = radioPropsBase;
radio$4.useRadio = useRadio;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var radio3 = radio$4;
  var script2 = vue2.defineComponent({
    name: "ElRadio",
    props: radio3.radioProps,
    emits: radio3.radioEmits,
    setup(props2, { emit }) {
      const { radioRef, isGroup, focus, size: size2, disabled, tabIndex, modelValue } = radio3.useRadio(props2, emit);
      function handleChange() {
        vue2.nextTick(() => emit("change", modelValue.value));
      }
      return {
        focus,
        isGroup,
        modelValue,
        tabIndex,
        size: size2,
        disabled,
        radioRef,
        handleChange
      };
    }
  });
  exports["default"] = script2;
})(radio_vue_vue_type_script_lang);
var radio_vue_vue_type_template_id_6aa3dfc7_lang = {};
Object.defineProperty(radio_vue_vue_type_template_id_6aa3dfc7_lang, "__esModule", { value: true });
var vue$1W = require$$0$1;
const _hoisted_1$10 = ["aria-checked", "aria-disabled", "tabindex"];
const _hoisted_2$L = /* @__PURE__ */ vue$1W.createElementVNode("span", { class: "el-radio__inner" }, null, -1);
const _hoisted_3$C = ["value", "name", "disabled"];
function render$1r(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1W.openBlock(), vue$1W.createElementBlock("label", {
    class: vue$1W.normalizeClass(["el-radio", {
      [`el-radio--${_ctx.size || ""}`]: _ctx.size,
      "is-disabled": _ctx.disabled,
      "is-focus": _ctx.focus,
      "is-bordered": _ctx.border,
      "is-checked": _ctx.modelValue === _ctx.label
    }]),
    role: "radio",
    "aria-checked": _ctx.modelValue === _ctx.label,
    "aria-disabled": _ctx.disabled,
    tabindex: _ctx.tabIndex,
    onKeydown: _cache[5] || (_cache[5] = vue$1W.withKeys(vue$1W.withModifiers(($event) => _ctx.modelValue = _ctx.disabled ? _ctx.modelValue : _ctx.label, ["stop", "prevent"]), ["space"]))
  }, [
    vue$1W.createElementVNode("span", {
      class: vue$1W.normalizeClass(["el-radio__input", {
        "is-disabled": _ctx.disabled,
        "is-checked": _ctx.modelValue === _ctx.label
      }])
    }, [
      _hoisted_2$L,
      vue$1W.withDirectives(vue$1W.createElementVNode("input", {
        ref: "radioRef",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.modelValue = $event),
        class: "el-radio__original",
        value: _ctx.label,
        type: "radio",
        "aria-hidden": "true",
        name: _ctx.name,
        disabled: _ctx.disabled,
        tabindex: "-1",
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focus = true),
        onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.focus = false),
        onChange: _cache[3] || (_cache[3] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
      }, null, 40, _hoisted_3$C), [
        [vue$1W.vModelRadio, _ctx.modelValue]
      ])
    ], 2),
    vue$1W.createElementVNode("span", {
      class: "el-radio__label",
      onKeydown: _cache[4] || (_cache[4] = vue$1W.withModifiers(() => {
      }, ["stop"]))
    }, [
      vue$1W.renderSlot(_ctx.$slots, "default", {}, () => [
        vue$1W.createTextVNode(vue$1W.toDisplayString(_ctx.label), 1)
      ])
    ], 32)
  ], 42, _hoisted_1$10);
}
radio_vue_vue_type_template_id_6aa3dfc7_lang.render = render$1r;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var radio_vue_vue_type_script_lang$1 = radio_vue_vue_type_script_lang;
  var radio_vue_vue_type_template_id_6aa3dfc7_lang$1 = radio_vue_vue_type_template_id_6aa3dfc7_lang;
  radio_vue_vue_type_script_lang$1["default"].render = radio_vue_vue_type_template_id_6aa3dfc7_lang$1.render;
  radio_vue_vue_type_script_lang$1["default"].__file = "packages/components/radio/src/radio.vue";
  exports["default"] = radio_vue_vue_type_script_lang$1["default"];
})(radio2);
var radioButton2 = {};
var radioButton_vue_vue_type_script_lang = {};
var radioButton$1 = {};
Object.defineProperty(radioButton$1, "__esModule", { value: true });
var props$s = props$N;
var radio$2 = radio$4;
const radioButtonProps = props$s.buildProps(__spreadProps(__spreadValues({}, radio$2.radioPropsBase), {
  name: {
    type: String,
    default: ""
  }
}));
radioButton$1.radioButtonProps = radioButtonProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var radio3 = radio$4;
  var radioButton3 = radioButton$1;
  var script2 = vue2.defineComponent({
    name: "ElRadioButton",
    props: radioButton3.radioButtonProps,
    setup(props2, { emit }) {
      const {
        radioRef,
        isGroup,
        focus,
        size: size2,
        disabled,
        tabIndex,
        modelValue,
        radioGroup: radioGroup3
      } = radio3.useRadio(props2, emit);
      const activeStyle = vue2.computed(() => {
        return {
          backgroundColor: (radioGroup3 == null ? void 0 : radioGroup3.fill) || "",
          borderColor: (radioGroup3 == null ? void 0 : radioGroup3.fill) || "",
          boxShadow: (radioGroup3 == null ? void 0 : radioGroup3.fill) ? `-1px 0 0 0 ${radioGroup3.fill}` : "",
          color: (radioGroup3 == null ? void 0 : radioGroup3.textColor) || ""
        };
      });
      return {
        isGroup,
        size: size2,
        disabled,
        tabIndex,
        modelValue,
        focus,
        activeStyle,
        radioRef
      };
    }
  });
  exports["default"] = script2;
})(radioButton_vue_vue_type_script_lang);
var radioButton_vue_vue_type_template_id_14e266b0_lang = {};
Object.defineProperty(radioButton_vue_vue_type_template_id_14e266b0_lang, "__esModule", { value: true });
var vue$1V = require$$0$1;
const _hoisted_1$$ = ["aria-checked", "aria-disabled", "tabindex"];
const _hoisted_2$K = ["value", "name", "disabled"];
function render$1q(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1V.openBlock(), vue$1V.createElementBlock("label", {
    class: vue$1V.normalizeClass(["el-radio-button", [
      _ctx.size ? "el-radio-button--" + _ctx.size : "",
      {
        "is-active": _ctx.modelValue === _ctx.label,
        "is-disabled": _ctx.disabled,
        "is-focus": _ctx.focus
      }
    ]]),
    role: "radio",
    "aria-checked": _ctx.modelValue === _ctx.label,
    "aria-disabled": _ctx.disabled,
    tabindex: _ctx.tabIndex,
    onKeydown: _cache[4] || (_cache[4] = vue$1V.withKeys(vue$1V.withModifiers(($event) => _ctx.modelValue = _ctx.disabled ? _ctx.modelValue : _ctx.label, ["stop", "prevent"]), ["space"]))
  }, [
    vue$1V.withDirectives(vue$1V.createElementVNode("input", {
      ref: "radioRef",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.modelValue = $event),
      class: "el-radio-button__original-radio",
      value: _ctx.label,
      type: "radio",
      name: _ctx.name,
      disabled: _ctx.disabled,
      tabindex: "-1",
      onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focus = true),
      onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_2$K), [
      [vue$1V.vModelRadio, _ctx.modelValue]
    ]),
    vue$1V.createElementVNode("span", {
      class: "el-radio-button__inner",
      style: vue$1V.normalizeStyle(_ctx.modelValue === _ctx.label ? _ctx.activeStyle : {}),
      onKeydown: _cache[3] || (_cache[3] = vue$1V.withModifiers(() => {
      }, ["stop"]))
    }, [
      vue$1V.renderSlot(_ctx.$slots, "default", {}, () => [
        vue$1V.createTextVNode(vue$1V.toDisplayString(_ctx.label), 1)
      ])
    ], 36)
  ], 42, _hoisted_1$$);
}
radioButton_vue_vue_type_template_id_14e266b0_lang.render = render$1q;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var radioButton_vue_vue_type_script_lang$1 = radioButton_vue_vue_type_script_lang;
  var radioButton_vue_vue_type_template_id_14e266b0_lang$1 = radioButton_vue_vue_type_template_id_14e266b0_lang;
  radioButton_vue_vue_type_script_lang$1["default"].render = radioButton_vue_vue_type_template_id_14e266b0_lang$1.render;
  radioButton_vue_vue_type_script_lang$1["default"].__file = "packages/components/radio/src/radio-button.vue";
  exports["default"] = radioButton_vue_vue_type_script_lang$1["default"];
})(radioButton2);
var radioGroup2 = {};
var radioGroup_vue_vue_type_script_lang = {};
var radioGroup$1 = {};
Object.defineProperty(radioGroup$1, "__esModule", { value: true });
var props$r = props$N;
var radio$1 = radio$4;
var index$1e = useCommonProps;
const radioGroupProps = props$r.buildProps({
  size: index$1e.useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  textColor: {
    type: String,
    default: ""
  }
});
const radioGroupEmits = radio$1.radioEmits;
radioGroup$1.radioGroupEmits = radioGroupEmits;
radioGroup$1.radioGroupProps = radioGroupProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var aria2 = aria$5;
  var constants2 = constants$f;
  var radioGroup3 = radioGroup$1;
  var index2 = useFormItem$1;
  var radio3 = radio$6;
  var script2 = vue2.defineComponent({
    name: "ElRadioGroup",
    props: radioGroup3.radioGroupProps,
    emits: radioGroup3.radioGroupEmits,
    setup(props2, ctx) {
      const radioGroupRef = vue2.ref();
      const { formItem: formItem2 } = index2.useFormItem();
      const changeEvent = (value) => {
        ctx.emit(constants2.UPDATE_MODEL_EVENT, value);
        vue2.nextTick(() => ctx.emit("change", value));
      };
      const handleKeydown = (e) => {
        if (!radioGroupRef.value)
          return;
        const target2 = e.target;
        const className = target2.nodeName === "INPUT" ? "[type=radio]" : "[role=radio]";
        const radios = radioGroupRef.value.querySelectorAll(className);
        const length = radios.length;
        const index3 = Array.from(radios).indexOf(target2);
        const roleRadios = radioGroupRef.value.querySelectorAll("[role=radio]");
        let nextIndex = null;
        switch (e.code) {
          case aria2.EVENT_CODE.left:
          case aria2.EVENT_CODE.up:
            e.stopPropagation();
            e.preventDefault();
            nextIndex = index3 === 0 ? length - 1 : index3 - 1;
            break;
          case aria2.EVENT_CODE.right:
          case aria2.EVENT_CODE.down:
            e.stopPropagation();
            e.preventDefault();
            nextIndex = index3 === length - 1 ? 0 : index3 + 1;
            break;
        }
        if (nextIndex === null)
          return;
        roleRadios[nextIndex].click();
        roleRadios[nextIndex].focus();
      };
      vue2.onMounted(() => {
        const radios = radioGroupRef.value.querySelectorAll("[type=radio]");
        const firstLabel = radios[0];
        if (!Array.from(radios).some((radio4) => radio4.checked) && firstLabel) {
          firstLabel.tabIndex = 0;
        }
      });
      vue2.provide(radio3.radioGroupKey, vue2.reactive(__spreadProps(__spreadValues({}, vue2.toRefs(props2)), {
        changeEvent
      })));
      vue2.watch(() => props2.modelValue, () => formItem2 == null ? void 0 : formItem2.validate("change"));
      return {
        radioGroupRef,
        handleKeydown
      };
    }
  });
  exports["default"] = script2;
})(radioGroup_vue_vue_type_script_lang);
var radioGroup_vue_vue_type_template_id_53ef81f9_lang = {};
Object.defineProperty(radioGroup_vue_vue_type_template_id_53ef81f9_lang, "__esModule", { value: true });
var vue$1U = require$$0$1;
function render$1p(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1U.openBlock(), vue$1U.createElementBlock("div", {
    ref: "radioGroupRef",
    class: "el-radio-group",
    role: "radiogroup",
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
  }, [
    vue$1U.renderSlot(_ctx.$slots, "default")
  ], 544);
}
radioGroup_vue_vue_type_template_id_53ef81f9_lang.render = render$1p;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var radioGroup_vue_vue_type_script_lang$1 = radioGroup_vue_vue_type_script_lang;
  var radioGroup_vue_vue_type_template_id_53ef81f9_lang$1 = radioGroup_vue_vue_type_template_id_53ef81f9_lang;
  radioGroup_vue_vue_type_script_lang$1["default"].render = radioGroup_vue_vue_type_template_id_53ef81f9_lang$1.render;
  radioGroup_vue_vue_type_script_lang$1["default"].__file = "packages/components/radio/src/radio-group.vue";
  exports["default"] = radioGroup_vue_vue_type_script_lang$1["default"];
})(radioGroup2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var radio3 = radio$4;
  var radioGroup3 = radioGroup$1;
  var radioButton3 = radioButton$1;
  var radio_vue_vue_type_script_lang$1 = radio_vue_vue_type_script_lang;
  var radioButton_vue_vue_type_script_lang$1 = radioButton_vue_vue_type_script_lang;
  var radioGroup_vue_vue_type_script_lang$1 = radioGroup_vue_vue_type_script_lang;
  const ElRadio = withInstall2.withInstall(radio_vue_vue_type_script_lang$1["default"], {
    RadioButton: radioButton_vue_vue_type_script_lang$1["default"],
    RadioGroup: radioGroup_vue_vue_type_script_lang$1["default"]
  });
  const ElRadioGroup = withInstall2.withNoopInstall(radioGroup_vue_vue_type_script_lang$1["default"]);
  const ElRadioButton = withInstall2.withNoopInstall(radioButton_vue_vue_type_script_lang$1["default"]);
  exports.radioEmits = radio3.radioEmits;
  exports.radioProps = radio3.radioProps;
  exports.radioPropsBase = radio3.radioPropsBase;
  exports.useRadio = radio3.useRadio;
  exports.radioGroupEmits = radioGroup3.radioGroupEmits;
  exports.radioGroupProps = radioGroup3.radioGroupProps;
  exports.radioButtonProps = radioButton3.radioButtonProps;
  exports.ElRadio = ElRadio;
  exports.ElRadioButton = ElRadioButton;
  exports.ElRadioGroup = ElRadioGroup;
  exports["default"] = ElRadio;
})(radio$5);
var nodeContent = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var NodeContent = vue2.defineComponent({
    name: "NodeContent",
    render() {
      const { node: node3, panel } = this.$parent;
      const { data: data2, label } = node3;
      const { renderLabelFn } = panel;
      return vue2.h("span", { class: "el-cascader-node__label" }, renderLabelFn ? renderLabelFn({ node: node3, data: data2 }) : label);
    }
  });
  exports["default"] = NodeContent;
})(nodeContent);
var types$2 = {};
Object.defineProperty(types$2, "__esModule", { value: true });
var ExpandTrigger = /* @__PURE__ */ ((ExpandTrigger2) => {
  ExpandTrigger2["CLICK"] = "click";
  ExpandTrigger2["HOVER"] = "hover";
  return ExpandTrigger2;
})(ExpandTrigger || {});
const CASCADER_PANEL_INJECTION_KEY = Symbol();
types$2.CASCADER_PANEL_INJECTION_KEY = CASCADER_PANEL_INJECTION_KEY;
types$2.ExpandTrigger = ExpandTrigger;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = checkbox$1;
  var index$110 = radio$5;
  var index$22 = icon$4;
  var iconsVue2 = require$$3;
  var nodeContent$1 = nodeContent;
  var types2 = types$2;
  var script2 = vue2.defineComponent({
    name: "ElCascaderNode",
    components: {
      ElCheckbox: index2.ElCheckbox,
      ElRadio: index$110.ElRadio,
      NodeContent: nodeContent$1["default"],
      ElIcon: index$22.ElIcon,
      Check: iconsVue2.Check,
      Loading: iconsVue2.Loading,
      ArrowRight: iconsVue2.ArrowRight
    },
    props: {
      node: {
        type: Object,
        required: true
      },
      menuId: String
    },
    emits: ["expand"],
    setup(props2, { emit }) {
      const panel = vue2.inject(types2.CASCADER_PANEL_INJECTION_KEY);
      const isHoverMenu = vue2.computed(() => panel.isHoverMenu);
      const multiple = vue2.computed(() => panel.config.multiple);
      const checkStrictly = vue2.computed(() => panel.config.checkStrictly);
      const checkedNodeId = vue2.computed(() => {
        var _a;
        return (_a = panel.checkedNodes[0]) == null ? void 0 : _a.uid;
      });
      const isDisabled = vue2.computed(() => props2.node.isDisabled);
      const isLeaf = vue2.computed(() => props2.node.isLeaf);
      const expandable = vue2.computed(() => checkStrictly.value && !isLeaf.value || !isDisabled.value);
      const inExpandingPath = vue2.computed(() => isInPath(panel.expandingNode));
      const inCheckedPath = vue2.computed(() => checkStrictly.value && panel.checkedNodes.some(isInPath));
      const isInPath = (node3) => {
        var _a;
        const { level, uid: uid2 } = props2.node;
        return ((_a = node3 == null ? void 0 : node3.pathNodes[level - 1]) == null ? void 0 : _a.uid) === uid2;
      };
      const doExpand = () => {
        if (inExpandingPath.value)
          return;
        panel.expandNode(props2.node);
      };
      const doCheck = (checked2) => {
        const { node: node3 } = props2;
        if (checked2 === node3.checked)
          return;
        panel.handleCheckChange(node3, checked2);
      };
      const doLoad = () => {
        panel.lazyLoad(props2.node, () => {
          if (!isLeaf.value)
            doExpand();
        });
      };
      const handleHoverExpand = (e) => {
        if (!isHoverMenu.value)
          return;
        handleExpand();
        !isLeaf.value && emit("expand", e);
      };
      const handleExpand = () => {
        const { node: node3 } = props2;
        if (!expandable.value || node3.loading)
          return;
        node3.loaded ? doExpand() : doLoad();
      };
      const handleClick = () => {
        if (isHoverMenu.value && !isLeaf.value)
          return;
        if (isLeaf.value && !isDisabled.value && !checkStrictly.value && !multiple.value) {
          handleCheck(true);
        } else {
          handleExpand();
        }
      };
      const handleCheck = (checked2) => {
        if (!props2.node.loaded) {
          doLoad();
        } else {
          doCheck(checked2);
          !checkStrictly.value && doExpand();
        }
      };
      return {
        panel,
        isHoverMenu,
        multiple,
        checkStrictly,
        checkedNodeId,
        isDisabled,
        isLeaf,
        expandable,
        inExpandingPath,
        inCheckedPath,
        handleHoverExpand,
        handleExpand,
        handleClick,
        handleCheck
      };
    }
  });
  exports["default"] = script2;
})(node_vue_vue_type_script_lang);
var node_vue_vue_type_template_id_18b09cb2_lang = {};
Object.defineProperty(node_vue_vue_type_template_id_18b09cb2_lang, "__esModule", { value: true });
var vue$1T = require$$0$1;
const _hoisted_1$_ = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"];
const _hoisted_2$J = /* @__PURE__ */ vue$1T.createElementVNode("span", null, null, -1);
function render$1o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = vue$1T.resolveComponent("el-checkbox");
  const _component_el_radio = vue$1T.resolveComponent("el-radio");
  const _component_check = vue$1T.resolveComponent("check");
  const _component_el_icon = vue$1T.resolveComponent("el-icon");
  const _component_node_content = vue$1T.resolveComponent("node-content");
  const _component_loading = vue$1T.resolveComponent("loading");
  const _component_arrow_right = vue$1T.resolveComponent("arrow-right");
  return vue$1T.openBlock(), vue$1T.createElementBlock("li", {
    id: `${_ctx.menuId}-${_ctx.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !_ctx.isLeaf,
    "aria-owns": _ctx.isLeaf ? null : _ctx.menuId,
    "aria-expanded": _ctx.inExpandingPath,
    tabindex: _ctx.expandable ? -1 : void 0,
    class: vue$1T.normalizeClass([
      "el-cascader-node",
      _ctx.checkStrictly && "is-selectable",
      _ctx.inExpandingPath && "in-active-path",
      _ctx.inCheckedPath && "in-checked-path",
      _ctx.node.checked && "is-active",
      !_ctx.expandable && "is-disabled"
    ]),
    onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    vue$1T.createCommentVNode(" prefix "),
    _ctx.multiple ? (vue$1T.openBlock(), vue$1T.createBlock(_component_el_checkbox, {
      key: 0,
      "model-value": _ctx.node.checked,
      indeterminate: _ctx.node.indeterminate,
      disabled: _ctx.isDisabled,
      onClick: _cache[0] || (_cache[0] = vue$1T.withModifiers(() => {
      }, ["stop"])),
      "onUpdate:modelValue": _ctx.handleCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : _ctx.checkStrictly ? (vue$1T.openBlock(), vue$1T.createBlock(_component_el_radio, {
      key: 1,
      "model-value": _ctx.checkedNodeId,
      label: _ctx.node.uid,
      disabled: _ctx.isDisabled,
      "onUpdate:modelValue": _ctx.handleCheck,
      onClick: _cache[1] || (_cache[1] = vue$1T.withModifiers(() => {
      }, ["stop"]))
    }, {
      default: vue$1T.withCtx(() => [
        vue$1T.createCommentVNode("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
        _hoisted_2$J
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : _ctx.isLeaf && _ctx.node.checked ? (vue$1T.openBlock(), vue$1T.createBlock(_component_el_icon, {
      key: 2,
      class: "el-cascader-node__prefix"
    }, {
      default: vue$1T.withCtx(() => [
        vue$1T.createVNode(_component_check)
      ]),
      _: 1
    })) : vue$1T.createCommentVNode("v-if", true),
    vue$1T.createCommentVNode(" content "),
    vue$1T.createVNode(_component_node_content),
    vue$1T.createCommentVNode(" postfix "),
    !_ctx.isLeaf ? (vue$1T.openBlock(), vue$1T.createElementBlock(vue$1T.Fragment, { key: 3 }, [
      _ctx.node.loading ? (vue$1T.openBlock(), vue$1T.createBlock(_component_el_icon, {
        key: 0,
        class: "is-loading el-cascader-node__postfix"
      }, {
        default: vue$1T.withCtx(() => [
          vue$1T.createVNode(_component_loading)
        ]),
        _: 1
      })) : (vue$1T.openBlock(), vue$1T.createBlock(_component_el_icon, {
        key: 1,
        class: "arrow-right el-cascader-node__postfix"
      }, {
        default: vue$1T.withCtx(() => [
          vue$1T.createVNode(_component_arrow_right)
        ]),
        _: 1
      }))
    ], 2112)) : vue$1T.createCommentVNode("v-if", true)
  ], 42, _hoisted_1$_);
}
node_vue_vue_type_template_id_18b09cb2_lang.render = render$1o;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_vue_vue_type_script_lang$1 = node_vue_vue_type_script_lang;
  var node_vue_vue_type_template_id_18b09cb2_lang$1 = node_vue_vue_type_template_id_18b09cb2_lang;
  node_vue_vue_type_script_lang$1["default"].render = node_vue_vue_type_template_id_18b09cb2_lang$1.render;
  node_vue_vue_type_script_lang$1["default"].__file = "packages/components/cascader-panel/src/node.vue";
  exports["default"] = node_vue_vue_type_script_lang$1["default"];
})(node2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = scrollbar$3;
  var util2 = util$l;
  var types2 = types$2;
  var node_vue_vue_type_script_lang$1 = node_vue_vue_type_script_lang;
  var index$110 = useLocale$1;
  var script2 = vue2.defineComponent({
    name: "ElCascaderMenu",
    components: {
      ElScrollbar: index2.ElScrollbar,
      ElCascaderNode: node_vue_vue_type_script_lang$1["default"]
    },
    props: {
      nodes: {
        type: Array,
        required: true
      },
      index: {
        type: Number,
        required: true
      }
    },
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const { t } = index$110.useLocale();
      const id = util2.generateId();
      let activeNode = null;
      let hoverTimer = null;
      const panel = vue2.inject(types2.CASCADER_PANEL_INJECTION_KEY);
      const hoverZone = vue2.ref(null);
      const isEmpty = vue2.computed(() => !props2.nodes.length);
      const menuId = vue2.computed(() => `cascader-menu-${id}-${props2.index}`);
      const handleExpand = (e) => {
        activeNode = e.target;
      };
      const handleMouseMove = (e) => {
        if (!panel.isHoverMenu || !activeNode || !hoverZone.value)
          return;
        if (activeNode.contains(e.target)) {
          clearHoverTimer();
          const el = instance.vnode.el;
          const { left: left2 } = el.getBoundingClientRect();
          const { offsetWidth, offsetHeight } = el;
          const startX = e.clientX - left2;
          const top2 = activeNode.offsetTop;
          const bottom2 = top2 + activeNode.offsetHeight;
          hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top2} L${offsetWidth} 0 V${top2} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom2} L${offsetWidth} ${offsetHeight} V${bottom2} Z" />
        `;
        } else if (!hoverTimer) {
          hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
        }
      };
      const clearHoverTimer = () => {
        if (!hoverTimer)
          return;
        clearTimeout(hoverTimer);
        hoverTimer = null;
      };
      const clearHoverZone = () => {
        if (!hoverZone.value)
          return;
        hoverZone.value.innerHTML = "";
        clearHoverTimer();
      };
      return {
        panel,
        hoverZone,
        isEmpty,
        menuId,
        t,
        handleExpand,
        handleMouseMove,
        clearHoverZone
      };
    }
  });
  exports["default"] = script2;
})(menu_vue_vue_type_script_lang);
var menu_vue_vue_type_template_id_9c79e4e2_lang = {};
Object.defineProperty(menu_vue_vue_type_template_id_9c79e4e2_lang, "__esModule", { value: true });
var vue$1S = require$$0$1;
const _hoisted_1$Z = {
  key: 0,
  class: "el-cascader-menu__empty-text"
};
const _hoisted_2$I = {
  key: 1,
  ref: "hoverZone",
  class: "el-cascader-menu__hover-zone"
};
function render$1n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_node = vue$1S.resolveComponent("el-cascader-node");
  const _component_el_scrollbar = vue$1S.resolveComponent("el-scrollbar");
  return vue$1S.openBlock(), vue$1S.createBlock(_component_el_scrollbar, {
    key: _ctx.menuId,
    tag: "ul",
    role: "menu",
    class: "el-cascader-menu",
    "wrap-class": "el-cascader-menu__wrap",
    "view-class": ["el-cascader-menu__list", _ctx.isEmpty && "is-empty"],
    onMousemove: _ctx.handleMouseMove,
    onMouseleave: _ctx.clearHoverZone
  }, {
    default: vue$1S.withCtx(() => {
      var _a;
      return [
        (vue$1S.openBlock(true), vue$1S.createElementBlock(vue$1S.Fragment, null, vue$1S.renderList(_ctx.nodes, (node3) => {
          return vue$1S.openBlock(), vue$1S.createBlock(_component_el_cascader_node, {
            key: node3.uid,
            node: node3,
            "menu-id": _ctx.menuId,
            onExpand: _ctx.handleExpand
          }, null, 8, ["node", "menu-id", "onExpand"]);
        }), 128)),
        _ctx.isEmpty ? (vue$1S.openBlock(), vue$1S.createElementBlock("div", _hoisted_1$Z, vue$1S.toDisplayString(_ctx.t("el.cascader.noData")), 1)) : ((_a = _ctx.panel) == null ? void 0 : _a.isHoverMenu) ? (vue$1S.openBlock(), vue$1S.createElementBlock("svg", _hoisted_2$I, null, 512)) : vue$1S.createCommentVNode("v-if", true)
      ];
    }),
    _: 1
  }, 8, ["view-class", "onMousemove", "onMouseleave"]);
}
menu_vue_vue_type_template_id_9c79e4e2_lang.render = render$1n;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var menu_vue_vue_type_script_lang$1 = menu_vue_vue_type_script_lang;
  var menu_vue_vue_type_template_id_9c79e4e2_lang$1 = menu_vue_vue_type_template_id_9c79e4e2_lang;
  menu_vue_vue_type_script_lang$1["default"].render = menu_vue_vue_type_template_id_9c79e4e2_lang$1.render;
  menu_vue_vue_type_script_lang$1["default"].__file = "packages/components/cascader-panel/src/menu.vue";
  exports["default"] = menu_vue_vue_type_script_lang$1["default"];
})(menu$3);
var store$1 = {};
var node$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var shared2 = require$$1$1;
  var util2 = util$l;
  var ExpandTrigger2 = /* @__PURE__ */ ((ExpandTrigger22) => {
    ExpandTrigger22["CLICK"] = "click";
    ExpandTrigger22["HOVER"] = "hover";
    return ExpandTrigger22;
  })(ExpandTrigger2 || {});
  let uid2 = 0;
  const calculatePathNodes = (node3) => {
    const nodes = [node3];
    let { parent } = node3;
    while (parent) {
      nodes.unshift(parent);
      parent = parent.parent;
    }
    return nodes;
  };
  class Node2 {
    constructor(data2, config2, parent, root2 = false) {
      this.data = data2;
      this.config = config2;
      this.parent = parent;
      this.root = root2;
      this.uid = uid2++;
      this.checked = false;
      this.indeterminate = false;
      this.loading = false;
      const { value: valueKey, label: labelKey, children: childrenKey } = config2;
      const childrenData = data2[childrenKey];
      const pathNodes = calculatePathNodes(this);
      this.level = root2 ? 0 : parent ? parent.level + 1 : 1;
      this.value = data2[valueKey];
      this.label = data2[labelKey];
      this.pathNodes = pathNodes;
      this.pathValues = pathNodes.map((node3) => node3.value);
      this.pathLabels = pathNodes.map((node3) => node3.label);
      this.childrenData = childrenData;
      this.children = (childrenData || []).map((child) => new Node2(child, config2, this));
      this.loaded = !config2.lazy || this.isLeaf || !util2.isEmpty(childrenData);
    }
    get isDisabled() {
      const { data: data2, parent, config: config2 } = this;
      const { disabled, checkStrictly } = config2;
      const isDisabled = shared2.isFunction(disabled) ? disabled(data2, this) : !!data2[disabled];
      return isDisabled || !checkStrictly && (parent == null ? void 0 : parent.isDisabled);
    }
    get isLeaf() {
      const { data: data2, config: config2, childrenData, loaded } = this;
      const { lazy, leaf } = config2;
      const isLeaf = shared2.isFunction(leaf) ? leaf(data2, this) : data2[leaf];
      return util2.isUndefined(isLeaf) ? lazy && !loaded ? false : !(Array.isArray(childrenData) && childrenData.length) : !!isLeaf;
    }
    get valueByOption() {
      return this.config.emitPath ? this.pathValues : this.value;
    }
    appendChild(childData) {
      const { childrenData, children } = this;
      const node3 = new Node2(childData, this.config, this);
      if (Array.isArray(childrenData)) {
        childrenData.push(childData);
      } else {
        this.childrenData = [childData];
      }
      children.push(node3);
      return node3;
    }
    calcText(allLevels, separator) {
      const text = allLevels ? this.pathLabels.join(separator) : this.label;
      this.text = text;
      return text;
    }
    broadcast(event, ...args) {
      const handlerName = `onParent${shared2.capitalize(event)}`;
      this.children.forEach((child) => {
        if (child) {
          child.broadcast(event, ...args);
          child[handlerName] && child[handlerName](...args);
        }
      });
    }
    emit(event, ...args) {
      const { parent } = this;
      const handlerName = `onChild${shared2.capitalize(event)}`;
      if (parent) {
        parent[handlerName] && parent[handlerName](...args);
        parent.emit(event, ...args);
      }
    }
    onParentCheck(checked2) {
      if (!this.isDisabled) {
        this.setCheckState(checked2);
      }
    }
    onChildCheck() {
      const { children } = this;
      const validChildren = children.filter((child) => !child.isDisabled);
      const checked2 = validChildren.length ? validChildren.every((child) => child.checked) : false;
      this.setCheckState(checked2);
    }
    setCheckState(checked2) {
      const totalNum = this.children.length;
      const checkedNum = this.children.reduce((c2, p2) => {
        const num = p2.checked ? 1 : p2.indeterminate ? 0.5 : 0;
        return c2 + num;
      }, 0);
      this.checked = this.loaded && this.children.every((child) => child.loaded && child.checked) && checked2;
      this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
    }
    doCheck(checked2) {
      if (this.checked === checked2)
        return;
      const { checkStrictly, multiple } = this.config;
      if (checkStrictly || !multiple) {
        this.checked = checked2;
      } else {
        this.broadcast("check", checked2);
        this.setCheckState(checked2);
        this.emit("check");
      }
    }
  }
  exports.ExpandTrigger = ExpandTrigger2;
  exports["default"] = Node2;
})(node$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var isEqual2 = isEqual_1;
  var node3 = node$2;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var isEqual__default2 = /* @__PURE__ */ _interopDefaultLegacy2(isEqual2);
  const flatNodes = (nodes, leafOnly) => {
    return nodes.reduce((res, node4) => {
      if (node4.isLeaf) {
        res.push(node4);
      } else {
        !leafOnly && res.push(node4);
        res = res.concat(flatNodes(node4.children, leafOnly));
      }
      return res;
    }, []);
  };
  class Store3 {
    constructor(data2, config2) {
      this.config = config2;
      const nodes = (data2 || []).map((nodeData) => new node3["default"](nodeData, this.config));
      this.nodes = nodes;
      this.allNodes = flatNodes(nodes, false);
      this.leafNodes = flatNodes(nodes, true);
    }
    getNodes() {
      return this.nodes;
    }
    getFlattedNodes(leafOnly) {
      return leafOnly ? this.leafNodes : this.allNodes;
    }
    appendNode(nodeData, parentNode) {
      const node$12 = parentNode ? parentNode.appendChild(nodeData) : new node3["default"](nodeData, this.config);
      if (!parentNode)
        this.nodes.push(node$12);
      this.allNodes.push(node$12);
      node$12.isLeaf && this.leafNodes.push(node$12);
    }
    appendNodes(nodeDataList, parentNode) {
      nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode));
    }
    getNodeByValue(value, leafOnly = false) {
      if (!value && value !== 0)
        return null;
      const nodes = this.getFlattedNodes(leafOnly).filter((node4) => isEqual__default2["default"](node4.value, value) || isEqual__default2["default"](node4.pathValues, value));
      return nodes[0] || null;
    }
    getSameNode(node4) {
      if (!node4)
        return null;
      const nodes = this.getFlattedNodes(false).filter(({ value, level }) => isEqual__default2["default"](node4.value, value) && node4.level === level);
      return nodes[0] || null;
    }
  }
  exports["default"] = Store3;
})(store$1);
var config$2 = {};
Object.defineProperty(config$2, "__esModule", { value: true });
var vue$1R = require$$0$1;
var shared$9 = require$$1$1;
var node$1 = node$2;
const CommonProps = {
  modelValue: [Number, String, Array],
  options: {
    type: Array,
    default: () => []
  },
  props: {
    type: Object,
    default: () => ({})
  }
};
const DefaultProps = {
  expandTrigger: node$1.ExpandTrigger.CLICK,
  multiple: false,
  checkStrictly: false,
  emitPath: true,
  lazy: false,
  lazyLoad: shared$9.NOOP,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
};
const useCascaderConfig = (props2) => {
  return vue$1R.computed(() => __spreadValues(__spreadValues({}, DefaultProps), props2.props));
};
config$2.CommonProps = CommonProps;
config$2.DefaultProps = DefaultProps;
config$2.useCascaderConfig = useCascaderConfig;
var utils$g = {};
Object.defineProperty(utils$g, "__esModule", { value: true });
var aria$3 = aria$5;
const getMenuIndex = (el) => {
  if (!el)
    return 0;
  const pieces = el.id.split("-");
  return Number(pieces[pieces.length - 2]);
};
const checkNode = (el) => {
  if (!el)
    return;
  const input3 = el.querySelector("input");
  if (input3) {
    input3.click();
  } else if (aria$3.isLeaf(el)) {
    el.click();
  }
};
const sortByOriginalOrder = (oldNodes, newNodes) => {
  const newNodesCopy = newNodes.slice(0);
  const newIds = newNodesCopy.map((node3) => node3.uid);
  const res = oldNodes.reduce((acc, item2) => {
    const index2 = newIds.indexOf(item2.uid);
    if (index2 > -1) {
      acc.push(item2);
      newNodesCopy.splice(index2, 1);
      newIds.splice(index2, 1);
    }
    return acc;
  }, []);
  res.push(...newNodesCopy);
  return res;
};
utils$g.checkNode = checkNode;
utils$g.getMenuIndex = getMenuIndex;
utils$g.sortByOriginalOrder = sortByOriginalOrder;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var isEqual2 = isEqual_1;
  var aria2 = aria$5;
  var constants2 = constants$f;
  var isServer2 = isServer$8;
  var scrollIntoView2 = scrollIntoView$1;
  var util2 = util$l;
  var store2 = store$1;
  var node3 = node$2;
  var config2 = config$2;
  var utils2 = utils$g;
  var types2 = types$2;
  var menu_vue_vue_type_script_lang$1 = menu_vue_vue_type_script_lang;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var isEqual__default2 = /* @__PURE__ */ _interopDefaultLegacy2(isEqual2);
  var script2 = vue2.defineComponent({
    name: "ElCascaderPanel",
    components: {
      ElCascaderMenu: menu_vue_vue_type_script_lang$1["default"]
    },
    props: __spreadProps(__spreadValues({}, config2.CommonProps), {
      border: {
        type: Boolean,
        default: true
      },
      renderLabel: Function
    }),
    emits: [constants2.UPDATE_MODEL_EVENT, constants2.CHANGE_EVENT, "close", "expand-change"],
    setup(props2, { emit, slots }) {
      let initialLoaded = true;
      let manualChecked = false;
      const config$12 = config2.useCascaderConfig(props2);
      let store$12 = null;
      const menuList = vue2.ref([]);
      const checkedValue = vue2.ref(null);
      const menus = vue2.ref([]);
      const expandingNode = vue2.ref(null);
      const checkedNodes = vue2.ref([]);
      const isHoverMenu = vue2.computed(() => config$12.value.expandTrigger === node3.ExpandTrigger.HOVER);
      const renderLabelFn = vue2.computed(() => props2.renderLabel || slots.default);
      const initStore = () => {
        const { options } = props2;
        const cfg = config$12.value;
        manualChecked = false;
        store$12 = new store2["default"](options, cfg);
        menus.value = [store$12.getNodes()];
        if (cfg.lazy && util2.isEmpty(props2.options)) {
          initialLoaded = false;
          lazyLoad(void 0, (list2) => {
            if (list2) {
              store$12 = new store2["default"](list2, cfg);
              menus.value = [store$12.getNodes()];
            }
            initialLoaded = true;
            syncCheckedValue(false, true);
          });
        } else {
          syncCheckedValue(false, true);
        }
      };
      const lazyLoad = (node$12, cb) => {
        const cfg = config$12.value;
        node$12 = node$12 || new node3["default"]({}, cfg, void 0, true);
        node$12.loading = true;
        const resolve2 = (dataList) => {
          const _node = node$12;
          const parent = _node.root ? null : _node;
          dataList && (store$12 == null ? void 0 : store$12.appendNodes(dataList, parent));
          _node.loading = false;
          _node.loaded = true;
          _node.childrenData = _node.childrenData || [];
          cb && cb(dataList);
        };
        cfg.lazyLoad(node$12, resolve2);
      };
      const expandNode = (node4, silent) => {
        var _a;
        const { level } = node4;
        const newMenus = menus.value.slice(0, level);
        let newExpandingNode;
        if (node4.isLeaf) {
          newExpandingNode = node4.pathNodes[level - 2];
        } else {
          newExpandingNode = node4;
          newMenus.push(node4.children);
        }
        if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
          expandingNode.value = node4;
          menus.value = newMenus;
          !silent && emit("expand-change", (node4 == null ? void 0 : node4.pathValues) || []);
        }
      };
      const handleCheckChange = (node4, checked2, emitClose = true) => {
        const { checkStrictly, multiple } = config$12.value;
        const oldNode = checkedNodes.value[0];
        manualChecked = true;
        !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));
        node4.doCheck(checked2);
        calculateCheckedValue();
        emitClose && !multiple && !checkStrictly && emit("close");
        !emitClose && !multiple && !checkStrictly && expandParentNode(node4);
      };
      const expandParentNode = (node4) => {
        if (!node4)
          return;
        node4 = node4.parent;
        expandParentNode(node4);
        node4 && expandNode(node4);
      };
      const getFlattedNodes = (leafOnly) => {
        return store$12 == null ? void 0 : store$12.getFlattedNodes(leafOnly);
      };
      const getCheckedNodes = (leafOnly) => {
        var _a;
        return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter((node4) => node4.checked !== false);
      };
      const clearCheckedNodes = () => {
        checkedNodes.value.forEach((node4) => node4.doCheck(false));
        calculateCheckedValue();
      };
      const calculateCheckedValue = () => {
        var _a;
        const { checkStrictly, multiple } = config$12.value;
        const oldNodes = checkedNodes.value;
        const newNodes = getCheckedNodes(!checkStrictly);
        const nodes = utils2.sortByOriginalOrder(oldNodes, newNodes);
        const values = nodes.map((node4) => node4.valueByOption);
        checkedNodes.value = nodes;
        checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;
      };
      const syncCheckedValue = (loaded = false, forced = false) => {
        const { modelValue } = props2;
        const { lazy, multiple, checkStrictly } = config$12.value;
        const leafOnly = !checkStrictly;
        if (!initialLoaded || manualChecked || !forced && isEqual__default2["default"](modelValue, checkedValue.value))
          return;
        if (lazy && !loaded) {
          const values = util2.deduplicate(util2.arrayFlat(util2.coerceTruthyValueToArray(modelValue)));
          const nodes = values.map((val) => store$12 == null ? void 0 : store$12.getNodeByValue(val)).filter((node4) => !!node4 && !node4.loaded && !node4.loading);
          if (nodes.length) {
            nodes.forEach((node4) => {
              lazyLoad(node4, () => syncCheckedValue(false, forced));
            });
          } else {
            syncCheckedValue(true, forced);
          }
        } else {
          const values = multiple ? util2.coerceTruthyValueToArray(modelValue) : [modelValue];
          const nodes = util2.deduplicate(values.map((val) => store$12 == null ? void 0 : store$12.getNodeByValue(val, leafOnly)));
          syncMenuState(nodes, false);
          checkedValue.value = modelValue;
        }
      };
      const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
        const { checkStrictly } = config$12.value;
        const oldNodes = checkedNodes.value;
        const newNodes = newCheckedNodes.filter((node4) => !!node4 && (checkStrictly || node4.isLeaf));
        const oldExpandingNode = store$12 == null ? void 0 : store$12.getSameNode(expandingNode.value);
        const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
        if (newExpandingNode) {
          newExpandingNode.pathNodes.forEach((node4) => expandNode(node4, true));
        } else {
          expandingNode.value = null;
        }
        oldNodes.forEach((node4) => node4.doCheck(false));
        newNodes.forEach((node4) => node4.doCheck(true));
        checkedNodes.value = newNodes;
        vue2.nextTick(scrollToExpandingNode);
      };
      const scrollToExpandingNode = () => {
        if (isServer2["default"])
          return;
        menuList.value.forEach((menu2) => {
          const menuElement = menu2 == null ? void 0 : menu2.$el;
          if (menuElement) {
            const container2 = menuElement.querySelector(".el-scrollbar__wrap");
            const activeNode = menuElement.querySelector(".el-cascader-node.is-active") || menuElement.querySelector(".el-cascader-node.in-active-path");
            scrollIntoView2["default"](container2, activeNode);
          }
        });
      };
      const handleKeyDown = (e) => {
        const target2 = e.target;
        const { code: code2 } = e;
        switch (code2) {
          case aria2.EVENT_CODE.up:
          case aria2.EVENT_CODE.down: {
            const distance = code2 === aria2.EVENT_CODE.up ? -1 : 1;
            aria2.focusNode(aria2.getSibling(target2, distance, '.el-cascader-node[tabindex="-1"]'));
            break;
          }
          case aria2.EVENT_CODE.left: {
            const preMenu = menuList.value[utils2.getMenuIndex(target2) - 1];
            const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector('.el-cascader-node[aria-expanded="true"]');
            aria2.focusNode(expandedNode);
            break;
          }
          case aria2.EVENT_CODE.right: {
            const nextMenu = menuList.value[utils2.getMenuIndex(target2) + 1];
            const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector('.el-cascader-node[tabindex="-1"]');
            aria2.focusNode(firstNode);
            break;
          }
          case aria2.EVENT_CODE.enter:
            utils2.checkNode(target2);
            break;
          case aria2.EVENT_CODE.esc:
          case aria2.EVENT_CODE.tab:
            emit("close");
            break;
        }
      };
      vue2.provide(types2.CASCADER_PANEL_INJECTION_KEY, vue2.reactive({
        config: config$12,
        expandingNode,
        checkedNodes,
        isHoverMenu,
        renderLabelFn,
        lazyLoad,
        expandNode,
        handleCheckChange
      }));
      vue2.watch([config$12, () => props2.options], initStore, {
        deep: true,
        immediate: true
      });
      vue2.watch(() => props2.modelValue, () => {
        manualChecked = false;
        syncCheckedValue();
      });
      vue2.watch(checkedValue, (val) => {
        if (!isEqual__default2["default"](val, props2.modelValue)) {
          emit(constants2.UPDATE_MODEL_EVENT, val);
          emit(constants2.CHANGE_EVENT, val);
        }
      });
      vue2.onBeforeUpdate(() => menuList.value = []);
      vue2.onMounted(() => !util2.isEmpty(props2.modelValue) && syncCheckedValue());
      return {
        menuList,
        menus,
        checkedNodes,
        handleKeyDown,
        handleCheckChange,
        getFlattedNodes,
        getCheckedNodes,
        clearCheckedNodes,
        calculateCheckedValue,
        scrollToExpandingNode
      };
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$a);
var index_vue_vue_type_template_id_97c48f5c_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_97c48f5c_lang, "__esModule", { value: true });
var vue$1Q = require$$0$1;
function render$1m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_menu = vue$1Q.resolveComponent("el-cascader-menu");
  return vue$1Q.openBlock(), vue$1Q.createElementBlock("div", {
    class: vue$1Q.normalizeClass(["el-cascader-panel", _ctx.border && "is-bordered"]),
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))
  }, [
    (vue$1Q.openBlock(true), vue$1Q.createElementBlock(vue$1Q.Fragment, null, vue$1Q.renderList(_ctx.menus, (menu2, index2) => {
      return vue$1Q.openBlock(), vue$1Q.createBlock(_component_el_cascader_menu, {
        key: index2,
        ref: (item2) => _ctx.menuList[index2] = item2,
        index: index2,
        nodes: menu2
      }, null, 8, ["index", "nodes"]);
    }), 128))
  ], 34);
}
index_vue_vue_type_template_id_97c48f5c_lang.render = render$1m;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$a;
  var index_vue_vue_type_template_id_97c48f5c_lang$1 = index_vue_vue_type_template_id_97c48f5c_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_97c48f5c_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/cascader-panel/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$d);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var types2 = types$2;
  var config2 = config$2;
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$a;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  const _CascaderPanel = index_vue_vue_type_script_lang2["default"];
  const ElCascaderPanel = _CascaderPanel;
  exports.CASCADER_PANEL_INJECTION_KEY = types2.CASCADER_PANEL_INJECTION_KEY;
  exports.ExpandTrigger = types2.ExpandTrigger;
  exports.CommonProps = config2.CommonProps;
  exports.DefaultProps = config2.DefaultProps;
  exports.useCascaderConfig = config2.useCascaderConfig;
  exports.ElCascaderPanel = ElCascaderPanel;
  exports["default"] = _CascaderPanel;
})(cascaderPanel);
var tag$2 = {};
var tag2 = {};
var tag_vue_vue_type_script_lang = {};
var tag$1 = {};
Object.defineProperty(tag$1, "__esModule", { value: true });
var props$q = props$N;
const tagProps = props$q.buildProps({
  closable: Boolean,
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  hit: Boolean,
  disableTransitions: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: ["large", "medium", "small", "mini"]
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  }
});
const tagEmits = {
  close: (evt) => evt instanceof MouseEvent,
  click: (evt) => evt instanceof MouseEvent
};
tag$1.tagEmits = tagEmits;
tag$1.tagProps = tagProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var tag3 = tag$1;
  var index$110 = useCommonProps;
  var script2 = vue2.defineComponent({
    name: "ElTag",
    components: { ElIcon: index2.ElIcon, Close: iconsVue2.Close },
    props: tag3.tagProps,
    emits: tag3.tagEmits,
    setup(props2, { emit }) {
      const tagSize = index$110.useSize();
      const classes = vue2.computed(() => {
        const { type: type4, hit, effect: effect2 } = props2;
        return [
          "el-tag",
          type4 ? `el-tag--${type4}` : "",
          tagSize.value ? `el-tag--${tagSize.value}` : "",
          effect2 ? `el-tag--${effect2}` : "",
          hit && "is-hit"
        ];
      });
      const handleClose = (event) => {
        event.stopPropagation();
        emit("close", event);
      };
      const handleClick = (event) => {
        emit("click", event);
      };
      return {
        classes,
        handleClose,
        handleClick
      };
    }
  });
  exports["default"] = script2;
})(tag_vue_vue_type_script_lang);
var tag_vue_vue_type_template_id_525996c5_lang = {};
Object.defineProperty(tag_vue_vue_type_template_id_525996c5_lang, "__esModule", { value: true });
var vue$1P = require$$0$1;
function render$1l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_close = vue$1P.resolveComponent("close");
  const _component_el_icon = vue$1P.resolveComponent("el-icon");
  return !_ctx.disableTransitions ? (vue$1P.openBlock(), vue$1P.createElementBlock("span", {
    key: 0,
    class: vue$1P.normalizeClass(_ctx.classes),
    style: vue$1P.normalizeStyle({ backgroundColor: _ctx.color }),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    vue$1P.renderSlot(_ctx.$slots, "default"),
    _ctx.closable ? (vue$1P.openBlock(), vue$1P.createBlock(_component_el_icon, {
      key: 0,
      class: "el-tag__close",
      onClick: _ctx.handleClose
    }, {
      default: vue$1P.withCtx(() => [
        vue$1P.createVNode(_component_close)
      ]),
      _: 1
    }, 8, ["onClick"])) : vue$1P.createCommentVNode("v-if", true)
  ], 6)) : (vue$1P.openBlock(), vue$1P.createBlock(vue$1P.Transition, {
    key: 1,
    name: "el-zoom-in-center"
  }, {
    default: vue$1P.withCtx(() => [
      vue$1P.createElementVNode("span", {
        class: vue$1P.normalizeClass(_ctx.classes),
        style: vue$1P.normalizeStyle({ backgroundColor: _ctx.color }),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, [
        vue$1P.renderSlot(_ctx.$slots, "default"),
        _ctx.closable ? (vue$1P.openBlock(), vue$1P.createBlock(_component_el_icon, {
          key: 0,
          class: "el-tag__close",
          onClick: _ctx.handleClose
        }, {
          default: vue$1P.withCtx(() => [
            vue$1P.createVNode(_component_close)
          ]),
          _: 1
        }, 8, ["onClick"])) : vue$1P.createCommentVNode("v-if", true)
      ], 6)
    ]),
    _: 3
  }));
}
tag_vue_vue_type_template_id_525996c5_lang.render = render$1l;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tag_vue_vue_type_script_lang$1 = tag_vue_vue_type_script_lang;
  var tag_vue_vue_type_template_id_525996c5_lang$1 = tag_vue_vue_type_template_id_525996c5_lang;
  tag_vue_vue_type_script_lang$1["default"].render = tag_vue_vue_type_template_id_525996c5_lang$1.render;
  tag_vue_vue_type_script_lang$1["default"].__file = "packages/components/tag/src/tag.vue";
  exports["default"] = tag_vue_vue_type_script_lang$1["default"];
})(tag2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var tag3 = tag$1;
  var tag_vue_vue_type_script_lang$1 = tag_vue_vue_type_script_lang;
  const ElTag = withInstall2.withInstall(tag_vue_vue_type_script_lang$1["default"]);
  exports.tagEmits = tag3.tagEmits;
  exports.tagProps = tag3.tagProps;
  exports.ElTag = ElTag;
  exports["default"] = ElTag;
})(tag$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var debounce2 = debounce_1;
  var index2 = cascaderPanel;
  var index$110 = input$2;
  var index$22 = popper$3;
  var index$32 = scrollbar$3;
  var index$42 = tag$2;
  var index$52 = icon$4;
  var aria2 = aria$5;
  var constants2 = constants$f;
  var isServer2 = isServer$8;
  var resizeEvent$1 = resizeEvent;
  var validators2 = validators$6;
  var isDef2 = isDef$2;
  var iconsVue2 = require$$3;
  var index$62 = clickOutside;
  var config2 = config$2;
  var index$72 = useLocale$1;
  var form2 = form$7;
  var index$82 = useCommonProps;
  var defaults2 = defaults$d;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var debounce__default2 = /* @__PURE__ */ _interopDefaultLegacy2(debounce2);
  const DEFAULT_INPUT_HEIGHT = 40;
  const INPUT_HEIGHT_MAP = {
    medium: 36,
    small: 32,
    mini: 28
  };
  const popperOptions2 = {
    modifiers: [
      {
        name: "arrowPosition",
        enabled: true,
        phase: "main",
        fn: ({ state }) => {
          const { modifiersData, placement } = state;
          if (["right", "left"].includes(placement))
            return;
          modifiersData.arrow.x = 35;
        },
        requires: ["arrow"]
      }
    ]
  };
  var script2 = vue2.defineComponent({
    name: "ElCascader",
    components: {
      ElCascaderPanel: index2["default"],
      ElInput: index$110.ElInput,
      ElPopper: index$22["default"],
      ElScrollbar: index$32.ElScrollbar,
      ElTag: index$42.ElTag,
      ElIcon: index$52.ElIcon,
      CircleClose: iconsVue2.CircleClose,
      Check: iconsVue2.Check,
      ArrowDown: iconsVue2.ArrowDown
    },
    directives: {
      Clickoutside: index$62["default"]
    },
    props: __spreadProps(__spreadValues({}, config2.CommonProps), {
      size: {
        type: String,
        validator: validators2.isValidComponentSize
      },
      placeholder: {
        type: String
      },
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      filterMethod: {
        type: Function,
        default: (node3, keyword) => node3.text.includes(keyword)
      },
      separator: {
        type: String,
        default: " / "
      },
      showAllLevels: {
        type: Boolean,
        default: true
      },
      collapseTags: Boolean,
      debounce: {
        type: Number,
        default: 300
      },
      beforeFilter: {
        type: Function,
        default: () => true
      },
      popperClass: {
        type: String,
        default: ""
      },
      popperAppendToBody: {
        type: Boolean,
        default: true
      }
    }),
    emits: [
      constants2.UPDATE_MODEL_EVENT,
      constants2.CHANGE_EVENT,
      "focus",
      "blur",
      "visible-change",
      "expand-change",
      "remove-tag"
    ],
    setup(props2, { emit }) {
      let inputInitialHeight = 0;
      let pressDeleteCount = 0;
      const { t } = index$72.useLocale();
      const elForm = vue2.inject(form2.elFormKey, {});
      const elFormItem = vue2.inject(form2.elFormItemKey, {});
      const popper2 = vue2.ref(null);
      const input3 = vue2.ref(null);
      const tagWrapper = vue2.ref(null);
      const panel = vue2.ref(null);
      const suggestionPanel = vue2.ref(null);
      const popperVisible = vue2.ref(false);
      const inputHover = vue2.ref(false);
      const filtering = vue2.ref(false);
      const inputValue = vue2.ref("");
      const searchInputValue = vue2.ref("");
      const presentTags = vue2.ref([]);
      const suggestions = vue2.ref([]);
      const isOnComposition = vue2.ref(false);
      const isDisabled = vue2.computed(() => props2.disabled || elForm.disabled);
      const inputPlaceholder = vue2.computed(() => props2.placeholder || t("el.cascader.placeholder"));
      const realSize = index$82.useSize();
      const tagSize = vue2.computed(() => ["small", "mini"].includes(realSize.value) ? "mini" : "small");
      const multiple = vue2.computed(() => !!props2.props.multiple);
      const readonly2 = vue2.computed(() => !props2.filterable || multiple.value);
      const searchKeyword = vue2.computed(() => multiple.value ? searchInputValue.value : inputValue.value);
      const checkedNodes = vue2.computed(() => {
        var _a;
        return ((_a = panel.value) == null ? void 0 : _a.checkedNodes) || [];
      });
      const clearBtnVisible = vue2.computed(() => {
        if (!props2.clearable || isDisabled.value || filtering.value || !inputHover.value)
          return false;
        return !!checkedNodes.value.length;
      });
      const presentText = vue2.computed(() => {
        const { showAllLevels, separator } = props2;
        const nodes = checkedNodes.value;
        return nodes.length ? multiple.value ? " " : nodes[0].calcText(showAllLevels, separator) : "";
      });
      const checkedValue = vue2.computed({
        get() {
          return props2.modelValue;
        },
        set(val) {
          var _a;
          emit(constants2.UPDATE_MODEL_EVENT, val);
          emit(constants2.CHANGE_EVENT, val);
          (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change");
        }
      });
      const popperPaneRef = vue2.computed(() => {
        var _a;
        return (_a = popper2.value) == null ? void 0 : _a.popperRef;
      });
      const togglePopperVisible = (visible) => {
        var _a, _b, _c;
        if (isDisabled.value)
          return;
        visible = visible != null ? visible : !popperVisible.value;
        if (visible !== popperVisible.value) {
          popperVisible.value = visible;
          (_b = (_a = input3.value) == null ? void 0 : _a.input) == null ? void 0 : _b.setAttribute("aria-expanded", `${visible}`);
          if (visible) {
            updatePopperPosition();
            vue2.nextTick((_c = panel.value) == null ? void 0 : _c.scrollToExpandingNode);
          } else if (props2.filterable) {
            const { value } = presentText;
            inputValue.value = value;
            searchInputValue.value = value;
          }
          emit("visible-change", visible);
        }
      };
      const updatePopperPosition = () => {
        var _a;
        vue2.nextTick((_a = popper2.value) == null ? void 0 : _a.update);
      };
      const hideSuggestionPanel = () => {
        filtering.value = false;
      };
      const genTag2 = (node3) => {
        const { showAllLevels, separator } = props2;
        return {
          node: node3,
          key: node3.uid,
          text: node3.calcText(showAllLevels, separator),
          hitState: false,
          closable: !isDisabled.value && !node3.isDisabled
        };
      };
      const deleteTag = (tag3) => {
        var _a;
        const node3 = tag3.node;
        node3.doCheck(false);
        (_a = panel.value) == null ? void 0 : _a.calculateCheckedValue();
        emit("remove-tag", node3.valueByOption);
      };
      const calculatePresentTags = () => {
        if (!multiple.value)
          return;
        const nodes = checkedNodes.value;
        const tags = [];
        if (nodes.length) {
          const [first, ...rest] = nodes;
          const restCount = rest.length;
          tags.push(genTag2(first));
          if (restCount) {
            if (props2.collapseTags) {
              tags.push({
                key: -1,
                text: `+ ${restCount}`,
                closable: false
              });
            } else {
              rest.forEach((node3) => tags.push(genTag2(node3)));
            }
          }
        }
        presentTags.value = tags;
      };
      const calculateSuggestions = () => {
        var _a, _b;
        const { filterMethod, showAllLevels, separator } = props2;
        const res = (_b = (_a = panel.value) == null ? void 0 : _a.getFlattedNodes(!props2.props.checkStrictly)) == null ? void 0 : _b.filter((node3) => {
          if (node3.isDisabled)
            return false;
          node3.calcText(showAllLevels, separator);
          return filterMethod(node3, searchKeyword.value);
        });
        if (multiple.value) {
          presentTags.value.forEach((tag3) => {
            tag3.hitState = false;
          });
        }
        filtering.value = true;
        suggestions.value = res;
        updatePopperPosition();
      };
      const focusFirstNode = () => {
        var _a;
        let firstNode;
        if (filtering.value && suggestionPanel.value) {
          firstNode = suggestionPanel.value.$el.querySelector(".el-cascader__suggestion-item");
        } else {
          firstNode = (_a = panel.value) == null ? void 0 : _a.$el.querySelector('.el-cascader-node[tabindex="-1"]');
        }
        if (firstNode) {
          firstNode.focus();
          !filtering.value && firstNode.click();
        }
      };
      const updateStyle = () => {
        var _a, _b;
        const inputInner = (_a = input3.value) == null ? void 0 : _a.input;
        const tagWrapperEl = tagWrapper.value;
        const suggestionPanelEl = (_b = suggestionPanel.value) == null ? void 0 : _b.$el;
        if (isServer2["default"] || !inputInner)
          return;
        if (suggestionPanelEl) {
          const suggestionList = suggestionPanelEl.querySelector(".el-cascader__suggestion-list");
          suggestionList.style.minWidth = `${inputInner.offsetWidth}px`;
        }
        if (tagWrapperEl) {
          const { offsetHeight } = tagWrapperEl;
          const height = presentTags.value.length > 0 ? `${Math.max(offsetHeight + 6, inputInitialHeight)}px` : `${inputInitialHeight}px`;
          inputInner.style.height = height;
          updatePopperPosition();
        }
      };
      const getCheckedNodes = (leafOnly) => {
        var _a;
        return (_a = panel.value) == null ? void 0 : _a.getCheckedNodes(leafOnly);
      };
      const handleExpandChange = (value) => {
        updatePopperPosition();
        emit("expand-change", value);
      };
      const handleComposition = (event) => {
        var _a;
        const text = (_a = event.target) == null ? void 0 : _a.value;
        if (event.type === "compositionend") {
          isOnComposition.value = false;
          vue2.nextTick(() => handleInput(text));
        } else {
          const lastCharacter = text[text.length - 1] || "";
          isOnComposition.value = !isDef2.isKorean(lastCharacter);
        }
      };
      const handleKeyDown = (e) => {
        if (isOnComposition.value)
          return;
        switch (e.code) {
          case aria2.EVENT_CODE.enter:
            togglePopperVisible();
            break;
          case aria2.EVENT_CODE.down:
            togglePopperVisible(true);
            vue2.nextTick(focusFirstNode);
            e.preventDefault();
            break;
          case aria2.EVENT_CODE.esc:
          case aria2.EVENT_CODE.tab:
            togglePopperVisible(false);
            break;
        }
      };
      const handleClear = () => {
        var _a;
        (_a = panel.value) == null ? void 0 : _a.clearCheckedNodes();
        togglePopperVisible(false);
      };
      const handleSuggestionClick = (node3) => {
        var _a, _b;
        const { checked: checked2 } = node3;
        if (multiple.value) {
          (_a = panel.value) == null ? void 0 : _a.handleCheckChange(node3, !checked2, false);
        } else {
          !checked2 && ((_b = panel.value) == null ? void 0 : _b.handleCheckChange(node3, true, false));
          togglePopperVisible(false);
        }
      };
      const handleSuggestionKeyDown = (e) => {
        const target2 = e.target;
        const { code: code2 } = e;
        switch (code2) {
          case aria2.EVENT_CODE.up:
          case aria2.EVENT_CODE.down: {
            const distance = code2 === aria2.EVENT_CODE.up ? -1 : 1;
            aria2.focusNode(aria2.getSibling(target2, distance, '.el-cascader__suggestion-item[tabindex="-1"]'));
            break;
          }
          case aria2.EVENT_CODE.enter:
            target2.click();
            break;
          case aria2.EVENT_CODE.esc:
          case aria2.EVENT_CODE.tab:
            togglePopperVisible(false);
            break;
        }
      };
      const handleDelete = () => {
        const tags = presentTags.value;
        const lastTag = tags[tags.length - 1];
        pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
        if (!lastTag || !pressDeleteCount)
          return;
        if (lastTag.hitState) {
          deleteTag(lastTag);
        } else {
          lastTag.hitState = true;
        }
      };
      const handleFilter = debounce__default2["default"](() => {
        const { value } = searchKeyword;
        if (!value)
          return;
        const passed = props2.beforeFilter(value);
        if (shared2.isPromise(passed)) {
          passed.then(calculateSuggestions).catch(() => {
          });
        } else if (passed !== false) {
          calculateSuggestions();
        } else {
          hideSuggestionPanel();
        }
      }, props2.debounce);
      const handleInput = (val, e) => {
        !popperVisible.value && togglePopperVisible(true);
        if (e == null ? void 0 : e.isComposing)
          return;
        val ? handleFilter() : hideSuggestionPanel();
      };
      vue2.watch(filtering, updatePopperPosition);
      vue2.watch([checkedNodes, isDisabled], calculatePresentTags);
      vue2.watch(presentTags, () => {
        vue2.nextTick(() => updateStyle());
      });
      vue2.watch(presentText, (val) => inputValue.value = val, { immediate: true });
      vue2.onMounted(() => {
        var _a;
        const inputEl = (_a = input3.value) == null ? void 0 : _a.$el;
        inputInitialHeight = (inputEl == null ? void 0 : inputEl.offsetHeight) || INPUT_HEIGHT_MAP[realSize.value] || DEFAULT_INPUT_HEIGHT;
        resizeEvent$1.addResizeListener(inputEl, updateStyle);
      });
      vue2.onBeforeUnmount(() => {
        var _a;
        resizeEvent$1.removeResizeListener((_a = input3.value) == null ? void 0 : _a.$el, updateStyle);
      });
      return {
        Effect: defaults2.Effect,
        popperOptions: popperOptions2,
        popper: popper2,
        popperPaneRef,
        input: input3,
        tagWrapper,
        panel,
        suggestionPanel,
        popperVisible,
        inputHover,
        inputPlaceholder,
        filtering,
        presentText,
        checkedValue,
        inputValue,
        searchInputValue,
        presentTags,
        suggestions,
        isDisabled,
        isOnComposition,
        realSize,
        tagSize,
        multiple,
        readonly: readonly2,
        clearBtnVisible,
        t,
        togglePopperVisible,
        hideSuggestionPanel,
        deleteTag,
        focusFirstNode,
        getCheckedNodes,
        handleExpandChange,
        handleKeyDown,
        handleComposition,
        handleClear,
        handleSuggestionClick,
        handleSuggestionKeyDown,
        handleDelete,
        handleInput
      };
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$b);
var index_vue_vue_type_template_id_0429c2db_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_0429c2db_lang, "__esModule", { value: true });
var vue$1O = require$$0$1;
const _hoisted_1$Y = {
  key: 0,
  ref: "tagWrapper",
  class: "el-cascader__tags"
};
const _hoisted_2$H = ["placeholder"];
const _hoisted_3$B = ["onClick"];
const _hoisted_4$s = { class: "el-cascader__empty-text" };
function render$1k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_circle_close = vue$1O.resolveComponent("circle-close");
  const _component_el_icon = vue$1O.resolveComponent("el-icon");
  const _component_arrow_down = vue$1O.resolveComponent("arrow-down");
  const _component_el_input = vue$1O.resolveComponent("el-input");
  const _component_el_tag = vue$1O.resolveComponent("el-tag");
  const _component_el_cascader_panel = vue$1O.resolveComponent("el-cascader-panel");
  const _component_check = vue$1O.resolveComponent("check");
  const _component_el_scrollbar = vue$1O.resolveComponent("el-scrollbar");
  const _component_el_popper = vue$1O.resolveComponent("el-popper");
  const _directive_clickoutside = vue$1O.resolveDirective("clickoutside");
  return vue$1O.openBlock(), vue$1O.createBlock(_component_el_popper, {
    ref: "popper",
    visible: _ctx.popperVisible,
    "onUpdate:visible": _cache[17] || (_cache[17] = ($event) => _ctx.popperVisible = $event),
    "manual-mode": "",
    "append-to-body": _ctx.popperAppendToBody,
    placement: "bottom-start",
    "popper-class": `el-cascader__dropdown ${_ctx.popperClass}`,
    "popper-options": _ctx.popperOptions,
    "fallback-placements": ["bottom-start", "top-start", "right", "left"],
    "stop-popper-mouse-event": false,
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    effect: _ctx.Effect.LIGHT,
    pure: "",
    onAfterLeave: _ctx.hideSuggestionPanel
  }, {
    trigger: vue$1O.withCtx(() => [
      vue$1O.withDirectives(vue$1O.createElementVNode("div", {
        class: vue$1O.normalizeClass([
          "el-cascader",
          _ctx.realSize && `el-cascader--${_ctx.realSize}`,
          { "is-disabled": _ctx.isDisabled }
        ]),
        onClick: _cache[11] || (_cache[11] = () => _ctx.togglePopperVisible(_ctx.readonly ? void 0 : true)),
        onKeydown: _cache[12] || (_cache[12] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args)),
        onMouseenter: _cache[13] || (_cache[13] = ($event) => _ctx.inputHover = true),
        onMouseleave: _cache[14] || (_cache[14] = ($event) => _ctx.inputHover = false)
      }, [
        vue$1O.createVNode(_component_el_input, {
          ref: "input",
          modelValue: _ctx.inputValue,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.inputValue = $event),
          modelModifiers: { trim: true },
          placeholder: _ctx.inputPlaceholder,
          readonly: _ctx.readonly,
          disabled: _ctx.isDisabled,
          "validate-event": false,
          size: _ctx.realSize,
          class: vue$1O.normalizeClass({ "is-focus": _ctx.popperVisible }),
          onCompositionstart: _ctx.handleComposition,
          onCompositionupdate: _ctx.handleComposition,
          onCompositionend: _ctx.handleComposition,
          onFocus: _cache[2] || (_cache[2] = (e) => _ctx.$emit("focus", e)),
          onBlur: _cache[3] || (_cache[3] = (e) => _ctx.$emit("blur", e)),
          onInput: _ctx.handleInput
        }, {
          suffix: vue$1O.withCtx(() => [
            _ctx.clearBtnVisible ? (vue$1O.openBlock(), vue$1O.createBlock(_component_el_icon, {
              key: "clear",
              class: "el-input__icon icon-circle-close",
              onClick: vue$1O.withModifiers(_ctx.handleClear, ["stop"])
            }, {
              default: vue$1O.withCtx(() => [
                vue$1O.createVNode(_component_circle_close)
              ]),
              _: 1
            }, 8, ["onClick"])) : (vue$1O.openBlock(), vue$1O.createBlock(_component_el_icon, {
              key: "arrow-down",
              class: vue$1O.normalizeClass([
                "el-input__icon",
                "icon-arrow-down",
                _ctx.popperVisible && "is-reverse"
              ]),
              onClick: _cache[0] || (_cache[0] = vue$1O.withModifiers(($event) => _ctx.togglePopperVisible(), ["stop"]))
            }, {
              default: vue$1O.withCtx(() => [
                vue$1O.createVNode(_component_arrow_down)
              ]),
              _: 1
            }, 8, ["class"]))
          ]),
          _: 1
        }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput"]),
        _ctx.multiple ? (vue$1O.openBlock(), vue$1O.createElementBlock("div", _hoisted_1$Y, [
          (vue$1O.openBlock(true), vue$1O.createElementBlock(vue$1O.Fragment, null, vue$1O.renderList(_ctx.presentTags, (tag3) => {
            return vue$1O.openBlock(), vue$1O.createBlock(_component_el_tag, {
              key: tag3.key,
              type: "info",
              size: _ctx.tagSize,
              hit: tag3.hitState,
              closable: tag3.closable,
              "disable-transitions": "",
              onClose: ($event) => _ctx.deleteTag(tag3)
            }, {
              default: vue$1O.withCtx(() => [
                vue$1O.createElementVNode("span", null, vue$1O.toDisplayString(tag3.text), 1)
              ]),
              _: 2
            }, 1032, ["size", "hit", "closable", "onClose"]);
          }), 128)),
          _ctx.filterable && !_ctx.isDisabled ? vue$1O.withDirectives((vue$1O.openBlock(), vue$1O.createElementBlock("input", {
            key: 0,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.searchInputValue = $event),
            type: "text",
            class: "el-cascader__search-input",
            placeholder: _ctx.presentText ? "" : _ctx.inputPlaceholder,
            onInput: _cache[5] || (_cache[5] = (e) => _ctx.handleInput(_ctx.searchInputValue, e)),
            onClick: _cache[6] || (_cache[6] = vue$1O.withModifiers(($event) => _ctx.togglePopperVisible(true), ["stop"])),
            onKeydown: _cache[7] || (_cache[7] = vue$1O.withKeys((...args) => _ctx.handleDelete && _ctx.handleDelete(...args), ["delete"])),
            onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
            onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
            onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args))
          }, null, 40, _hoisted_2$H)), [
            [
              vue$1O.vModelText,
              _ctx.searchInputValue,
              void 0,
              { trim: true }
            ]
          ]) : vue$1O.createCommentVNode("v-if", true)
        ], 512)) : vue$1O.createCommentVNode("v-if", true)
      ], 34), [
        [_directive_clickoutside, () => _ctx.togglePopperVisible(false), _ctx.popperPaneRef]
      ])
    ]),
    default: vue$1O.withCtx(() => [
      vue$1O.withDirectives(vue$1O.createVNode(_component_el_cascader_panel, {
        ref: "panel",
        modelValue: _ctx.checkedValue,
        "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.checkedValue = $event),
        options: _ctx.options,
        props: _ctx.props,
        border: false,
        "render-label": _ctx.$slots.default,
        onExpandChange: _ctx.handleExpandChange,
        onClose: _cache[16] || (_cache[16] = ($event) => _ctx.togglePopperVisible(false))
      }, null, 8, ["modelValue", "options", "props", "render-label", "onExpandChange"]), [
        [vue$1O.vShow, !_ctx.filtering]
      ]),
      _ctx.filterable ? vue$1O.withDirectives((vue$1O.openBlock(), vue$1O.createBlock(_component_el_scrollbar, {
        key: 0,
        ref: "suggestionPanel",
        tag: "ul",
        class: "el-cascader__suggestion-panel",
        "view-class": "el-cascader__suggestion-list",
        onKeydown: _ctx.handleSuggestionKeyDown
      }, {
        default: vue$1O.withCtx(() => [
          _ctx.suggestions.length ? (vue$1O.openBlock(true), vue$1O.createElementBlock(vue$1O.Fragment, { key: 0 }, vue$1O.renderList(_ctx.suggestions, (item2) => {
            return vue$1O.openBlock(), vue$1O.createElementBlock("li", {
              key: item2.uid,
              class: vue$1O.normalizeClass([
                "el-cascader__suggestion-item",
                item2.checked && "is-checked"
              ]),
              tabindex: -1,
              onClick: ($event) => _ctx.handleSuggestionClick(item2)
            }, [
              vue$1O.createElementVNode("span", null, vue$1O.toDisplayString(item2.text), 1),
              item2.checked ? (vue$1O.openBlock(), vue$1O.createBlock(_component_el_icon, { key: 0 }, {
                default: vue$1O.withCtx(() => [
                  vue$1O.createVNode(_component_check)
                ]),
                _: 1
              })) : vue$1O.createCommentVNode("v-if", true)
            ], 10, _hoisted_3$B);
          }), 128)) : vue$1O.renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
            vue$1O.createElementVNode("li", _hoisted_4$s, vue$1O.toDisplayString(_ctx.t("el.cascader.noMatch")), 1)
          ])
        ]),
        _: 3
      }, 8, ["onKeydown"])), [
        [vue$1O.vShow, _ctx.filtering]
      ]) : vue$1O.createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 8, ["visible", "append-to-body", "popper-class", "popper-options", "effect", "onAfterLeave"]);
}
index_vue_vue_type_template_id_0429c2db_lang.render = render$1k;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$b;
  var index_vue_vue_type_template_id_0429c2db_lang$1 = index_vue_vue_type_template_id_0429c2db_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_0429c2db_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/cascader/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$e);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$b;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  const _Cascader = index_vue_vue_type_script_lang2["default"];
  const ElCascader = _Cascader;
  exports.ElCascader = ElCascader;
  exports["default"] = _Cascader;
})(cascader);
var checkTag = {};
var src$c = {};
var index_vue_vue_type_script_lang$9 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  const checkTagProps = {
    checked: {
      type: Boolean,
      default: false
    }
  };
  var script2 = vue2.defineComponent({
    name: "ElCheckTag",
    props: checkTagProps,
    emits: ["change", "update:checked"],
    setup(props2, { emit }) {
      const onChange = () => {
        const checked2 = !props2.checked;
        emit("change", checked2);
        emit("update:checked", checked2);
      };
      return {
        onChange
      };
    }
  });
  exports.checkTagProps = checkTagProps;
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$9);
var index_vue_vue_type_template_id_58558910_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_58558910_lang, "__esModule", { value: true });
var vue$1N = require$$0$1;
function render$1j(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1N.openBlock(), vue$1N.createElementBlock("span", {
    class: vue$1N.normalizeClass({
      "el-check-tag": true,
      "is-checked": _ctx.checked
    }),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onChange && _ctx.onChange(...args))
  }, [
    vue$1N.renderSlot(_ctx.$slots, "default")
  ], 2);
}
index_vue_vue_type_template_id_58558910_lang.render = render$1j;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$9;
  var index_vue_vue_type_template_id_58558910_lang$1 = index_vue_vue_type_template_id_58558910_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_58558910_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/check-tag/src/index.vue";
  exports.checkTagProps = index_vue_vue_type_script_lang2.checkTagProps;
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$c);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$9;
  const ElCheckTag = withInstall2.withInstall(index_vue_vue_type_script_lang2["default"]);
  exports.ElCheckTag = ElCheckTag;
  exports["default"] = ElCheckTag;
})(checkTag);
var col$2 = {};
var col$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var props2 = props$N;
  const colProps = props2.buildProps({
    tag: {
      type: String,
      default: "div"
    },
    span: {
      type: Number,
      default: 24
    },
    offset: {
      type: Number,
      default: 0
    },
    pull: {
      type: Number,
      default: 0
    },
    push: {
      type: Number,
      default: 0
    },
    xs: {
      type: props2.definePropType([Number, Object]),
      default: () => props2.mutable({})
    },
    sm: {
      type: props2.definePropType([Number, Object]),
      default: () => props2.mutable({})
    },
    md: {
      type: props2.definePropType([Number, Object]),
      default: () => props2.mutable({})
    },
    lg: {
      type: props2.definePropType([Number, Object]),
      default: () => props2.mutable({})
    },
    xl: {
      type: props2.definePropType([Number, Object]),
      default: () => props2.mutable({})
    }
  });
  var Col = vue2.defineComponent({
    name: "ElCol",
    props: colProps,
    setup(props3, { slots }) {
      const { gutter } = vue2.inject("ElRow", { gutter: { value: 0 } });
      const style = vue2.computed(() => {
        if (gutter.value) {
          return {
            paddingLeft: `${gutter.value / 2}px`,
            paddingRight: `${gutter.value / 2}px`
          };
        }
        return {};
      });
      const classList = vue2.computed(() => {
        const classes = [];
        const pos = ["span", "offset", "pull", "push"];
        pos.forEach((prop) => {
          const size2 = props3[prop];
          if (typeof size2 === "number") {
            if (prop === "span")
              classes.push(`el-col-${props3[prop]}`);
            else if (size2 > 0)
              classes.push(`el-col-${prop}-${props3[prop]}`);
          }
        });
        const sizes2 = ["xs", "sm", "md", "lg", "xl"];
        sizes2.forEach((size2) => {
          if (typeof props3[size2] === "number") {
            classes.push(`el-col-${size2}-${props3[size2]}`);
          } else if (typeof props3[size2] === "object") {
            const sizeProps = props3[size2];
            Object.keys(sizeProps).forEach((prop) => {
              classes.push(prop !== "span" ? `el-col-${size2}-${prop}-${sizeProps[prop]}` : `el-col-${size2}-${sizeProps[prop]}`);
            });
          }
        });
        if (gutter.value) {
          classes.push("is-guttered");
        }
        return classes;
      });
      return () => vue2.h(props3.tag, {
        class: ["el-col", classList.value],
        style: style.value
      }, [vue2.renderSlot(slots, "default")]);
    }
  });
  exports.colProps = colProps;
  exports["default"] = Col;
})(col$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var col2 = col$1;
  const ElCol = withInstall2.withInstall(col2["default"]);
  exports.colProps = col2.colProps;
  exports.ElCol = ElCol;
  exports["default"] = ElCol;
})(col$2);
var collapse$1 = {};
var collapse = {};
var collapse_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var constants2 = constants$f;
  var script2 = vue2.defineComponent({
    name: "ElCollapse",
    props: {
      accordion: Boolean,
      modelValue: {
        type: [Array, String, Number],
        default: () => []
      }
    },
    emits: [constants2.UPDATE_MODEL_EVENT, constants2.CHANGE_EVENT],
    setup(props2, { emit }) {
      const activeNames = vue2.ref([].concat(props2.modelValue));
      const setActiveNames = (_activeNames) => {
        activeNames.value = [].concat(_activeNames);
        const value = props2.accordion ? activeNames.value[0] : activeNames.value;
        emit(constants2.UPDATE_MODEL_EVENT, value);
        emit(constants2.CHANGE_EVENT, value);
      };
      const handleItemClick = (name) => {
        if (props2.accordion) {
          setActiveNames((activeNames.value[0] || activeNames.value[0] === 0) && activeNames.value[0] === name ? "" : name);
        } else {
          const _activeNames = activeNames.value.slice(0);
          const index2 = _activeNames.indexOf(name);
          if (index2 > -1) {
            _activeNames.splice(index2, 1);
          } else {
            _activeNames.push(name);
          }
          setActiveNames(_activeNames);
        }
      };
      vue2.watch(() => props2.modelValue, () => {
        activeNames.value = [].concat(props2.modelValue);
      });
      vue2.provide("collapse", {
        activeNames,
        handleItemClick
      });
      return {
        activeNames,
        setActiveNames,
        handleItemClick
      };
    }
  });
  exports["default"] = script2;
})(collapse_vue_vue_type_script_lang);
var collapse_vue_vue_type_template_id_71a60e25_lang = {};
Object.defineProperty(collapse_vue_vue_type_template_id_71a60e25_lang, "__esModule", { value: true });
var vue$1M = require$$0$1;
const _hoisted_1$X = {
  class: "el-collapse",
  role: "tablist",
  "aria-multiselectable": "true"
};
function render$1i(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1M.openBlock(), vue$1M.createElementBlock("div", _hoisted_1$X, [
    vue$1M.renderSlot(_ctx.$slots, "default")
  ]);
}
collapse_vue_vue_type_template_id_71a60e25_lang.render = render$1i;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var collapse_vue_vue_type_script_lang$1 = collapse_vue_vue_type_script_lang;
  var collapse_vue_vue_type_template_id_71a60e25_lang$1 = collapse_vue_vue_type_template_id_71a60e25_lang;
  collapse_vue_vue_type_script_lang$1["default"].render = collapse_vue_vue_type_template_id_71a60e25_lang$1.render;
  collapse_vue_vue_type_script_lang$1["default"].__file = "packages/components/collapse/src/collapse.vue";
  exports["default"] = collapse_vue_vue_type_script_lang$1["default"];
})(collapse);
var collapseItem = {};
var collapseItem_vue_vue_type_script_lang = {};
var collapseTransition$1 = {};
var collapseTransition = {};
var collapseTransition_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var script2 = vue2.defineComponent({
    name: "ElCollapseTransition",
    setup() {
      return {
        on: {
          beforeEnter(el) {
            dom2.addClass(el, "collapse-transition");
            if (!el.dataset)
              el.dataset = {};
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.style.height = "0";
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          },
          enter(el) {
            el.dataset.oldOverflow = el.style.overflow;
            if (el.scrollHeight !== 0) {
              el.style.height = `${el.scrollHeight}px`;
              el.style.paddingTop = el.dataset.oldPaddingTop;
              el.style.paddingBottom = el.dataset.oldPaddingBottom;
            } else {
              el.style.height = "";
              el.style.paddingTop = el.dataset.oldPaddingTop;
              el.style.paddingBottom = el.dataset.oldPaddingBottom;
            }
            el.style.overflow = "hidden";
          },
          afterEnter(el) {
            dom2.removeClass(el, "collapse-transition");
            el.style.height = "";
            el.style.overflow = el.dataset.oldOverflow;
          },
          beforeLeave(el) {
            if (!el.dataset)
              el.dataset = {};
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.dataset.oldOverflow = el.style.overflow;
            el.style.height = `${el.scrollHeight}px`;
            el.style.overflow = "hidden";
          },
          leave(el) {
            if (el.scrollHeight !== 0) {
              dom2.addClass(el, "collapse-transition");
              el.style.transitionProperty = "height";
              el.style.height = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            }
          },
          afterLeave(el) {
            dom2.removeClass(el, "collapse-transition");
            el.style.height = "";
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }
        }
      };
    }
  });
  exports["default"] = script2;
})(collapseTransition_vue_vue_type_script_lang);
var collapseTransition_vue_vue_type_template_id_f68ae30a_lang = {};
Object.defineProperty(collapseTransition_vue_vue_type_template_id_f68ae30a_lang, "__esModule", { value: true });
var vue$1L = require$$0$1;
function render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1L.openBlock(), vue$1L.createBlock(vue$1L.Transition, vue$1L.toHandlers(_ctx.on), {
    default: vue$1L.withCtx(() => [
      vue$1L.renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
collapseTransition_vue_vue_type_template_id_f68ae30a_lang.render = render$1h;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var collapseTransition_vue_vue_type_script_lang$1 = collapseTransition_vue_vue_type_script_lang;
  var collapseTransition_vue_vue_type_template_id_f68ae30a_lang$1 = collapseTransition_vue_vue_type_template_id_f68ae30a_lang;
  collapseTransition_vue_vue_type_script_lang$1["default"].render = collapseTransition_vue_vue_type_template_id_f68ae30a_lang$1.render;
  collapseTransition_vue_vue_type_script_lang$1["default"].__file = "packages/components/collapse-transition/src/collapse-transition.vue";
  exports["default"] = collapseTransition_vue_vue_type_script_lang$1["default"];
})(collapseTransition);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var collapseTransition_vue_vue_type_script_lang$1 = collapseTransition_vue_vue_type_script_lang;
  collapseTransition_vue_vue_type_script_lang$1["default"].install = (app) => {
    app.component(collapseTransition_vue_vue_type_script_lang$1["default"].name, collapseTransition_vue_vue_type_script_lang$1["default"]);
  };
  const _CollapseTransition2 = collapseTransition_vue_vue_type_script_lang$1["default"];
  const ElCollapseTransition = _CollapseTransition2;
  exports.ElCollapseTransition = ElCollapseTransition;
  exports["default"] = _CollapseTransition2;
})(collapseTransition$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$l;
  var index2 = collapseTransition$1;
  var index$110 = icon$4;
  var iconsVue2 = require$$3;
  var script2 = vue2.defineComponent({
    name: "ElCollapseItem",
    components: { ElCollapseTransition: index2["default"], ElIcon: index$110.ElIcon, ArrowRight: iconsVue2.ArrowRight },
    props: {
      title: {
        type: String,
        default: ""
      },
      name: {
        type: [String, Number],
        default: () => {
          return util2.generateId();
        }
      },
      disabled: Boolean
    },
    setup(props2) {
      const collapse2 = vue2.inject("collapse");
      const contentWrapStyle = vue2.ref({
        height: "auto",
        display: "block"
      });
      const contentHeight = vue2.ref(0);
      const focusing = vue2.ref(false);
      const isClick = vue2.ref(false);
      const id = vue2.ref(util2.generateId());
      const isActive = vue2.computed(() => {
        return (collapse2 == null ? void 0 : collapse2.activeNames.value.indexOf(props2.name)) > -1;
      });
      const handleFocus = () => {
        setTimeout(() => {
          if (!isClick.value) {
            focusing.value = true;
          } else {
            isClick.value = false;
          }
        }, 50);
      };
      const handleHeaderClick = () => {
        if (props2.disabled)
          return;
        collapse2 == null ? void 0 : collapse2.handleItemClick(props2.name);
        focusing.value = false;
        isClick.value = true;
      };
      const handleEnterClick = () => {
        collapse2 == null ? void 0 : collapse2.handleItemClick(props2.name);
      };
      return {
        isActive,
        contentWrapStyle,
        contentHeight,
        focusing,
        isClick,
        id,
        handleFocus,
        handleHeaderClick,
        handleEnterClick,
        collapse: collapse2
      };
    }
  });
  exports["default"] = script2;
})(collapseItem_vue_vue_type_script_lang);
var collapseItem_vue_vue_type_template_id_80da782a_lang = {};
Object.defineProperty(collapseItem_vue_vue_type_template_id_80da782a_lang, "__esModule", { value: true });
var vue$1K = require$$0$1;
const _hoisted_1$W = ["aria-expanded", "aria-controls", "aria-describedby"];
const _hoisted_2$G = ["id", "tabindex"];
const _hoisted_3$A = ["id", "aria-hidden", "aria-labelledby"];
const _hoisted_4$r = { class: "el-collapse-item__content" };
function render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_right = vue$1K.resolveComponent("arrow-right");
  const _component_el_icon = vue$1K.resolveComponent("el-icon");
  const _component_el_collapse_transition = vue$1K.resolveComponent("el-collapse-transition");
  return vue$1K.openBlock(), vue$1K.createElementBlock("div", {
    class: vue$1K.normalizeClass(["el-collapse-item", { "is-active": _ctx.isActive, "is-disabled": _ctx.disabled }])
  }, [
    vue$1K.createElementVNode("div", {
      role: "tab",
      "aria-expanded": _ctx.isActive,
      "aria-controls": `el-collapse-content-${_ctx.id}`,
      "aria-describedby": `el-collapse-content-${_ctx.id}`
    }, [
      vue$1K.createElementVNode("div", {
        id: `el-collapse-head-${_ctx.id}`,
        class: vue$1K.normalizeClass(["el-collapse-item__header", {
          focusing: _ctx.focusing,
          "is-active": _ctx.isActive
        }]),
        role: "button",
        tabindex: _ctx.disabled ? -1 : 0,
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleHeaderClick && _ctx.handleHeaderClick(...args)),
        onKeyup: _cache[1] || (_cache[1] = vue$1K.withKeys(vue$1K.withModifiers((...args) => _ctx.handleEnterClick && _ctx.handleEnterClick(...args), ["stop"]), ["space", "enter"])),
        onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focusing = false)
      }, [
        vue$1K.renderSlot(_ctx.$slots, "title", {}, () => [
          vue$1K.createTextVNode(vue$1K.toDisplayString(_ctx.title), 1)
        ]),
        vue$1K.createVNode(_component_el_icon, {
          class: vue$1K.normalizeClass(["el-collapse-item__arrow", { "is-active": _ctx.isActive }])
        }, {
          default: vue$1K.withCtx(() => [
            vue$1K.createVNode(_component_arrow_right)
          ]),
          _: 1
        }, 8, ["class"])
      ], 42, _hoisted_2$G)
    ], 8, _hoisted_1$W),
    vue$1K.createVNode(_component_el_collapse_transition, null, {
      default: vue$1K.withCtx(() => [
        vue$1K.withDirectives(vue$1K.createElementVNode("div", {
          id: `el-collapse-content-${_ctx.id}`,
          class: "el-collapse-item__wrap",
          role: "tabpanel",
          "aria-hidden": !_ctx.isActive,
          "aria-labelledby": `el-collapse-head-${_ctx.id}`
        }, [
          vue$1K.createElementVNode("div", _hoisted_4$r, [
            vue$1K.renderSlot(_ctx.$slots, "default")
          ])
        ], 8, _hoisted_3$A), [
          [vue$1K.vShow, _ctx.isActive]
        ])
      ]),
      _: 3
    })
  ], 2);
}
collapseItem_vue_vue_type_template_id_80da782a_lang.render = render$1g;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var collapseItem_vue_vue_type_script_lang$1 = collapseItem_vue_vue_type_script_lang;
  var collapseItem_vue_vue_type_template_id_80da782a_lang$1 = collapseItem_vue_vue_type_template_id_80da782a_lang;
  collapseItem_vue_vue_type_script_lang$1["default"].render = collapseItem_vue_vue_type_template_id_80da782a_lang$1.render;
  collapseItem_vue_vue_type_script_lang$1["default"].__file = "packages/components/collapse/src/collapse-item.vue";
  exports["default"] = collapseItem_vue_vue_type_script_lang$1["default"];
})(collapseItem);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var collapse_vue_vue_type_script_lang$1 = collapse_vue_vue_type_script_lang;
  var collapseItem_vue_vue_type_script_lang$1 = collapseItem_vue_vue_type_script_lang;
  const ElCollapse = withInstall2.withInstall(collapse_vue_vue_type_script_lang$1["default"], {
    CollapseItem: collapseItem_vue_vue_type_script_lang$1["default"]
  });
  const ElCollapseItem = withInstall2.withNoopInstall(collapseItem_vue_vue_type_script_lang$1["default"]);
  exports.ElCollapse = ElCollapse;
  exports.ElCollapseItem = ElCollapseItem;
  exports["default"] = ElCollapse;
})(collapse$1);
var colorPicker = {};
var src$b = {};
var index_vue_vue_type_script_lang$8 = {};
var alphaSlider = {};
var alphaSlider_vue_vue_type_script_lang = {};
var draggable = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var isServer2 = isServer$8;
  var dom2 = dom$8;
  let isDragging = false;
  function draggable2(element, options) {
    if (isServer2["default"])
      return;
    const moveFn = function(event) {
      var _a;
      (_a = options.drag) == null ? void 0 : _a.call(options, event);
    };
    const upFn = function(event) {
      var _a;
      dom2.off(document, "mousemove", moveFn);
      dom2.off(document, "mouseup", upFn);
      dom2.off(document, "touchmove", moveFn);
      dom2.off(document, "touchend", upFn);
      document.onselectstart = null;
      document.ondragstart = null;
      isDragging = false;
      (_a = options.end) == null ? void 0 : _a.call(options, event);
    };
    const downFn = function(event) {
      var _a;
      if (isDragging)
        return;
      event.preventDefault();
      document.onselectstart = () => false;
      document.ondragstart = () => false;
      dom2.on(document, "mousemove", moveFn);
      dom2.on(document, "mouseup", upFn);
      dom2.on(document, "touchmove", moveFn);
      dom2.on(document, "touchend", upFn);
      isDragging = true;
      (_a = options.start) == null ? void 0 : _a.call(options, event);
    };
    dom2.on(element, "mousedown", downFn);
    dom2.on(element, "touchstart", downFn);
  }
  exports["default"] = draggable2;
})(draggable);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var draggable$1 = draggable;
  var script2 = vue2.defineComponent({
    name: "ElColorAlphaSlider",
    props: {
      color: {
        type: Object,
        required: true
      },
      vertical: {
        type: Boolean,
        default: false
      }
    },
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const thumb = vue2.shallowRef(null);
      const bar3 = vue2.shallowRef(null);
      const thumbLeft = vue2.ref(0);
      const thumbTop = vue2.ref(0);
      const background = vue2.ref(null);
      vue2.watch(() => props2.color.get("alpha"), () => {
        update3();
      });
      vue2.watch(() => props2.color.value, () => {
        update3();
      });
      function getThumbLeft() {
        if (props2.vertical)
          return 0;
        const el = instance.vnode.el;
        const alpha = props2.color.get("alpha");
        if (!el)
          return 0;
        return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
      }
      function getThumbTop() {
        const el = instance.vnode.el;
        if (!props2.vertical)
          return 0;
        const alpha = props2.color.get("alpha");
        if (!el)
          return 0;
        return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
      }
      function getBackground() {
        if (props2.color && props2.color.value) {
          const { r, g, b: b2 } = props2.color.toRgb();
          return `linear-gradient(to right, rgba(${r}, ${g}, ${b2}, 0) 0%, rgba(${r}, ${g}, ${b2}, 1) 100%)`;
        }
        return null;
      }
      function handleClick(event) {
        const target2 = event.target;
        if (target2 !== thumb.value) {
          handleDrag(event);
        }
      }
      function handleDrag(event) {
        const el = instance.vnode.el;
        const rect = el.getBoundingClientRect();
        const { clientX, clientY } = dom2.getClientXY(event);
        if (!props2.vertical) {
          let left2 = clientX - rect.left;
          left2 = Math.max(thumb.value.offsetWidth / 2, left2);
          left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
          props2.color.set("alpha", Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
        } else {
          let top2 = clientY - rect.top;
          top2 = Math.max(thumb.value.offsetHeight / 2, top2);
          top2 = Math.min(top2, rect.height - thumb.value.offsetHeight / 2);
          props2.color.set("alpha", Math.round((top2 - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
        }
      }
      function update3() {
        thumbLeft.value = getThumbLeft();
        thumbTop.value = getThumbTop();
        background.value = getBackground();
      }
      vue2.onMounted(() => {
        const dragConfig = {
          drag: (event) => {
            handleDrag(event);
          },
          end: (event) => {
            handleDrag(event);
          }
        };
        draggable$1["default"](bar3.value, dragConfig);
        draggable$1["default"](thumb.value, dragConfig);
        update3();
      });
      return {
        thumb,
        bar: bar3,
        thumbLeft,
        thumbTop,
        background,
        handleClick,
        update: update3
      };
    }
  });
  exports["default"] = script2;
})(alphaSlider_vue_vue_type_script_lang);
var alphaSlider_vue_vue_type_template_id_4fb2624c_lang = {};
Object.defineProperty(alphaSlider_vue_vue_type_template_id_4fb2624c_lang, "__esModule", { value: true });
var vue$1J = require$$0$1;
function render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1J.openBlock(), vue$1J.createElementBlock("div", {
    class: vue$1J.normalizeClass(["el-color-alpha-slider", { "is-vertical": _ctx.vertical }])
  }, [
    vue$1J.createElementVNode("div", {
      ref: "bar",
      class: "el-color-alpha-slider__bar",
      style: vue$1J.normalizeStyle({
        background: _ctx.background
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, null, 4),
    vue$1J.createElementVNode("div", {
      ref: "thumb",
      class: "el-color-alpha-slider__thumb",
      style: vue$1J.normalizeStyle({
        left: _ctx.thumbLeft + "px",
        top: _ctx.thumbTop + "px"
      })
    }, null, 4)
  ], 2);
}
alphaSlider_vue_vue_type_template_id_4fb2624c_lang.render = render$1f;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var alphaSlider_vue_vue_type_script_lang$1 = alphaSlider_vue_vue_type_script_lang;
  var alphaSlider_vue_vue_type_template_id_4fb2624c_lang$1 = alphaSlider_vue_vue_type_template_id_4fb2624c_lang;
  alphaSlider_vue_vue_type_script_lang$1["default"].render = alphaSlider_vue_vue_type_template_id_4fb2624c_lang$1.render;
  alphaSlider_vue_vue_type_script_lang$1["default"].__file = "packages/components/color-picker/src/components/alpha-slider.vue";
  exports["default"] = alphaSlider_vue_vue_type_script_lang$1["default"];
})(alphaSlider);
var hueSlider = {};
var hueSlider_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var draggable$1 = draggable;
  var script2 = vue2.defineComponent({
    name: "ElColorHueSlider",
    props: {
      color: {
        type: Object,
        required: true
      },
      vertical: Boolean
    },
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const thumb = vue2.ref(null);
      const bar3 = vue2.ref(null);
      const thumbLeft = vue2.ref(0);
      const thumbTop = vue2.ref(0);
      const hueValue = vue2.computed(() => {
        return props2.color.get("hue");
      });
      vue2.watch(() => hueValue.value, () => {
        update3();
      });
      function handleClick(event) {
        const target2 = event.target;
        if (target2 !== thumb.value) {
          handleDrag(event);
        }
      }
      function handleDrag(event) {
        const el = instance.vnode.el;
        const rect = el.getBoundingClientRect();
        const { clientX, clientY } = dom2.getClientXY(event);
        let hue;
        if (!props2.vertical) {
          let left2 = clientX - rect.left;
          left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
          left2 = Math.max(thumb.value.offsetWidth / 2, left2);
          hue = Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
        } else {
          let top2 = clientY - rect.top;
          top2 = Math.min(top2, rect.height - thumb.value.offsetHeight / 2);
          top2 = Math.max(thumb.value.offsetHeight / 2, top2);
          hue = Math.round((top2 - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
        }
        props2.color.set("hue", hue);
      }
      function getThumbLeft() {
        const el = instance.vnode.el;
        if (props2.vertical)
          return 0;
        const hue = props2.color.get("hue");
        if (!el)
          return 0;
        return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
      }
      function getThumbTop() {
        const el = instance.vnode.el;
        if (!props2.vertical)
          return 0;
        const hue = props2.color.get("hue");
        if (!el)
          return 0;
        return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
      }
      function update3() {
        thumbLeft.value = getThumbLeft();
        thumbTop.value = getThumbTop();
      }
      vue2.onMounted(() => {
        const dragConfig = {
          drag: (event) => {
            handleDrag(event);
          },
          end: (event) => {
            handleDrag(event);
          }
        };
        draggable$1["default"](bar3.value, dragConfig);
        draggable$1["default"](thumb.value, dragConfig);
        update3();
      });
      return {
        bar: bar3,
        thumb,
        thumbLeft,
        thumbTop,
        hueValue,
        handleClick,
        update: update3
      };
    }
  });
  exports["default"] = script2;
})(hueSlider_vue_vue_type_script_lang);
var hueSlider_vue_vue_type_template_id_129d2b72_lang = {};
Object.defineProperty(hueSlider_vue_vue_type_template_id_129d2b72_lang, "__esModule", { value: true });
var vue$1I = require$$0$1;
function render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1I.openBlock(), vue$1I.createElementBlock("div", {
    class: vue$1I.normalizeClass(["el-color-hue-slider", { "is-vertical": _ctx.vertical }])
  }, [
    vue$1I.createElementVNode("div", {
      ref: "bar",
      class: "el-color-hue-slider__bar",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, null, 512),
    vue$1I.createElementVNode("div", {
      ref: "thumb",
      class: "el-color-hue-slider__thumb",
      style: vue$1I.normalizeStyle({
        left: _ctx.thumbLeft + "px",
        top: _ctx.thumbTop + "px"
      })
    }, null, 4)
  ], 2);
}
hueSlider_vue_vue_type_template_id_129d2b72_lang.render = render$1e;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var hueSlider_vue_vue_type_script_lang$1 = hueSlider_vue_vue_type_script_lang;
  var hueSlider_vue_vue_type_template_id_129d2b72_lang$1 = hueSlider_vue_vue_type_template_id_129d2b72_lang;
  hueSlider_vue_vue_type_script_lang$1["default"].render = hueSlider_vue_vue_type_template_id_129d2b72_lang$1.render;
  hueSlider_vue_vue_type_script_lang$1["default"].__file = "packages/components/color-picker/src/components/hue-slider.vue";
  exports["default"] = hueSlider_vue_vue_type_script_lang$1["default"];
})(hueSlider);
var predefine = {};
var predefine_vue_vue_type_script_lang = {};
var useOption$4 = {};
Object.defineProperty(useOption$4, "__esModule", { value: true });
var vue$1H = require$$0$1;
const OPTIONS_KEY = Symbol();
const useOptions = () => {
  return vue$1H.inject(OPTIONS_KEY);
};
useOption$4.OPTIONS_KEY = OPTIONS_KEY;
useOption$4.useOptions = useOptions;
var color = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var shared2 = require$$1$1;
  const hsv2hsl = function(hue, sat, val) {
    return [
      hue,
      sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
      hue / 2
    ];
  };
  const isOnePointZero = function(n) {
    return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
  };
  const isPercentage = function(n) {
    return typeof n === "string" && n.indexOf("%") !== -1;
  };
  const bound01 = function(value, max2) {
    if (isOnePointZero(value))
      value = "100%";
    const processPercent = isPercentage(value);
    value = Math.min(max2, Math.max(0, parseFloat(`${value}`)));
    if (processPercent) {
      value = parseInt(`${value * max2}`, 10) / 100;
    }
    if (Math.abs(value - max2) < 1e-6) {
      return 1;
    }
    return value % max2 / parseFloat(max2);
  };
  const INT_HEX_MAP = { 10: "A", 11: "B", 12: "C", 13: "D", 14: "E", 15: "F" };
  const hexOne = function(value) {
    value = Math.min(Math.round(value), 255);
    const high = Math.floor(value / 16);
    const low = value % 16;
    return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
  };
  const toHex = function({ r, g, b: b2 }) {
    if (isNaN(r) || isNaN(g) || isNaN(b2))
      return "";
    return `#${hexOne(r)}${hexOne(g)}${hexOne(b2)}`;
  };
  const HEX_INT_MAP = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 };
  const parseHexChannel = function(hex2) {
    if (hex2.length === 2) {
      return (HEX_INT_MAP[hex2[0].toUpperCase()] || +hex2[0]) * 16 + (HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1]);
    }
    return HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1];
  };
  const hsl2hsv = function(hue, sat, light) {
    sat = sat / 100;
    light = light / 100;
    let smin = sat;
    const lmin = Math.max(light, 0.01);
    light *= 2;
    sat *= light <= 1 ? light : 2 - light;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v2 = (light + sat) / 2;
    const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
    return {
      h: hue,
      s: sv * 100,
      v: v2 * 100
    };
  };
  const rgb2hsv = function(r, g, b2) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b2 = bound01(b2, 255);
    const max2 = Math.max(r, g, b2);
    const min2 = Math.min(r, g, b2);
    let h2;
    const v2 = max2;
    const d2 = max2 - min2;
    const s2 = max2 === 0 ? 0 : d2 / max2;
    if (max2 === min2) {
      h2 = 0;
    } else {
      switch (max2) {
        case r: {
          h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
          break;
        }
        case g: {
          h2 = (b2 - r) / d2 + 2;
          break;
        }
        case b2: {
          h2 = (r - g) / d2 + 4;
          break;
        }
      }
      h2 /= 6;
    }
    return { h: h2 * 360, s: s2 * 100, v: v2 * 100 };
  };
  const hsv2rgb = function(h2, s2, v2) {
    h2 = bound01(h2, 360) * 6;
    s2 = bound01(s2, 100);
    v2 = bound01(v2, 100);
    const i = Math.floor(h2);
    const f2 = h2 - i;
    const p2 = v2 * (1 - s2);
    const q = v2 * (1 - f2 * s2);
    const t = v2 * (1 - (1 - f2) * s2);
    const mod = i % 6;
    const r = [v2, q, p2, p2, t, v2][mod];
    const g = [t, v2, v2, q, p2, p2][mod];
    const b2 = [p2, p2, t, v2, v2, q][mod];
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b2 * 255)
    };
  };
  class Color {
    constructor(options) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this._alpha = 100;
      this.enableAlpha = false;
      this.format = "hex";
      this.value = "";
      options = options || {};
      for (const option2 in options) {
        if (shared2.hasOwn(options, option2)) {
          this[option2] = options[option2];
        }
      }
      this.doOnChange();
    }
    set(prop, value) {
      if (arguments.length === 1 && typeof prop === "object") {
        for (const p2 in prop) {
          if (shared2.hasOwn(prop, p2)) {
            this.set(p2, prop[p2]);
          }
        }
        return;
      }
      this[`_${prop}`] = value;
      this.doOnChange();
    }
    get(prop) {
      if (prop === "alpha") {
        return Math.floor(this[`_${prop}`]);
      }
      return this[`_${prop}`];
    }
    toRgb() {
      return hsv2rgb(this._hue, this._saturation, this._value);
    }
    fromString(value) {
      if (!value) {
        this._hue = 0;
        this._saturation = 100;
        this._value = 100;
        this.doOnChange();
        return;
      }
      const fromHSV = (h2, s2, v2) => {
        this._hue = Math.max(0, Math.min(360, h2));
        this._saturation = Math.max(0, Math.min(100, s2));
        this._value = Math.max(0, Math.min(100, v2));
        this.doOnChange();
      };
      if (value.indexOf("hsl") !== -1) {
        const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
        if (parts.length === 4) {
          this._alpha = parseFloat(parts[3]) * 100;
        } else if (parts.length === 3) {
          this._alpha = 100;
        }
        if (parts.length >= 3) {
          const { h: h2, s: s2, v: v2 } = hsl2hsv(parts[0], parts[1], parts[2]);
          fromHSV(h2, s2, v2);
        }
      } else if (value.indexOf("hsv") !== -1) {
        const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
        if (parts.length === 4) {
          this._alpha = parseFloat(parts[3]) * 100;
        } else if (parts.length === 3) {
          this._alpha = 100;
        }
        if (parts.length >= 3) {
          fromHSV(parts[0], parts[1], parts[2]);
        }
      } else if (value.indexOf("rgb") !== -1) {
        const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
        if (parts.length === 4) {
          this._alpha = parseFloat(parts[3]) * 100;
        } else if (parts.length === 3) {
          this._alpha = 100;
        }
        if (parts.length >= 3) {
          const { h: h2, s: s2, v: v2 } = rgb2hsv(parts[0], parts[1], parts[2]);
          fromHSV(h2, s2, v2);
        }
      } else if (value.indexOf("#") !== -1) {
        const hex2 = value.replace("#", "").trim();
        if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex2))
          return;
        let r, g, b2;
        if (hex2.length === 3) {
          r = parseHexChannel(hex2[0] + hex2[0]);
          g = parseHexChannel(hex2[1] + hex2[1]);
          b2 = parseHexChannel(hex2[2] + hex2[2]);
        } else if (hex2.length === 6 || hex2.length === 8) {
          r = parseHexChannel(hex2.substring(0, 2));
          g = parseHexChannel(hex2.substring(2, 4));
          b2 = parseHexChannel(hex2.substring(4, 6));
        }
        if (hex2.length === 8) {
          this._alpha = parseHexChannel(hex2.substring(6)) / 255 * 100;
        } else if (hex2.length === 3 || hex2.length === 6) {
          this._alpha = 100;
        }
        const { h: h2, s: s2, v: v2 } = rgb2hsv(r, g, b2);
        fromHSV(h2, s2, v2);
      }
    }
    compare(color2) {
      return Math.abs(color2._hue - this._hue) < 2 && Math.abs(color2._saturation - this._saturation) < 1 && Math.abs(color2._value - this._value) < 1 && Math.abs(color2._alpha - this._alpha) < 1;
    }
    doOnChange() {
      const { _hue, _saturation, _value, _alpha, format: format2 } = this;
      if (this.enableAlpha) {
        switch (format2) {
          case "hsl": {
            const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
            this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get("alpha") / 100})`;
            break;
          }
          case "hsv": {
            this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get("alpha") / 100})`;
            break;
          }
          case "hex": {
            this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;
            break;
          }
          default: {
            const { r, g, b: b2 } = hsv2rgb(_hue, _saturation, _value);
            this.value = `rgba(${r}, ${g}, ${b2}, ${this.get("alpha") / 100})`;
          }
        }
      } else {
        switch (format2) {
          case "hsl": {
            const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
            this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
            break;
          }
          case "hsv": {
            this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
            break;
          }
          case "rgb": {
            const { r, g, b: b2 } = hsv2rgb(_hue, _saturation, _value);
            this.value = `rgb(${r}, ${g}, ${b2})`;
            break;
          }
          default: {
            this.value = toHex(hsv2rgb(_hue, _saturation, _value));
          }
        }
      }
    }
  }
  exports["default"] = Color;
})(color);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var useOption2 = useOption$4;
  var color$12 = color;
  var script2 = vue2.defineComponent({
    props: {
      colors: { type: Array, required: true },
      color: {
        type: Object,
        required: true
      }
    },
    setup(props2) {
      const { currentColor } = useOption2.useOptions();
      const rgbaColors = vue2.ref(parseColors(props2.colors, props2.color));
      vue2.watch(() => currentColor.value, (val) => {
        const color$1$1 = new color$12["default"]();
        color$1$1.fromString(val);
        rgbaColors.value.forEach((item2) => {
          item2.selected = color$1$1.compare(item2);
        });
      });
      vue2.watchEffect(() => {
        rgbaColors.value = parseColors(props2.colors, props2.color);
      });
      function handleSelect(index2) {
        props2.color.fromString(props2.colors[index2]);
      }
      function parseColors(colors, color$1$1) {
        return colors.map((value) => {
          const c2 = new color$12["default"]();
          c2.enableAlpha = true;
          c2.format = "rgba";
          c2.fromString(value);
          c2.selected = c2.value === color$1$1.value;
          return c2;
        });
      }
      return {
        rgbaColors,
        handleSelect
      };
    }
  });
  exports["default"] = script2;
})(predefine_vue_vue_type_script_lang);
var predefine_vue_vue_type_template_id_391a669c_lang = {};
Object.defineProperty(predefine_vue_vue_type_template_id_391a669c_lang, "__esModule", { value: true });
var vue$1G = require$$0$1;
const _hoisted_1$V = { class: "el-color-predefine" };
const _hoisted_2$F = { class: "el-color-predefine__colors" };
const _hoisted_3$z = ["onClick"];
function render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1G.openBlock(), vue$1G.createElementBlock("div", _hoisted_1$V, [
    vue$1G.createElementVNode("div", _hoisted_2$F, [
      (vue$1G.openBlock(true), vue$1G.createElementBlock(vue$1G.Fragment, null, vue$1G.renderList(_ctx.rgbaColors, (item2, index2) => {
        return vue$1G.openBlock(), vue$1G.createElementBlock("div", {
          key: _ctx.colors[index2],
          class: vue$1G.normalizeClass(["el-color-predefine__color-selector", { selected: item2.selected, "is-alpha": item2._alpha < 100 }]),
          onClick: ($event) => _ctx.handleSelect(index2)
        }, [
          vue$1G.createElementVNode("div", {
            style: vue$1G.normalizeStyle({ backgroundColor: item2.value })
          }, null, 4)
        ], 10, _hoisted_3$z);
      }), 128))
    ])
  ]);
}
predefine_vue_vue_type_template_id_391a669c_lang.render = render$1d;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var predefine_vue_vue_type_script_lang$1 = predefine_vue_vue_type_script_lang;
  var predefine_vue_vue_type_template_id_391a669c_lang$1 = predefine_vue_vue_type_template_id_391a669c_lang;
  predefine_vue_vue_type_script_lang$1["default"].render = predefine_vue_vue_type_template_id_391a669c_lang$1.render;
  predefine_vue_vue_type_script_lang$1["default"].__file = "packages/components/color-picker/src/components/predefine.vue";
  exports["default"] = predefine_vue_vue_type_script_lang$1["default"];
})(predefine);
var svPanel = {};
var svPanel_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var draggable$1 = draggable;
  var script2 = vue2.defineComponent({
    name: "ElSlPanel",
    props: {
      color: {
        type: Object,
        required: true
      }
    },
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const cursorTop = vue2.ref(0);
      const cursorLeft = vue2.ref(0);
      const background = vue2.ref("hsl(0, 100%, 50%)");
      const colorValue = vue2.computed(() => {
        const hue = props2.color.get("hue");
        const value = props2.color.get("value");
        return { hue, value };
      });
      function update3() {
        const saturation = props2.color.get("saturation");
        const value = props2.color.get("value");
        const el = instance.vnode.el;
        const { clientWidth: width, clientHeight: height } = el;
        cursorLeft.value = saturation * width / 100;
        cursorTop.value = (100 - value) * height / 100;
        background.value = `hsl(${props2.color.get("hue")}, 100%, 50%)`;
      }
      function handleDrag(event) {
        const el = instance.vnode.el;
        const rect = el.getBoundingClientRect();
        const { clientX, clientY } = dom2.getClientXY(event);
        let left2 = clientX - rect.left;
        let top2 = clientY - rect.top;
        left2 = Math.max(0, left2);
        left2 = Math.min(left2, rect.width);
        top2 = Math.max(0, top2);
        top2 = Math.min(top2, rect.height);
        cursorLeft.value = left2;
        cursorTop.value = top2;
        props2.color.set({
          saturation: left2 / rect.width * 100,
          value: 100 - top2 / rect.height * 100
        });
      }
      vue2.watch(() => colorValue.value, () => {
        update3();
      });
      vue2.onMounted(() => {
        draggable$1["default"](instance.vnode.el, {
          drag: (event) => {
            handleDrag(event);
          },
          end: (event) => {
            handleDrag(event);
          }
        });
        update3();
      });
      return {
        cursorTop,
        cursorLeft,
        background,
        colorValue,
        handleDrag,
        update: update3
      };
    }
  });
  exports["default"] = script2;
})(svPanel_vue_vue_type_script_lang);
var svPanel_vue_vue_type_template_id_67046d94_lang = {};
Object.defineProperty(svPanel_vue_vue_type_template_id_67046d94_lang, "__esModule", { value: true });
var vue$1F = require$$0$1;
const _hoisted_1$U = /* @__PURE__ */ vue$1F.createElementVNode("div", { class: "el-color-svpanel__white" }, null, -1);
const _hoisted_2$E = /* @__PURE__ */ vue$1F.createElementVNode("div", { class: "el-color-svpanel__black" }, null, -1);
const _hoisted_3$y = /* @__PURE__ */ vue$1F.createElementVNode("div", null, null, -1);
const _hoisted_4$q = [
  _hoisted_3$y
];
function render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1F.openBlock(), vue$1F.createElementBlock("div", {
    class: "el-color-svpanel",
    style: vue$1F.normalizeStyle({
      backgroundColor: _ctx.background
    })
  }, [
    _hoisted_1$U,
    _hoisted_2$E,
    vue$1F.createElementVNode("div", {
      class: "el-color-svpanel__cursor",
      style: vue$1F.normalizeStyle({
        top: _ctx.cursorTop + "px",
        left: _ctx.cursorLeft + "px"
      })
    }, _hoisted_4$q, 4)
  ], 4);
}
svPanel_vue_vue_type_template_id_67046d94_lang.render = render$1c;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var svPanel_vue_vue_type_script_lang$1 = svPanel_vue_vue_type_script_lang;
  var svPanel_vue_vue_type_template_id_67046d94_lang$1 = svPanel_vue_vue_type_template_id_67046d94_lang;
  svPanel_vue_vue_type_script_lang$1["default"].render = svPanel_vue_vue_type_template_id_67046d94_lang$1.render;
  svPanel_vue_vue_type_script_lang$1["default"].__file = "packages/components/color-picker/src/components/sv-panel.vue";
  exports["default"] = svPanel_vue_vue_type_script_lang$1["default"];
})(svPanel);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var debounce2 = debounce_1;
  var index2 = button$5;
  var index$32 = icon$4;
  var index$110 = popper$3;
  var index$22 = input$2;
  var constants2 = constants$f;
  var validators2 = validators$6;
  var iconsVue2 = require$$3;
  var color$12 = color;
  var useOption2 = useOption$4;
  var svPanel_vue_vue_type_script_lang$1 = svPanel_vue_vue_type_script_lang;
  var hueSlider_vue_vue_type_script_lang$1 = hueSlider_vue_vue_type_script_lang;
  var alphaSlider_vue_vue_type_script_lang$1 = alphaSlider_vue_vue_type_script_lang;
  var predefine_vue_vue_type_script_lang$1 = predefine_vue_vue_type_script_lang;
  var index$42 = clickOutside;
  var index$52 = useLocale$1;
  var form2 = form$7;
  var index$62 = useCommonProps;
  var defaults2 = defaults$d;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var debounce__default2 = /* @__PURE__ */ _interopDefaultLegacy2(debounce2);
  var script2 = vue2.defineComponent({
    name: "ElColorPicker",
    components: {
      ElButton: index2.ElButton,
      ElPopper: index$110["default"],
      ElInput: index$22.ElInput,
      ElIcon: index$32.ElIcon,
      Close: iconsVue2.Close,
      ArrowDown: iconsVue2.ArrowDown,
      SvPanel: svPanel_vue_vue_type_script_lang$1["default"],
      HueSlider: hueSlider_vue_vue_type_script_lang$1["default"],
      AlphaSlider: alphaSlider_vue_vue_type_script_lang$1["default"],
      Predefine: predefine_vue_vue_type_script_lang$1["default"]
    },
    directives: {
      ClickOutside: index$42["default"]
    },
    props: {
      modelValue: String,
      showAlpha: Boolean,
      colorFormat: String,
      disabled: Boolean,
      size: {
        type: String,
        validator: validators2.isValidComponentSize
      },
      popperClass: String,
      predefine: Array
    },
    emits: ["change", "active-change", constants2.UPDATE_MODEL_EVENT],
    setup(props2, { emit }) {
      const { t } = index$52.useLocale();
      const elForm = vue2.inject(form2.elFormKey, {});
      const elFormItem = vue2.inject(form2.elFormItemKey, {});
      const hue = vue2.ref(null);
      const svPanel2 = vue2.ref(null);
      const alpha = vue2.ref(null);
      const popper2 = vue2.ref(null);
      const color$1$1 = vue2.reactive(new color$12["default"]({
        enableAlpha: props2.showAlpha,
        format: props2.colorFormat
      }));
      const showPicker = vue2.ref(false);
      const showPanelColor = vue2.ref(false);
      const customInput = vue2.ref("");
      const displayedColor = vue2.computed(() => {
        if (!props2.modelValue && !showPanelColor.value) {
          return "transparent";
        }
        return displayedRgb(color$1$1, props2.showAlpha);
      });
      const colorSize = index$62.useSize();
      const colorDisabled = vue2.computed(() => {
        return props2.disabled || elForm.disabled;
      });
      const currentColor = vue2.computed(() => {
        return !props2.modelValue && !showPanelColor.value ? "" : color$1$1.value;
      });
      vue2.watch(() => props2.modelValue, (newVal) => {
        if (!newVal) {
          showPanelColor.value = false;
        } else if (newVal && newVal !== color$1$1.value) {
          color$1$1.fromString(newVal);
        }
      });
      vue2.watch(() => currentColor.value, (val) => {
        customInput.value = val;
        emit("active-change", val);
      });
      vue2.watch(() => color$1$1.value, () => {
        if (!props2.modelValue && !showPanelColor.value) {
          showPanelColor.value = true;
        }
      });
      function displayedRgb(color2, showAlpha) {
        if (!(color2 instanceof color$12["default"])) {
          throw Error("color should be instance of _color Class");
        }
        const { r, g, b: b2 } = color2.toRgb();
        return showAlpha ? `rgba(${r}, ${g}, ${b2}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b2})`;
      }
      function setShowPicker(value) {
        showPicker.value = value;
      }
      const debounceSetShowPicker = debounce__default2["default"](setShowPicker, 100);
      function hide2() {
        debounceSetShowPicker(false);
        resetColor();
      }
      function resetColor() {
        vue2.nextTick(() => {
          if (props2.modelValue) {
            color$1$1.fromString(props2.modelValue);
          } else {
            showPanelColor.value = false;
          }
        });
      }
      function handleTrigger() {
        if (colorDisabled.value)
          return;
        debounceSetShowPicker(!showPicker.value);
      }
      function handleConfirm() {
        color$1$1.fromString(customInput.value);
      }
      function confirmValue() {
        var _a;
        const value = color$1$1.value;
        emit(constants2.UPDATE_MODEL_EVENT, value);
        emit("change", value);
        (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change");
        debounceSetShowPicker(false);
        vue2.nextTick(() => {
          const newColor = new color$12["default"]({
            enableAlpha: props2.showAlpha,
            format: props2.colorFormat
          });
          newColor.fromString(props2.modelValue);
          if (!color$1$1.compare(newColor)) {
            resetColor();
          }
        });
      }
      function clear2() {
        var _a;
        debounceSetShowPicker(false);
        emit(constants2.UPDATE_MODEL_EVENT, null);
        emit("change", null);
        if (props2.modelValue !== null) {
          (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change");
        }
        resetColor();
      }
      vue2.onMounted(() => {
        if (props2.modelValue) {
          color$1$1.fromString(props2.modelValue);
          customInput.value = currentColor.value;
        }
      });
      vue2.watch(() => showPicker.value, () => {
        vue2.nextTick(() => {
          var _a, _b, _c;
          (_a = hue.value) == null ? void 0 : _a.update();
          (_b = svPanel2.value) == null ? void 0 : _b.update();
          (_c = alpha.value) == null ? void 0 : _c.update();
        });
      });
      vue2.provide(useOption2.OPTIONS_KEY, {
        currentColor
      });
      return {
        Effect: defaults2.Effect,
        color: color$1$1,
        colorDisabled,
        colorSize,
        displayedColor,
        showPanelColor,
        showPicker,
        customInput,
        handleConfirm,
        hide: hide2,
        handleTrigger,
        clear: clear2,
        confirmValue,
        t,
        hue,
        svPanel: svPanel2,
        alpha,
        popper: popper2
      };
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$8);
var index_vue_vue_type_template_id_46a474d5_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_46a474d5_lang, "__esModule", { value: true });
var vue$1E = require$$0$1;
const _hoisted_1$T = { class: "el-color-dropdown__main-wrapper" };
const _hoisted_2$D = { class: "el-color-dropdown__btns" };
const _hoisted_3$x = { class: "el-color-dropdown__value" };
const _hoisted_4$p = {
  key: 0,
  class: "el-color-picker__mask"
};
function render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_hue_slider = vue$1E.resolveComponent("hue-slider");
  const _component_sv_panel = vue$1E.resolveComponent("sv-panel");
  const _component_alpha_slider = vue$1E.resolveComponent("alpha-slider");
  const _component_predefine = vue$1E.resolveComponent("predefine");
  const _component_el_input = vue$1E.resolveComponent("el-input");
  const _component_el_button = vue$1E.resolveComponent("el-button");
  const _component_close = vue$1E.resolveComponent("close");
  const _component_el_icon = vue$1E.resolveComponent("el-icon");
  const _component_arrow_down = vue$1E.resolveComponent("arrow-down");
  const _component_el_popper = vue$1E.resolveComponent("el-popper");
  const _directive_click_outside = vue$1E.resolveDirective("click-outside");
  return vue$1E.openBlock(), vue$1E.createBlock(_component_el_popper, {
    ref: "popper",
    visible: _ctx.showPicker,
    "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => _ctx.showPicker = $event),
    effect: _ctx.Effect.LIGHT,
    "manual-mode": "",
    trigger: "click",
    "show-arrow": false,
    "fallback-placements": ["bottom", "top", "right", "left"],
    offset: 0,
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    "popper-class": `el-color-picker__panel el-color-dropdown ${_ctx.popperClass}`,
    "stop-popper-mouse-event": false
  }, {
    default: vue$1E.withCtx(() => [
      vue$1E.withDirectives(vue$1E.createElementVNode("div", null, [
        vue$1E.createElementVNode("div", _hoisted_1$T, [
          vue$1E.createVNode(_component_hue_slider, {
            ref: "hue",
            class: "hue-slider",
            color: _ctx.color,
            vertical: ""
          }, null, 8, ["color"]),
          vue$1E.createVNode(_component_sv_panel, {
            ref: "svPanel",
            color: _ctx.color
          }, null, 8, ["color"])
        ]),
        _ctx.showAlpha ? (vue$1E.openBlock(), vue$1E.createBlock(_component_alpha_slider, {
          key: 0,
          ref: "alpha",
          color: _ctx.color
        }, null, 8, ["color"])) : vue$1E.createCommentVNode("v-if", true),
        _ctx.predefine ? (vue$1E.openBlock(), vue$1E.createBlock(_component_predefine, {
          key: 1,
          ref: "predefine",
          color: _ctx.color,
          colors: _ctx.predefine
        }, null, 8, ["color", "colors"])) : vue$1E.createCommentVNode("v-if", true),
        vue$1E.createElementVNode("div", _hoisted_2$D, [
          vue$1E.createElementVNode("span", _hoisted_3$x, [
            vue$1E.createVNode(_component_el_input, {
              modelValue: _ctx.customInput,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.customInput = $event),
              "validate-event": false,
              size: "mini",
              onKeyup: vue$1E.withKeys(_ctx.handleConfirm, ["enter"]),
              onBlur: _ctx.handleConfirm
            }, null, 8, ["modelValue", "onKeyup", "onBlur"])
          ]),
          vue$1E.createVNode(_component_el_button, {
            size: "mini",
            type: "text",
            class: "el-color-dropdown__link-btn",
            onClick: _ctx.clear
          }, {
            default: vue$1E.withCtx(() => [
              vue$1E.createTextVNode(vue$1E.toDisplayString(_ctx.t("el.colorpicker.clear")), 1)
            ]),
            _: 1
          }, 8, ["onClick"]),
          vue$1E.createVNode(_component_el_button, {
            plain: "",
            size: "mini",
            class: "el-color-dropdown__btn",
            onClick: _ctx.confirmValue
          }, {
            default: vue$1E.withCtx(() => [
              vue$1E.createTextVNode(vue$1E.toDisplayString(_ctx.t("el.colorpicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ], 512), [
        [_directive_click_outside, _ctx.hide]
      ])
    ]),
    trigger: vue$1E.withCtx(() => [
      vue$1E.createElementVNode("div", {
        class: vue$1E.normalizeClass([
          "el-color-picker",
          _ctx.colorDisabled ? "is-disabled" : "",
          _ctx.colorSize ? `el-color-picker--${_ctx.colorSize}` : ""
        ])
      }, [
        _ctx.colorDisabled ? (vue$1E.openBlock(), vue$1E.createElementBlock("div", _hoisted_4$p)) : vue$1E.createCommentVNode("v-if", true),
        vue$1E.createElementVNode("div", {
          class: "el-color-picker__trigger",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleTrigger && _ctx.handleTrigger(...args))
        }, [
          vue$1E.createElementVNode("span", {
            class: vue$1E.normalizeClass(["el-color-picker__color", { "is-alpha": _ctx.showAlpha }])
          }, [
            vue$1E.createElementVNode("span", {
              class: "el-color-picker__color-inner",
              style: vue$1E.normalizeStyle({
                backgroundColor: _ctx.displayedColor
              })
            }, null, 4),
            !_ctx.modelValue && !_ctx.showPanelColor ? (vue$1E.openBlock(), vue$1E.createBlock(_component_el_icon, {
              key: 0,
              class: "el-color-picker__empty is-icon-close"
            }, {
              default: vue$1E.withCtx(() => [
                vue$1E.createVNode(_component_close)
              ]),
              _: 1
            })) : vue$1E.createCommentVNode("v-if", true)
          ], 2),
          vue$1E.withDirectives(vue$1E.createVNode(_component_el_icon, { class: "el-color-picker__icon is-icon-arrow-down" }, {
            default: vue$1E.withCtx(() => [
              vue$1E.createVNode(_component_arrow_down)
            ]),
            _: 1
          }, 512), [
            [vue$1E.vShow, _ctx.modelValue || _ctx.showPanelColor]
          ])
        ])
      ], 2)
    ]),
    _: 1
  }, 8, ["visible", "effect", "popper-class"]);
}
index_vue_vue_type_template_id_46a474d5_lang.render = render$1b;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$8;
  var index_vue_vue_type_template_id_46a474d5_lang$1 = index_vue_vue_type_template_id_46a474d5_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_46a474d5_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/color-picker/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$b);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$8;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  const _ColorPicker = index_vue_vue_type_script_lang2["default"];
  const ElColorPicker = _ColorPicker;
  exports.ElColorPicker = ElColorPicker;
  exports["default"] = _ColorPicker;
})(colorPicker);
var configProvider$3 = {};
var src$a = {};
var configProvider$2 = {};
Object.defineProperty(configProvider$2, "__esModule", { value: true });
var props$p = props$N;
var index$1d = useLocale$1;
const configProviderProps = props$p.buildProps(__spreadProps(__spreadValues({}, index$1d.useLocaleProps), {
  size: {
    type: String,
    values: ["large", "medium", "small", "mini"]
  },
  button: {
    type: props$p.definePropType(Object)
  }
}));
configProvider$2.configProviderProps = configProviderProps;
Object.defineProperty(src$a, "__esModule", { value: true });
var vue$1D = require$$0$1;
var configProvider$1 = configProvider$2;
var index$1c = useLocale$1;
var configProvider$1$1 = configProvider$5;
const ConfigProvider = vue$1D.defineComponent({
  name: "ElConfigProvider",
  props: configProvider$1.configProviderProps,
  setup(props2, { slots }) {
    index$1c.provideLocale();
    vue$1D.provide(configProvider$1$1.configProviderContextKey, props2);
    return () => {
      var _a;
      return (_a = slots.default) == null ? void 0 : _a.call(slots);
    };
  }
});
src$a.ConfigProvider = ConfigProvider;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var index2 = src$a;
  var configProvider2 = configProvider$2;
  const ElConfigProvider = withInstall2.withInstall(index2.ConfigProvider);
  exports.configProviderProps = configProvider2.configProviderProps;
  exports.ElConfigProvider = ElConfigProvider;
  exports["default"] = ElConfigProvider;
})(configProvider$3);
var container$1 = {};
var container = {};
var container_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElContainer",
    props: {
      direction: {
        type: String,
        default: ""
      }
    },
    setup(props2, { slots }) {
      const isVertical = vue2.computed(() => {
        if (props2.direction === "vertical") {
          return true;
        } else if (props2.direction === "horizontal") {
          return false;
        }
        if (slots && slots.default) {
          const vNodes = slots.default();
          return vNodes.some((vNode) => {
            const tag3 = vNode.type.name;
            return tag3 === "ElHeader" || tag3 === "ElFooter";
          });
        } else {
          return false;
        }
      });
      return {
        isVertical
      };
    }
  });
  exports["default"] = script2;
})(container_vue_vue_type_script_lang);
var container_vue_vue_type_template_id_60a2865a_lang = {};
Object.defineProperty(container_vue_vue_type_template_id_60a2865a_lang, "__esModule", { value: true });
var vue$1C = require$$0$1;
function render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1C.openBlock(), vue$1C.createElementBlock("section", {
    class: vue$1C.normalizeClass(["el-container", { "is-vertical": _ctx.isVertical }])
  }, [
    vue$1C.renderSlot(_ctx.$slots, "default")
  ], 2);
}
container_vue_vue_type_template_id_60a2865a_lang.render = render$1a;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var container_vue_vue_type_script_lang$1 = container_vue_vue_type_script_lang;
  var container_vue_vue_type_template_id_60a2865a_lang$1 = container_vue_vue_type_template_id_60a2865a_lang;
  container_vue_vue_type_script_lang$1["default"].render = container_vue_vue_type_template_id_60a2865a_lang$1.render;
  container_vue_vue_type_script_lang$1["default"].__file = "packages/components/container/src/container.vue";
  exports["default"] = container_vue_vue_type_script_lang$1["default"];
})(container);
var aside = {};
var aside_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElAside",
    props: {
      width: {
        type: String,
        default: null
      }
    },
    setup(props2) {
      return {
        style: vue2.computed(() => {
          return props2.width ? { "--el-aside-width": props2.width } : {};
        })
      };
    }
  });
  exports["default"] = script2;
})(aside_vue_vue_type_script_lang);
var aside_vue_vue_type_template_id_47e12f0a_lang = {};
Object.defineProperty(aside_vue_vue_type_template_id_47e12f0a_lang, "__esModule", { value: true });
var vue$1B = require$$0$1;
function render$19(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1B.openBlock(), vue$1B.createElementBlock("aside", {
    class: "el-aside",
    style: vue$1B.normalizeStyle(_ctx.style)
  }, [
    vue$1B.renderSlot(_ctx.$slots, "default")
  ], 4);
}
aside_vue_vue_type_template_id_47e12f0a_lang.render = render$19;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var aside_vue_vue_type_script_lang$1 = aside_vue_vue_type_script_lang;
  var aside_vue_vue_type_template_id_47e12f0a_lang$1 = aside_vue_vue_type_template_id_47e12f0a_lang;
  aside_vue_vue_type_script_lang$1["default"].render = aside_vue_vue_type_template_id_47e12f0a_lang$1.render;
  aside_vue_vue_type_script_lang$1["default"].__file = "packages/components/container/src/aside.vue";
  exports["default"] = aside_vue_vue_type_script_lang$1["default"];
})(aside);
var footer = {};
var footer_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElFooter",
    props: {
      height: {
        type: String,
        default: null
      }
    },
    setup(props2) {
      return {
        style: vue2.computed(() => props2.height ? {
          "--el-footer-height": props2.height
        } : {})
      };
    }
  });
  exports["default"] = script2;
})(footer_vue_vue_type_script_lang);
var footer_vue_vue_type_template_id_2c2b128e_lang = {};
Object.defineProperty(footer_vue_vue_type_template_id_2c2b128e_lang, "__esModule", { value: true });
var vue$1A = require$$0$1;
function render$18(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1A.openBlock(), vue$1A.createElementBlock("footer", {
    class: "el-footer",
    style: vue$1A.normalizeStyle(_ctx.style)
  }, [
    vue$1A.renderSlot(_ctx.$slots, "default")
  ], 4);
}
footer_vue_vue_type_template_id_2c2b128e_lang.render = render$18;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var footer_vue_vue_type_script_lang$1 = footer_vue_vue_type_script_lang;
  var footer_vue_vue_type_template_id_2c2b128e_lang$1 = footer_vue_vue_type_template_id_2c2b128e_lang;
  footer_vue_vue_type_script_lang$1["default"].render = footer_vue_vue_type_template_id_2c2b128e_lang$1.render;
  footer_vue_vue_type_script_lang$1["default"].__file = "packages/components/container/src/footer.vue";
  exports["default"] = footer_vue_vue_type_script_lang$1["default"];
})(footer);
var header = {};
var header_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElHeader",
    props: {
      height: {
        type: String,
        default: null
      }
    },
    setup(props2) {
      return {
        style: vue2.computed(() => props2.height ? {
          "--el-header-height": props2.height
        } : {})
      };
    }
  });
  exports["default"] = script2;
})(header_vue_vue_type_script_lang);
var header_vue_vue_type_template_id_0b1cdaab_lang = {};
Object.defineProperty(header_vue_vue_type_template_id_0b1cdaab_lang, "__esModule", { value: true });
var vue$1z = require$$0$1;
function render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1z.openBlock(), vue$1z.createElementBlock("header", {
    class: "el-header",
    style: vue$1z.normalizeStyle(_ctx.style)
  }, [
    vue$1z.renderSlot(_ctx.$slots, "default")
  ], 4);
}
header_vue_vue_type_template_id_0b1cdaab_lang.render = render$17;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var header_vue_vue_type_script_lang$1 = header_vue_vue_type_script_lang;
  var header_vue_vue_type_template_id_0b1cdaab_lang$1 = header_vue_vue_type_template_id_0b1cdaab_lang;
  header_vue_vue_type_script_lang$1["default"].render = header_vue_vue_type_template_id_0b1cdaab_lang$1.render;
  header_vue_vue_type_script_lang$1["default"].__file = "packages/components/container/src/header.vue";
  exports["default"] = header_vue_vue_type_script_lang$1["default"];
})(header);
var main = {};
var main_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElMain"
  });
  exports["default"] = script2;
})(main_vue_vue_type_script_lang);
var main_vue_vue_type_template_id_526ed157_lang = {};
Object.defineProperty(main_vue_vue_type_template_id_526ed157_lang, "__esModule", { value: true });
var vue$1y = require$$0$1;
const _hoisted_1$S = { class: "el-main" };
function render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1y.openBlock(), vue$1y.createElementBlock("main", _hoisted_1$S, [
    vue$1y.renderSlot(_ctx.$slots, "default")
  ]);
}
main_vue_vue_type_template_id_526ed157_lang.render = render$16;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var main_vue_vue_type_script_lang$12 = main_vue_vue_type_script_lang;
  var main_vue_vue_type_template_id_526ed157_lang$1 = main_vue_vue_type_template_id_526ed157_lang;
  main_vue_vue_type_script_lang$12["default"].render = main_vue_vue_type_template_id_526ed157_lang$1.render;
  main_vue_vue_type_script_lang$12["default"].__file = "packages/components/container/src/main.vue";
  exports["default"] = main_vue_vue_type_script_lang$12["default"];
})(main);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var container_vue_vue_type_script_lang$1 = container_vue_vue_type_script_lang;
  var aside_vue_vue_type_script_lang$1 = aside_vue_vue_type_script_lang;
  var footer_vue_vue_type_script_lang$1 = footer_vue_vue_type_script_lang;
  var header_vue_vue_type_script_lang$1 = header_vue_vue_type_script_lang;
  var main_vue_vue_type_script_lang$12 = main_vue_vue_type_script_lang;
  const ElContainer = withInstall2.withInstall(container_vue_vue_type_script_lang$1["default"], {
    Aside: aside_vue_vue_type_script_lang$1["default"],
    Footer: footer_vue_vue_type_script_lang$1["default"],
    Header: header_vue_vue_type_script_lang$1["default"],
    Main: main_vue_vue_type_script_lang$12["default"]
  });
  const ElAside = withInstall2.withNoopInstall(aside_vue_vue_type_script_lang$1["default"]);
  const ElFooter = withInstall2.withNoopInstall(footer_vue_vue_type_script_lang$1["default"]);
  const ElHeader = withInstall2.withNoopInstall(header_vue_vue_type_script_lang$1["default"]);
  const ElMain = withInstall2.withNoopInstall(main_vue_vue_type_script_lang$12["default"]);
  exports.ElAside = ElAside;
  exports.ElContainer = ElContainer;
  exports.ElFooter = ElFooter;
  exports.ElHeader = ElHeader;
  exports.ElMain = ElMain;
  exports["default"] = ElContainer;
})(container$1);
var datePicker$1 = {};
var datePicker = {};
var advancedFormat = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, r) {
      var n = t.prototype, s2 = n.format;
      r.en.ordinal = function(e2) {
        var t2 = ["th", "st", "nd", "rd"], r2 = e2 % 100;
        return "[" + e2 + (t2[(r2 - 20) % 10] || t2[r2] || t2[0]) + "]";
      }, n.format = function(e2) {
        var t2 = this, r2 = this.$locale();
        if (!this.isValid())
          return s2.bind(this)(e2);
        var n2 = this.$utils(), a2 = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
          switch (e3) {
            case "Q":
              return Math.ceil((t2.$M + 1) / 3);
            case "Do":
              return r2.ordinal(t2.$D);
            case "gggg":
              return t2.weekYear();
            case "GGGG":
              return t2.isoWeekYear();
            case "wo":
              return r2.ordinal(t2.week(), "W");
            case "w":
            case "ww":
              return n2.s(t2.week(), e3 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return n2.s(t2.isoWeek(), e3 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return n2.s(String(t2.$H === 0 ? 24 : t2.$H), e3 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(t2.$d.getTime() / 1e3);
            case "x":
              return t2.$d.getTime();
            case "z":
              return "[" + t2.offsetName() + "]";
            case "zzz":
              return "[" + t2.offsetName("long") + "]";
            default:
              return e3;
          }
        });
        return s2.bind(this)(a2);
      };
    };
  });
})(advancedFormat);
var weekOfYear = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    var e = "week", t = "year";
    return function(i, n, r) {
      var f2 = n.prototype;
      f2.week = function(i2) {
        if (i2 === void 0 && (i2 = null), i2 !== null)
          return this.add(7 * (i2 - this.week()), "day");
        var n2 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var f3 = r(this).startOf(t).add(1, t).date(n2), s2 = r(this).endOf(e);
          if (f3.isBefore(s2))
            return 1;
        }
        var a2 = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o2 = this.diff(a2, e, true);
        return o2 < 0 ? r(this).startOf("week").week() : Math.ceil(o2);
      }, f2.weeks = function(e2) {
        return e2 === void 0 && (e2 = null), this.week(e2);
      };
    };
  });
})(weekOfYear);
var weekYear = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.weekYear = function() {
        var e2 = this.month(), t2 = this.week(), n = this.year();
        return t2 === 1 && e2 === 11 ? n + 1 : e2 === 0 && t2 >= 52 ? n - 1 : n;
      };
    };
  });
})(weekYear);
var dayOfYear = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, n) {
      t.prototype.dayOfYear = function(e2) {
        var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
        return e2 == null ? t2 : this.add(e2 - t2, "day");
      };
    };
  });
})(dayOfYear);
var isSameOrAfter = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.isSameOrAfter = function(e2, t2) {
        return this.isSame(e2, t2) || this.isAfter(e2, t2);
      };
    };
  });
})(isSameOrAfter);
var isSameOrBefore = { exports: {} };
(function(module, exports) {
  !function(e, i) {
    module.exports = i();
  }(commonjsGlobal, function() {
    return function(e, i) {
      i.prototype.isSameOrBefore = function(e2, i2) {
        return this.isSame(e2, i2) || this.isBefore(e2, i2);
      };
    };
  });
})(isSameOrBefore);
var panelDatePick = {};
var panelDatePick_vue_vue_type_script_lang = {};
var basicDateTable = {};
var basicDateTable_vue_vue_type_script_lang = {};
var basicCellRender = {};
var datePicker_type = {};
Object.defineProperty(datePicker_type, "__esModule", { value: true });
const ROOT_PICKER_INJECTION_KEY = Symbol();
datePicker_type.ROOT_PICKER_INJECTION_KEY = ROOT_PICKER_INJECTION_KEY;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var props2 = props$N;
  var datePicker_type$1 = datePicker_type;
  var ElDatePickerCell = vue2.defineComponent({
    name: "ElDatePickerCell",
    props: props2.buildProps({
      cell: {
        type: props2.definePropType(Object)
      }
    }),
    setup(props3) {
      const picker2 = vue2.inject(datePicker_type$1.ROOT_PICKER_INJECTION_KEY);
      return () => {
        const cell = props3.cell;
        return (picker2 == null ? void 0 : picker2.ctx.slots.default) ? picker2.ctx.slots.default(cell) : vue2.h("div", {
          class: "el-date-table-cell"
        }, [
          vue2.h("span", {
            class: "el-date-table-cell__text"
          }, [cell == null ? void 0 : cell.text])
        ]);
      };
    }
  });
  exports["default"] = ElDatePickerCell;
})(basicCellRender);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var util2 = util$l;
  var basicCellRender$1 = basicCellRender;
  var index2 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var script2 = vue2.defineComponent({
    components: {
      ElDatePickerCell: basicCellRender$1["default"]
    },
    props: {
      date: {
        type: Object
      },
      minDate: {
        type: Object
      },
      maxDate: {
        type: Object
      },
      parsedValue: {
        type: [Object, Array]
      },
      selectionMode: {
        type: String,
        default: "day"
      },
      showWeekNumber: {
        type: Boolean,
        default: false
      },
      disabledDate: {
        type: Function
      },
      cellClassName: {
        type: Function
      },
      rangeState: {
        type: Object,
        default: () => ({
          endDate: null,
          selecting: false
        })
      }
    },
    emits: ["changerange", "pick", "select"],
    setup(props2, ctx) {
      const { t, lang } = index2.useLocale();
      const lastRow = vue2.ref(null);
      const lastColumn = vue2.ref(null);
      const tableRows = vue2.ref([[], [], [], [], [], []]);
      const firstDayOfWeek = props2.date.$locale().weekStart || 7;
      const WEEKS_CONSTANT = props2.date.locale("en").localeData().weekdaysShort().map((_2) => _2.toLowerCase());
      const offsetDay = vue2.computed(() => {
        return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
      });
      const startDate = vue2.computed(() => {
        const startDayOfMonth = props2.date.startOf("month");
        return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
      });
      const WEEKS = vue2.computed(() => {
        return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
      });
      const rows = vue2.computed(() => {
        var _a;
        const startOfMonth = props2.date.startOf("month");
        const startOfMonthDay = startOfMonth.day() || 7;
        const dateCountOfMonth = startOfMonth.daysInMonth();
        const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
        const offset2 = offsetDay.value;
        const rows_ = tableRows.value;
        let count = 1;
        const selectedDate = props2.selectionMode === "dates" ? util2.coerceTruthyValueToArray(props2.parsedValue) : [];
        const calNow = dayjs__default["default"]().locale(lang.value).startOf("day");
        for (let i = 0; i < 6; i++) {
          const row2 = rows_[i];
          if (props2.showWeekNumber) {
            if (!row2[0]) {
              row2[0] = {
                type: "week",
                text: startDate.value.add(i * 7 + 1, "day").week()
              };
            }
          }
          for (let j = 0; j < 7; j++) {
            let cell = row2[props2.showWeekNumber ? j + 1 : j];
            if (!cell) {
              cell = {
                row: i,
                column: j,
                type: "normal",
                inRange: false,
                start: false,
                end: false
              };
            }
            const index3 = i * 7 + j;
            const calTime = startDate.value.add(index3 - offset2, "day");
            cell.dayjs = calTime;
            cell.date = calTime.toDate();
            cell.timestamp = calTime.valueOf();
            cell.type = "normal";
            const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate;
            cell.inRange = props2.minDate && calTime.isSameOrAfter(props2.minDate, "day") && calEndDate && calTime.isSameOrBefore(calEndDate, "day") || props2.minDate && calTime.isSameOrBefore(props2.minDate, "day") && calEndDate && calTime.isSameOrAfter(calEndDate, "day");
            if ((_a = props2.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
              cell.start = calEndDate && calTime.isSame(calEndDate, "day");
              cell.end = props2.minDate && calTime.isSame(props2.minDate, "day");
            } else {
              cell.start = props2.minDate && calTime.isSame(props2.minDate, "day");
              cell.end = calEndDate && calTime.isSame(calEndDate, "day");
            }
            const isToday = calTime.isSame(calNow, "day");
            if (isToday) {
              cell.type = "today";
            }
            if (i >= 0 && i <= 1) {
              const numberOfDaysFromPreviousMonth = startOfMonthDay + offset2 < 0 ? 7 + startOfMonthDay + offset2 : startOfMonthDay + offset2;
              if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
                cell.text = count++;
              } else {
                cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
                cell.type = "prev-month";
              }
            } else {
              if (count <= dateCountOfMonth) {
                cell.text = count++;
              } else {
                cell.text = count++ - dateCountOfMonth;
                cell.type = "next-month";
              }
            }
            const cellDate = calTime.toDate();
            cell.selected = selectedDate.find((_2) => _2.valueOf() === calTime.valueOf());
            cell.isSelected = !!cell.selected;
            cell.isCurrent = isCurrent(cell);
            cell.disabled = props2.disabledDate && props2.disabledDate(cellDate);
            cell.customClass = props2.cellClassName && props2.cellClassName(cellDate);
            row2[props2.showWeekNumber ? j + 1 : j] = cell;
          }
          if (props2.selectionMode === "week") {
            const start2 = props2.showWeekNumber ? 1 : 0;
            const end2 = props2.showWeekNumber ? 7 : 6;
            const isActive = isWeekActive(row2[start2 + 1]);
            row2[start2].inRange = isActive;
            row2[start2].start = isActive;
            row2[end2].inRange = isActive;
            row2[end2].end = isActive;
          }
        }
        return rows_;
      });
      const isCurrent = (cell) => {
        return props2.selectionMode === "day" && (cell.type === "normal" || cell.type === "today") && cellMatchesDate(cell, props2.parsedValue);
      };
      const cellMatchesDate = (cell, date4) => {
        if (!date4)
          return false;
        return dayjs__default["default"](date4).locale(lang.value).isSame(props2.date.date(Number(cell.text)), "day");
      };
      const getCellClasses = (cell) => {
        const classes = [];
        if ((cell.type === "normal" || cell.type === "today") && !cell.disabled) {
          classes.push("available");
          if (cell.type === "today") {
            classes.push("today");
          }
        } else {
          classes.push(cell.type);
        }
        if (isCurrent(cell)) {
          classes.push("current");
        }
        if (cell.inRange && (cell.type === "normal" || cell.type === "today" || props2.selectionMode === "week")) {
          classes.push("in-range");
          if (cell.start) {
            classes.push("start-date");
          }
          if (cell.end) {
            classes.push("end-date");
          }
        }
        if (cell.disabled) {
          classes.push("disabled");
        }
        if (cell.selected) {
          classes.push("selected");
        }
        if (cell.customClass) {
          classes.push(cell.customClass);
        }
        return classes.join(" ");
      };
      const getDateOfCell = (row2, column) => {
        const offsetFromStart = row2 * 7 + (column - (props2.showWeekNumber ? 1 : 0)) - offsetDay.value;
        return startDate.value.add(offsetFromStart, "day");
      };
      const handleMouseMove = (event) => {
        if (!props2.rangeState.selecting)
          return;
        let target2 = event.target;
        if (target2.tagName === "SPAN") {
          target2 = target2.parentNode.parentNode;
        }
        if (target2.tagName === "DIV") {
          target2 = target2.parentNode;
        }
        if (target2.tagName !== "TD")
          return;
        const row2 = target2.parentNode.rowIndex - 1;
        const column = target2.cellIndex;
        if (rows.value[row2][column].disabled)
          return;
        if (row2 !== lastRow.value || column !== lastColumn.value) {
          lastRow.value = row2;
          lastColumn.value = column;
          ctx.emit("changerange", {
            selecting: true,
            endDate: getDateOfCell(row2, column)
          });
        }
      };
      const handleClick = (event) => {
        let target2 = event.target;
        while (target2) {
          if (target2.tagName === "TD") {
            break;
          }
          target2 = target2.parentNode;
        }
        if (!target2 || target2.tagName !== "TD")
          return;
        const row2 = target2.parentNode.rowIndex - 1;
        const column = target2.cellIndex;
        const cell = rows.value[row2][column];
        if (cell.disabled || cell.type === "week")
          return;
        const newDate = getDateOfCell(row2, column);
        if (props2.selectionMode === "range") {
          if (!props2.rangeState.selecting) {
            ctx.emit("pick", { minDate: newDate, maxDate: null });
            ctx.emit("select", true);
          } else {
            if (newDate >= props2.minDate) {
              ctx.emit("pick", { minDate: props2.minDate, maxDate: newDate });
            } else {
              ctx.emit("pick", { minDate: newDate, maxDate: props2.minDate });
            }
            ctx.emit("select", false);
          }
        } else if (props2.selectionMode === "day") {
          ctx.emit("pick", newDate);
        } else if (props2.selectionMode === "week") {
          const weekNumber = newDate.week();
          const value = `${newDate.year()}w${weekNumber}`;
          ctx.emit("pick", {
            year: newDate.year(),
            week: weekNumber,
            value,
            date: newDate.startOf("week")
          });
        } else if (props2.selectionMode === "dates") {
          const newValue = cell.selected ? util2.coerceTruthyValueToArray(props2.parsedValue).filter((_2) => _2.valueOf() !== newDate.valueOf()) : util2.coerceTruthyValueToArray(props2.parsedValue).concat([newDate]);
          ctx.emit("pick", newValue);
        }
      };
      const isWeekActive = (cell) => {
        if (props2.selectionMode !== "week")
          return false;
        let newDate = props2.date.startOf("day");
        if (cell.type === "prev-month") {
          newDate = newDate.subtract(1, "month");
        }
        if (cell.type === "next-month") {
          newDate = newDate.add(1, "month");
        }
        newDate = newDate.date(parseInt(cell.text, 10));
        if (props2.parsedValue && !Array.isArray(props2.parsedValue)) {
          const dayOffset = (props2.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
          const weekDate = props2.parsedValue.subtract(dayOffset, "day");
          return weekDate.isSame(newDate, "day");
        }
        return false;
      };
      return {
        handleMouseMove,
        t,
        rows,
        isWeekActive,
        getCellClasses,
        WEEKS,
        handleClick
      };
    }
  });
  exports["default"] = script2;
})(basicDateTable_vue_vue_type_script_lang);
var basicDateTable_vue_vue_type_template_id_0572814e_lang = {};
Object.defineProperty(basicDateTable_vue_vue_type_template_id_0572814e_lang, "__esModule", { value: true });
var vue$1x = require$$0$1;
const _hoisted_1$R = { key: 0 };
function render$15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_date_picker_cell = vue$1x.resolveComponent("el-date-picker-cell");
  return vue$1x.openBlock(), vue$1x.createElementBlock("table", {
    cellspacing: "0",
    cellpadding: "0",
    class: vue$1x.normalizeClass(["el-date-table", { "is-week-mode": _ctx.selectionMode === "week" }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [
    vue$1x.createElementVNode("tbody", null, [
      vue$1x.createElementVNode("tr", null, [
        _ctx.showWeekNumber ? (vue$1x.openBlock(), vue$1x.createElementBlock("th", _hoisted_1$R, vue$1x.toDisplayString(_ctx.t("el.datepicker.week")), 1)) : vue$1x.createCommentVNode("v-if", true),
        (vue$1x.openBlock(true), vue$1x.createElementBlock(vue$1x.Fragment, null, vue$1x.renderList(_ctx.WEEKS, (week, key2) => {
          return vue$1x.openBlock(), vue$1x.createElementBlock("th", { key: key2 }, vue$1x.toDisplayString(_ctx.t("el.datepicker.weeks." + week)), 1);
        }), 128))
      ]),
      (vue$1x.openBlock(true), vue$1x.createElementBlock(vue$1x.Fragment, null, vue$1x.renderList(_ctx.rows, (row2, key2) => {
        return vue$1x.openBlock(), vue$1x.createElementBlock("tr", {
          key: key2,
          class: vue$1x.normalizeClass(["el-date-table__row", { current: _ctx.isWeekActive(row2[1]) }])
        }, [
          (vue$1x.openBlock(true), vue$1x.createElementBlock(vue$1x.Fragment, null, vue$1x.renderList(row2, (cell, key_) => {
            return vue$1x.openBlock(), vue$1x.createElementBlock("td", {
              key: key_,
              class: vue$1x.normalizeClass(_ctx.getCellClasses(cell))
            }, [
              vue$1x.createVNode(_component_el_date_picker_cell, { cell }, null, 8, ["cell"])
            ], 2);
          }), 128))
        ], 2);
      }), 128))
    ])
  ], 34);
}
basicDateTable_vue_vue_type_template_id_0572814e_lang.render = render$15;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var basicDateTable_vue_vue_type_script_lang$1 = basicDateTable_vue_vue_type_script_lang;
  var basicDateTable_vue_vue_type_template_id_0572814e_lang$1 = basicDateTable_vue_vue_type_template_id_0572814e_lang;
  basicDateTable_vue_vue_type_script_lang$1["default"].render = basicDateTable_vue_vue_type_template_id_0572814e_lang$1.render;
  basicDateTable_vue_vue_type_script_lang$1["default"].__file = "packages/components/date-picker/src/date-picker-com/basic-date-table.vue";
  exports["default"] = basicDateTable_vue_vue_type_script_lang$1["default"];
})(basicDateTable);
var basicMonthTable = {};
var basicMonthTable_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var dom2 = dom$8;
  var util2 = util$l;
  var dateUtils2 = dateUtils$1;
  var index2 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  const datesInMonth = (year, month, lang) => {
    const firstDay = dayjs__default["default"]().locale(lang).startOf("month").month(month).year(year);
    const numOfDays = firstDay.daysInMonth();
    return dateUtils2.rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
  };
  var script2 = vue2.defineComponent({
    props: {
      disabledDate: {
        type: Function
      },
      selectionMode: {
        type: String,
        default: "month"
      },
      minDate: {
        type: Object
      },
      maxDate: {
        type: Object
      },
      date: {
        type: Object
      },
      parsedValue: {
        type: Object
      },
      rangeState: {
        type: Object,
        default: () => ({
          endDate: null,
          selecting: false
        })
      }
    },
    emits: ["changerange", "pick", "select"],
    setup(props2, ctx) {
      const { t, lang } = index2.useLocale();
      const months = vue2.ref(props2.date.locale("en").localeData().monthsShort().map((_2) => _2.toLowerCase()));
      const tableRows = vue2.ref([[], [], []]);
      const lastRow = vue2.ref(null);
      const lastColumn = vue2.ref(null);
      const rows = vue2.computed(() => {
        var _a;
        const rows2 = tableRows.value;
        const now2 = dayjs__default["default"]().locale(lang.value).startOf("month");
        for (let i = 0; i < 3; i++) {
          const row2 = rows2[i];
          for (let j = 0; j < 4; j++) {
            let cell = row2[j];
            if (!cell) {
              cell = {
                row: i,
                column: j,
                type: "normal",
                inRange: false,
                start: false,
                end: false
              };
            }
            cell.type = "normal";
            const index3 = i * 4 + j;
            const calTime = props2.date.startOf("year").month(index3);
            const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate;
            cell.inRange = props2.minDate && calTime.isSameOrAfter(props2.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month") || props2.minDate && calTime.isSameOrBefore(props2.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month");
            if ((_a = props2.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
              cell.start = calEndDate && calTime.isSame(calEndDate, "month");
              cell.end = props2.minDate && calTime.isSame(props2.minDate, "month");
            } else {
              cell.start = props2.minDate && calTime.isSame(props2.minDate, "month");
              cell.end = calEndDate && calTime.isSame(calEndDate, "month");
            }
            const isToday = now2.isSame(calTime);
            if (isToday) {
              cell.type = "today";
            }
            cell.text = index3;
            const cellDate = calTime.toDate();
            cell.disabled = props2.disabledDate && props2.disabledDate(cellDate);
            row2[j] = cell;
          }
        }
        return rows2;
      });
      const getCellStyle = (cell) => {
        const style = {};
        const year = props2.date.year();
        const today = new Date();
        const month = cell.text;
        style.disabled = props2.disabledDate ? datesInMonth(year, month, lang.value).every(props2.disabledDate) : false;
        style.current = util2.coerceTruthyValueToArray(props2.parsedValue).findIndex((date4) => date4.year() === year && date4.month() === month) >= 0;
        style.today = today.getFullYear() === year && today.getMonth() === month;
        if (cell.inRange) {
          style["in-range"] = true;
          if (cell.start) {
            style["start-date"] = true;
          }
          if (cell.end) {
            style["end-date"] = true;
          }
        }
        return style;
      };
      const handleMouseMove = (event) => {
        if (!props2.rangeState.selecting)
          return;
        let target2 = event.target;
        if (target2.tagName === "A") {
          target2 = target2.parentNode.parentNode;
        }
        if (target2.tagName === "DIV") {
          target2 = target2.parentNode;
        }
        if (target2.tagName !== "TD")
          return;
        const row2 = target2.parentNode.rowIndex;
        const column = target2.cellIndex;
        if (rows.value[row2][column].disabled)
          return;
        if (row2 !== lastRow.value || column !== lastColumn.value) {
          lastRow.value = row2;
          lastColumn.value = column;
          ctx.emit("changerange", {
            selecting: true,
            endDate: props2.date.startOf("year").month(row2 * 4 + column)
          });
        }
      };
      const handleMonthTableClick = (event) => {
        let target2 = event.target;
        if (target2.tagName === "A") {
          target2 = target2.parentNode.parentNode;
        }
        if (target2.tagName === "DIV") {
          target2 = target2.parentNode;
        }
        if (target2.tagName !== "TD")
          return;
        if (dom2.hasClass(target2, "disabled"))
          return;
        const column = target2.cellIndex;
        const row2 = target2.parentNode.rowIndex;
        const month = row2 * 4 + column;
        const newDate = props2.date.startOf("year").month(month);
        if (props2.selectionMode === "range") {
          if (!props2.rangeState.selecting) {
            ctx.emit("pick", { minDate: newDate, maxDate: null });
            ctx.emit("select", true);
          } else {
            if (newDate >= props2.minDate) {
              ctx.emit("pick", { minDate: props2.minDate, maxDate: newDate });
            } else {
              ctx.emit("pick", { minDate: newDate, maxDate: props2.minDate });
            }
            ctx.emit("select", false);
          }
        } else {
          ctx.emit("pick", month);
        }
      };
      return {
        handleMouseMove,
        handleMonthTableClick,
        rows,
        getCellStyle,
        t,
        months
      };
    }
  });
  exports["default"] = script2;
})(basicMonthTable_vue_vue_type_script_lang);
var basicMonthTable_vue_vue_type_template_id_2f6fcbf2_lang = {};
Object.defineProperty(basicMonthTable_vue_vue_type_template_id_2f6fcbf2_lang, "__esModule", { value: true });
var vue$1w = require$$0$1;
const _hoisted_1$Q = { class: "cell" };
function render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1w.openBlock(), vue$1w.createElementBlock("table", {
    class: "el-month-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMonthTableClick && _ctx.handleMonthTableClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [
    vue$1w.createElementVNode("tbody", null, [
      (vue$1w.openBlock(true), vue$1w.createElementBlock(vue$1w.Fragment, null, vue$1w.renderList(_ctx.rows, (row2, key2) => {
        return vue$1w.openBlock(), vue$1w.createElementBlock("tr", { key: key2 }, [
          (vue$1w.openBlock(true), vue$1w.createElementBlock(vue$1w.Fragment, null, vue$1w.renderList(row2, (cell, key_) => {
            return vue$1w.openBlock(), vue$1w.createElementBlock("td", {
              key: key_,
              class: vue$1w.normalizeClass(_ctx.getCellStyle(cell))
            }, [
              vue$1w.createElementVNode("div", null, [
                vue$1w.createElementVNode("a", _hoisted_1$Q, vue$1w.toDisplayString(_ctx.t("el.datepicker.months." + _ctx.months[cell.text])), 1)
              ])
            ], 2);
          }), 128))
        ]);
      }), 128))
    ])
  ], 32);
}
basicMonthTable_vue_vue_type_template_id_2f6fcbf2_lang.render = render$14;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var basicMonthTable_vue_vue_type_script_lang$1 = basicMonthTable_vue_vue_type_script_lang;
  var basicMonthTable_vue_vue_type_template_id_2f6fcbf2_lang$1 = basicMonthTable_vue_vue_type_template_id_2f6fcbf2_lang;
  basicMonthTable_vue_vue_type_script_lang$1["default"].render = basicMonthTable_vue_vue_type_template_id_2f6fcbf2_lang$1.render;
  basicMonthTable_vue_vue_type_script_lang$1["default"].__file = "packages/components/date-picker/src/date-picker-com/basic-month-table.vue";
  exports["default"] = basicMonthTable_vue_vue_type_script_lang$1["default"];
})(basicMonthTable);
var basicYearTable = {};
var basicYearTable_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var dom2 = dom$8;
  var util2 = util$l;
  var dateUtils2 = dateUtils$1;
  var index2 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  const datesInYear = (year, lang) => {
    const firstDay = dayjs__default["default"](String(year)).locale(lang).startOf("year");
    const lastDay = firstDay.endOf("year");
    const numOfDays = lastDay.dayOfYear();
    return dateUtils2.rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
  };
  var script2 = vue2.defineComponent({
    props: {
      disabledDate: {
        type: Function
      },
      parsedValue: {
        type: Object
      },
      date: {
        type: Object
      }
    },
    emits: ["pick"],
    setup(props2, ctx) {
      const { lang } = index2.useLocale();
      const startYear = vue2.computed(() => {
        return Math.floor(props2.date.year() / 10) * 10;
      });
      const getCellStyle = (year) => {
        const style = {};
        const today = dayjs__default["default"]().locale(lang.value);
        style.disabled = props2.disabledDate ? datesInYear(year, lang.value).every(props2.disabledDate) : false;
        style.current = util2.coerceTruthyValueToArray(props2.parsedValue).findIndex((_2) => _2.year() === year) >= 0;
        style.today = today.year() === year;
        return style;
      };
      const handleYearTableClick = (event) => {
        const target2 = event.target;
        if (target2.tagName === "A") {
          if (dom2.hasClass(target2.parentNode, "disabled"))
            return;
          const year = target2.textContent || target2.innerText;
          ctx.emit("pick", Number(year));
        }
      };
      return {
        startYear,
        getCellStyle,
        handleYearTableClick
      };
    }
  });
  exports["default"] = script2;
})(basicYearTable_vue_vue_type_script_lang);
var basicYearTable_vue_vue_type_template_id_441df31d_lang = {};
Object.defineProperty(basicYearTable_vue_vue_type_template_id_441df31d_lang, "__esModule", { value: true });
var vue$1v = require$$0$1;
const _hoisted_1$P = { class: "cell" };
const _hoisted_2$C = { class: "cell" };
const _hoisted_3$w = { class: "cell" };
const _hoisted_4$o = { class: "cell" };
const _hoisted_5$k = { class: "cell" };
const _hoisted_6$e = { class: "cell" };
const _hoisted_7$a = { class: "cell" };
const _hoisted_8$9 = { class: "cell" };
const _hoisted_9$7 = { class: "cell" };
const _hoisted_10$7 = { class: "cell" };
const _hoisted_11$3 = /* @__PURE__ */ vue$1v.createElementVNode("td", null, null, -1);
const _hoisted_12$3 = /* @__PURE__ */ vue$1v.createElementVNode("td", null, null, -1);
function render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1v.openBlock(), vue$1v.createElementBlock("table", {
    class: "el-year-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleYearTableClick && _ctx.handleYearTableClick(...args))
  }, [
    vue$1v.createElementVNode("tbody", null, [
      vue$1v.createElementVNode("tr", null, [
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 0)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_1$P, vue$1v.toDisplayString(_ctx.startYear), 1)
        ], 2),
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 1)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_2$C, vue$1v.toDisplayString(_ctx.startYear + 1), 1)
        ], 2),
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 2)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_3$w, vue$1v.toDisplayString(_ctx.startYear + 2), 1)
        ], 2),
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 3)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_4$o, vue$1v.toDisplayString(_ctx.startYear + 3), 1)
        ], 2)
      ]),
      vue$1v.createElementVNode("tr", null, [
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 4)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_5$k, vue$1v.toDisplayString(_ctx.startYear + 4), 1)
        ], 2),
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 5)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_6$e, vue$1v.toDisplayString(_ctx.startYear + 5), 1)
        ], 2),
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 6)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_7$a, vue$1v.toDisplayString(_ctx.startYear + 6), 1)
        ], 2),
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 7)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_8$9, vue$1v.toDisplayString(_ctx.startYear + 7), 1)
        ], 2)
      ]),
      vue$1v.createElementVNode("tr", null, [
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 8)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_9$7, vue$1v.toDisplayString(_ctx.startYear + 8), 1)
        ], 2),
        vue$1v.createElementVNode("td", {
          class: vue$1v.normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 9)])
        }, [
          vue$1v.createElementVNode("a", _hoisted_10$7, vue$1v.toDisplayString(_ctx.startYear + 9), 1)
        ], 2),
        _hoisted_11$3,
        _hoisted_12$3
      ])
    ])
  ]);
}
basicYearTable_vue_vue_type_template_id_441df31d_lang.render = render$13;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var basicYearTable_vue_vue_type_script_lang$1 = basicYearTable_vue_vue_type_script_lang;
  var basicYearTable_vue_vue_type_template_id_441df31d_lang$1 = basicYearTable_vue_vue_type_template_id_441df31d_lang;
  basicYearTable_vue_vue_type_script_lang$1["default"].render = basicYearTable_vue_vue_type_template_id_441df31d_lang$1.render;
  basicYearTable_vue_vue_type_script_lang$1["default"].__file = "packages/components/date-picker/src/date-picker-com/basic-year-table.vue";
  exports["default"] = basicYearTable_vue_vue_type_script_lang$1["default"];
})(basicYearTable);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var index$110 = button$5;
  var index2 = input$2;
  var index$22 = icon$4;
  var aria2 = aria$5;
  var validators2 = validators$6;
  var iconsVue2 = require$$3;
  var basicDateTable_vue_vue_type_script_lang$1 = basicDateTable_vue_vue_type_script_lang;
  var panelTimePick_vue_vue_type_script_lang2 = panelTimePick_vue_vue_type_script_lang$1;
  var basicMonthTable_vue_vue_type_script_lang$1 = basicMonthTable_vue_vue_type_script_lang;
  var basicYearTable_vue_vue_type_script_lang$1 = basicYearTable_vue_vue_type_script_lang;
  var index$32 = clickOutside;
  var index$42 = useLocale$1;
  var dateUtils2 = dateUtils$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  const timeWithinRange = (_2, __, ___) => true;
  var script2 = vue2.defineComponent({
    components: {
      DateTable: basicDateTable_vue_vue_type_script_lang$1["default"],
      ElInput: index2.ElInput,
      ElButton: index$110.ElButton,
      ElIcon: index$22.ElIcon,
      TimePickPanel: panelTimePick_vue_vue_type_script_lang2["default"],
      MonthTable: basicMonthTable_vue_vue_type_script_lang$1["default"],
      YearTable: basicYearTable_vue_vue_type_script_lang$1["default"],
      DArrowLeft: iconsVue2.DArrowLeft,
      ArrowLeft: iconsVue2.ArrowLeft,
      DArrowRight: iconsVue2.DArrowRight,
      ArrowRight: iconsVue2.ArrowRight
    },
    directives: { clickoutside: index$32["default"] },
    props: {
      visible: {
        type: Boolean,
        default: false
      },
      parsedValue: {
        type: [Object, Array]
      },
      format: {
        type: String,
        default: ""
      },
      type: {
        type: String,
        required: true,
        validator: validators2.isValidDatePickType
      }
    },
    emits: ["pick", "set-picker-option"],
    setup(props2, ctx) {
      const { t, lang } = index$42.useLocale();
      const pickerBase = vue2.inject("EP_PICKER_BASE");
      const {
        shortcuts,
        disabledDate,
        cellClassName,
        defaultTime,
        defaultValue,
        arrowControl
      } = pickerBase.props;
      const innerDate = vue2.ref(dayjs__default["default"]().locale(lang.value));
      const defaultTimeD = vue2.computed(() => {
        return dayjs__default["default"](defaultTime).locale(lang.value);
      });
      const month = vue2.computed(() => {
        return innerDate.value.month();
      });
      const year = vue2.computed(() => {
        return innerDate.value.year();
      });
      const selectableRange = vue2.ref([]);
      const userInputDate = vue2.ref(null);
      const userInputTime = vue2.ref(null);
      const checkDateWithinRange = (date4) => {
        return selectableRange.value.length > 0 ? timeWithinRange(date4, selectableRange.value, props2.format || "HH:mm:ss") : true;
      };
      const formatEmit = (emitDayjs) => {
        if (defaultTime && !visibleTime.value) {
          return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
        }
        if (showTime.value)
          return emitDayjs.millisecond(0);
        return emitDayjs.startOf("day");
      };
      const emit = (value, ...args) => {
        if (!value) {
          ctx.emit("pick", value, ...args);
        } else if (Array.isArray(value)) {
          const dates = value.map(formatEmit);
          ctx.emit("pick", dates, ...args);
        } else {
          ctx.emit("pick", formatEmit(value), ...args);
        }
        userInputDate.value = null;
        userInputTime.value = null;
      };
      const handleDatePick = (value) => {
        if (selectionMode.value === "day") {
          let newDate = props2.parsedValue ? props2.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
          if (!checkDateWithinRange(newDate)) {
            newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
          }
          innerDate.value = newDate;
          emit(newDate, showTime.value);
        } else if (selectionMode.value === "week") {
          emit(value.date);
        } else if (selectionMode.value === "dates") {
          emit(value, true);
        }
      };
      const prevMonth_ = () => {
        innerDate.value = innerDate.value.subtract(1, "month");
      };
      const nextMonth_ = () => {
        innerDate.value = innerDate.value.add(1, "month");
      };
      const prevYear_ = () => {
        if (currentView.value === "year") {
          innerDate.value = innerDate.value.subtract(10, "year");
        } else {
          innerDate.value = innerDate.value.subtract(1, "year");
        }
      };
      const nextYear_ = () => {
        if (currentView.value === "year") {
          innerDate.value = innerDate.value.add(10, "year");
        } else {
          innerDate.value = innerDate.value.add(1, "year");
        }
      };
      const currentView = vue2.ref("date");
      const yearLabel = vue2.computed(() => {
        const yearTranslation = t("el.datepicker.year");
        if (currentView.value === "year") {
          const startYear = Math.floor(year.value / 10) * 10;
          if (yearTranslation) {
            return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
          }
          return `${startYear} - ${startYear + 9}`;
        }
        return `${year.value} ${yearTranslation}`;
      });
      const handleShortcutClick = (shortcut) => {
        const shortcutValue = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
        if (shortcutValue) {
          emit(dayjs__default["default"](shortcutValue).locale(lang.value));
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick(ctx);
        }
      };
      const selectionMode = vue2.computed(() => {
        if (["week", "month", "year", "dates"].includes(props2.type)) {
          return props2.type;
        }
        return "day";
      });
      vue2.watch(() => selectionMode.value, (val) => {
        if (["month", "year"].includes(val)) {
          currentView.value = val;
          return;
        }
        currentView.value = "date";
      }, { immediate: true });
      const hasShortcuts = vue2.computed(() => !!shortcuts.length);
      const handleMonthPick = (month2) => {
        innerDate.value = innerDate.value.startOf("month").month(month2);
        if (selectionMode.value === "month") {
          emit(innerDate.value);
        } else {
          currentView.value = "date";
        }
      };
      const handleYearPick = (year2) => {
        if (selectionMode.value === "year") {
          innerDate.value = innerDate.value.startOf("year").year(year2);
          emit(innerDate.value);
        } else {
          innerDate.value = innerDate.value.year(year2);
          currentView.value = "month";
        }
      };
      const showMonthPicker = () => {
        currentView.value = "month";
      };
      const showYearPicker = () => {
        currentView.value = "year";
      };
      const showTime = vue2.computed(() => props2.type === "datetime" || props2.type === "datetimerange");
      const footerVisible = vue2.computed(() => {
        return showTime.value || selectionMode.value === "dates";
      });
      const onConfirm = () => {
        if (selectionMode.value === "dates") {
          emit(props2.parsedValue);
        } else {
          let result3 = props2.parsedValue;
          if (!result3) {
            const defaultTimeD2 = dayjs__default["default"](defaultTime).locale(lang.value);
            const defaultValueD = getDefaultValue();
            result3 = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
          }
          innerDate.value = result3;
          emit(result3);
        }
      };
      const changeToNow = () => {
        const now2 = dayjs__default["default"]().locale(lang.value);
        const nowDate = now2.toDate();
        if ((!disabledDate || !disabledDate(nowDate)) && checkDateWithinRange(nowDate)) {
          innerDate.value = dayjs__default["default"]().locale(lang.value);
          emit(innerDate.value);
        }
      };
      const timeFormat = vue2.computed(() => {
        return dateUtils2.extractTimeFormat(props2.format);
      });
      const dateFormat = vue2.computed(() => {
        return dateUtils2.extractDateFormat(props2.format);
      });
      const visibleTime = vue2.computed(() => {
        if (userInputTime.value)
          return userInputTime.value;
        if (!props2.parsedValue && !defaultValue)
          return;
        return (props2.parsedValue || innerDate.value).format(timeFormat.value);
      });
      const visibleDate = vue2.computed(() => {
        if (userInputDate.value)
          return userInputDate.value;
        if (!props2.parsedValue && !defaultValue)
          return;
        return (props2.parsedValue || innerDate.value).format(dateFormat.value);
      });
      const timePickerVisible = vue2.ref(false);
      const onTimePickerInputFocus = () => {
        timePickerVisible.value = true;
      };
      const handleTimePickClose = () => {
        timePickerVisible.value = false;
      };
      const handleTimePick = (value, visible, first) => {
        const newDate = props2.parsedValue ? props2.parsedValue.hour(value.hour()).minute(value.minute()).second(value.second()) : value;
        innerDate.value = newDate;
        emit(innerDate.value, true);
        if (!first) {
          timePickerVisible.value = visible;
        }
      };
      const handleVisibleTimeChange = (value) => {
        const newDate = dayjs__default["default"](value, timeFormat.value).locale(lang.value);
        if (newDate.isValid() && checkDateWithinRange(newDate)) {
          innerDate.value = newDate.year(innerDate.value.year()).month(innerDate.value.month()).date(innerDate.value.date());
          userInputTime.value = null;
          timePickerVisible.value = false;
          emit(innerDate.value, true);
        }
      };
      const handleVisibleDateChange = (value) => {
        const newDate = dayjs__default["default"](value, dateFormat.value).locale(lang.value);
        if (newDate.isValid()) {
          if (disabledDate && disabledDate(newDate.toDate())) {
            return;
          }
          innerDate.value = newDate.hour(innerDate.value.hour()).minute(innerDate.value.minute()).second(innerDate.value.second());
          userInputDate.value = null;
          emit(innerDate.value, true);
        }
      };
      const isValidValue = (date4) => {
        return dayjs__default["default"].isDayjs(date4) && date4.isValid() && (disabledDate ? !disabledDate(date4.toDate()) : true);
      };
      const formatToString = (value) => {
        if (selectionMode.value === "dates") {
          return value.map((_2) => _2.format(props2.format));
        }
        return value.format(props2.format);
      };
      const parseUserInput = (value) => {
        return dayjs__default["default"](value, props2.format).locale(lang.value);
      };
      const getDefaultValue = () => {
        const parseDate = dayjs__default["default"](defaultValue).locale(lang.value);
        if (!defaultValue) {
          const defaultTimeDValue = defaultTimeD.value;
          return dayjs__default["default"]().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang.value);
        }
        return parseDate;
      };
      const handleKeydown = (event) => {
        const { code: code2, keyCode } = event;
        const list2 = [
          aria2.EVENT_CODE.up,
          aria2.EVENT_CODE.down,
          aria2.EVENT_CODE.left,
          aria2.EVENT_CODE.right
        ];
        if (props2.visible && !timePickerVisible.value) {
          if (list2.includes(code2)) {
            handleKeyControl(keyCode);
            event.stopPropagation();
            event.preventDefault();
          }
          if (code2 === aria2.EVENT_CODE.enter && userInputDate.value === null && userInputTime.value === null) {
            emit(innerDate, false);
          }
        }
      };
      const handleKeyControl = (keyCode) => {
        const mapping = {
          year: {
            38: -4,
            40: 4,
            37: -1,
            39: 1,
            offset: (date4, step) => date4.setFullYear(date4.getFullYear() + step)
          },
          month: {
            38: -4,
            40: 4,
            37: -1,
            39: 1,
            offset: (date4, step) => date4.setMonth(date4.getMonth() + step)
          },
          week: {
            38: -1,
            40: 1,
            37: -1,
            39: 1,
            offset: (date4, step) => date4.setDate(date4.getDate() + step * 7)
          },
          day: {
            38: -7,
            40: 7,
            37: -1,
            39: 1,
            offset: (date4, step) => date4.setDate(date4.getDate() + step)
          }
        };
        const newDate = innerDate.value.toDate();
        while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
          const map = mapping[selectionMode.value];
          map.offset(newDate, map[keyCode]);
          if (disabledDate && disabledDate(newDate)) {
            continue;
          }
          const result3 = dayjs__default["default"](newDate).locale(lang.value);
          innerDate.value = result3;
          ctx.emit("pick", result3, true);
          break;
        }
      };
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
      vue2.watch(() => props2.parsedValue, (val) => {
        if (val) {
          if (selectionMode.value === "dates")
            return;
          if (Array.isArray(val))
            return;
          innerDate.value = val;
        } else {
          innerDate.value = getDefaultValue();
        }
      }, { immediate: true });
      return {
        handleTimePick,
        handleTimePickClose,
        onTimePickerInputFocus,
        timePickerVisible,
        visibleTime,
        visibleDate,
        showTime,
        changeToNow,
        onConfirm,
        footerVisible,
        handleYearPick,
        showMonthPicker,
        showYearPicker,
        handleMonthPick,
        hasShortcuts,
        shortcuts,
        arrowControl,
        disabledDate,
        cellClassName,
        selectionMode,
        handleShortcutClick,
        prevYear_,
        nextYear_,
        prevMonth_,
        nextMonth_,
        innerDate,
        t,
        yearLabel,
        currentView,
        month,
        handleDatePick,
        handleVisibleTimeChange,
        handleVisibleDateChange,
        timeFormat,
        userInputTime,
        userInputDate
      };
    }
  });
  exports["default"] = script2;
})(panelDatePick_vue_vue_type_script_lang);
var panelDatePick_vue_vue_type_template_id_78e07aa7_lang = {};
Object.defineProperty(panelDatePick_vue_vue_type_template_id_78e07aa7_lang, "__esModule", { value: true });
var vue$1u = require$$0$1;
const _hoisted_1$O = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$B = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$v = ["onClick"];
const _hoisted_4$n = { class: "el-picker-panel__body" };
const _hoisted_5$j = {
  key: 0,
  class: "el-date-picker__time-header"
};
const _hoisted_6$d = { class: "el-date-picker__editor-wrap" };
const _hoisted_7$9 = { class: "el-date-picker__editor-wrap" };
const _hoisted_8$8 = ["aria-label"];
const _hoisted_9$6 = ["aria-label"];
const _hoisted_10$6 = ["aria-label"];
const _hoisted_11$2 = ["aria-label"];
const _hoisted_12$2 = { class: "el-picker-panel__content" };
const _hoisted_13$2 = { class: "el-picker-panel__footer" };
function render$12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = vue$1u.resolveComponent("el-input");
  const _component_time_pick_panel = vue$1u.resolveComponent("time-pick-panel");
  const _component_d_arrow_left = vue$1u.resolveComponent("d-arrow-left");
  const _component_el_icon = vue$1u.resolveComponent("el-icon");
  const _component_arrow_left = vue$1u.resolveComponent("arrow-left");
  const _component_d_arrow_right = vue$1u.resolveComponent("d-arrow-right");
  const _component_arrow_right = vue$1u.resolveComponent("arrow-right");
  const _component_date_table = vue$1u.resolveComponent("date-table");
  const _component_year_table = vue$1u.resolveComponent("year-table");
  const _component_month_table = vue$1u.resolveComponent("month-table");
  const _component_el_button = vue$1u.resolveComponent("el-button");
  const _directive_clickoutside = vue$1u.resolveDirective("clickoutside");
  return vue$1u.openBlock(), vue$1u.createElementBlock("div", {
    class: vue$1u.normalizeClass(["el-picker-panel el-date-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
        "has-time": _ctx.showTime
      }
    ]])
  }, [
    vue$1u.createElementVNode("div", _hoisted_1$O, [
      vue$1u.renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (vue$1u.openBlock(), vue$1u.createElementBlock("div", _hoisted_2$B, [
        (vue$1u.openBlock(true), vue$1u.createElementBlock(vue$1u.Fragment, null, vue$1u.renderList(_ctx.shortcuts, (shortcut, key2) => {
          return vue$1u.openBlock(), vue$1u.createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, vue$1u.toDisplayString(shortcut.text), 9, _hoisted_3$v);
        }), 128))
      ])) : vue$1u.createCommentVNode("v-if", true),
      vue$1u.createElementVNode("div", _hoisted_4$n, [
        _ctx.showTime ? (vue$1u.openBlock(), vue$1u.createElementBlock("div", _hoisted_5$j, [
          vue$1u.createElementVNode("span", _hoisted_6$d, [
            vue$1u.createVNode(_component_el_input, {
              placeholder: _ctx.t("el.datepicker.selectDate"),
              "model-value": _ctx.visibleDate,
              size: "small",
              onInput: _cache[0] || (_cache[0] = (val) => _ctx.userInputDate = val),
              onChange: _ctx.handleVisibleDateChange
            }, null, 8, ["placeholder", "model-value", "onChange"])
          ]),
          vue$1u.withDirectives(vue$1u.createElementVNode("span", _hoisted_7$9, [
            vue$1u.createVNode(_component_el_input, {
              placeholder: _ctx.t("el.datepicker.selectTime"),
              "model-value": _ctx.visibleTime,
              size: "small",
              onFocus: _ctx.onTimePickerInputFocus,
              onInput: _cache[1] || (_cache[1] = (val) => _ctx.userInputTime = val),
              onChange: _ctx.handleVisibleTimeChange
            }, null, 8, ["placeholder", "model-value", "onFocus", "onChange"]),
            vue$1u.createVNode(_component_time_pick_panel, {
              visible: _ctx.timePickerVisible,
              format: _ctx.timeFormat,
              "time-arrow-control": _ctx.arrowControl,
              "parsed-value": _ctx.innerDate,
              onPick: _ctx.handleTimePick
            }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
          ], 512), [
            [_directive_clickoutside, _ctx.handleTimePickClose]
          ])
        ])) : vue$1u.createCommentVNode("v-if", true),
        vue$1u.withDirectives(vue$1u.createElementVNode("div", {
          class: vue$1u.normalizeClass(["el-date-picker__header", {
            "el-date-picker__header--bordered": _ctx.currentView === "year" || _ctx.currentView === "month"
          }])
        }, [
          vue$1u.createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.prevYear`),
            class: "el-picker-panel__icon-btn el-date-picker__prev-btn d-arrow-left",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.prevYear_ && _ctx.prevYear_(...args))
          }, [
            vue$1u.createVNode(_component_el_icon, null, {
              default: vue$1u.withCtx(() => [
                vue$1u.createVNode(_component_d_arrow_left)
              ]),
              _: 1
            })
          ], 8, _hoisted_8$8),
          vue$1u.withDirectives(vue$1u.createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.prevMonth`),
            class: "el-picker-panel__icon-btn el-date-picker__prev-btn arrow-left",
            onClick: _cache[3] || (_cache[3] = (...args) => _ctx.prevMonth_ && _ctx.prevMonth_(...args))
          }, [
            vue$1u.createVNode(_component_el_icon, null, {
              default: vue$1u.withCtx(() => [
                vue$1u.createVNode(_component_arrow_left)
              ]),
              _: 1
            })
          ], 8, _hoisted_9$6), [
            [vue$1u.vShow, _ctx.currentView === "date"]
          ]),
          vue$1u.createElementVNode("span", {
            role: "button",
            class: "el-date-picker__header-label",
            onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showYearPicker && _ctx.showYearPicker(...args))
          }, vue$1u.toDisplayString(_ctx.yearLabel), 1),
          vue$1u.withDirectives(vue$1u.createElementVNode("span", {
            role: "button",
            class: vue$1u.normalizeClass(["el-date-picker__header-label", { active: _ctx.currentView === "month" }]),
            onClick: _cache[5] || (_cache[5] = (...args) => _ctx.showMonthPicker && _ctx.showMonthPicker(...args))
          }, vue$1u.toDisplayString(_ctx.t(`el.datepicker.month${_ctx.month + 1}`)), 3), [
            [vue$1u.vShow, _ctx.currentView === "date"]
          ]),
          vue$1u.createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.nextYear`),
            class: "el-picker-panel__icon-btn el-date-picker__next-btn d-arrow-right",
            onClick: _cache[6] || (_cache[6] = (...args) => _ctx.nextYear_ && _ctx.nextYear_(...args))
          }, [
            vue$1u.createVNode(_component_el_icon, null, {
              default: vue$1u.withCtx(() => [
                vue$1u.createVNode(_component_d_arrow_right)
              ]),
              _: 1
            })
          ], 8, _hoisted_10$6),
          vue$1u.withDirectives(vue$1u.createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.nextMonth`),
            class: "el-picker-panel__icon-btn el-date-picker__next-btn arrow-right",
            onClick: _cache[7] || (_cache[7] = (...args) => _ctx.nextMonth_ && _ctx.nextMonth_(...args))
          }, [
            vue$1u.createVNode(_component_el_icon, null, {
              default: vue$1u.withCtx(() => [
                vue$1u.createVNode(_component_arrow_right)
              ]),
              _: 1
            })
          ], 8, _hoisted_11$2), [
            [vue$1u.vShow, _ctx.currentView === "date"]
          ])
        ], 2), [
          [vue$1u.vShow, _ctx.currentView !== "time"]
        ]),
        vue$1u.createElementVNode("div", _hoisted_12$2, [
          _ctx.currentView === "date" ? (vue$1u.openBlock(), vue$1u.createBlock(_component_date_table, {
            key: 0,
            "selection-mode": _ctx.selectionMode,
            date: _ctx.innerDate,
            "parsed-value": _ctx.parsedValue,
            "disabled-date": _ctx.disabledDate,
            onPick: _ctx.handleDatePick
          }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "onPick"])) : vue$1u.createCommentVNode("v-if", true),
          _ctx.currentView === "year" ? (vue$1u.openBlock(), vue$1u.createBlock(_component_year_table, {
            key: 1,
            date: _ctx.innerDate,
            "disabled-date": _ctx.disabledDate,
            "parsed-value": _ctx.parsedValue,
            onPick: _ctx.handleYearPick
          }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : vue$1u.createCommentVNode("v-if", true),
          _ctx.currentView === "month" ? (vue$1u.openBlock(), vue$1u.createBlock(_component_month_table, {
            key: 2,
            date: _ctx.innerDate,
            "parsed-value": _ctx.parsedValue,
            "disabled-date": _ctx.disabledDate,
            onPick: _ctx.handleMonthPick
          }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : vue$1u.createCommentVNode("v-if", true)
        ])
      ])
    ]),
    vue$1u.withDirectives(vue$1u.createElementVNode("div", _hoisted_13$2, [
      vue$1u.withDirectives(vue$1u.createVNode(_component_el_button, {
        size: "mini",
        type: "text",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.changeToNow
      }, {
        default: vue$1u.withCtx(() => [
          vue$1u.createTextVNode(vue$1u.toDisplayString(_ctx.t("el.datepicker.now")), 1)
        ]),
        _: 1
      }, 8, ["onClick"]), [
        [vue$1u.vShow, _ctx.selectionMode !== "dates"]
      ]),
      vue$1u.createVNode(_component_el_button, {
        plain: "",
        size: "mini",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.onConfirm
      }, {
        default: vue$1u.withCtx(() => [
          vue$1u.createTextVNode(vue$1u.toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])
    ], 512), [
      [vue$1u.vShow, _ctx.footerVisible && _ctx.currentView === "date"]
    ])
  ], 2);
}
panelDatePick_vue_vue_type_template_id_78e07aa7_lang.render = render$12;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var panelDatePick_vue_vue_type_script_lang$1 = panelDatePick_vue_vue_type_script_lang;
  var panelDatePick_vue_vue_type_template_id_78e07aa7_lang$1 = panelDatePick_vue_vue_type_template_id_78e07aa7_lang;
  panelDatePick_vue_vue_type_script_lang$1["default"].render = panelDatePick_vue_vue_type_template_id_78e07aa7_lang$1.render;
  panelDatePick_vue_vue_type_script_lang$1["default"].__file = "packages/components/date-picker/src/date-picker-com/panel-date-pick.vue";
  exports["default"] = panelDatePick_vue_vue_type_script_lang$1["default"];
})(panelDatePick);
var panelDateRange = {};
var panelDateRange_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var index$22 = button$5;
  var index$110 = input$2;
  var index$32 = icon$4;
  var validators2 = validators$6;
  var iconsVue2 = require$$3;
  var index2 = clickOutside;
  var panelTimePick_vue_vue_type_script_lang2 = panelTimePick_vue_vue_type_script_lang$1;
  var basicDateTable_vue_vue_type_script_lang$1 = basicDateTable_vue_vue_type_script_lang;
  var index$42 = useLocale$1;
  var dateUtils2 = dateUtils$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var script2 = vue2.defineComponent({
    directives: { clickoutside: index2["default"] },
    components: {
      TimePickPanel: panelTimePick_vue_vue_type_script_lang2["default"],
      DateTable: basicDateTable_vue_vue_type_script_lang$1["default"],
      ElInput: index$110.ElInput,
      ElButton: index$22.ElButton,
      ElIcon: index$32.ElIcon,
      DArrowLeft: iconsVue2.DArrowLeft,
      ArrowLeft: iconsVue2.ArrowLeft,
      DArrowRight: iconsVue2.DArrowRight,
      ArrowRight: iconsVue2.ArrowRight
    },
    props: {
      unlinkPanels: Boolean,
      parsedValue: {
        type: Array
      },
      type: {
        type: String,
        required: true,
        validator: validators2.isValidDatePickType
      }
    },
    emits: ["pick", "set-picker-option", "calendar-change"],
    setup(props2, ctx) {
      const { t, lang } = index$42.useLocale();
      const leftDate = vue2.ref(dayjs__default["default"]().locale(lang.value));
      const rightDate = vue2.ref(dayjs__default["default"]().locale(lang.value).add(1, "month"));
      const minDate = vue2.ref(null);
      const maxDate = vue2.ref(null);
      const dateUserInput = vue2.ref({
        min: null,
        max: null
      });
      const timeUserInput = vue2.ref({
        min: null,
        max: null
      });
      const leftLabel = vue2.computed(() => {
        return `${leftDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
      });
      const rightLabel = vue2.computed(() => {
        return `${rightDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
      });
      const leftYear = vue2.computed(() => {
        return leftDate.value.year();
      });
      const leftMonth = vue2.computed(() => {
        return leftDate.value.month();
      });
      const rightYear = vue2.computed(() => {
        return rightDate.value.year();
      });
      const rightMonth = vue2.computed(() => {
        return rightDate.value.month();
      });
      const hasShortcuts = vue2.computed(() => !!shortcuts.length);
      const minVisibleDate = vue2.computed(() => {
        if (dateUserInput.value.min !== null)
          return dateUserInput.value.min;
        if (minDate.value)
          return minDate.value.format(dateFormat.value);
        return "";
      });
      const maxVisibleDate = vue2.computed(() => {
        if (dateUserInput.value.max !== null)
          return dateUserInput.value.max;
        if (maxDate.value || minDate.value)
          return (maxDate.value || minDate.value).format(dateFormat.value);
        return "";
      });
      const minVisibleTime = vue2.computed(() => {
        if (timeUserInput.value.min !== null)
          return timeUserInput.value.min;
        if (minDate.value)
          return minDate.value.format(timeFormat.value);
        return "";
      });
      const maxVisibleTime = vue2.computed(() => {
        if (timeUserInput.value.max !== null)
          return timeUserInput.value.max;
        if (maxDate.value || minDate.value)
          return (maxDate.value || minDate.value).format(timeFormat.value);
        return "";
      });
      const timeFormat = vue2.computed(() => {
        return dateUtils2.extractTimeFormat(format2);
      });
      const dateFormat = vue2.computed(() => {
        return dateUtils2.extractDateFormat(format2);
      });
      const leftPrevYear = () => {
        leftDate.value = leftDate.value.subtract(1, "year");
        if (!props2.unlinkPanels) {
          rightDate.value = leftDate.value.add(1, "month");
        }
      };
      const leftPrevMonth = () => {
        leftDate.value = leftDate.value.subtract(1, "month");
        if (!props2.unlinkPanels) {
          rightDate.value = leftDate.value.add(1, "month");
        }
      };
      const rightNextYear = () => {
        if (!props2.unlinkPanels) {
          leftDate.value = leftDate.value.add(1, "year");
          rightDate.value = leftDate.value.add(1, "month");
        } else {
          rightDate.value = rightDate.value.add(1, "year");
        }
      };
      const rightNextMonth = () => {
        if (!props2.unlinkPanels) {
          leftDate.value = leftDate.value.add(1, "month");
          rightDate.value = leftDate.value.add(1, "month");
        } else {
          rightDate.value = rightDate.value.add(1, "month");
        }
      };
      const leftNextYear = () => {
        leftDate.value = leftDate.value.add(1, "year");
      };
      const leftNextMonth = () => {
        leftDate.value = leftDate.value.add(1, "month");
      };
      const rightPrevYear = () => {
        rightDate.value = rightDate.value.subtract(1, "year");
      };
      const rightPrevMonth = () => {
        rightDate.value = rightDate.value.subtract(1, "month");
      };
      const enableMonthArrow = vue2.computed(() => {
        const nextMonth = (leftMonth.value + 1) % 12;
        const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
        return props2.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
      });
      const enableYearArrow = vue2.computed(() => {
        return props2.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
      });
      const isValidValue = (value) => {
        return Array.isArray(value) && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
      };
      const rangeState = vue2.ref({
        endDate: null,
        selecting: false
      });
      const btnDisabled = vue2.computed(() => {
        return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidValue([minDate.value, maxDate.value]));
      });
      const handleChangeRange = (val) => {
        rangeState.value = val;
      };
      const onSelect = (selecting) => {
        rangeState.value.selecting = selecting;
        if (!selecting) {
          rangeState.value.endDate = null;
        }
      };
      const showTime = vue2.computed(() => props2.type === "datetime" || props2.type === "datetimerange");
      const handleConfirm = (visible = false) => {
        if (isValidValue([minDate.value, maxDate.value])) {
          ctx.emit("pick", [minDate.value, maxDate.value], visible);
        }
      };
      const formatEmit = (emitDayjs, index3) => {
        if (!emitDayjs)
          return;
        if (defaultTime) {
          const defaultTimeD = dayjs__default["default"](defaultTime[index3] || defaultTime).locale(lang.value);
          return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
        }
        return emitDayjs;
      };
      const handleRangePick = (val, close2 = true) => {
        const min_ = val.minDate;
        const max_ = val.maxDate;
        const minDate_ = formatEmit(min_, 0);
        const maxDate_ = formatEmit(max_, 1);
        if (maxDate.value === maxDate_ && minDate.value === minDate_) {
          return;
        }
        ctx.emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
        maxDate.value = maxDate_;
        minDate.value = minDate_;
        if (!close2 || showTime.value)
          return;
        handleConfirm();
      };
      const handleShortcutClick = (shortcut) => {
        const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
        if (shortcutValues) {
          ctx.emit("pick", [
            dayjs__default["default"](shortcutValues[0]).locale(lang.value),
            dayjs__default["default"](shortcutValues[1]).locale(lang.value)
          ]);
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick(ctx);
        }
      };
      const minTimePickerVisible = vue2.ref(false);
      const maxTimePickerVisible = vue2.ref(false);
      const handleMinTimeClose = () => {
        minTimePickerVisible.value = false;
      };
      const handleMaxTimeClose = () => {
        maxTimePickerVisible.value = false;
      };
      const handleDateInput = (value, type4) => {
        dateUserInput.value[type4] = value;
        const parsedValueD = dayjs__default["default"](value, dateFormat.value).locale(lang.value);
        if (parsedValueD.isValid()) {
          if (disabledDate && disabledDate(parsedValueD.toDate())) {
            return;
          }
          if (type4 === "min") {
            leftDate.value = parsedValueD;
            minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
            if (!props2.unlinkPanels) {
              rightDate.value = parsedValueD.add(1, "month");
              maxDate.value = minDate.value.add(1, "month");
            }
          } else {
            rightDate.value = parsedValueD;
            maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
            if (!props2.unlinkPanels) {
              leftDate.value = parsedValueD.subtract(1, "month");
              minDate.value = maxDate.value.subtract(1, "month");
            }
          }
        }
      };
      const handleDateChange = (_2, type4) => {
        dateUserInput.value[type4] = null;
      };
      const handleTimeInput = (value, type4) => {
        timeUserInput.value[type4] = value;
        const parsedValueD = dayjs__default["default"](value, timeFormat.value).locale(lang.value);
        if (parsedValueD.isValid()) {
          if (type4 === "min") {
            minTimePickerVisible.value = true;
            minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
            if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
              maxDate.value = minDate.value;
            }
          } else {
            maxTimePickerVisible.value = true;
            maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
            rightDate.value = maxDate.value;
            if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
              minDate.value = maxDate.value;
            }
          }
        }
      };
      const handleTimeChange = (value, type4) => {
        timeUserInput.value[type4] = null;
        if (type4 === "min") {
          leftDate.value = minDate.value;
          minTimePickerVisible.value = false;
        } else {
          rightDate.value = maxDate.value;
          maxTimePickerVisible.value = false;
        }
      };
      const handleMinTimePick = (value, visible, first) => {
        if (timeUserInput.value.min)
          return;
        if (value) {
          leftDate.value = value;
          minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
        }
        if (!first) {
          minTimePickerVisible.value = visible;
        }
        if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
          maxDate.value = minDate.value;
          rightDate.value = value;
        }
      };
      const handleMaxTimePick = (value, visible, first) => {
        if (timeUserInput.value.max)
          return;
        if (value) {
          rightDate.value = value;
          maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
        }
        if (!first) {
          maxTimePickerVisible.value = visible;
        }
        if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
          minDate.value = maxDate.value;
        }
      };
      const handleClear = () => {
        leftDate.value = getDefaultValue()[0];
        rightDate.value = leftDate.value.add(1, "month");
        ctx.emit("pick", null);
      };
      const formatToString = (value) => {
        return Array.isArray(value) ? value.map((_2) => _2.format(format2)) : value.format(format2);
      };
      const parseUserInput = (value) => {
        return Array.isArray(value) ? value.map((_2) => dayjs__default["default"](_2, format2).locale(lang.value)) : dayjs__default["default"](value, format2).locale(lang.value);
      };
      const getDefaultValue = () => {
        let start2;
        if (Array.isArray(defaultValue)) {
          const left2 = dayjs__default["default"](defaultValue[0]);
          let right2 = dayjs__default["default"](defaultValue[1]);
          if (!props2.unlinkPanels) {
            right2 = left2.add(1, "month");
          }
          return [left2, right2];
        } else if (defaultValue) {
          start2 = dayjs__default["default"](defaultValue);
        } else {
          start2 = dayjs__default["default"]();
        }
        start2 = start2.locale(lang.value);
        return [start2, start2.add(1, "month")];
      };
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["handleClear", handleClear]);
      const pickerBase = vue2.inject("EP_PICKER_BASE");
      const {
        shortcuts,
        disabledDate,
        cellClassName,
        format: format2,
        defaultTime,
        defaultValue,
        arrowControl,
        clearable
      } = pickerBase.props;
      vue2.watch(() => props2.parsedValue, (newVal) => {
        if (newVal && newVal.length === 2) {
          minDate.value = newVal[0];
          maxDate.value = newVal[1];
          leftDate.value = minDate.value;
          if (props2.unlinkPanels && maxDate.value) {
            const minDateYear = minDate.value.year();
            const minDateMonth = minDate.value.month();
            const maxDateYear = maxDate.value.year();
            const maxDateMonth = maxDate.value.month();
            rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate.value.add(1, "month") : maxDate.value;
          } else {
            rightDate.value = leftDate.value.add(1, "month");
            if (maxDate.value) {
              rightDate.value = rightDate.value.hour(maxDate.value.hour()).minute(maxDate.value.minute()).second(maxDate.value.second());
            }
          }
        } else {
          const defaultArr = getDefaultValue();
          minDate.value = null;
          maxDate.value = null;
          leftDate.value = defaultArr[0];
          rightDate.value = defaultArr[1];
        }
      }, { immediate: true });
      return {
        shortcuts,
        disabledDate,
        cellClassName,
        minTimePickerVisible,
        maxTimePickerVisible,
        handleMinTimeClose,
        handleMaxTimeClose,
        handleShortcutClick,
        rangeState,
        minDate,
        maxDate,
        handleRangePick,
        onSelect,
        handleChangeRange,
        btnDisabled,
        enableYearArrow,
        enableMonthArrow,
        rightPrevMonth,
        rightPrevYear,
        rightNextMonth,
        rightNextYear,
        leftPrevMonth,
        leftPrevYear,
        leftNextMonth,
        leftNextYear,
        hasShortcuts,
        leftLabel,
        rightLabel,
        leftDate,
        rightDate,
        showTime,
        t,
        minVisibleDate,
        maxVisibleDate,
        minVisibleTime,
        maxVisibleTime,
        arrowControl,
        handleDateInput,
        handleDateChange,
        handleTimeInput,
        handleTimeChange,
        handleMinTimePick,
        handleMaxTimePick,
        handleClear,
        handleConfirm,
        timeFormat,
        clearable
      };
    }
  });
  exports["default"] = script2;
})(panelDateRange_vue_vue_type_script_lang);
var panelDateRange_vue_vue_type_template_id_62b45ab2_lang = {};
Object.defineProperty(panelDateRange_vue_vue_type_template_id_62b45ab2_lang, "__esModule", { value: true });
var vue$1t = require$$0$1;
const _hoisted_1$N = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$A = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$u = ["onClick"];
const _hoisted_4$m = { class: "el-picker-panel__body" };
const _hoisted_5$i = {
  key: 0,
  class: "el-date-range-picker__time-header"
};
const _hoisted_6$c = { class: "el-date-range-picker__editors-wrap" };
const _hoisted_7$8 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_8$7 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_9$5 = { class: "el-date-range-picker__editors-wrap is-right" };
const _hoisted_10$5 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_11$1 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_12$1 = { class: "el-picker-panel__content el-date-range-picker__content is-left" };
const _hoisted_13$1 = { class: "el-date-range-picker__header" };
const _hoisted_14$1 = ["disabled"];
const _hoisted_15$1 = ["disabled"];
const _hoisted_16$1 = { class: "el-picker-panel__content el-date-range-picker__content is-right" };
const _hoisted_17$1 = { class: "el-date-range-picker__header" };
const _hoisted_18$1 = ["disabled"];
const _hoisted_19$1 = ["disabled"];
const _hoisted_20$1 = {
  key: 0,
  class: "el-picker-panel__footer"
};
function render$11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = vue$1t.resolveComponent("el-input");
  const _component_time_pick_panel = vue$1t.resolveComponent("time-pick-panel");
  const _component_arrow_right = vue$1t.resolveComponent("arrow-right");
  const _component_el_icon = vue$1t.resolveComponent("el-icon");
  const _component_d_arrow_left = vue$1t.resolveComponent("d-arrow-left");
  const _component_arrow_left = vue$1t.resolveComponent("arrow-left");
  const _component_d_arrow_right = vue$1t.resolveComponent("d-arrow-right");
  const _component_date_table = vue$1t.resolveComponent("date-table");
  const _component_el_button = vue$1t.resolveComponent("el-button");
  const _directive_clickoutside = vue$1t.resolveDirective("clickoutside");
  return vue$1t.openBlock(), vue$1t.createElementBlock("div", {
    class: vue$1t.normalizeClass(["el-picker-panel el-date-range-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
        "has-time": _ctx.showTime
      }
    ]])
  }, [
    vue$1t.createElementVNode("div", _hoisted_1$N, [
      vue$1t.renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (vue$1t.openBlock(), vue$1t.createElementBlock("div", _hoisted_2$A, [
        (vue$1t.openBlock(true), vue$1t.createElementBlock(vue$1t.Fragment, null, vue$1t.renderList(_ctx.shortcuts, (shortcut, key2) => {
          return vue$1t.openBlock(), vue$1t.createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, vue$1t.toDisplayString(shortcut.text), 9, _hoisted_3$u);
        }), 128))
      ])) : vue$1t.createCommentVNode("v-if", true),
      vue$1t.createElementVNode("div", _hoisted_4$m, [
        _ctx.showTime ? (vue$1t.openBlock(), vue$1t.createElementBlock("div", _hoisted_5$i, [
          vue$1t.createElementVNode("span", _hoisted_6$c, [
            vue$1t.createElementVNode("span", _hoisted_7$8, [
              vue$1t.createVNode(_component_el_input, {
                size: "small",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.startDate"),
                class: "el-date-range-picker__editor",
                "model-value": _ctx.minVisibleDate,
                onInput: _cache[0] || (_cache[0] = (val) => _ctx.handleDateInput(val, "min")),
                onChange: _cache[1] || (_cache[1] = (val) => _ctx.handleDateChange(val, "min"))
              }, null, 8, ["disabled", "placeholder", "model-value"])
            ]),
            vue$1t.withDirectives(vue$1t.createElementVNode("span", _hoisted_8$7, [
              vue$1t.createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.startTime"),
                "model-value": _ctx.minVisibleTime,
                onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.minTimePickerVisible = true),
                onInput: _cache[3] || (_cache[3] = (val) => _ctx.handleTimeInput(val, "min")),
                onChange: _cache[4] || (_cache[4] = (val) => _ctx.handleTimeChange(val, "min"))
              }, null, 8, ["disabled", "placeholder", "model-value"]),
              vue$1t.createVNode(_component_time_pick_panel, {
                visible: _ctx.minTimePickerVisible,
                format: _ctx.timeFormat,
                "datetime-role": "start",
                "time-arrow-control": _ctx.arrowControl,
                "parsed-value": _ctx.leftDate,
                onPick: _ctx.handleMinTimePick
              }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
            ], 512), [
              [_directive_clickoutside, _ctx.handleMinTimeClose]
            ])
          ]),
          vue$1t.createElementVNode("span", null, [
            vue$1t.createVNode(_component_el_icon, null, {
              default: vue$1t.withCtx(() => [
                vue$1t.createVNode(_component_arrow_right)
              ]),
              _: 1
            })
          ]),
          vue$1t.createElementVNode("span", _hoisted_9$5, [
            vue$1t.createElementVNode("span", _hoisted_10$5, [
              vue$1t.createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.endDate"),
                "model-value": _ctx.maxVisibleDate,
                readonly: !_ctx.minDate,
                onInput: _cache[5] || (_cache[5] = (val) => _ctx.handleDateInput(val, "max")),
                onChange: _cache[6] || (_cache[6] = (val) => _ctx.handleDateChange(val, "max"))
              }, null, 8, ["disabled", "placeholder", "model-value", "readonly"])
            ]),
            vue$1t.withDirectives(vue$1t.createElementVNode("span", _hoisted_11$1, [
              vue$1t.createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.endTime"),
                "model-value": _ctx.maxVisibleTime,
                readonly: !_ctx.minDate,
                onFocus: _cache[7] || (_cache[7] = ($event) => _ctx.minDate && (_ctx.maxTimePickerVisible = true)),
                onInput: _cache[8] || (_cache[8] = (val) => _ctx.handleTimeInput(val, "max")),
                onChange: _cache[9] || (_cache[9] = (val) => _ctx.handleTimeChange(val, "max"))
              }, null, 8, ["disabled", "placeholder", "model-value", "readonly"]),
              vue$1t.createVNode(_component_time_pick_panel, {
                "datetime-role": "end",
                visible: _ctx.maxTimePickerVisible,
                format: _ctx.timeFormat,
                "time-arrow-control": _ctx.arrowControl,
                "parsed-value": _ctx.rightDate,
                onPick: _ctx.handleMaxTimePick
              }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
            ], 512), [
              [_directive_clickoutside, _ctx.handleMaxTimeClose]
            ])
          ])
        ])) : vue$1t.createCommentVNode("v-if", true),
        vue$1t.createElementVNode("div", _hoisted_12$1, [
          vue$1t.createElementVNode("div", _hoisted_13$1, [
            vue$1t.createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn d-arrow-left",
              onClick: _cache[10] || (_cache[10] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
            }, [
              vue$1t.createVNode(_component_el_icon, null, {
                default: vue$1t.withCtx(() => [
                  vue$1t.createVNode(_component_d_arrow_left)
                ]),
                _: 1
              })
            ]),
            vue$1t.createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn arrow-left",
              onClick: _cache[11] || (_cache[11] = (...args) => _ctx.leftPrevMonth && _ctx.leftPrevMonth(...args))
            }, [
              vue$1t.createVNode(_component_el_icon, null, {
                default: vue$1t.withCtx(() => [
                  vue$1t.createVNode(_component_arrow_left)
                ]),
                _: 1
              })
            ]),
            _ctx.unlinkPanels ? (vue$1t.openBlock(), vue$1t.createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: vue$1t.normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn d-arrow-right"]),
              onClick: _cache[12] || (_cache[12] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
            }, [
              vue$1t.createVNode(_component_el_icon, null, {
                default: vue$1t.withCtx(() => [
                  vue$1t.createVNode(_component_d_arrow_right)
                ]),
                _: 1
              })
            ], 10, _hoisted_14$1)) : vue$1t.createCommentVNode("v-if", true),
            _ctx.unlinkPanels ? (vue$1t.openBlock(), vue$1t.createElementBlock("button", {
              key: 1,
              type: "button",
              disabled: !_ctx.enableMonthArrow,
              class: vue$1t.normalizeClass([{ "is-disabled": !_ctx.enableMonthArrow }, "el-picker-panel__icon-btn arrow-right"]),
              onClick: _cache[13] || (_cache[13] = (...args) => _ctx.leftNextMonth && _ctx.leftNextMonth(...args))
            }, [
              vue$1t.createVNode(_component_el_icon, null, {
                default: vue$1t.withCtx(() => [
                  vue$1t.createVNode(_component_arrow_right)
                ]),
                _: 1
              })
            ], 10, _hoisted_15$1)) : vue$1t.createCommentVNode("v-if", true),
            vue$1t.createElementVNode("div", null, vue$1t.toDisplayString(_ctx.leftLabel), 1)
          ]),
          vue$1t.createVNode(_component_date_table, {
            "selection-mode": "range",
            date: _ctx.leftDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            "cell-class-name": _ctx.cellClassName,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])
        ]),
        vue$1t.createElementVNode("div", _hoisted_16$1, [
          vue$1t.createElementVNode("div", _hoisted_17$1, [
            _ctx.unlinkPanels ? (vue$1t.openBlock(), vue$1t.createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: vue$1t.normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn d-arrow-left"]),
              onClick: _cache[14] || (_cache[14] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
            }, [
              vue$1t.createVNode(_component_el_icon, null, {
                default: vue$1t.withCtx(() => [
                  vue$1t.createVNode(_component_d_arrow_left)
                ]),
                _: 1
              })
            ], 10, _hoisted_18$1)) : vue$1t.createCommentVNode("v-if", true),
            _ctx.unlinkPanels ? (vue$1t.openBlock(), vue$1t.createElementBlock("button", {
              key: 1,
              type: "button",
              disabled: !_ctx.enableMonthArrow,
              class: vue$1t.normalizeClass([{ "is-disabled": !_ctx.enableMonthArrow }, "el-picker-panel__icon-btn arrow-left"]),
              onClick: _cache[15] || (_cache[15] = (...args) => _ctx.rightPrevMonth && _ctx.rightPrevMonth(...args))
            }, [
              vue$1t.createVNode(_component_el_icon, null, {
                default: vue$1t.withCtx(() => [
                  vue$1t.createVNode(_component_arrow_left)
                ]),
                _: 1
              })
            ], 10, _hoisted_19$1)) : vue$1t.createCommentVNode("v-if", true),
            vue$1t.createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn d-arrow-right",
              onClick: _cache[16] || (_cache[16] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
            }, [
              vue$1t.createVNode(_component_el_icon, null, {
                default: vue$1t.withCtx(() => [
                  vue$1t.createVNode(_component_d_arrow_right)
                ]),
                _: 1
              })
            ]),
            vue$1t.createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn arrow-right",
              onClick: _cache[17] || (_cache[17] = (...args) => _ctx.rightNextMonth && _ctx.rightNextMonth(...args))
            }, [
              vue$1t.createVNode(_component_el_icon, null, {
                default: vue$1t.withCtx(() => [
                  vue$1t.createVNode(_component_arrow_right)
                ]),
                _: 1
              })
            ]),
            vue$1t.createElementVNode("div", null, vue$1t.toDisplayString(_ctx.rightLabel), 1)
          ]),
          vue$1t.createVNode(_component_date_table, {
            "selection-mode": "range",
            date: _ctx.rightDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            "cell-class-name": _ctx.cellClassName,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])
        ])
      ])
    ]),
    _ctx.showTime ? (vue$1t.openBlock(), vue$1t.createElementBlock("div", _hoisted_20$1, [
      _ctx.clearable ? (vue$1t.openBlock(), vue$1t.createBlock(_component_el_button, {
        key: 0,
        size: "mini",
        type: "text",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.handleClear
      }, {
        default: vue$1t.withCtx(() => [
          vue$1t.createTextVNode(vue$1t.toDisplayString(_ctx.t("el.datepicker.clear")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])) : vue$1t.createCommentVNode("v-if", true),
      vue$1t.createVNode(_component_el_button, {
        plain: "",
        size: "mini",
        class: "el-picker-panel__link-btn",
        disabled: _ctx.btnDisabled,
        onClick: _cache[18] || (_cache[18] = ($event) => _ctx.handleConfirm(false))
      }, {
        default: vue$1t.withCtx(() => [
          vue$1t.createTextVNode(vue$1t.toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ]),
        _: 1
      }, 8, ["disabled"])
    ])) : vue$1t.createCommentVNode("v-if", true)
  ], 2);
}
panelDateRange_vue_vue_type_template_id_62b45ab2_lang.render = render$11;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var panelDateRange_vue_vue_type_script_lang$1 = panelDateRange_vue_vue_type_script_lang;
  var panelDateRange_vue_vue_type_template_id_62b45ab2_lang$1 = panelDateRange_vue_vue_type_template_id_62b45ab2_lang;
  panelDateRange_vue_vue_type_script_lang$1["default"].render = panelDateRange_vue_vue_type_template_id_62b45ab2_lang$1.render;
  panelDateRange_vue_vue_type_script_lang$1["default"].__file = "packages/components/date-picker/src/date-picker-com/panel-date-range.vue";
  exports["default"] = panelDateRange_vue_vue_type_script_lang$1["default"];
})(panelDateRange);
var panelMonthRange = {};
var panelMonthRange_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var basicMonthTable_vue_vue_type_script_lang$1 = basicMonthTable_vue_vue_type_script_lang;
  var index$110 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var script2 = vue2.defineComponent({
    components: { MonthTable: basicMonthTable_vue_vue_type_script_lang$1["default"], ElIcon: index2.ElIcon, DArrowLeft: iconsVue2.DArrowLeft, DArrowRight: iconsVue2.DArrowRight },
    props: {
      unlinkPanels: Boolean,
      parsedValue: {
        type: Array
      }
    },
    emits: ["pick", "set-picker-option"],
    setup(props2, ctx) {
      const { t, lang } = index$110.useLocale();
      const leftDate = vue2.ref(dayjs__default["default"]().locale(lang.value));
      const rightDate = vue2.ref(dayjs__default["default"]().locale(lang.value).add(1, "year"));
      const hasShortcuts = vue2.computed(() => !!shortcuts.length);
      const handleShortcutClick = (shortcut) => {
        const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
        if (shortcutValues) {
          ctx.emit("pick", [
            dayjs__default["default"](shortcutValues[0]).locale(lang.value),
            dayjs__default["default"](shortcutValues[1]).locale(lang.value)
          ]);
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick(ctx);
        }
      };
      const leftPrevYear = () => {
        leftDate.value = leftDate.value.subtract(1, "year");
        if (!props2.unlinkPanels) {
          rightDate.value = rightDate.value.subtract(1, "year");
        }
      };
      const rightNextYear = () => {
        if (!props2.unlinkPanels) {
          leftDate.value = leftDate.value.add(1, "year");
        }
        rightDate.value = rightDate.value.add(1, "year");
      };
      const leftNextYear = () => {
        leftDate.value = leftDate.value.add(1, "year");
      };
      const rightPrevYear = () => {
        rightDate.value = rightDate.value.subtract(1, "year");
      };
      const leftLabel = vue2.computed(() => {
        return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
      });
      const rightLabel = vue2.computed(() => {
        return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
      });
      const leftYear = vue2.computed(() => {
        return leftDate.value.year();
      });
      const rightYear = vue2.computed(() => {
        return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
      });
      const enableYearArrow = vue2.computed(() => {
        return props2.unlinkPanels && rightYear.value > leftYear.value + 1;
      });
      const minDate = vue2.ref(null);
      const maxDate = vue2.ref(null);
      const rangeState = vue2.ref({
        endDate: null,
        selecting: false
      });
      const handleChangeRange = (val) => {
        rangeState.value = val;
      };
      const handleRangePick = (val, close2 = true) => {
        const minDate_ = val.minDate;
        const maxDate_ = val.maxDate;
        if (maxDate.value === maxDate_ && minDate.value === minDate_) {
          return;
        }
        maxDate.value = maxDate_;
        minDate.value = minDate_;
        if (!close2)
          return;
        handleConfirm();
      };
      const isValidValue = (value) => {
        return Array.isArray(value) && value && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
      };
      const handleConfirm = (visible = false) => {
        if (isValidValue([minDate.value, maxDate.value])) {
          ctx.emit("pick", [minDate.value, maxDate.value], visible);
        }
      };
      const onSelect = (selecting) => {
        rangeState.value.selecting = selecting;
        if (!selecting) {
          rangeState.value.endDate = null;
        }
      };
      const formatToString = (value) => {
        return value.map((_2) => _2.format(format2));
      };
      const getDefaultValue = () => {
        let start2;
        if (Array.isArray(defaultValue)) {
          const left2 = dayjs__default["default"](defaultValue[0]);
          let right2 = dayjs__default["default"](defaultValue[1]);
          if (!props2.unlinkPanels) {
            right2 = left2.add(1, "year");
          }
          return [left2, right2];
        } else if (defaultValue) {
          start2 = dayjs__default["default"](defaultValue);
        } else {
          start2 = dayjs__default["default"]();
        }
        start2 = start2.locale(lang.value);
        return [start2, start2.add(1, "year")];
      };
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      const pickerBase = vue2.inject("EP_PICKER_BASE");
      const { shortcuts, disabledDate, format: format2, defaultValue } = pickerBase.props;
      vue2.watch(() => props2.parsedValue, (newVal) => {
        if (newVal && newVal.length === 2) {
          minDate.value = newVal[0];
          maxDate.value = newVal[1];
          leftDate.value = minDate.value;
          if (props2.unlinkPanels && maxDate.value) {
            const minDateYear = minDate.value.year();
            const maxDateYear = maxDate.value.year();
            rightDate.value = minDateYear === maxDateYear ? maxDate.value.add(1, "year") : maxDate.value;
          } else {
            rightDate.value = leftDate.value.add(1, "year");
          }
        } else {
          const defaultArr = getDefaultValue();
          leftDate.value = defaultArr[0];
          rightDate.value = defaultArr[1];
        }
      }, { immediate: true });
      return {
        shortcuts,
        disabledDate,
        onSelect,
        handleRangePick,
        rangeState,
        handleChangeRange,
        minDate,
        maxDate,
        enableYearArrow,
        leftLabel,
        rightLabel,
        leftNextYear,
        leftPrevYear,
        rightNextYear,
        rightPrevYear,
        t,
        leftDate,
        rightDate,
        hasShortcuts,
        handleShortcutClick
      };
    }
  });
  exports["default"] = script2;
})(panelMonthRange_vue_vue_type_script_lang);
var panelMonthRange_vue_vue_type_template_id_2e377892_lang = {};
Object.defineProperty(panelMonthRange_vue_vue_type_template_id_2e377892_lang, "__esModule", { value: true });
var vue$1s = require$$0$1;
const _hoisted_1$M = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$z = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$t = ["onClick"];
const _hoisted_4$l = { class: "el-picker-panel__body" };
const _hoisted_5$h = { class: "el-picker-panel__content el-date-range-picker__content is-left" };
const _hoisted_6$b = { class: "el-date-range-picker__header" };
const _hoisted_7$7 = ["disabled"];
const _hoisted_8$6 = { class: "el-picker-panel__content el-date-range-picker__content is-right" };
const _hoisted_9$4 = { class: "el-date-range-picker__header" };
const _hoisted_10$4 = ["disabled"];
function render$10(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_d_arrow_left = vue$1s.resolveComponent("d-arrow-left");
  const _component_el_icon = vue$1s.resolveComponent("el-icon");
  const _component_d_arrow_right = vue$1s.resolveComponent("d-arrow-right");
  const _component_month_table = vue$1s.resolveComponent("month-table");
  return vue$1s.openBlock(), vue$1s.createElementBlock("div", {
    class: vue$1s.normalizeClass(["el-picker-panel el-date-range-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts
      }
    ]])
  }, [
    vue$1s.createElementVNode("div", _hoisted_1$M, [
      vue$1s.renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (vue$1s.openBlock(), vue$1s.createElementBlock("div", _hoisted_2$z, [
        (vue$1s.openBlock(true), vue$1s.createElementBlock(vue$1s.Fragment, null, vue$1s.renderList(_ctx.shortcuts, (shortcut, key2) => {
          return vue$1s.openBlock(), vue$1s.createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, vue$1s.toDisplayString(shortcut.text), 9, _hoisted_3$t);
        }), 128))
      ])) : vue$1s.createCommentVNode("v-if", true),
      vue$1s.createElementVNode("div", _hoisted_4$l, [
        vue$1s.createElementVNode("div", _hoisted_5$h, [
          vue$1s.createElementVNode("div", _hoisted_6$b, [
            vue$1s.createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn d-arrow-left",
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
            }, [
              vue$1s.createVNode(_component_el_icon, null, {
                default: vue$1s.withCtx(() => [
                  vue$1s.createVNode(_component_d_arrow_left)
                ]),
                _: 1
              })
            ]),
            _ctx.unlinkPanels ? (vue$1s.openBlock(), vue$1s.createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: vue$1s.normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn d-arrow-right"]),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
            }, [
              vue$1s.createVNode(_component_el_icon, null, {
                default: vue$1s.withCtx(() => [
                  vue$1s.createVNode(_component_d_arrow_right)
                ]),
                _: 1
              })
            ], 10, _hoisted_7$7)) : vue$1s.createCommentVNode("v-if", true),
            vue$1s.createElementVNode("div", null, vue$1s.toDisplayString(_ctx.leftLabel), 1)
          ]),
          vue$1s.createVNode(_component_month_table, {
            "selection-mode": "range",
            date: _ctx.leftDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])
        ]),
        vue$1s.createElementVNode("div", _hoisted_8$6, [
          vue$1s.createElementVNode("div", _hoisted_9$4, [
            _ctx.unlinkPanels ? (vue$1s.openBlock(), vue$1s.createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: vue$1s.normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn d-arrow-left"]),
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
            }, [
              vue$1s.createVNode(_component_el_icon, null, {
                default: vue$1s.withCtx(() => [
                  vue$1s.createVNode(_component_d_arrow_left)
                ]),
                _: 1
              })
            ], 10, _hoisted_10$4)) : vue$1s.createCommentVNode("v-if", true),
            vue$1s.createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn d-arrow-right",
              onClick: _cache[3] || (_cache[3] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
            }, [
              vue$1s.createVNode(_component_el_icon, null, {
                default: vue$1s.withCtx(() => [
                  vue$1s.createVNode(_component_d_arrow_right)
                ]),
                _: 1
              })
            ]),
            vue$1s.createElementVNode("div", null, vue$1s.toDisplayString(_ctx.rightLabel), 1)
          ]),
          vue$1s.createVNode(_component_month_table, {
            "selection-mode": "range",
            date: _ctx.rightDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])
        ])
      ])
    ])
  ], 2);
}
panelMonthRange_vue_vue_type_template_id_2e377892_lang.render = render$10;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var panelMonthRange_vue_vue_type_script_lang$1 = panelMonthRange_vue_vue_type_script_lang;
  var panelMonthRange_vue_vue_type_template_id_2e377892_lang$1 = panelMonthRange_vue_vue_type_template_id_2e377892_lang;
  panelMonthRange_vue_vue_type_script_lang$1["default"].render = panelMonthRange_vue_vue_type_template_id_2e377892_lang$1.render;
  panelMonthRange_vue_vue_type_script_lang$1["default"].__file = "packages/components/date-picker/src/date-picker-com/panel-month-range.vue";
  exports["default"] = panelMonthRange_vue_vue_type_script_lang$1["default"];
})(panelMonthRange);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dayjs = dayjs_min.exports;
  var customParseFormat$1 = customParseFormat.exports;
  var advancedFormat$1 = advancedFormat.exports;
  var localeData$1 = localeData.exports;
  var weekOfYear$1 = weekOfYear.exports;
  var weekYear$1 = weekYear.exports;
  var dayOfYear$1 = dayOfYear.exports;
  var isSameOrAfter$1 = isSameOrAfter.exports;
  var isSameOrBefore$1 = isSameOrBefore.exports;
  var datePicker_type$1 = datePicker_type;
  var panelDateRange_vue_vue_type_script_lang$1 = panelDateRange_vue_vue_type_script_lang;
  var panelMonthRange_vue_vue_type_script_lang$1 = panelMonthRange_vue_vue_type_script_lang;
  var panelDatePick_vue_vue_type_script_lang$1 = panelDatePick_vue_vue_type_script_lang;
  var props2 = props$x;
  var constant2 = constant$3;
  var picker_vue_vue_type_script_lang2 = picker_vue_vue_type_script_lang$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var dayjs__default = /* @__PURE__ */ _interopDefaultLegacy2(dayjs);
  var customParseFormat__default = /* @__PURE__ */ _interopDefaultLegacy2(customParseFormat$1);
  var advancedFormat__default = /* @__PURE__ */ _interopDefaultLegacy2(advancedFormat$1);
  var localeData__default = /* @__PURE__ */ _interopDefaultLegacy2(localeData$1);
  var weekOfYear__default = /* @__PURE__ */ _interopDefaultLegacy2(weekOfYear$1);
  var weekYear__default = /* @__PURE__ */ _interopDefaultLegacy2(weekYear$1);
  var dayOfYear__default = /* @__PURE__ */ _interopDefaultLegacy2(dayOfYear$1);
  var isSameOrAfter__default = /* @__PURE__ */ _interopDefaultLegacy2(isSameOrAfter$1);
  var isSameOrBefore__default = /* @__PURE__ */ _interopDefaultLegacy2(isSameOrBefore$1);
  dayjs__default["default"].extend(localeData__default["default"]);
  dayjs__default["default"].extend(advancedFormat__default["default"]);
  dayjs__default["default"].extend(customParseFormat__default["default"]);
  dayjs__default["default"].extend(weekOfYear__default["default"]);
  dayjs__default["default"].extend(weekYear__default["default"]);
  dayjs__default["default"].extend(dayOfYear__default["default"]);
  dayjs__default["default"].extend(isSameOrAfter__default["default"]);
  dayjs__default["default"].extend(isSameOrBefore__default["default"]);
  const getPanel = function(type4) {
    if (type4 === "daterange" || type4 === "datetimerange") {
      return panelDateRange_vue_vue_type_script_lang$1["default"];
    } else if (type4 === "monthrange") {
      return panelMonthRange_vue_vue_type_script_lang$1["default"];
    }
    return panelDatePick_vue_vue_type_script_lang$1["default"];
  };
  var DatePicker = vue2.defineComponent({
    name: "ElDatePicker",
    install: null,
    props: __spreadProps(__spreadValues({}, props2.timePickerDefaultProps), {
      type: {
        type: String,
        default: "date"
      }
    }),
    emits: ["update:modelValue"],
    setup(props3, ctx) {
      vue2.provide("ElPopperOptions", props3.popperOptions);
      vue2.provide(datePicker_type$1.ROOT_PICKER_INJECTION_KEY, {
        ctx
      });
      const commonPicker = vue2.ref(null);
      const refProps = __spreadProps(__spreadValues({}, props3), {
        focus: () => {
          var _a;
          (_a = commonPicker.value) == null ? void 0 : _a.handleFocus();
        }
      });
      ctx.expose(refProps);
      return () => {
        var _a;
        const format2 = (_a = props3.format) != null ? _a : constant2.DEFAULT_FORMATS_DATEPICKER[props3.type] || constant2.DEFAULT_FORMATS_DATE;
        return vue2.h(picker_vue_vue_type_script_lang2["default"], __spreadProps(__spreadValues({}, props3), {
          format: format2,
          type: props3.type,
          ref: commonPicker,
          "onUpdate:modelValue": (value) => ctx.emit("update:modelValue", value)
        }), {
          default: (scopedProps) => vue2.h(getPanel(props3.type), scopedProps),
          "range-separator": () => vue2.renderSlot(ctx.slots, "range-separator")
        });
      };
    }
  });
  exports["default"] = DatePicker;
})(datePicker);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var datePicker$12 = datePicker;
  const _DatePicker = datePicker$12["default"];
  _DatePicker.install = (app) => {
    app.component(_DatePicker.name, _DatePicker);
  };
  const ElDatePicker = _DatePicker;
  exports.ElDatePicker = ElDatePicker;
  exports["default"] = _DatePicker;
})(datePicker$1);
var descriptions = {};
var src$9 = {};
var index_vue_vue_type_script_lang$7 = {};
var descriptionsRow = {};
var descriptionsRow_vue_vue_type_script_lang = {};
var descriptionsCell = {};
var token$5 = {};
Object.defineProperty(token$5, "__esModule", { value: true });
const elDescriptionsKey = "elDescriptions";
token$5.elDescriptionsKey = elDescriptionsKey;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$l;
  var vnode2 = vnode$1;
  var token2 = token$5;
  var DescriptionsCell = vue2.defineComponent({
    name: "ElDescriptionsCell",
    props: {
      cell: {
        type: Object
      },
      tag: {
        type: String
      },
      type: {
        type: String
      }
    },
    setup() {
      const descriptions2 = vue2.inject(token2.elDescriptionsKey, {});
      return {
        descriptions: descriptions2
      };
    },
    render() {
      var _a, _b, _c, _d, _e, _f;
      const item2 = vnode2.getNormalizedProps(this.cell);
      const label = ((_c = (_b = (_a = this.cell) == null ? void 0 : _a.children) == null ? void 0 : _b.label) == null ? void 0 : _c.call(_b)) || item2.label;
      const content = (_f = (_e = (_d = this.cell) == null ? void 0 : _d.children) == null ? void 0 : _e.default) == null ? void 0 : _f.call(_e);
      const span = item2.span;
      const align = item2.align ? `is-${item2.align}` : "";
      const labelAlign = item2.labelAlign ? `is-${item2.labelAlign}` : align;
      const className = item2.className;
      const labelClassName = item2.labelClassName;
      const style = {
        width: util2.addUnit(item2.width),
        minWidth: util2.addUnit(item2.minWidth)
      };
      switch (this.type) {
        case "label":
          return vue2.h(this.tag, {
            style,
            class: [
              "el-descriptions__cell",
              "el-descriptions__label",
              { "is-bordered-label": this.descriptions.border },
              labelAlign,
              labelClassName
            ],
            colSpan: this.descriptions.direction === "vertical" ? span : 1
          }, label);
        case "content":
          return vue2.h(this.tag, {
            style,
            class: [
              "el-descriptions__cell",
              "el-descriptions__content",
              align,
              className
            ],
            colSpan: this.descriptions.direction === "vertical" ? span : span * 2 - 1
          }, content);
        default:
          return vue2.h("td", {
            style,
            class: ["el-descriptions__cell", align],
            colSpan: span
          }, [
            vue2.h("span", {
              class: ["el-descriptions__label", labelClassName]
            }, label),
            vue2.h("span", {
              class: ["el-descriptions__content", className]
            }, content)
          ]);
      }
    }
  });
  exports["default"] = DescriptionsCell;
})(descriptionsCell);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var descriptionsCell$1 = descriptionsCell;
  var token2 = token$5;
  var script2 = vue2.defineComponent({
    name: "ElDescriptionsRow",
    components: {
      [descriptionsCell$1["default"].name]: descriptionsCell$1["default"]
    },
    props: {
      row: {
        type: Array
      }
    },
    setup() {
      const descriptions2 = vue2.inject(token2.elDescriptionsKey, {});
      return {
        descriptions: descriptions2
      };
    }
  });
  exports["default"] = script2;
})(descriptionsRow_vue_vue_type_script_lang);
var descriptionsRow_vue_vue_type_template_id_29b1db72_lang = {};
Object.defineProperty(descriptionsRow_vue_vue_type_template_id_29b1db72_lang, "__esModule", { value: true });
var vue$1r = require$$0$1;
const _hoisted_1$L = { key: 1 };
function render$$(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_descriptions_cell = vue$1r.resolveComponent("el-descriptions-cell");
  return _ctx.descriptions.direction === "vertical" ? (vue$1r.openBlock(), vue$1r.createElementBlock(vue$1r.Fragment, { key: 0 }, [
    vue$1r.createElementVNode("tr", null, [
      (vue$1r.openBlock(true), vue$1r.createElementBlock(vue$1r.Fragment, null, vue$1r.renderList(_ctx.row, (cell, index2) => {
        return vue$1r.openBlock(), vue$1r.createBlock(_component_el_descriptions_cell, {
          key: `tr1-${index2}`,
          cell,
          tag: "th",
          type: "label"
        }, null, 8, ["cell"]);
      }), 128))
    ]),
    vue$1r.createElementVNode("tr", null, [
      (vue$1r.openBlock(true), vue$1r.createElementBlock(vue$1r.Fragment, null, vue$1r.renderList(_ctx.row, (cell, index2) => {
        return vue$1r.openBlock(), vue$1r.createBlock(_component_el_descriptions_cell, {
          key: `tr2-${index2}`,
          cell,
          tag: "td",
          type: "content"
        }, null, 8, ["cell"]);
      }), 128))
    ])
  ], 64)) : (vue$1r.openBlock(), vue$1r.createElementBlock("tr", _hoisted_1$L, [
    (vue$1r.openBlock(true), vue$1r.createElementBlock(vue$1r.Fragment, null, vue$1r.renderList(_ctx.row, (cell, index2) => {
      return vue$1r.openBlock(), vue$1r.createElementBlock(vue$1r.Fragment, {
        key: `tr3-${index2}`
      }, [
        _ctx.descriptions.border ? (vue$1r.openBlock(), vue$1r.createElementBlock(vue$1r.Fragment, { key: 0 }, [
          vue$1r.createVNode(_component_el_descriptions_cell, {
            cell,
            tag: "td",
            type: "label"
          }, null, 8, ["cell"]),
          vue$1r.createVNode(_component_el_descriptions_cell, {
            cell,
            tag: "td",
            type: "content"
          }, null, 8, ["cell"])
        ], 64)) : (vue$1r.openBlock(), vue$1r.createBlock(_component_el_descriptions_cell, {
          key: 1,
          cell,
          tag: "td",
          type: "both"
        }, null, 8, ["cell"]))
      ], 64);
    }), 128))
  ]));
}
descriptionsRow_vue_vue_type_template_id_29b1db72_lang.render = render$$;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var descriptionsRow_vue_vue_type_script_lang$1 = descriptionsRow_vue_vue_type_script_lang;
  var descriptionsRow_vue_vue_type_template_id_29b1db72_lang$1 = descriptionsRow_vue_vue_type_template_id_29b1db72_lang;
  descriptionsRow_vue_vue_type_script_lang$1["default"].render = descriptionsRow_vue_vue_type_template_id_29b1db72_lang$1.render;
  descriptionsRow_vue_vue_type_script_lang$1["default"].__file = "packages/components/descriptions/src/descriptions-row.vue";
  exports["default"] = descriptionsRow_vue_vue_type_script_lang$1["default"];
})(descriptionsRow);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var validators2 = validators$6;
  var token2 = token$5;
  var descriptionsRow_vue_vue_type_script_lang$1 = descriptionsRow_vue_vue_type_script_lang;
  var index2 = useCommonProps;
  var script2 = vue2.defineComponent({
    name: "ElDescriptions",
    components: {
      [descriptionsRow_vue_vue_type_script_lang$1["default"].name]: descriptionsRow_vue_vue_type_script_lang$1["default"]
    },
    props: {
      border: {
        type: Boolean,
        default: false
      },
      column: {
        type: Number,
        default: 3
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      size: {
        type: String,
        validator: validators2.isValidComponentSize
      },
      title: {
        type: String,
        default: ""
      },
      extra: {
        type: String,
        default: ""
      }
    },
    setup(props2, { slots }) {
      vue2.provide(token2.elDescriptionsKey, props2);
      const descriptionsSize = index2.useSize();
      const flattedChildren = (children) => {
        const temp = Array.isArray(children) ? children : [children];
        const res = [];
        temp.forEach((child) => {
          if (Array.isArray(child.children)) {
            res.push(...flattedChildren(child.children));
          } else {
            res.push(child);
          }
        });
        return res;
      };
      const filledNode = (node3, span, count, isLast = false) => {
        if (!node3.props) {
          node3.props = {};
        }
        if (span > count) {
          node3.props.span = count;
        }
        if (isLast) {
          node3.props.span = span;
        }
        return node3;
      };
      const getRows = () => {
        var _a;
        const children = flattedChildren((_a = slots.default) == null ? void 0 : _a.call(slots)).filter((node3) => {
          var _a2;
          return ((_a2 = node3 == null ? void 0 : node3.type) == null ? void 0 : _a2.name) === "ElDescriptionsItem";
        });
        const rows = [];
        let temp = [];
        let count = props2.column;
        let totalSpan = 0;
        children.forEach((node3, index3) => {
          var _a2;
          const span = ((_a2 = node3.props) == null ? void 0 : _a2.span) || 1;
          if (index3 < children.length - 1) {
            totalSpan += span > count ? count : span;
          }
          if (index3 === children.length - 1) {
            const lastSpan = props2.column - totalSpan % props2.column;
            temp.push(filledNode(node3, lastSpan, count, true));
            rows.push(temp);
            return;
          }
          if (span < count) {
            count -= span;
            temp.push(node3);
          } else {
            temp.push(filledNode(node3, span, count));
            rows.push(temp);
            count = props2.column;
            temp = [];
          }
        });
        return rows;
      };
      return {
        descriptionsSize,
        getRows
      };
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$7);
var index_vue_vue_type_template_id_788d3854_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_788d3854_lang, "__esModule", { value: true });
var vue$1q = require$$0$1;
const _hoisted_1$K = { class: "el-descriptions" };
const _hoisted_2$y = {
  key: 0,
  class: "el-descriptions__header"
};
const _hoisted_3$s = { class: "el-descriptions__title" };
const _hoisted_4$k = { class: "el-descriptions__extra" };
const _hoisted_5$g = { class: "el-descriptions__body" };
function render$_(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_descriptions_row = vue$1q.resolveComponent("el-descriptions-row");
  return vue$1q.openBlock(), vue$1q.createElementBlock("div", _hoisted_1$K, [
    _ctx.title || _ctx.extra || _ctx.$slots.title || _ctx.$slots.extra ? (vue$1q.openBlock(), vue$1q.createElementBlock("div", _hoisted_2$y, [
      vue$1q.createElementVNode("div", _hoisted_3$s, [
        vue$1q.renderSlot(_ctx.$slots, "title", {}, () => [
          vue$1q.createTextVNode(vue$1q.toDisplayString(_ctx.title), 1)
        ])
      ]),
      vue$1q.createElementVNode("div", _hoisted_4$k, [
        vue$1q.renderSlot(_ctx.$slots, "extra", {}, () => [
          vue$1q.createTextVNode(vue$1q.toDisplayString(_ctx.extra), 1)
        ])
      ])
    ])) : vue$1q.createCommentVNode("v-if", true),
    vue$1q.createElementVNode("div", _hoisted_5$g, [
      vue$1q.createElementVNode("table", {
        class: vue$1q.normalizeClass([
          "el-descriptions__table",
          { "is-bordered": _ctx.border },
          _ctx.descriptionsSize ? `el-descriptions--${_ctx.descriptionsSize}` : ""
        ])
      }, [
        vue$1q.createElementVNode("tbody", null, [
          (vue$1q.openBlock(true), vue$1q.createElementBlock(vue$1q.Fragment, null, vue$1q.renderList(_ctx.getRows(), (row2, index2) => {
            return vue$1q.openBlock(), vue$1q.createBlock(_component_el_descriptions_row, {
              key: index2,
              row: row2
            }, null, 8, ["row"]);
          }), 128))
        ])
      ], 2)
    ])
  ]);
}
index_vue_vue_type_template_id_788d3854_lang.render = render$_;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$7;
  var index_vue_vue_type_template_id_788d3854_lang$1 = index_vue_vue_type_template_id_788d3854_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_788d3854_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/descriptions/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$9);
var descriptionItem = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var DescriptionsItem = vue2.defineComponent({
    name: "ElDescriptionsItem",
    props: {
      label: {
        type: String,
        default: ""
      },
      span: {
        type: Number,
        default: 1
      },
      width: {
        type: [String, Number],
        default: ""
      },
      minWidth: {
        type: [String, Number],
        default: ""
      },
      align: {
        type: String,
        default: "left"
      },
      labelAlign: {
        type: String,
        default: ""
      },
      className: {
        type: String,
        default: ""
      },
      labelClassName: {
        type: String,
        default: ""
      }
    }
  });
  exports["default"] = DescriptionsItem;
})(descriptionItem);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var descriptionItem$1 = descriptionItem;
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$7;
  const ElDescriptions = withInstall2.withInstall(index_vue_vue_type_script_lang2["default"], {
    DescriptionsItem: descriptionItem$1["default"]
  });
  const ElDescriptionsItem = withInstall2.withNoopInstall(descriptionItem$1["default"]);
  exports.ElDescriptions = ElDescriptions;
  exports.ElDescriptionsItem = ElDescriptionsItem;
  exports["default"] = ElDescriptions;
})(descriptions);
var dialog$3 = {};
var dialog2 = {};
var dialog_vue_vue_type_script_lang = {};
var overlay$2 = {};
var overlay$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var vnode2 = vnode$1;
  var props2 = props$N;
  var index2 = useSameTarget$1;
  const overlayProps = props2.buildProps({
    mask: {
      type: Boolean,
      default: true
    },
    customMaskEvent: {
      type: Boolean,
      default: false
    },
    overlayClass: {
      type: props2.definePropType([
        String,
        Array,
        Object
      ])
    },
    zIndex: {
      type: props2.definePropType([String, Number])
    }
  });
  const overlayEmits = {
    click: (evt) => evt instanceof MouseEvent
  };
  var Overlay = vue2.defineComponent({
    name: "ElOverlay",
    props: overlayProps,
    emits: overlayEmits,
    setup(props3, { slots, emit }) {
      const onMaskClick = (e) => {
        emit("click", e);
      };
      const { onClick, onMousedown, onMouseup } = index2.useSameTarget(props3.customMaskEvent ? void 0 : onMaskClick);
      return () => {
        return props3.mask ? vue2.createVNode("div", {
          class: ["el-overlay", props3.overlayClass],
          style: {
            zIndex: props3.zIndex
          },
          onClick,
          onMousedown,
          onMouseup
        }, [vue2.renderSlot(slots, "default")], vnode2.PatchFlags.STYLE | vnode2.PatchFlags.CLASS | vnode2.PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : vue2.h("div", {
          class: props3.overlayClass,
          style: {
            zIndex: props3.zIndex,
            position: "fixed",
            top: "0px",
            right: "0px",
            bottom: "0px",
            left: "0px"
          }
        }, [vue2.renderSlot(slots, "default")]);
      };
    }
  });
  exports["default"] = Overlay;
  exports.overlayEmits = overlayEmits;
  exports.overlayProps = overlayProps;
})(overlay$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var overlay2 = overlay$1;
  const ElOverlay = overlay2["default"];
  exports.overlayEmits = overlay2.overlayEmits;
  exports.overlayProps = overlay2.overlayProps;
  exports.ElOverlay = ElOverlay;
  exports["default"] = ElOverlay;
})(overlay$2);
var dialog$2 = {};
Object.defineProperty(dialog$2, "__esModule", { value: true });
var validators$4 = validators$6;
var props$o = props$N;
var constants$9 = constants$f;
const dialogProps = props$o.buildProps({
  appendToBody: {
    type: Boolean,
    default: false
  },
  beforeClose: {
    type: props$o.definePropType(Function)
  },
  destroyOnClose: {
    type: Boolean,
    default: false
  },
  center: {
    type: Boolean,
    default: false
  },
  customClass: {
    type: String,
    default: ""
  },
  closeIcon: {
    type: props$o.definePropType([String, Object]),
    default: ""
  },
  closeOnClickModal: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  fullscreen: {
    type: Boolean,
    default: false
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  modal: {
    type: Boolean,
    default: true
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: {
    type: Boolean,
    required: true
  },
  modalClass: String,
  width: {
    type: [String, Number],
    validator: validators$4.isValidWidthUnit
  },
  zIndex: {
    type: Number
  }
});
const dialogEmits = {
  open: () => true,
  opened: () => true,
  close: () => true,
  closed: () => true,
  [constants$9.UPDATE_MODEL_EVENT]: (value) => typeof value === "boolean"
};
dialog$2.dialogEmits = dialogEmits;
dialog$2.dialogProps = dialogProps;
var useDialog$2 = {};
Object.defineProperty(useDialog$2, "__esModule", { value: true });
var vue$1p = require$$0$1;
var core$1 = core$7;
var constants$8 = constants$f;
var isServer$2 = isServer$8;
var popupManager$1 = popupManager$3;
var util$c = util$l;
var index$1b = useLockscreen$1;
var index$1$3 = useModal$1;
var index$2$1 = useRestoreActive$1;
const useDialog$1 = (props2, { emit }, targetRef) => {
  const visible = vue$1p.ref(false);
  const closed = vue$1p.ref(false);
  const rendered = vue$1p.ref(false);
  const zIndex2 = vue$1p.ref(props2.zIndex || popupManager$1["default"].nextZIndex());
  let openTimer = void 0;
  let closeTimer = void 0;
  const normalizeWidth = vue$1p.computed(() => util$c.isNumber(props2.width) ? `${props2.width}px` : props2.width);
  const style = vue$1p.computed(() => {
    const style2 = {};
    const varPrefix = `--el-dialog`;
    if (!props2.fullscreen) {
      if (props2.top) {
        style2[`${varPrefix}-margin-top`] = props2.top;
      }
      if (props2.width) {
        style2[`${varPrefix}-width`] = normalizeWidth.value;
      }
    }
    return style2;
  });
  function afterEnter() {
    emit("opened");
  }
  function afterLeave() {
    emit("closed");
    emit(constants$8.UPDATE_MODEL_EVENT, false);
    if (props2.destroyOnClose) {
      rendered.value = false;
    }
  }
  function beforeLeave() {
    emit("close");
  }
  function open2() {
    closeTimer == null ? void 0 : closeTimer();
    openTimer == null ? void 0 : openTimer();
    if (props2.openDelay && props2.openDelay > 0) {
      ({ stop: openTimer } = core$1.useTimeoutFn(() => doOpen(), props2.openDelay));
    } else {
      doOpen();
    }
  }
  function close2() {
    openTimer == null ? void 0 : openTimer();
    closeTimer == null ? void 0 : closeTimer();
    if (props2.closeDelay && props2.closeDelay > 0) {
      ({ stop: closeTimer } = core$1.useTimeoutFn(() => doClose(), props2.closeDelay));
    } else {
      doClose();
    }
  }
  function hide2(shouldCancel) {
    if (shouldCancel)
      return;
    closed.value = true;
    visible.value = false;
  }
  function handleClose() {
    if (props2.beforeClose) {
      props2.beforeClose(hide2);
    } else {
      close2();
    }
  }
  function onModalClick2() {
    if (props2.closeOnClickModal) {
      handleClose();
    }
  }
  function doOpen() {
    if (isServer$2["default"]) {
      return;
    }
    visible.value = true;
  }
  function doClose() {
    visible.value = false;
  }
  if (props2.lockScroll) {
    index$1b.useLockscreen(visible);
  }
  if (props2.closeOnPressEscape) {
    index$1$3.useModal({
      handleClose
    }, visible);
  }
  index$2$1.useRestoreActive(visible);
  vue$1p.watch(() => props2.modelValue, (val) => {
    if (val) {
      closed.value = false;
      open2();
      rendered.value = true;
      emit("open");
      zIndex2.value = props2.zIndex ? zIndex2.value++ : popupManager$1["default"].nextZIndex();
      vue$1p.nextTick(() => {
        if (targetRef.value) {
          targetRef.value.scrollTop = 0;
        }
      });
    } else {
      if (visible.value) {
        close2();
      }
    }
  });
  vue$1p.onMounted(() => {
    if (props2.modelValue) {
      visible.value = true;
      rendered.value = true;
      open2();
    }
  });
  return {
    afterEnter,
    afterLeave,
    beforeLeave,
    handleClose,
    onModalClick: onModalClick2,
    close: close2,
    doClose,
    closed,
    style,
    rendered,
    visible,
    zIndex: zIndex2
  };
};
useDialog$2.useDialog = useDialog$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = overlay$2;
  var index$110 = icon$4;
  var icon3 = icon$2;
  var dialog3 = dialog$2;
  var useDialog2 = useDialog$2;
  var index$22 = trapFocus;
  var index$32 = useSameTarget$1;
  var script2 = vue2.defineComponent({
    name: "ElDialog",
    components: __spreadValues({
      ElOverlay: index2.ElOverlay,
      ElIcon: index$110.ElIcon
    }, icon3.CloseComponents),
    directives: {
      TrapFocus: index$22["default"]
    },
    props: dialog3.dialogProps,
    emits: dialog3.dialogEmits,
    setup(props2, ctx) {
      const dialogRef = vue2.ref();
      const dialog4 = useDialog2.useDialog(props2, ctx, dialogRef);
      const overlayEvent = index$32.useSameTarget(dialog4.onModalClick);
      return __spreadValues({
        dialogRef,
        overlayEvent
      }, dialog4);
    }
  });
  exports["default"] = script2;
})(dialog_vue_vue_type_script_lang);
var dialog_vue_vue_type_template_id_02672805_lang = {};
Object.defineProperty(dialog_vue_vue_type_template_id_02672805_lang, "__esModule", { value: true });
var vue$1o = require$$0$1;
const _hoisted_1$J = ["aria-label"];
const _hoisted_2$x = { class: "el-dialog__header" };
const _hoisted_3$r = { class: "el-dialog__title" };
const _hoisted_4$j = {
  key: 0,
  class: "el-dialog__body"
};
const _hoisted_5$f = {
  key: 1,
  class: "el-dialog__footer"
};
function render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$1o.resolveComponent("el-icon");
  const _component_el_overlay = vue$1o.resolveComponent("el-overlay");
  const _directive_trap_focus = vue$1o.resolveDirective("trap-focus");
  return vue$1o.openBlock(), vue$1o.createBlock(vue$1o.Teleport, {
    to: "body",
    disabled: !_ctx.appendToBody
  }, [
    vue$1o.createVNode(vue$1o.Transition, {
      name: "dialog-fade",
      onAfterEnter: _ctx.afterEnter,
      onAfterLeave: _ctx.afterLeave,
      onBeforeLeave: _ctx.beforeLeave
    }, {
      default: vue$1o.withCtx(() => [
        vue$1o.withDirectives(vue$1o.createVNode(_component_el_overlay, {
          "custom-mask-event": "",
          mask: _ctx.modal,
          "overlay-class": _ctx.modalClass,
          "z-index": _ctx.zIndex
        }, {
          default: vue$1o.withCtx(() => [
            vue$1o.createElementVNode("div", {
              class: "el-overlay-dialog",
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
              onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
              onMouseup: _cache[4] || (_cache[4] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
            }, [
              vue$1o.withDirectives(vue$1o.createElementVNode("div", {
                ref: "dialogRef",
                class: vue$1o.normalizeClass([
                  "el-dialog",
                  {
                    "is-fullscreen": _ctx.fullscreen,
                    "el-dialog--center": _ctx.center
                  },
                  _ctx.customClass
                ]),
                "aria-modal": "true",
                role: "dialog",
                "aria-label": _ctx.title || "dialog",
                style: vue$1o.normalizeStyle(_ctx.style),
                onClick: _cache[1] || (_cache[1] = vue$1o.withModifiers(() => {
                }, ["stop"]))
              }, [
                vue$1o.createElementVNode("div", _hoisted_2$x, [
                  vue$1o.renderSlot(_ctx.$slots, "title", {}, () => [
                    vue$1o.createElementVNode("span", _hoisted_3$r, vue$1o.toDisplayString(_ctx.title), 1)
                  ]),
                  _ctx.showClose ? (vue$1o.openBlock(), vue$1o.createElementBlock("button", {
                    key: 0,
                    "aria-label": "close",
                    class: "el-dialog__headerbtn",
                    type: "button",
                    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
                  }, [
                    vue$1o.createVNode(_component_el_icon, { class: "el-dialog__close" }, {
                      default: vue$1o.withCtx(() => [
                        (vue$1o.openBlock(), vue$1o.createBlock(vue$1o.resolveDynamicComponent(_ctx.closeIcon || "close")))
                      ]),
                      _: 1
                    })
                  ])) : vue$1o.createCommentVNode("v-if", true)
                ]),
                _ctx.rendered ? (vue$1o.openBlock(), vue$1o.createElementBlock("div", _hoisted_4$j, [
                  vue$1o.renderSlot(_ctx.$slots, "default")
                ])) : vue$1o.createCommentVNode("v-if", true),
                _ctx.$slots.footer ? (vue$1o.openBlock(), vue$1o.createElementBlock("div", _hoisted_5$f, [
                  vue$1o.renderSlot(_ctx.$slots, "footer")
                ])) : vue$1o.createCommentVNode("v-if", true)
              ], 14, _hoisted_1$J), [
                [_directive_trap_focus]
              ])
            ], 32)
          ]),
          _: 3
        }, 8, ["mask", "overlay-class", "z-index"]), [
          [vue$1o.vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
  ], 8, ["disabled"]);
}
dialog_vue_vue_type_template_id_02672805_lang.render = render$Z;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dialog_vue_vue_type_script_lang$1 = dialog_vue_vue_type_script_lang;
  var dialog_vue_vue_type_template_id_02672805_lang$1 = dialog_vue_vue_type_template_id_02672805_lang;
  dialog_vue_vue_type_script_lang$1["default"].render = dialog_vue_vue_type_template_id_02672805_lang$1.render;
  dialog_vue_vue_type_script_lang$1["default"].__file = "packages/components/dialog/src/dialog.vue";
  exports["default"] = dialog_vue_vue_type_script_lang$1["default"];
})(dialog2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var useDialog2 = useDialog$2;
  var dialog3 = dialog$2;
  var dialog_vue_vue_type_script_lang$1 = dialog_vue_vue_type_script_lang;
  const ElDialog = withInstall2.withInstall(dialog_vue_vue_type_script_lang$1["default"]);
  exports.useDialog = useDialog2.useDialog;
  exports.dialogEmits = dialog3.dialogEmits;
  exports.dialogProps = dialog3.dialogProps;
  exports.ElDialog = ElDialog;
  exports["default"] = ElDialog;
})(dialog$3);
var divider$2 = {};
var divider2 = {};
var divider_vue_vue_type_script_lang = {};
var divider$1 = {};
Object.defineProperty(divider$1, "__esModule", { value: true });
var props$n = props$N;
const dividerProps = props$n.buildProps({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: props$n.definePropType(String),
    default: "solid"
  }
});
divider$1.dividerProps = dividerProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var divider3 = divider$1;
  var script2 = vue2.defineComponent({
    name: "ElDivider",
    props: divider3.dividerProps
  });
  exports["default"] = script2;
})(divider_vue_vue_type_script_lang);
var divider_vue_vue_type_template_id_6ddd3543_lang = {};
Object.defineProperty(divider_vue_vue_type_template_id_6ddd3543_lang, "__esModule", { value: true });
var vue$1n = require$$0$1;
function render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1n.openBlock(), vue$1n.createElementBlock("div", {
    class: vue$1n.normalizeClass(["el-divider", `el-divider--${_ctx.direction}`]),
    style: vue$1n.normalizeStyle({ "--el-border-style": _ctx.borderStyle })
  }, [
    _ctx.$slots.default && _ctx.direction !== "vertical" ? (vue$1n.openBlock(), vue$1n.createElementBlock("div", {
      key: 0,
      class: vue$1n.normalizeClass(["el-divider__text", `is-${_ctx.contentPosition}`])
    }, [
      vue$1n.renderSlot(_ctx.$slots, "default")
    ], 2)) : vue$1n.createCommentVNode("v-if", true)
  ], 6);
}
divider_vue_vue_type_template_id_6ddd3543_lang.render = render$Y;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var divider_vue_vue_type_script_lang$1 = divider_vue_vue_type_script_lang;
  var divider_vue_vue_type_template_id_6ddd3543_lang$1 = divider_vue_vue_type_template_id_6ddd3543_lang;
  divider_vue_vue_type_script_lang$1["default"].render = divider_vue_vue_type_template_id_6ddd3543_lang$1.render;
  divider_vue_vue_type_script_lang$1["default"].__file = "packages/components/divider/src/divider.vue";
  exports["default"] = divider_vue_vue_type_script_lang$1["default"];
})(divider2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var divider3 = divider$1;
  var divider_vue_vue_type_script_lang$1 = divider_vue_vue_type_script_lang;
  const ElDivider = withInstall2.withInstall(divider_vue_vue_type_script_lang$1["default"]);
  exports.dividerProps = divider3.dividerProps;
  exports.ElDivider = ElDivider;
  exports["default"] = ElDivider;
})(divider$2);
var drawer$2 = {};
var drawer2 = {};
var drawer_vue_vue_type_script_lang = {};
var drawer$1 = {};
Object.defineProperty(drawer$1, "__esModule", { value: true });
var props$m = props$N;
var dialog$1 = dialog$2;
const drawerProps = props$m.buildProps(__spreadProps(__spreadValues({}, dialog$1.dialogProps), {
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: true
  },
  modalFade: {
    type: Boolean,
    default: true
  }
}));
const drawerEmits = dialog$1.dialogEmits;
drawer$1.drawerEmits = drawerEmits;
drawer$1.drawerProps = drawerProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var iconsVue2 = require$$3;
  var index2 = overlay$2;
  var index$110 = icon$4;
  var drawer3 = drawer$1;
  var index$22 = trapFocus;
  var useDialog2 = useDialog$2;
  var script2 = vue2.defineComponent({
    name: "ElDrawer",
    components: {
      ElOverlay: index2.ElOverlay,
      ElIcon: index$110.ElIcon,
      Close: iconsVue2.Close
    },
    directives: {
      TrapFocus: index$22["default"]
    },
    props: drawer3.drawerProps,
    emits: drawer3.drawerEmits,
    setup(props2, ctx) {
      const drawerRef = vue2.ref();
      const isHorizontal2 = vue2.computed(() => props2.direction === "rtl" || props2.direction === "ltr");
      const drawerSize = vue2.computed(() => typeof props2.size === "number" ? `${props2.size}px` : props2.size);
      return __spreadProps(__spreadValues({}, useDialog2.useDialog(props2, ctx, drawerRef)), {
        drawerRef,
        isHorizontal: isHorizontal2,
        drawerSize
      });
    }
  });
  exports["default"] = script2;
})(drawer_vue_vue_type_script_lang);
var drawer_vue_vue_type_template_id_e0557736_lang = {};
Object.defineProperty(drawer_vue_vue_type_template_id_e0557736_lang, "__esModule", { value: true });
var vue$1m = require$$0$1;
const _hoisted_1$I = ["aria-label"];
const _hoisted_2$w = {
  key: 0,
  id: "el-drawer__title",
  class: "el-drawer__header"
};
const _hoisted_3$q = ["title"];
const _hoisted_4$i = ["aria-label"];
const _hoisted_5$e = {
  key: 1,
  class: "el-drawer__body"
};
function render$X(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_close = vue$1m.resolveComponent("close");
  const _component_el_icon = vue$1m.resolveComponent("el-icon");
  const _component_el_overlay = vue$1m.resolveComponent("el-overlay");
  const _directive_trap_focus = vue$1m.resolveDirective("trap-focus");
  return vue$1m.openBlock(), vue$1m.createBlock(vue$1m.Teleport, {
    to: "body",
    disabled: !_ctx.appendToBody
  }, [
    vue$1m.createVNode(vue$1m.Transition, {
      name: "el-drawer-fade",
      onAfterEnter: _ctx.afterEnter,
      onAfterLeave: _ctx.afterLeave,
      onBeforeLeave: _ctx.beforeLeave
    }, {
      default: vue$1m.withCtx(() => [
        vue$1m.withDirectives(vue$1m.createVNode(_component_el_overlay, {
          mask: _ctx.modal,
          "overlay-class": _ctx.modalClass,
          "z-index": _ctx.zIndex,
          onClick: _ctx.onModalClick
        }, {
          default: vue$1m.withCtx(() => [
            vue$1m.withDirectives(vue$1m.createElementVNode("div", {
              ref: "drawerRef",
              "aria-modal": "true",
              "aria-labelledby": "el-drawer__title",
              "aria-label": _ctx.title,
              class: vue$1m.normalizeClass(["el-drawer", _ctx.direction, _ctx.visible && "open", _ctx.customClass]),
              style: vue$1m.normalizeStyle(_ctx.isHorizontal ? "width: " + _ctx.drawerSize : "height: " + _ctx.drawerSize),
              role: "dialog",
              onClick: _cache[1] || (_cache[1] = vue$1m.withModifiers(() => {
              }, ["stop"]))
            }, [
              _ctx.withHeader ? (vue$1m.openBlock(), vue$1m.createElementBlock("header", _hoisted_2$w, [
                vue$1m.renderSlot(_ctx.$slots, "title", {}, () => [
                  vue$1m.createElementVNode("span", {
                    role: "heading",
                    title: _ctx.title
                  }, vue$1m.toDisplayString(_ctx.title), 9, _hoisted_3$q)
                ]),
                _ctx.showClose ? (vue$1m.openBlock(), vue$1m.createElementBlock("button", {
                  key: 0,
                  "aria-label": "close " + (_ctx.title || "drawer"),
                  class: "el-drawer__close-btn",
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
                }, [
                  vue$1m.createVNode(_component_el_icon, { class: "el-drawer__close" }, {
                    default: vue$1m.withCtx(() => [
                      vue$1m.createVNode(_component_close)
                    ]),
                    _: 1
                  })
                ], 8, _hoisted_4$i)) : vue$1m.createCommentVNode("v-if", true)
              ])) : vue$1m.createCommentVNode("v-if", true),
              _ctx.rendered ? (vue$1m.openBlock(), vue$1m.createElementBlock("section", _hoisted_5$e, [
                vue$1m.renderSlot(_ctx.$slots, "default")
              ])) : vue$1m.createCommentVNode("v-if", true)
            ], 14, _hoisted_1$I), [
              [_directive_trap_focus]
            ])
          ]),
          _: 3
        }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
          [vue$1m.vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
  ], 8, ["disabled"]);
}
drawer_vue_vue_type_template_id_e0557736_lang.render = render$X;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var drawer_vue_vue_type_script_lang$1 = drawer_vue_vue_type_script_lang;
  var drawer_vue_vue_type_template_id_e0557736_lang$1 = drawer_vue_vue_type_template_id_e0557736_lang;
  drawer_vue_vue_type_script_lang$1["default"].render = drawer_vue_vue_type_template_id_e0557736_lang$1.render;
  drawer_vue_vue_type_script_lang$1["default"].__file = "packages/components/drawer/src/drawer.vue";
  exports["default"] = drawer_vue_vue_type_script_lang$1["default"];
})(drawer2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var drawer3 = drawer$1;
  var drawer_vue_vue_type_script_lang$1 = drawer_vue_vue_type_script_lang;
  const ElDrawer = withInstall2.withInstall(drawer_vue_vue_type_script_lang$1["default"]);
  exports.drawerEmits = drawer3.drawerEmits;
  exports.drawerProps = drawer3.drawerProps;
  exports.ElDrawer = ElDrawer;
  exports["default"] = ElDrawer;
})(drawer$2);
var dropdown = {};
var dropdown2 = {};
var dropdown_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = button$5;
  var index$22 = popper$3;
  var index$110 = scrollbar$3;
  var index$32 = icon$4;
  var dom2 = dom$8;
  var util2 = util$l;
  var iconsVue2 = require$$3;
  var defaults2 = defaults$d;
  var index$42 = useCommonProps;
  const { ButtonGroup: ElButtonGroup } = index2.ElButton;
  var script2 = vue2.defineComponent({
    name: "ElDropdown",
    components: {
      ElButton: index2.ElButton,
      ElButtonGroup,
      ElScrollbar: index$110.ElScrollbar,
      ElPopper: index$22["default"],
      ElIcon: index$32.ElIcon,
      ArrowDown: iconsVue2.ArrowDown
    },
    props: {
      trigger: {
        type: String,
        default: "hover"
      },
      type: String,
      size: {
        type: String,
        default: ""
      },
      splitButton: Boolean,
      hideOnClick: {
        type: Boolean,
        default: true
      },
      placement: {
        type: String,
        default: "bottom"
      },
      showTimeout: {
        type: Number,
        default: 150
      },
      hideTimeout: {
        type: Number,
        default: 150
      },
      tabindex: {
        type: [Number, String],
        default: 0
      },
      effect: {
        type: String,
        default: defaults2.Effect.LIGHT
      },
      maxHeight: {
        type: [Number, String],
        default: ""
      }
    },
    emits: ["visible-change", "click", "command"],
    setup(props2, { emit }) {
      const _instance = vue2.getCurrentInstance();
      const timeout = vue2.ref(null);
      const visible = vue2.ref(false);
      const scrollbar3 = vue2.ref(null);
      const wrapStyle = vue2.computed(() => ({
        maxHeight: util2.addUnit(props2.maxHeight)
      }));
      vue2.watch(() => visible.value, (val) => {
        if (val)
          triggerElmFocus();
        if (!val)
          triggerElmBlur();
        emit("visible-change", val);
      });
      const focusing = vue2.ref(false);
      vue2.watch(() => focusing.value, (val) => {
        const selfDefine = triggerElm.value;
        if (selfDefine) {
          if (val) {
            dom2.addClass(selfDefine, "focusing");
          } else {
            dom2.removeClass(selfDefine, "focusing");
          }
        }
      });
      const triggerVnode = vue2.ref(null);
      const triggerElm = vue2.computed(() => {
        var _a, _b, _c;
        const _2 = (_b = (_a = triggerVnode.value) == null ? void 0 : _a.$refs.triggerRef) == null ? void 0 : _b.children[0];
        return !props2.splitButton ? _2 : (_c = _2 == null ? void 0 : _2.children) == null ? void 0 : _c[1];
      });
      function handleClick() {
        var _a;
        if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
          return;
        if (visible.value) {
          hide2();
        } else {
          show();
        }
      }
      function show() {
        var _a;
        if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
          return;
        timeout.value && clearTimeout(timeout.value);
        timeout.value = window.setTimeout(() => {
          visible.value = true;
        }, ["click", "contextmenu"].includes(props2.trigger) ? 0 : props2.showTimeout);
      }
      function hide2() {
        var _a;
        if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
          return;
        removeTabindex();
        if (props2.tabindex >= 0) {
          resetTabindex(triggerElm.value);
        }
        clearTimeout(timeout.value);
        timeout.value = window.setTimeout(() => {
          visible.value = false;
        }, ["click", "contextmenu"].includes(props2.trigger) ? 0 : props2.hideTimeout);
      }
      function removeTabindex() {
        var _a;
        (_a = triggerElm.value) == null ? void 0 : _a.setAttribute("tabindex", "-1");
      }
      function resetTabindex(ele) {
        removeTabindex();
        ele == null ? void 0 : ele.setAttribute("tabindex", "0");
      }
      function triggerElmFocus() {
        var _a, _b;
        (_b = (_a = triggerElm.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      }
      function triggerElmBlur() {
        var _a, _b;
        (_b = (_a = triggerElm.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
      }
      const dropdownSize = index$42.useSize();
      function commandHandler(...args) {
        emit("command", ...args);
      }
      vue2.provide("elDropdown", {
        instance: _instance,
        dropdownSize,
        visible,
        handleClick,
        commandHandler,
        show,
        hide: hide2,
        trigger: vue2.computed(() => props2.trigger),
        hideOnClick: vue2.computed(() => props2.hideOnClick),
        triggerElm
      });
      vue2.onMounted(() => {
        if (!props2.splitButton) {
          dom2.on(triggerElm.value, "focus", () => {
            focusing.value = true;
          });
          dom2.on(triggerElm.value, "blur", () => {
            focusing.value = false;
          });
          dom2.on(triggerElm.value, "click", () => {
            focusing.value = false;
          });
        }
        if (props2.trigger === "hover") {
          dom2.on(triggerElm.value, "mouseenter", show);
          dom2.on(triggerElm.value, "mouseleave", hide2);
        } else if (props2.trigger === "click") {
          dom2.on(triggerElm.value, "click", handleClick);
        } else if (props2.trigger === "contextmenu") {
          dom2.on(triggerElm.value, "contextmenu", (e) => {
            e.preventDefault();
            handleClick();
          });
        }
        Object.assign(_instance, {
          handleClick,
          hide: hide2,
          resetTabindex
        });
      });
      const handlerMainButtonClick = (event) => {
        emit("click", event);
        hide2();
      };
      return {
        visible,
        scrollbar: scrollbar3,
        wrapStyle,
        dropdownSize,
        handlerMainButtonClick,
        triggerVnode
      };
    }
  });
  exports["default"] = script2;
})(dropdown_vue_vue_type_script_lang);
var dropdown_vue_vue_type_template_id_3ed790a5_lang = {};
Object.defineProperty(dropdown_vue_vue_type_template_id_3ed790a5_lang, "__esModule", { value: true });
var vue$1l = require$$0$1;
const _hoisted_1$H = { class: "el-dropdown" };
function render$W(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = vue$1l.resolveComponent("el-scrollbar");
  const _component_el_button = vue$1l.resolveComponent("el-button");
  const _component_arrow_down = vue$1l.resolveComponent("arrow-down");
  const _component_el_icon = vue$1l.resolveComponent("el-icon");
  const _component_el_button_group = vue$1l.resolveComponent("el-button-group");
  const _component_el_popper = vue$1l.resolveComponent("el-popper");
  return vue$1l.openBlock(), vue$1l.createElementBlock("div", _hoisted_1$H, [
    vue$1l.createVNode(_component_el_popper, {
      ref: "triggerVnode",
      visible: _ctx.visible,
      "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.visible = $event),
      placement: _ctx.placement,
      "fallback-placements": ["bottom", "top", "right", "left"],
      effect: _ctx.effect,
      pure: "",
      "manual-mode": true,
      trigger: [_ctx.trigger],
      "popper-class": "el-dropdown__popper",
      "append-to-body": "",
      transition: "el-zoom-in-top",
      "stop-popper-mouse-event": false,
      "gpu-acceleration": false
    }, {
      default: vue$1l.withCtx(() => [
        vue$1l.createVNode(_component_el_scrollbar, {
          ref: "scrollbar",
          tag: "ul",
          "wrap-style": _ctx.wrapStyle,
          "view-class": "el-dropdown__list"
        }, {
          default: vue$1l.withCtx(() => [
            vue$1l.renderSlot(_ctx.$slots, "dropdown")
          ]),
          _: 3
        }, 8, ["wrap-style"])
      ]),
      trigger: vue$1l.withCtx(() => [
        vue$1l.createElementVNode("div", {
          class: vue$1l.normalizeClass([_ctx.dropdownSize ? "el-dropdown--" + _ctx.dropdownSize : ""])
        }, [
          !_ctx.splitButton ? vue$1l.renderSlot(_ctx.$slots, "default", { key: 0 }) : (vue$1l.openBlock(), vue$1l.createBlock(_component_el_button_group, { key: 1 }, {
            default: vue$1l.withCtx(() => [
              vue$1l.createVNode(_component_el_button, {
                size: _ctx.dropdownSize,
                type: _ctx.type,
                onClick: _ctx.handlerMainButtonClick
              }, {
                default: vue$1l.withCtx(() => [
                  vue$1l.renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["size", "type", "onClick"]),
              vue$1l.createVNode(_component_el_button, {
                size: _ctx.dropdownSize,
                type: _ctx.type,
                class: "el-dropdown__caret-button"
              }, {
                default: vue$1l.withCtx(() => [
                  vue$1l.createVNode(_component_el_icon, { class: "el-dropdown__icon" }, {
                    default: vue$1l.withCtx(() => [
                      vue$1l.createVNode(_component_arrow_down)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["size", "type"])
            ]),
            _: 3
          }))
        ], 2)
      ]),
      _: 3
    }, 8, ["visible", "placement", "effect", "trigger"])
  ]);
}
dropdown_vue_vue_type_template_id_3ed790a5_lang.render = render$W;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dropdown_vue_vue_type_script_lang$1 = dropdown_vue_vue_type_script_lang;
  var dropdown_vue_vue_type_template_id_3ed790a5_lang$1 = dropdown_vue_vue_type_template_id_3ed790a5_lang;
  dropdown_vue_vue_type_script_lang$1["default"].render = dropdown_vue_vue_type_template_id_3ed790a5_lang$1.render;
  dropdown_vue_vue_type_script_lang$1["default"].__file = "packages/components/dropdown/src/dropdown.vue";
  exports["default"] = dropdown_vue_vue_type_script_lang$1["default"];
})(dropdown2);
var dropdownItem = {};
var dropdownItem_vue_vue_type_script_lang = {};
var useDropdown$1 = {};
Object.defineProperty(useDropdown$1, "__esModule", { value: true });
var vue$1k = require$$0$1;
var util$b = util$l;
var aria$2 = aria$5;
var dom$5 = dom$8;
const useDropdown = () => {
  const elDropdown = vue$1k.inject("elDropdown", {});
  const _elDropdownSize = vue$1k.computed(() => elDropdown == null ? void 0 : elDropdown.dropdownSize);
  return {
    elDropdown,
    _elDropdownSize
  };
};
const initDropdownDomEvent = (dropdownChildren, triggerElm, _instance) => {
  const menuItems = vue$1k.ref(null);
  const menuItemsArray = vue$1k.ref(null);
  const dropdownElm = vue$1k.ref(null);
  const listId = vue$1k.ref(`dropdown-menu-${util$b.generateId()}`);
  dropdownElm.value = dropdownChildren == null ? void 0 : dropdownChildren.subTree.el;
  function removeTabindex() {
    var _a;
    triggerElm.setAttribute("tabindex", "-1");
    (_a = menuItemsArray.value) == null ? void 0 : _a.forEach((item2) => {
      item2.setAttribute("tabindex", "-1");
    });
  }
  function resetTabindex(ele) {
    removeTabindex();
    ele == null ? void 0 : ele.setAttribute("tabindex", "0");
  }
  function handleTriggerKeyDown(ev) {
    const code2 = ev.code;
    if ([aria$2.EVENT_CODE.up, aria$2.EVENT_CODE.down].includes(code2)) {
      removeTabindex();
      resetTabindex(menuItems.value[0]);
      menuItems.value[0].focus();
      ev.preventDefault();
      ev.stopPropagation();
    } else if (code2 === aria$2.EVENT_CODE.enter) {
      _instance.handleClick();
    } else if ([aria$2.EVENT_CODE.tab, aria$2.EVENT_CODE.esc].includes(code2)) {
      _instance.hide();
    }
  }
  function handleItemKeyDown(ev) {
    const code2 = ev.code;
    const target2 = ev.target;
    const currentIndex = menuItemsArray.value.indexOf(target2);
    const max2 = menuItemsArray.value.length - 1;
    let nextIndex;
    if ([aria$2.EVENT_CODE.up, aria$2.EVENT_CODE.down].includes(code2)) {
      if (code2 === aria$2.EVENT_CODE.up) {
        nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
      } else {
        nextIndex = currentIndex < max2 ? currentIndex + 1 : max2;
      }
      removeTabindex();
      resetTabindex(menuItems.value[nextIndex]);
      menuItems.value[nextIndex].focus();
      ev.preventDefault();
      ev.stopPropagation();
    } else if (code2 === aria$2.EVENT_CODE.enter) {
      triggerElmFocus();
      target2.click();
      if (_instance.props.hideOnClick) {
        _instance.hide();
      }
    } else if ([aria$2.EVENT_CODE.tab, aria$2.EVENT_CODE.esc].includes(code2)) {
      _instance.hide();
      triggerElmFocus();
    }
  }
  function initAria() {
    dropdownElm.value.setAttribute("id", listId.value);
    triggerElm.setAttribute("aria-haspopup", "list");
    triggerElm.setAttribute("aria-controls", listId.value);
    if (!_instance.props.splitButton) {
      triggerElm.setAttribute("role", "button");
      triggerElm.setAttribute("tabindex", _instance.props.tabindex);
      dom$5.addClass(triggerElm, "el-dropdown-selfdefine");
    }
  }
  function initEvent() {
    dom$5.on(triggerElm, "keydown", handleTriggerKeyDown);
    dom$5.on(dropdownElm.value, "keydown", handleItemKeyDown, true);
  }
  function initDomOperation() {
    menuItems.value = dropdownElm.value.querySelectorAll("[tabindex='-1']");
    menuItemsArray.value = [].slice.call(menuItems.value);
    initEvent();
    initAria();
  }
  function triggerElmFocus() {
    triggerElm.focus();
  }
  initDomOperation();
};
useDropdown$1.initDropdownDomEvent = initDropdownDomEvent;
useDropdown$1.useDropdown = useDropdown;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var props2 = props$N;
  var useDropdown2 = useDropdown$1;
  var script2 = vue2.defineComponent({
    name: "ElDropdownItem",
    components: { ElIcon: index2.ElIcon },
    props: props2.buildProps({
      command: {
        type: [Object, String, Number],
        default: () => ({})
      },
      disabled: Boolean,
      divided: Boolean,
      icon: {
        type: props2.definePropType([String, Object])
      }
    }),
    setup(props3) {
      const { elDropdown } = useDropdown2.useDropdown();
      const _instance = vue2.getCurrentInstance();
      function handleClick(e) {
        var _a, _b;
        if (props3.disabled) {
          e.stopImmediatePropagation();
          return;
        }
        if (elDropdown.hideOnClick.value) {
          (_a = elDropdown.handleClick) == null ? void 0 : _a.call(elDropdown);
        }
        (_b = elDropdown.commandHandler) == null ? void 0 : _b.call(elDropdown, props3.command, _instance, e);
      }
      return {
        handleClick
      };
    }
  });
  exports["default"] = script2;
})(dropdownItem_vue_vue_type_script_lang);
var dropdownItem_vue_vue_type_template_id_396ed16b_lang = {};
Object.defineProperty(dropdownItem_vue_vue_type_template_id_396ed16b_lang, "__esModule", { value: true });
var vue$1j = require$$0$1;
const _hoisted_1$G = ["aria-disabled", "tabindex"];
function render$V(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$1j.resolveComponent("el-icon");
  return vue$1j.openBlock(), vue$1j.createElementBlock("li", {
    class: vue$1j.normalizeClass(["el-dropdown-menu__item", {
      "is-disabled": _ctx.disabled,
      "el-dropdown-menu__item--divided": _ctx.divided
    }]),
    "aria-disabled": _ctx.disabled,
    tabindex: _ctx.disabled ? null : -1,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.icon ? (vue$1j.openBlock(), vue$1j.createBlock(_component_el_icon, { key: 0 }, {
      default: vue$1j.withCtx(() => [
        (vue$1j.openBlock(), vue$1j.createBlock(vue$1j.resolveDynamicComponent(_ctx.icon)))
      ]),
      _: 1
    })) : vue$1j.createCommentVNode("v-if", true),
    vue$1j.renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_1$G);
}
dropdownItem_vue_vue_type_template_id_396ed16b_lang.render = render$V;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dropdownItem_vue_vue_type_script_lang$1 = dropdownItem_vue_vue_type_script_lang;
  var dropdownItem_vue_vue_type_template_id_396ed16b_lang$1 = dropdownItem_vue_vue_type_template_id_396ed16b_lang;
  dropdownItem_vue_vue_type_script_lang$1["default"].render = dropdownItem_vue_vue_type_template_id_396ed16b_lang$1.render;
  dropdownItem_vue_vue_type_script_lang$1["default"].__file = "packages/components/dropdown/src/dropdown-item.vue";
  exports["default"] = dropdownItem_vue_vue_type_script_lang$1["default"];
})(dropdownItem);
var dropdownMenu = {};
var dropdownMenu_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var useDropdown2 = useDropdown$1;
  var index2 = clickOutside;
  var script2 = vue2.defineComponent({
    name: "ElDropdownMenu",
    directives: {
      ClickOutside: index2["default"]
    },
    setup() {
      const { _elDropdownSize, elDropdown } = useDropdown2.useDropdown();
      const size2 = _elDropdownSize.value;
      function show() {
        var _a;
        if (["click", "contextmenu"].includes(elDropdown.trigger.value))
          return;
        (_a = elDropdown.show) == null ? void 0 : _a.call(elDropdown);
      }
      function hide2() {
        if (["click", "contextmenu"].includes(elDropdown.trigger.value))
          return;
        _hide();
      }
      function _hide() {
        var _a;
        (_a = elDropdown.hide) == null ? void 0 : _a.call(elDropdown);
      }
      vue2.onMounted(() => {
        const dropdownMenu2 = vue2.getCurrentInstance();
        useDropdown2.initDropdownDomEvent(dropdownMenu2, elDropdown.triggerElm.value, elDropdown.instance);
      });
      return {
        size: size2,
        show,
        hide: hide2,
        innerHide: _hide,
        triggerElm: elDropdown.triggerElm
      };
    }
  });
  exports["default"] = script2;
})(dropdownMenu_vue_vue_type_script_lang);
var dropdownMenu_vue_vue_type_template_id_617b3492_lang = {};
Object.defineProperty(dropdownMenu_vue_vue_type_template_id_617b3492_lang, "__esModule", { value: true });
var vue$1i = require$$0$1;
function render$U(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_clickOutside = vue$1i.resolveDirective("clickOutside");
  return vue$1i.withDirectives((vue$1i.openBlock(), vue$1i.createElementBlock("ul", {
    class: vue$1i.normalizeClass([[_ctx.size && `el-dropdown-menu--${_ctx.size}`], "el-dropdown-menu"]),
    onMouseenter: _cache[0] || (_cache[0] = vue$1i.withModifiers((...args) => _ctx.show && _ctx.show(...args), ["stop"])),
    onMouseleave: _cache[1] || (_cache[1] = vue$1i.withModifiers((...args) => _ctx.hide && _ctx.hide(...args), ["stop"]))
  }, [
    vue$1i.renderSlot(_ctx.$slots, "default")
  ], 34)), [
    [_directive_clickOutside, _ctx.innerHide, _ctx.triggerElm]
  ]);
}
dropdownMenu_vue_vue_type_template_id_617b3492_lang.render = render$U;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dropdownMenu_vue_vue_type_script_lang$1 = dropdownMenu_vue_vue_type_script_lang;
  var dropdownMenu_vue_vue_type_template_id_617b3492_lang$1 = dropdownMenu_vue_vue_type_template_id_617b3492_lang;
  dropdownMenu_vue_vue_type_script_lang$1["default"].render = dropdownMenu_vue_vue_type_template_id_617b3492_lang$1.render;
  dropdownMenu_vue_vue_type_script_lang$1["default"].__file = "packages/components/dropdown/src/dropdown-menu.vue";
  exports["default"] = dropdownMenu_vue_vue_type_script_lang$1["default"];
})(dropdownMenu);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var dropdown_vue_vue_type_script_lang$1 = dropdown_vue_vue_type_script_lang;
  var dropdownItem_vue_vue_type_script_lang$1 = dropdownItem_vue_vue_type_script_lang;
  var dropdownMenu_vue_vue_type_script_lang$1 = dropdownMenu_vue_vue_type_script_lang;
  const ElDropdown = withInstall2.withInstall(dropdown_vue_vue_type_script_lang$1["default"], {
    DropdownItem: dropdownItem_vue_vue_type_script_lang$1["default"],
    DropdownMenu: dropdownMenu_vue_vue_type_script_lang$1["default"]
  });
  const ElDropdownItem = withInstall2.withNoopInstall(dropdownItem_vue_vue_type_script_lang$1["default"]);
  const ElDropdownMenu = withInstall2.withNoopInstall(dropdownMenu_vue_vue_type_script_lang$1["default"]);
  exports.ElDropdown = ElDropdown;
  exports.ElDropdownItem = ElDropdownItem;
  exports.ElDropdownMenu = ElDropdownMenu;
  exports["default"] = ElDropdown;
})(dropdown);
var empty$2 = {};
var empty2 = {};
var empty_vue_vue_type_script_lang = {};
var imgEmpty = {};
var imgEmpty_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  let id = 0;
  var script2 = vue2.defineComponent({
    name: "ImgEmpty",
    setup() {
      return {
        id: ++id
      };
    }
  });
  exports["default"] = script2;
})(imgEmpty_vue_vue_type_script_lang);
var imgEmpty_vue_vue_type_template_id_61c77d3e_lang = {};
Object.defineProperty(imgEmpty_vue_vue_type_template_id_61c77d3e_lang, "__esModule", { value: true });
var vue$1h = require$$0$1;
const _hoisted_1$F = {
  viewBox: "0 0 79 86",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$v = ["id"];
const _hoisted_3$p = /* @__PURE__ */ vue$1h.createElementVNode("stop", {
  "stop-color": "#FCFCFD",
  offset: "0%"
}, null, -1);
const _hoisted_4$h = /* @__PURE__ */ vue$1h.createElementVNode("stop", {
  "stop-color": "#EEEFF3",
  offset: "100%"
}, null, -1);
const _hoisted_5$d = [
  _hoisted_3$p,
  _hoisted_4$h
];
const _hoisted_6$a = ["id"];
const _hoisted_7$6 = /* @__PURE__ */ vue$1h.createElementVNode("stop", {
  "stop-color": "#FCFCFD",
  offset: "0%"
}, null, -1);
const _hoisted_8$5 = /* @__PURE__ */ vue$1h.createElementVNode("stop", {
  "stop-color": "#E9EBEF",
  offset: "100%"
}, null, -1);
const _hoisted_9$3 = [
  _hoisted_7$6,
  _hoisted_8$5
];
const _hoisted_10$3 = ["id"];
const _hoisted_11 = {
  id: "Illustrations",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
};
const _hoisted_12 = {
  id: "B-type",
  transform: "translate(-1268.000000, -535.000000)"
};
const _hoisted_13 = {
  id: "Group-2",
  transform: "translate(1268.000000, 535.000000)"
};
const _hoisted_14 = /* @__PURE__ */ vue$1h.createElementVNode("path", {
  id: "Oval-Copy-2",
  d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
  fill: "#F7F8FC"
}, null, -1);
const _hoisted_15 = /* @__PURE__ */ vue$1h.createElementVNode("polygon", {
  id: "Rectangle-Copy-14",
  fill: "#E5E7E9",
  transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
  points: "13 58 53 58 42 45 2 45"
}, null, -1);
const _hoisted_16 = {
  id: "Group-Copy",
  transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
};
const _hoisted_17 = /* @__PURE__ */ vue$1h.createElementVNode("polygon", {
  id: "Rectangle-Copy-10",
  fill: "#E5E7E9",
  transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
  points: "2.84078316e-14 3 18 3 23 7 5 7"
}, null, -1);
const _hoisted_18 = /* @__PURE__ */ vue$1h.createElementVNode("polygon", {
  id: "Rectangle-Copy-11",
  fill: "#EDEEF2",
  points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
}, null, -1);
const _hoisted_19 = ["fill"];
const _hoisted_20 = /* @__PURE__ */ vue$1h.createElementVNode("polygon", {
  id: "Rectangle-Copy-13",
  fill: "#F8F9FB",
  transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
  points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
}, null, -1);
const _hoisted_21 = ["fill"];
const _hoisted_22 = {
  id: "Rectangle-Copy-17",
  transform: "translate(53.000000, 45.000000)"
};
const _hoisted_23 = ["id"];
const _hoisted_24 = ["xlink:href"];
const _hoisted_25 = ["xlink:href"];
const _hoisted_26 = ["mask"];
const _hoisted_27 = /* @__PURE__ */ vue$1h.createElementVNode("polygon", {
  id: "Rectangle-Copy-18",
  fill: "#F8F9FB",
  transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
  points: "62 45 79 45 70 58 53 58"
}, null, -1);
function render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1h.openBlock(), vue$1h.createElementBlock("svg", _hoisted_1$F, [
    vue$1h.createElementVNode("defs", null, [
      vue$1h.createElementVNode("linearGradient", {
        id: `linearGradient-1-${_ctx.id}`,
        x1: "38.8503086%",
        y1: "0%",
        x2: "61.1496914%",
        y2: "100%"
      }, _hoisted_5$d, 8, _hoisted_2$v),
      vue$1h.createElementVNode("linearGradient", {
        id: `linearGradient-2-${_ctx.id}`,
        x1: "0%",
        y1: "9.5%",
        x2: "100%",
        y2: "90.5%"
      }, _hoisted_9$3, 8, _hoisted_6$a),
      vue$1h.createElementVNode("rect", {
        id: `path-3-${_ctx.id}`,
        x: "0",
        y: "0",
        width: "17",
        height: "36"
      }, null, 8, _hoisted_10$3)
    ]),
    vue$1h.createElementVNode("g", _hoisted_11, [
      vue$1h.createElementVNode("g", _hoisted_12, [
        vue$1h.createElementVNode("g", _hoisted_13, [
          _hoisted_14,
          _hoisted_15,
          vue$1h.createElementVNode("g", _hoisted_16, [
            _hoisted_17,
            _hoisted_18,
            vue$1h.createElementVNode("rect", {
              id: "Rectangle-Copy-12",
              fill: `url(#linearGradient-1-${_ctx.id})`,
              transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
              x: "38",
              y: "7",
              width: "17",
              height: "36"
            }, null, 8, _hoisted_19),
            _hoisted_20
          ]),
          vue$1h.createElementVNode("rect", {
            id: "Rectangle-Copy-15",
            fill: `url(#linearGradient-2-${_ctx.id})`,
            x: "13",
            y: "45",
            width: "40",
            height: "36"
          }, null, 8, _hoisted_21),
          vue$1h.createElementVNode("g", _hoisted_22, [
            vue$1h.createElementVNode("mask", {
              id: `mask-4-${_ctx.id}`,
              fill: "white"
            }, [
              vue$1h.createElementVNode("use", {
                "xlink:href": `#path-3-${_ctx.id}`
              }, null, 8, _hoisted_24)
            ], 8, _hoisted_23),
            vue$1h.createElementVNode("use", {
              id: "Mask",
              fill: "#E0E3E9",
              transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
              "xlink:href": `#path-3-${_ctx.id}`
            }, null, 8, _hoisted_25),
            vue$1h.createElementVNode("polygon", {
              id: "Rectangle-Copy",
              fill: "#D5D7DE",
              mask: `url(#mask-4-${_ctx.id})`,
              transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
              points: "7 0 24 0 20 18 -1.70530257e-13 16"
            }, null, 8, _hoisted_26)
          ]),
          _hoisted_27
        ])
      ])
    ])
  ]);
}
imgEmpty_vue_vue_type_template_id_61c77d3e_lang.render = render$T;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var imgEmpty_vue_vue_type_script_lang$1 = imgEmpty_vue_vue_type_script_lang;
  var imgEmpty_vue_vue_type_template_id_61c77d3e_lang$1 = imgEmpty_vue_vue_type_template_id_61c77d3e_lang;
  imgEmpty_vue_vue_type_script_lang$1["default"].render = imgEmpty_vue_vue_type_template_id_61c77d3e_lang$1.render;
  imgEmpty_vue_vue_type_script_lang$1["default"].__file = "packages/components/empty/src/img-empty.vue";
  exports["default"] = imgEmpty_vue_vue_type_script_lang$1["default"];
})(imgEmpty);
var empty$1 = {};
Object.defineProperty(empty$1, "__esModule", { value: true });
const emptyProps = {
  image: {
    type: String,
    default: ""
  },
  imageSize: Number,
  description: {
    type: String,
    default: ""
  }
};
empty$1.emptyProps = emptyProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var empty3 = empty$1;
  var imgEmpty_vue_vue_type_script_lang$1 = imgEmpty_vue_vue_type_script_lang;
  var index2 = useLocale$1;
  var script2 = vue2.defineComponent({
    name: "ElEmpty",
    components: {
      ImgEmpty: imgEmpty_vue_vue_type_script_lang$1["default"]
    },
    props: empty3.emptyProps,
    setup(props2) {
      const { t } = index2.useLocale();
      const emptyDescription = vue2.computed(() => props2.description || t("el.table.emptyText"));
      const imageStyle = vue2.computed(() => ({
        width: props2.imageSize ? `${props2.imageSize}px` : ""
      }));
      return {
        emptyDescription,
        imageStyle
      };
    }
  });
  exports["default"] = script2;
})(empty_vue_vue_type_script_lang);
var empty_vue_vue_type_template_id_10d211eb_lang = {};
Object.defineProperty(empty_vue_vue_type_template_id_10d211eb_lang, "__esModule", { value: true });
var vue$1g = require$$0$1;
const _hoisted_1$E = { class: "el-empty" };
const _hoisted_2$u = ["src"];
const _hoisted_3$o = { class: "el-empty__description" };
const _hoisted_4$g = { key: 1 };
const _hoisted_5$c = {
  key: 0,
  class: "el-empty__bottom"
};
function render$S(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_img_empty = vue$1g.resolveComponent("img-empty");
  return vue$1g.openBlock(), vue$1g.createElementBlock("div", _hoisted_1$E, [
    vue$1g.createElementVNode("div", {
      class: "el-empty__image",
      style: vue$1g.normalizeStyle(_ctx.imageStyle)
    }, [
      _ctx.image ? (vue$1g.openBlock(), vue$1g.createElementBlock("img", {
        key: 0,
        src: _ctx.image,
        ondragstart: "return false"
      }, null, 8, _hoisted_2$u)) : vue$1g.renderSlot(_ctx.$slots, "image", { key: 1 }, () => [
        vue$1g.createVNode(_component_img_empty)
      ])
    ], 4),
    vue$1g.createElementVNode("div", _hoisted_3$o, [
      _ctx.$slots.description ? vue$1g.renderSlot(_ctx.$slots, "description", { key: 0 }) : (vue$1g.openBlock(), vue$1g.createElementBlock("p", _hoisted_4$g, vue$1g.toDisplayString(_ctx.emptyDescription), 1))
    ]),
    _ctx.$slots.default ? (vue$1g.openBlock(), vue$1g.createElementBlock("div", _hoisted_5$c, [
      vue$1g.renderSlot(_ctx.$slots, "default")
    ])) : vue$1g.createCommentVNode("v-if", true)
  ]);
}
empty_vue_vue_type_template_id_10d211eb_lang.render = render$S;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var empty_vue_vue_type_script_lang$1 = empty_vue_vue_type_script_lang;
  var empty_vue_vue_type_template_id_10d211eb_lang$1 = empty_vue_vue_type_template_id_10d211eb_lang;
  empty_vue_vue_type_script_lang$1["default"].render = empty_vue_vue_type_template_id_10d211eb_lang$1.render;
  empty_vue_vue_type_script_lang$1["default"].__file = "packages/components/empty/src/empty.vue";
  exports["default"] = empty_vue_vue_type_script_lang$1["default"];
})(empty2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var empty3 = empty$1;
  var empty_vue_vue_type_script_lang$1 = empty_vue_vue_type_script_lang;
  const ElEmpty = withInstall2.withInstall(empty_vue_vue_type_script_lang$1["default"]);
  exports.emptyProps = empty3.emptyProps;
  exports.ElEmpty = ElEmpty;
  exports["default"] = ElEmpty;
})(empty$2);
var form$3 = {};
var form$2 = {};
var form_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var error2 = error$5;
  var form2 = form$7;
  function useFormLabelWidth() {
    const potentialLabelWidthArr = vue2.ref([]);
    const autoLabelWidth = vue2.computed(() => {
      if (!potentialLabelWidthArr.value.length)
        return "0";
      const max2 = Math.max(...potentialLabelWidthArr.value);
      return max2 ? `${max2}px` : "";
    });
    function getLabelWidthIndex(width) {
      const index2 = potentialLabelWidthArr.value.indexOf(width);
      if (index2 === -1) {
        error2.debugWarn("Form", `unexpected width ${width}`);
      }
      return index2;
    }
    function registerLabelWidth(val, oldVal) {
      if (val && oldVal) {
        const index2 = getLabelWidthIndex(oldVal);
        potentialLabelWidthArr.value.splice(index2, 1, val);
      } else if (val) {
        potentialLabelWidthArr.value.push(val);
      }
    }
    function deregisterLabelWidth(val) {
      const index2 = getLabelWidthIndex(val);
      index2 > -1 && potentialLabelWidthArr.value.splice(index2, 1);
    }
    return {
      autoLabelWidth,
      registerLabelWidth,
      deregisterLabelWidth
    };
  }
  var script2 = vue2.defineComponent({
    name: "ElForm",
    props: {
      model: Object,
      rules: Object,
      labelPosition: String,
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      labelSuffix: {
        type: String,
        default: ""
      },
      inline: Boolean,
      inlineMessage: Boolean,
      statusIcon: Boolean,
      showMessage: {
        type: Boolean,
        default: true
      },
      size: String,
      disabled: Boolean,
      validateOnRuleChange: {
        type: Boolean,
        default: true
      },
      hideRequiredAsterisk: {
        type: Boolean,
        default: false
      },
      scrollToError: Boolean
    },
    emits: ["validate"],
    setup(props2, { emit }) {
      const fields = [];
      vue2.watch(() => props2.rules, () => {
        fields.forEach((field) => {
          field.evaluateValidationEnabled();
        });
        if (props2.validateOnRuleChange) {
          validate(() => ({}));
        }
      });
      const addField = (field) => {
        if (field) {
          fields.push(field);
        }
      };
      const removeField = (field) => {
        if (field.prop) {
          fields.splice(fields.indexOf(field), 1);
        }
      };
      const resetFields = () => {
        if (!props2.model) {
          error2.debugWarn("Form", "model is required for resetFields to work.");
          return;
        }
        fields.forEach((field) => {
          field.resetField();
        });
      };
      const clearValidate = (props22 = []) => {
        const fds = props22.length ? typeof props22 === "string" ? fields.filter((field) => props22 === field.prop) : fields.filter((field) => props22.indexOf(field.prop) > -1) : fields;
        fds.forEach((field) => {
          field.clearValidate();
        });
      };
      const validate = (callback) => {
        if (!props2.model) {
          error2.debugWarn("Form", "model is required for validate to work!");
          return;
        }
        let promise;
        if (typeof callback !== "function") {
          promise = new Promise((resolve2, reject) => {
            callback = function(valid2, invalidFields2) {
              if (valid2) {
                resolve2(true);
              } else {
                reject(invalidFields2);
              }
            };
          });
        }
        if (fields.length === 0) {
          callback(true);
        }
        let valid = true;
        let count = 0;
        let invalidFields = {};
        let firstInvalidFields;
        for (const field of fields) {
          field.validate("", (message3, field2) => {
            if (message3) {
              valid = false;
              firstInvalidFields || (firstInvalidFields = field2);
            }
            invalidFields = __spreadValues(__spreadValues({}, invalidFields), field2);
            if (++count === fields.length) {
              callback(valid, invalidFields);
            }
          });
        }
        if (!valid && props2.scrollToError) {
          scrollToField(Object.keys(firstInvalidFields)[0]);
        }
        return promise;
      };
      const validateField = (props22, cb) => {
        props22 = [].concat(props22);
        const fds = fields.filter((field) => props22.indexOf(field.prop) !== -1);
        if (!fields.length) {
          error2.debugWarn("Form", "please pass correct props!");
          return;
        }
        fds.forEach((field) => {
          field.validate("", cb);
        });
      };
      const scrollToField = (prop) => {
        fields.forEach((item2) => {
          if (item2.prop === prop) {
            item2.$el.scrollIntoView();
          }
        });
      };
      const elForm = vue2.reactive(__spreadValues(__spreadProps(__spreadValues({}, vue2.toRefs(props2)), {
        resetFields,
        clearValidate,
        validateField,
        emit,
        addField,
        removeField
      }), useFormLabelWidth()));
      vue2.provide(form2.elFormKey, elForm);
      return {
        validate,
        resetFields,
        clearValidate,
        validateField,
        scrollToField
      };
    }
  });
  exports["default"] = script2;
})(form_vue_vue_type_script_lang);
var form_vue_vue_type_template_id_602d6cf6_lang = {};
Object.defineProperty(form_vue_vue_type_template_id_602d6cf6_lang, "__esModule", { value: true });
var vue$1f = require$$0$1;
function render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$1f.openBlock(), vue$1f.createElementBlock("form", {
    class: vue$1f.normalizeClass(["el-form", [
      _ctx.labelPosition ? "el-form--label-" + _ctx.labelPosition : "",
      { "el-form--inline": _ctx.inline }
    ]])
  }, [
    vue$1f.renderSlot(_ctx.$slots, "default")
  ], 2);
}
form_vue_vue_type_template_id_602d6cf6_lang.render = render$R;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var form_vue_vue_type_script_lang$1 = form_vue_vue_type_script_lang;
  var form_vue_vue_type_template_id_602d6cf6_lang$1 = form_vue_vue_type_template_id_602d6cf6_lang;
  form_vue_vue_type_script_lang$1["default"].render = form_vue_vue_type_template_id_602d6cf6_lang$1.render;
  form_vue_vue_type_script_lang$1["default"].__file = "packages/components/form/src/form.vue";
  exports["default"] = form_vue_vue_type_script_lang$1["default"];
})(form$2);
var formItem = {};
var formItem_vue_vue_type_script_lang = {};
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key2 in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key2)) {
          target2[key2] = source2[key2];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn3) {
  return Function.toString.call(fn3).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning = function warning2() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e) {
        return typeof e === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error2) {
    var field = error2.field;
    fields[field] = fields[field] || [];
    fields[field].push(error2);
  });
  return fields;
}
function format(template2) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template2 === "function") {
    return template2.apply(null, args);
  }
  if (typeof template2 === "string") {
    var str = template2.replace(formatRegExp, function(x2) {
      if (x2 === "%%") {
        return "%";
      }
      if (i >= len) {
        return x2;
      }
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_2) {
            return "[Circular]";
          }
          break;
        default:
          return x2;
      }
    });
    return str;
  }
  return template2;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total2 = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total2++;
    if (total2 === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a2) {
    func(a2, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next2);
    } else {
      callback([]);
    }
  }
  next2([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, objArr[k] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option2, func, callback, source2) {
  if (option2.first) {
    var _pending = new Promise(function(resolve2, reject) {
      var next2 = function next3(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source2);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    _pending["catch"](function(e) {
      return e;
    });
    return _pending;
  }
  var firstFields = option2.firstFields === true ? Object.keys(objArr) : option2.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total2 = 0;
  var results = [];
  var pending = new Promise(function(resolve2, reject) {
    var next2 = function next3(errors) {
      results.push.apply(results, errors);
      total2++;
      if (total2 === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source2);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve2(source2);
    }
    objArrKeys.forEach(function(key2) {
      var arr = objArr[key2];
      if (firstFields.indexOf(key2) !== -1) {
        asyncSerialArray(arr, func, next2);
      } else {
        asyncParallelArray(arr, func, next2);
      }
    });
  });
  pending["catch"](function(e) {
    return e;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue(value, path) {
  var v2 = value;
  for (var i = 0; i < path.length; i++) {
    if (v2 == void 0) {
      return v2;
    }
    v2 = v2[path[i]];
  }
  return v2;
}
function complementError(rule, source2) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue(source2, rule.fullFields);
    } else {
      fieldValue = source2[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target2, source2) {
  if (source2) {
    for (var s2 in source2) {
      if (source2.hasOwnProperty(s2)) {
        var value = source2[s2];
        if (typeof value === "object" && typeof target2[s2] === "object") {
          target2[s2] = _extends({}, target2[s2], value);
        } else {
          target2[s2] = value;
        }
      }
    }
  }
  return target2;
}
var required$1 = function required(rule, value, source2, errors, options, type4) {
  if (rule.required && (!source2.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source2, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i"),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types$1 = {
  integer: function integer(value) {
    return types$1.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types$1.number(value) && !types$1.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types$1.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(pattern$2.url);
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source2, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source2, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types$1[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source2, errors, options) {
  var len = typeof rule.len === "number";
  var min2 = typeof rule.min === "number";
  var max2 = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key2 = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key2 = "number";
  } else if (str) {
    key2 = "string";
  } else if (arr) {
    key2 = "array";
  }
  if (!key2) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key2].len, rule.fullField, rule.len));
    }
  } else if (min2 && !max2 && val < rule.min) {
    errors.push(format(options.messages[key2].min, rule.fullField, rule.min));
  } else if (max2 && !min2 && val > rule.max) {
    errors.push(format(options.messages[key2].max, rule.fullField, rule.max));
  } else if (min2 && max2 && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key2].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source2, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source2, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
      rules.pattern(rule, value, source2, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source2, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var number$1 = function number2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (!isEmptyValue(value)) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules[ENUM](rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules.pattern(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules.type(rule, dateObject, source2, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source2, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source2, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules.required(rule, value, source2, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source2, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
  }
  callback(errors);
};
var validators$3 = {
  string,
  method: method2,
  number: number$1,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item2 = rules2[name];
      _this.rules[name] = Array.isArray(item2) ? item2 : [item2];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o2, oc) {
    var _this2 = this;
    if (o2 === void 0) {
      o2 = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source2 = source_;
    var options = o2;
    var callback = oc;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source2);
      }
      return Promise.resolve(source2);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add2(e) {
        if (Array.isArray(e)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }
      for (var i = 0; i < results.length; i++) {
        add2(results[i]);
      }
      if (!errors.length) {
        callback(null, source2);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z) {
      var arr = _this2.rules[z];
      var value = source2[z];
      arr.forEach(function(r) {
        var rule = r;
        if (typeof rule.transform === "function") {
          if (source2 === source_) {
            source2 = _extends({}, source2);
          }
          value = source2[z] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this2.getType(rule);
        series[z] = series[z] || [];
        series[z].push({
          rule,
          value,
          source: source2,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data2, doIt) {
      var rule = data2.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data2.value);
      rule.field = data2.field;
      function addFullField(key2, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key2,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
        });
      }
      function cb(e) {
        if (e === void 0) {
          e = [];
        }
        var errorList = Array.isArray(e) ? e : [e];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source2));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data2.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source2));
            } else if (options.error) {
              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data2.value).map(function(key2) {
              fieldsSchema[key2] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data2.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options.messages);
          if (data2.rule.options) {
            data2.rule.options.messages = options.messages;
            data2.rule.options.error = options.error;
          }
          schema.validate(data2.value, data2.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data2.value, cb, data2.source, options);
      } else if (rule.validator) {
        res = rule.validator(rule, data2.value, cb, data2.source, options);
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e) {
          return cb(e);
        });
      }
    }, function(results) {
      complete(results);
    }, source2);
  };
  _proto.getType = function getType2(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators$3.hasOwnProperty(rule.type)) {
      throw new Error(format("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators$3.required;
    }
    return validators$3[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register(type4, validator2) {
  if (typeof validator2 !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators$3[type4] = validator2;
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators$3;
var distWeb = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Schema
});
var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(distWeb);
var labelWrap = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var resizeEvent$1 = resizeEvent;
  var form2 = form$7;
  var LabelWrap = vue2.defineComponent({
    name: "ElLabelWrap",
    props: {
      isAutoWidth: Boolean,
      updateAll: Boolean
    },
    setup(props2, { slots }) {
      const el = vue2.ref(null);
      const elForm = vue2.inject(form2.elFormKey);
      const elFormItem = vue2.inject(form2.elFormItemKey);
      const computedWidth = vue2.ref(0);
      vue2.watch(computedWidth, (val, oldVal) => {
        if (props2.updateAll) {
          elForm.registerLabelWidth(val, oldVal);
          elFormItem.updateComputedLabelWidth(val);
        }
      });
      const getLabelWidth = () => {
        var _a;
        if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
          const width = window.getComputedStyle(el.value.firstElementChild).width;
          return Math.ceil(parseFloat(width));
        } else {
          return 0;
        }
      };
      const updateLabelWidth = (action = "update") => {
        vue2.nextTick(() => {
          if (slots.default && props2.isAutoWidth) {
            if (action === "update") {
              computedWidth.value = getLabelWidth();
            } else if (action === "remove") {
              elForm.deregisterLabelWidth(computedWidth.value);
            }
          }
        });
      };
      const updateLabelWidthFn = () => updateLabelWidth("update");
      vue2.onMounted(() => {
        resizeEvent$1.addResizeListener(el.value.firstElementChild, updateLabelWidthFn);
        updateLabelWidthFn();
      });
      vue2.onUpdated(updateLabelWidthFn);
      vue2.onBeforeUnmount(() => {
        var _a;
        updateLabelWidth("remove");
        resizeEvent$1.removeResizeListener((_a = el.value) == null ? void 0 : _a.firstElementChild, updateLabelWidthFn);
      });
      function render2() {
        var _a, _b;
        if (!slots)
          return null;
        if (props2.isAutoWidth) {
          const autoLabelWidth = elForm.autoLabelWidth;
          const style = {};
          if (autoLabelWidth && autoLabelWidth !== "auto") {
            const marginWidth = Math.max(0, parseInt(autoLabelWidth, 10) - computedWidth.value);
            const marginPosition = elForm.labelPosition === "left" ? "marginRight" : "marginLeft";
            if (marginWidth) {
              style[marginPosition] = `${marginWidth}px`;
            }
          }
          return vue2.h("div", {
            ref: el,
            class: ["el-form-item__label-wrap"],
            style
          }, (_a = slots.default) == null ? void 0 : _a.call(slots));
        } else {
          return vue2.h(vue2.Fragment, { ref: el }, (_b = slots.default) == null ? void 0 : _b.call(slots));
        }
      }
      return render2;
    }
  });
  exports["default"] = LabelWrap;
})(labelWrap);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var AsyncValidator = require$$2$1;
  var util2 = util$l;
  var validators2 = validators$6;
  var labelWrap$1 = labelWrap;
  var form2 = form$7;
  var index2 = useCommonProps;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var AsyncValidator__default = /* @__PURE__ */ _interopDefaultLegacy2(AsyncValidator);
  var script2 = vue2.defineComponent({
    name: "ElFormItem",
    componentName: "ElFormItem",
    components: {
      LabelWrap: labelWrap$1["default"]
    },
    props: {
      label: String,
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      prop: String,
      required: {
        type: Boolean,
        default: void 0
      },
      rules: [Object, Array],
      error: String,
      validateStatus: String,
      for: String,
      inlineMessage: {
        type: [String, Boolean],
        default: ""
      },
      showMessage: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        validator: validators2.isValidComponentSize
      }
    },
    setup(props2, { slots }) {
      const elForm = vue2.inject(form2.elFormKey, {});
      const validateState = vue2.ref("");
      const validateMessage = vue2.ref("");
      const isValidationEnabled = vue2.ref(false);
      const computedLabelWidth = vue2.ref("");
      const formItemRef = vue2.ref();
      const vm = vue2.getCurrentInstance();
      const isNested = vue2.computed(() => {
        let parent = vm.parent;
        while (parent && parent.type.name !== "ElForm") {
          if (parent.type.name === "ElFormItem") {
            return true;
          }
          parent = parent.parent;
        }
        return false;
      });
      let initialValue = void 0;
      vue2.watch(() => props2.error, (val) => {
        validateMessage.value = val;
        validateState.value = val ? "error" : "";
      }, {
        immediate: true
      });
      vue2.watch(() => props2.validateStatus, (val) => {
        validateState.value = val;
      });
      const labelFor = vue2.computed(() => props2.for || props2.prop);
      const labelStyle = vue2.computed(() => {
        const ret = {};
        if (elForm.labelPosition === "top")
          return ret;
        const labelWidth = util2.addUnit(props2.labelWidth || elForm.labelWidth);
        if (labelWidth) {
          ret.width = labelWidth;
        }
        return ret;
      });
      const contentStyle = vue2.computed(() => {
        const ret = {};
        if (elForm.labelPosition === "top" || elForm.inline) {
          return ret;
        }
        if (!props2.label && !props2.labelWidth && isNested.value) {
          return ret;
        }
        const labelWidth = util2.addUnit(props2.labelWidth || elForm.labelWidth);
        if (!props2.label && !slots.label) {
          ret.marginLeft = labelWidth;
        }
        return ret;
      });
      const fieldValue = vue2.computed(() => {
        const model = elForm.model;
        if (!model || !props2.prop) {
          return;
        }
        let path = props2.prop;
        if (path.indexOf(":") !== -1) {
          path = path.replace(/:/, ".");
        }
        return util2.getPropByPath(model, path, true).v;
      });
      const isRequired = vue2.computed(() => {
        const rules2 = getRules();
        let required4 = false;
        if (rules2 && rules2.length) {
          rules2.every((rule) => {
            if (rule.required) {
              required4 = true;
              return false;
            }
            return true;
          });
        }
        return required4;
      });
      const sizeClass = index2.useSize(void 0, { formItem: false });
      const validate = (trigger2, callback = shared2.NOOP) => {
        if (!isValidationEnabled.value) {
          callback();
          return;
        }
        const rules2 = getFilteredRule(trigger2);
        if ((!rules2 || rules2.length === 0) && props2.required === void 0) {
          callback();
          return;
        }
        validateState.value = "validating";
        const descriptor = {};
        if (rules2 && rules2.length > 0) {
          rules2.forEach((rule) => {
            delete rule.trigger;
          });
        }
        descriptor[props2.prop] = rules2;
        const validator2 = new AsyncValidator__default["default"](descriptor);
        const model = {};
        model[props2.prop] = fieldValue.value;
        validator2.validate(model, { firstFields: true }, (errors, fields) => {
          var _a;
          validateState.value = !errors ? "success" : "error";
          validateMessage.value = errors ? errors[0].message || `${props2.prop} is required` : "";
          callback(validateMessage.value, errors ? fields : {});
          (_a = elForm.emit) == null ? void 0 : _a.call(elForm, "validate", props2.prop, !errors, validateMessage.value || null);
        });
      };
      const clearValidate = () => {
        validateState.value = "";
        validateMessage.value = "";
      };
      const resetField = () => {
        const model = elForm.model;
        const value = fieldValue.value;
        let path = props2.prop;
        if (path.indexOf(":") !== -1) {
          path = path.replace(/:/, ".");
        }
        const prop = util2.getPropByPath(model, path, true);
        if (Array.isArray(value)) {
          prop.o[prop.k] = [].concat(initialValue);
        } else {
          prop.o[prop.k] = initialValue;
        }
        vue2.nextTick(() => {
          clearValidate();
        });
      };
      const getRules = () => {
        const formRules = elForm.rules;
        const selfRules = props2.rules;
        const requiredRule = props2.required !== void 0 ? { required: !!props2.required } : [];
        const prop = util2.getPropByPath(formRules, props2.prop || "", false);
        const normalizedRule = formRules ? prop.o[props2.prop || ""] || prop.v : [];
        return [].concat(selfRules || normalizedRule || []).concat(requiredRule);
      };
      const getFilteredRule = (trigger2) => {
        const rules2 = getRules();
        return rules2.filter((rule) => {
          if (!rule.trigger || trigger2 === "")
            return true;
          if (Array.isArray(rule.trigger)) {
            return rule.trigger.indexOf(trigger2) > -1;
          } else {
            return rule.trigger === trigger2;
          }
        }).map((rule) => __spreadValues({}, rule));
      };
      const evaluateValidationEnabled = () => {
        var _a;
        isValidationEnabled.value = !!((_a = getRules()) == null ? void 0 : _a.length);
      };
      const updateComputedLabelWidth = (width) => {
        computedLabelWidth.value = width ? `${width}px` : "";
      };
      const elFormItem = vue2.reactive(__spreadProps(__spreadValues({}, vue2.toRefs(props2)), {
        size: sizeClass,
        validateState,
        $el: formItemRef,
        evaluateValidationEnabled,
        resetField,
        clearValidate,
        validate,
        updateComputedLabelWidth
      }));
      vue2.onMounted(() => {
        if (props2.prop) {
          elForm == null ? void 0 : elForm.addField(elFormItem);
          const value = fieldValue.value;
          initialValue = Array.isArray(value) ? [...value] : value;
          evaluateValidationEnabled();
        }
      });
      vue2.onBeforeUnmount(() => {
        elForm == null ? void 0 : elForm.removeField(elFormItem);
      });
      vue2.provide(form2.elFormItemKey, elFormItem);
      const formItemClass = vue2.computed(() => [
        {
          "el-form-item--feedback": elForm.statusIcon,
          "is-error": validateState.value === "error",
          "is-validating": validateState.value === "validating",
          "is-success": validateState.value === "success",
          "is-required": isRequired.value || props2.required,
          "is-no-asterisk": elForm.hideRequiredAsterisk
        },
        sizeClass.value ? `el-form-item--${sizeClass.value}` : ""
      ]);
      const shouldShowError = vue2.computed(() => {
        return validateState.value === "error" && props2.showMessage && elForm.showMessage;
      });
      const currentLabel = vue2.computed(() => (props2.label || "") + (elForm.labelSuffix || ""));
      return {
        formItemRef,
        formItemClass,
        shouldShowError,
        elForm,
        labelStyle,
        contentStyle,
        validateMessage,
        labelFor,
        resetField,
        clearValidate,
        currentLabel
      };
    }
  });
  exports["default"] = script2;
})(formItem_vue_vue_type_script_lang);
var formItem_vue_vue_type_template_id_24eda48b_lang = {};
Object.defineProperty(formItem_vue_vue_type_template_id_24eda48b_lang, "__esModule", { value: true });
var vue$1e = require$$0$1;
const _hoisted_1$D = ["for"];
function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LabelWrap = vue$1e.resolveComponent("LabelWrap");
  return vue$1e.openBlock(), vue$1e.createElementBlock("div", {
    ref: "formItemRef",
    class: vue$1e.normalizeClass(["el-form-item", _ctx.formItemClass])
  }, [
    vue$1e.createVNode(_component_LabelWrap, {
      "is-auto-width": _ctx.labelStyle.width === "auto",
      "update-all": _ctx.elForm.labelWidth === "auto"
    }, {
      default: vue$1e.withCtx(() => [
        _ctx.label || _ctx.$slots.label ? (vue$1e.openBlock(), vue$1e.createElementBlock("label", {
          key: 0,
          for: _ctx.labelFor,
          class: "el-form-item__label",
          style: vue$1e.normalizeStyle(_ctx.labelStyle)
        }, [
          vue$1e.renderSlot(_ctx.$slots, "label", { label: _ctx.currentLabel }, () => [
            vue$1e.createTextVNode(vue$1e.toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 12, _hoisted_1$D)) : vue$1e.createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 8, ["is-auto-width", "update-all"]),
    vue$1e.createElementVNode("div", {
      class: "el-form-item__content",
      style: vue$1e.normalizeStyle(_ctx.contentStyle)
    }, [
      vue$1e.renderSlot(_ctx.$slots, "default"),
      vue$1e.createVNode(vue$1e.Transition, { name: "el-zoom-in-top" }, {
        default: vue$1e.withCtx(() => [
          _ctx.shouldShowError ? vue$1e.renderSlot(_ctx.$slots, "error", {
            key: 0,
            error: _ctx.validateMessage
          }, () => [
            vue$1e.createElementVNode("div", {
              class: vue$1e.normalizeClass(["el-form-item__error", {
                "el-form-item__error--inline": typeof _ctx.inlineMessage === "boolean" ? _ctx.inlineMessage : _ctx.elForm.inlineMessage || false
              }])
            }, vue$1e.toDisplayString(_ctx.validateMessage), 3)
          ]) : vue$1e.createCommentVNode("v-if", true)
        ]),
        _: 3
      })
    ], 4)
  ], 2);
}
formItem_vue_vue_type_template_id_24eda48b_lang.render = render$Q;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var formItem_vue_vue_type_script_lang$1 = formItem_vue_vue_type_script_lang;
  var formItem_vue_vue_type_template_id_24eda48b_lang$1 = formItem_vue_vue_type_template_id_24eda48b_lang;
  formItem_vue_vue_type_script_lang$1["default"].render = formItem_vue_vue_type_template_id_24eda48b_lang$1.render;
  formItem_vue_vue_type_script_lang$1["default"].__file = "packages/components/form/src/form-item.vue";
  exports["default"] = formItem_vue_vue_type_script_lang$1["default"];
})(formItem);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var form_vue_vue_type_script_lang$1 = form_vue_vue_type_script_lang;
  var formItem_vue_vue_type_script_lang$1 = formItem_vue_vue_type_script_lang;
  const ElForm = withInstall2.withInstall(form_vue_vue_type_script_lang$1["default"], {
    FormItem: formItem_vue_vue_type_script_lang$1["default"]
  });
  const ElFormItem = withInstall2.withNoopInstall(formItem_vue_vue_type_script_lang$1["default"]);
  exports.ElForm = ElForm;
  exports.ElFormItem = ElFormItem;
  exports["default"] = ElForm;
})(form$3);
var image$2 = {};
var image2 = {};
var image_vue_vue_type_script_lang = {};
var imageViewer$2 = {};
var imageViewer2 = {};
var imageViewer_vue_vue_type_script_lang = {};
var imageViewer$1 = {};
Object.defineProperty(imageViewer$1, "__esModule", { value: true });
var props$l = props$N;
const imageViewerProps = props$l.buildProps({
  urlList: {
    type: props$l.definePropType(Array),
    default: () => props$l.mutable([])
  },
  zIndex: {
    type: Number,
    default: 2e3
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: true
  },
  hideOnClickModal: {
    type: Boolean,
    default: false
  }
});
const imageViewerEmits = {
  close: () => true,
  switch: (index2) => typeof index2 === "number"
};
imageViewer$1.imageViewerEmits = imageViewerEmits;
imageViewer$1.imageViewerProps = imageViewerProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var index2 = icon$4;
  var aria2 = aria$5;
  var util2 = util$l;
  var iconsVue2 = require$$3;
  var imageViewer3 = imageViewer$1;
  var index$110 = useLocale$1;
  const Mode = {
    CONTAIN: {
      name: "contain",
      icon: vue2.markRaw(iconsVue2.FullScreen)
    },
    ORIGINAL: {
      name: "original",
      icon: vue2.markRaw(iconsVue2.ScaleToOriginal)
    }
  };
  const mousewheelEventName = util2.isFirefox() ? "DOMMouseScroll" : "mousewheel";
  var script2 = vue2.defineComponent({
    name: "ElImageViewer",
    components: {
      ElIcon: index2.ElIcon,
      Close: iconsVue2.Close,
      ArrowLeft: iconsVue2.ArrowLeft,
      ArrowRight: iconsVue2.ArrowRight,
      ZoomOut: iconsVue2.ZoomOut,
      ZoomIn: iconsVue2.ZoomIn,
      RefreshLeft: iconsVue2.RefreshLeft,
      RefreshRight: iconsVue2.RefreshRight
    },
    props: imageViewer3.imageViewerProps,
    emits: imageViewer3.imageViewerEmits,
    setup(props2, { emit }) {
      const { t } = index$110.useLocale();
      const wrapper = vue2.ref();
      const img2 = vue2.ref();
      const scopeEventListener = vue2.effectScope();
      const loading2 = vue2.ref(true);
      const index3 = vue2.ref(props2.initialIndex);
      const mode = vue2.ref(Mode.CONTAIN);
      const transform2 = vue2.ref({
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: false
      });
      const isSingle = vue2.computed(() => {
        const { urlList } = props2;
        return urlList.length <= 1;
      });
      const isFirst = vue2.computed(() => {
        return index3.value === 0;
      });
      const isLast = vue2.computed(() => {
        return index3.value === props2.urlList.length - 1;
      });
      const currentImg = vue2.computed(() => {
        return props2.urlList[index3.value];
      });
      const imgStyle = vue2.computed(() => {
        const { scale, deg, offsetX, offsetY, enableTransition } = transform2.value;
        const style = {
          transform: `scale(${scale}) rotate(${deg}deg)`,
          transition: enableTransition ? "transform .3s" : "",
          marginLeft: `${offsetX}px`,
          marginTop: `${offsetY}px`
        };
        if (mode.value.name === Mode.CONTAIN.name) {
          style.maxWidth = style.maxHeight = "100%";
        }
        return style;
      });
      function hide2() {
        unregisterEventListener();
        emit("close");
      }
      function registerEventListener() {
        const keydownHandler = util2.rafThrottle((e) => {
          switch (e.code) {
            case aria2.EVENT_CODE.esc:
              hide2();
              break;
            case aria2.EVENT_CODE.space:
              toggleMode();
              break;
            case aria2.EVENT_CODE.left:
              prev2();
              break;
            case aria2.EVENT_CODE.up:
              handleActions("zoomIn");
              break;
            case aria2.EVENT_CODE.right:
              next2();
              break;
            case aria2.EVENT_CODE.down:
              handleActions("zoomOut");
              break;
          }
        });
        const mousewheelHandler = util2.rafThrottle((e) => {
          const delta = e.wheelDelta ? e.wheelDelta : -e.detail;
          if (delta > 0) {
            handleActions("zoomIn", {
              zoomRate: 0.015,
              enableTransition: false
            });
          } else {
            handleActions("zoomOut", {
              zoomRate: 0.015,
              enableTransition: false
            });
          }
        });
        scopeEventListener.run(() => {
          core2.useEventListener(document, "keydown", keydownHandler);
          core2.useEventListener(document, mousewheelEventName, mousewheelHandler);
        });
      }
      function unregisterEventListener() {
        scopeEventListener.stop();
      }
      function handleImgLoad() {
        loading2.value = false;
      }
      function handleImgError(e) {
        loading2.value = false;
        e.target.alt = t("el.image.error");
      }
      function handleMouseDown(e) {
        if (loading2.value || e.button !== 0 || !wrapper.value)
          return;
        const { offsetX, offsetY } = transform2.value;
        const startX = e.pageX;
        const startY = e.pageY;
        const divLeft = wrapper.value.clientLeft;
        const divRight = wrapper.value.clientLeft + wrapper.value.clientWidth;
        const divTop = wrapper.value.clientTop;
        const divBottom = wrapper.value.clientTop + wrapper.value.clientHeight;
        const dragHandler = util2.rafThrottle((ev) => {
          transform2.value = __spreadProps(__spreadValues({}, transform2.value), {
            offsetX: offsetX + ev.pageX - startX,
            offsetY: offsetY + ev.pageY - startY
          });
        });
        const removeMousemove = core2.useEventListener(document, "mousemove", dragHandler);
        core2.useEventListener(document, "mouseup", (evt) => {
          const mouseX = evt.pageX;
          const mouseY = evt.pageY;
          if (mouseX < divLeft || mouseX > divRight || mouseY < divTop || mouseY > divBottom) {
            reset2();
          }
          removeMousemove();
        });
        e.preventDefault();
      }
      function reset2() {
        transform2.value = {
          scale: 1,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: false
        };
      }
      function toggleMode() {
        if (loading2.value)
          return;
        const modeNames = Object.keys(Mode);
        const modeValues = Object.values(Mode);
        const currentMode = mode.value.name;
        const index22 = modeValues.findIndex((i) => i.name === currentMode);
        const nextIndex = (index22 + 1) % modeNames.length;
        mode.value = Mode[modeNames[nextIndex]];
        reset2();
      }
      function prev2() {
        if (isFirst.value && !props2.infinite)
          return;
        const len = props2.urlList.length;
        index3.value = (index3.value - 1 + len) % len;
      }
      function next2() {
        if (isLast.value && !props2.infinite)
          return;
        const len = props2.urlList.length;
        index3.value = (index3.value + 1) % len;
      }
      function handleActions(action, options = {}) {
        if (loading2.value)
          return;
        const { zoomRate, rotateDeg, enableTransition } = __spreadValues({
          zoomRate: 0.2,
          rotateDeg: 90,
          enableTransition: true
        }, options);
        switch (action) {
          case "zoomOut":
            if (transform2.value.scale > 0.2) {
              transform2.value.scale = parseFloat((transform2.value.scale - zoomRate).toFixed(3));
            }
            break;
          case "zoomIn":
            transform2.value.scale = parseFloat((transform2.value.scale + zoomRate).toFixed(3));
            break;
          case "clockwise":
            transform2.value.deg += rotateDeg;
            break;
          case "anticlockwise":
            transform2.value.deg -= rotateDeg;
            break;
        }
        transform2.value.enableTransition = enableTransition;
      }
      vue2.watch(currentImg, () => {
        vue2.nextTick(() => {
          const $img = img2.value;
          if (!($img == null ? void 0 : $img.complete)) {
            loading2.value = true;
          }
        });
      });
      vue2.watch(index3, (val) => {
        reset2();
        emit("switch", val);
      });
      vue2.onMounted(() => {
        var _a, _b;
        registerEventListener();
        (_b = (_a = wrapper.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      });
      return {
        index: index3,
        wrapper,
        img: img2,
        isSingle,
        isFirst,
        isLast,
        currentImg,
        imgStyle,
        mode,
        handleActions,
        prev: prev2,
        next: next2,
        hide: hide2,
        toggleMode,
        handleImgLoad,
        handleImgError,
        handleMouseDown
      };
    }
  });
  exports["default"] = script2;
})(imageViewer_vue_vue_type_script_lang);
var imageViewer_vue_vue_type_template_id_4b22ad85_lang = {};
Object.defineProperty(imageViewer_vue_vue_type_template_id_4b22ad85_lang, "__esModule", { value: true });
var vue$1d = require$$0$1;
const _hoisted_1$C = { class: "el-image-viewer__btn el-image-viewer__actions" };
const _hoisted_2$t = { class: "el-image-viewer__actions__inner" };
const _hoisted_3$n = /* @__PURE__ */ vue$1d.createElementVNode("i", { class: "el-image-viewer__actions__divider" }, null, -1);
const _hoisted_4$f = /* @__PURE__ */ vue$1d.createElementVNode("i", { class: "el-image-viewer__actions__divider" }, null, -1);
const _hoisted_5$b = { class: "el-image-viewer__canvas" };
const _hoisted_6$9 = ["src"];
function render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_close = vue$1d.resolveComponent("close");
  const _component_el_icon = vue$1d.resolveComponent("el-icon");
  const _component_arrow_left = vue$1d.resolveComponent("arrow-left");
  const _component_arrow_right = vue$1d.resolveComponent("arrow-right");
  const _component_zoom_out = vue$1d.resolveComponent("zoom-out");
  const _component_zoom_in = vue$1d.resolveComponent("zoom-in");
  const _component_refresh_left = vue$1d.resolveComponent("refresh-left");
  const _component_refresh_right = vue$1d.resolveComponent("refresh-right");
  return vue$1d.openBlock(), vue$1d.createBlock(vue$1d.Transition, { name: "viewer-fade" }, {
    default: vue$1d.withCtx(() => [
      vue$1d.createElementVNode("div", {
        ref: "wrapper",
        tabindex: -1,
        class: "el-image-viewer__wrapper",
        style: vue$1d.normalizeStyle({ zIndex: _ctx.zIndex })
      }, [
        vue$1d.createElementVNode("div", {
          class: "el-image-viewer__mask",
          onClick: _cache[0] || (_cache[0] = vue$1d.withModifiers(($event) => _ctx.hideOnClickModal && _ctx.hide(), ["self"]))
        }),
        vue$1d.createCommentVNode(" CLOSE "),
        vue$1d.createElementVNode("span", {
          class: "el-image-viewer__btn el-image-viewer__close",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.hide && _ctx.hide(...args))
        }, [
          vue$1d.createVNode(_component_el_icon, null, {
            default: vue$1d.withCtx(() => [
              vue$1d.createVNode(_component_close)
            ]),
            _: 1
          })
        ]),
        vue$1d.createCommentVNode(" ARROW "),
        !_ctx.isSingle ? (vue$1d.openBlock(), vue$1d.createElementBlock(vue$1d.Fragment, { key: 0 }, [
          vue$1d.createElementVNode("span", {
            class: vue$1d.normalizeClass(["el-image-viewer__btn el-image-viewer__prev", { "is-disabled": !_ctx.infinite && _ctx.isFirst }]),
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.prev && _ctx.prev(...args))
          }, [
            vue$1d.createVNode(_component_el_icon, null, {
              default: vue$1d.withCtx(() => [
                vue$1d.createVNode(_component_arrow_left)
              ]),
              _: 1
            })
          ], 2),
          vue$1d.createElementVNode("span", {
            class: vue$1d.normalizeClass(["el-image-viewer__btn el-image-viewer__next", { "is-disabled": !_ctx.infinite && _ctx.isLast }]),
            onClick: _cache[3] || (_cache[3] = (...args) => _ctx.next && _ctx.next(...args))
          }, [
            vue$1d.createVNode(_component_el_icon, null, {
              default: vue$1d.withCtx(() => [
                vue$1d.createVNode(_component_arrow_right)
              ]),
              _: 1
            })
          ], 2)
        ], 64)) : vue$1d.createCommentVNode("v-if", true),
        vue$1d.createCommentVNode(" ACTIONS "),
        vue$1d.createElementVNode("div", _hoisted_1$C, [
          vue$1d.createElementVNode("div", _hoisted_2$t, [
            vue$1d.createVNode(_component_el_icon, {
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.handleActions("zoomOut"))
            }, {
              default: vue$1d.withCtx(() => [
                vue$1d.createVNode(_component_zoom_out)
              ]),
              _: 1
            }),
            vue$1d.createVNode(_component_el_icon, {
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleActions("zoomIn"))
            }, {
              default: vue$1d.withCtx(() => [
                vue$1d.createVNode(_component_zoom_in)
              ]),
              _: 1
            }),
            _hoisted_3$n,
            vue$1d.createVNode(_component_el_icon, { onClick: _ctx.toggleMode }, {
              default: vue$1d.withCtx(() => [
                (vue$1d.openBlock(), vue$1d.createBlock(vue$1d.resolveDynamicComponent(_ctx.mode.icon)))
              ]),
              _: 1
            }, 8, ["onClick"]),
            _hoisted_4$f,
            vue$1d.createVNode(_component_el_icon, {
              onClick: _cache[6] || (_cache[6] = ($event) => _ctx.handleActions("anticlockwise"))
            }, {
              default: vue$1d.withCtx(() => [
                vue$1d.createVNode(_component_refresh_left)
              ]),
              _: 1
            }),
            vue$1d.createVNode(_component_el_icon, {
              onClick: _cache[7] || (_cache[7] = ($event) => _ctx.handleActions("clockwise"))
            }, {
              default: vue$1d.withCtx(() => [
                vue$1d.createVNode(_component_refresh_right)
              ]),
              _: 1
            })
          ])
        ]),
        vue$1d.createCommentVNode(" CANVAS "),
        vue$1d.createElementVNode("div", _hoisted_5$b, [
          (vue$1d.openBlock(true), vue$1d.createElementBlock(vue$1d.Fragment, null, vue$1d.renderList(_ctx.urlList, (url2, i) => {
            return vue$1d.withDirectives((vue$1d.openBlock(), vue$1d.createElementBlock("img", {
              ref: "img",
              key: url2,
              src: url2,
              style: vue$1d.normalizeStyle(_ctx.imgStyle),
              class: "el-image-viewer__img",
              onLoad: _cache[8] || (_cache[8] = (...args) => _ctx.handleImgLoad && _ctx.handleImgLoad(...args)),
              onError: _cache[9] || (_cache[9] = (...args) => _ctx.handleImgError && _ctx.handleImgError(...args)),
              onMousedown: _cache[10] || (_cache[10] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args))
            }, null, 44, _hoisted_6$9)), [
              [vue$1d.vShow, i === _ctx.index]
            ]);
          }), 128))
        ]),
        vue$1d.renderSlot(_ctx.$slots, "default")
      ], 4)
    ]),
    _: 3
  });
}
imageViewer_vue_vue_type_template_id_4b22ad85_lang.render = render$P;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var imageViewer_vue_vue_type_script_lang$1 = imageViewer_vue_vue_type_script_lang;
  var imageViewer_vue_vue_type_template_id_4b22ad85_lang$1 = imageViewer_vue_vue_type_template_id_4b22ad85_lang;
  imageViewer_vue_vue_type_script_lang$1["default"].render = imageViewer_vue_vue_type_template_id_4b22ad85_lang$1.render;
  imageViewer_vue_vue_type_script_lang$1["default"].__file = "packages/components/image-viewer/src/image-viewer.vue";
  exports["default"] = imageViewer_vue_vue_type_script_lang$1["default"];
})(imageViewer2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var imageViewer3 = imageViewer$1;
  var imageViewer_vue_vue_type_script_lang$1 = imageViewer_vue_vue_type_script_lang;
  const ElImageViewer = withInstall2.withInstall(imageViewer_vue_vue_type_script_lang$1["default"]);
  exports.imageViewerEmits = imageViewer3.imageViewerEmits;
  exports.imageViewerProps = imageViewer3.imageViewerProps;
  exports.ElImageViewer = ElImageViewer;
  exports["default"] = ElImageViewer;
})(imageViewer$2);
var image$1 = {};
Object.defineProperty(image$1, "__esModule", { value: true });
var props$k = props$N;
var util$a = util$l;
const imageProps = props$k.buildProps({
  appendToBody: {
    type: Boolean,
    default: false
  },
  hideOnClickModal: {
    type: Boolean,
    default: false
  },
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  lazy: {
    type: Boolean,
    default: false
  },
  scrollContainer: {
    type: props$k.definePropType([String, Object])
  },
  previewSrcList: {
    type: props$k.definePropType(Array),
    default: () => props$k.mutable([])
  },
  zIndex: {
    type: Number,
    default: 2e3
  },
  initialIndex: {
    type: Number,
    default: 0
  }
});
const imageEmits = {
  error: (evt) => evt instanceof Event,
  switch: (val) => util$a.isNumber(val),
  close: () => true
};
image$1.imageEmits = imageEmits;
image$1.imageProps = imageProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var core2 = core$7;
  var index2 = imageViewer$2;
  var isServer2 = isServer$8;
  var dom2 = dom$8;
  var image3 = image$1;
  var index$110 = useLocale$1;
  var index$22 = useAttrs$1;
  const isHtmlElement = (e) => e && e.nodeType === Node.ELEMENT_NODE;
  let prevOverflow = "";
  var script2 = vue2.defineComponent({
    name: "ElImage",
    components: {
      ImageViewer: index2.ElImageViewer
    },
    inheritAttrs: false,
    props: image3.imageProps,
    emits: image3.imageEmits,
    setup(props2, { emit, attrs: rawAttrs }) {
      const { t } = index$110.useLocale();
      const attrs = index$22.useAttrs();
      const hasLoadError = vue2.ref(false);
      const loading2 = vue2.ref(true);
      const imgWidth = vue2.ref(0);
      const imgHeight = vue2.ref(0);
      const showViewer = vue2.ref(false);
      const container2 = vue2.ref();
      const _scrollContainer = vue2.ref();
      let stopScrollListener;
      let stopWheelListener;
      const containerStyle = vue2.computed(() => rawAttrs.style);
      const imageStyle = vue2.computed(() => {
        const { fit } = props2;
        if (!isServer2["default"] && fit) {
          return { objectFit: fit };
        }
        return {};
      });
      const preview = vue2.computed(() => {
        const { previewSrcList } = props2;
        return Array.isArray(previewSrcList) && previewSrcList.length > 0;
      });
      const imageIndex = vue2.computed(() => {
        const { src: src2, previewSrcList, initialIndex } = props2;
        let previewIndex = initialIndex;
        const srcIndex = previewSrcList.indexOf(src2);
        if (srcIndex >= 0) {
          previewIndex = srcIndex;
        }
        return previewIndex;
      });
      const loadImage = () => {
        if (isServer2["default"])
          return;
        loading2.value = true;
        hasLoadError.value = false;
        const img2 = new Image();
        img2.addEventListener("load", (e) => handleLoad(e, img2));
        img2.addEventListener("error", handleError2);
        Object.entries(attrs.value).forEach(([key2, value]) => {
          if (key2.toLowerCase() === "onload")
            return;
          img2.setAttribute(key2, value);
        });
        img2.src = props2.src;
      };
      function handleLoad(e, img2) {
        imgWidth.value = img2.width;
        imgHeight.value = img2.height;
        loading2.value = false;
        hasLoadError.value = false;
      }
      function handleError2(event) {
        loading2.value = false;
        hasLoadError.value = true;
        emit("error", event);
      }
      function handleLazyLoad() {
        if (dom2.isInContainer(container2.value, _scrollContainer.value)) {
          loadImage();
          removeLazyLoadListener();
        }
      }
      const lazyLoadHandler = core2.useThrottleFn(handleLazyLoad, 200);
      async function addLazyLoadListener() {
        var _a;
        if (isServer2["default"])
          return;
        await vue2.nextTick();
        const { scrollContainer } = props2;
        if (isHtmlElement(scrollContainer)) {
          _scrollContainer.value = scrollContainer;
        } else if (shared2.isString(scrollContainer) && scrollContainer !== "") {
          _scrollContainer.value = (_a = document.querySelector(scrollContainer)) != null ? _a : void 0;
        } else if (container2.value) {
          _scrollContainer.value = dom2.getScrollContainer(container2.value);
        }
        if (_scrollContainer.value) {
          stopScrollListener = core2.useEventListener(_scrollContainer, "scroll", lazyLoadHandler);
          setTimeout(() => handleLazyLoad(), 100);
        }
      }
      function removeLazyLoadListener() {
        if (isServer2["default"] || !_scrollContainer.value || !lazyLoadHandler)
          return;
        stopScrollListener();
        _scrollContainer.value = void 0;
      }
      function wheelHandler(e) {
        if (!e.ctrlKey)
          return;
        if (e.deltaY < 0) {
          e.preventDefault();
          return false;
        } else if (e.deltaY > 0) {
          e.preventDefault();
          return false;
        }
      }
      function clickHandler() {
        if (!preview.value)
          return;
        stopWheelListener = core2.useEventListener("wheel", wheelHandler, {
          passive: false
        });
        prevOverflow = document.body.style.overflow;
        document.body.style.overflow = "hidden";
        showViewer.value = true;
      }
      function closeViewer() {
        stopWheelListener == null ? void 0 : stopWheelListener();
        document.body.style.overflow = prevOverflow;
        showViewer.value = false;
        emit("close");
      }
      function switchViewer(val) {
        emit("switch", val);
      }
      vue2.watch(() => props2.src, () => {
        if (props2.lazy) {
          loading2.value = true;
          hasLoadError.value = false;
          removeLazyLoadListener();
          addLazyLoadListener();
        } else {
          loadImage();
        }
      });
      vue2.onMounted(() => {
        if (props2.lazy) {
          addLazyLoadListener();
        } else {
          loadImage();
        }
      });
      return {
        attrs,
        loading: loading2,
        hasLoadError,
        showViewer,
        containerStyle,
        imageStyle,
        preview,
        imageIndex,
        container: container2,
        clickHandler,
        closeViewer,
        switchViewer,
        t
      };
    }
  });
  exports["default"] = script2;
})(image_vue_vue_type_script_lang);
var image_vue_vue_type_template_id_34467287_lang = {};
Object.defineProperty(image_vue_vue_type_template_id_34467287_lang, "__esModule", { value: true });
var vue$1c = require$$0$1;
const _hoisted_1$B = /* @__PURE__ */ vue$1c.createElementVNode("div", { class: "el-image__placeholder" }, null, -1);
const _hoisted_2$s = { class: "el-image__error" };
const _hoisted_3$m = ["src"];
const _hoisted_4$e = { key: 0 };
function render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_image_viewer = vue$1c.resolveComponent("image-viewer");
  return vue$1c.openBlock(), vue$1c.createElementBlock("div", {
    ref: "container",
    class: vue$1c.normalizeClass(["el-image", _ctx.$attrs.class]),
    style: vue$1c.normalizeStyle(_ctx.containerStyle)
  }, [
    _ctx.loading ? vue$1c.renderSlot(_ctx.$slots, "placeholder", { key: 0 }, () => [
      _hoisted_1$B
    ]) : _ctx.hasLoadError ? vue$1c.renderSlot(_ctx.$slots, "error", { key: 1 }, () => [
      vue$1c.createElementVNode("div", _hoisted_2$s, vue$1c.toDisplayString(_ctx.t("el.image.error")), 1)
    ]) : (vue$1c.openBlock(), vue$1c.createElementBlock("img", vue$1c.mergeProps({
      key: 2,
      class: "el-image__inner"
    }, _ctx.attrs, {
      src: _ctx.src,
      style: _ctx.imageStyle,
      class: {
        "el-image__preview": _ctx.preview
      },
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickHandler && _ctx.clickHandler(...args))
    }), null, 16, _hoisted_3$m)),
    (vue$1c.openBlock(), vue$1c.createBlock(vue$1c.Teleport, {
      to: "body",
      disabled: !_ctx.appendToBody
    }, [
      _ctx.preview ? (vue$1c.openBlock(), vue$1c.createElementBlock(vue$1c.Fragment, { key: 0 }, [
        _ctx.showViewer ? (vue$1c.openBlock(), vue$1c.createBlock(_component_image_viewer, {
          key: 0,
          "z-index": _ctx.zIndex,
          "initial-index": _ctx.imageIndex,
          "url-list": _ctx.previewSrcList,
          "hide-on-click-modal": _ctx.hideOnClickModal,
          onClose: _ctx.closeViewer,
          onSwitch: _ctx.switchViewer
        }, {
          default: vue$1c.withCtx(() => [
            _ctx.$slots.viewer ? (vue$1c.openBlock(), vue$1c.createElementBlock("div", _hoisted_4$e, [
              vue$1c.renderSlot(_ctx.$slots, "viewer")
            ])) : vue$1c.createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 8, ["z-index", "initial-index", "url-list", "hide-on-click-modal", "onClose", "onSwitch"])) : vue$1c.createCommentVNode("v-if", true)
      ], 2112)) : vue$1c.createCommentVNode("v-if", true)
    ], 8, ["disabled"]))
  ], 6);
}
image_vue_vue_type_template_id_34467287_lang.render = render$O;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var image_vue_vue_type_script_lang$1 = image_vue_vue_type_script_lang;
  var image_vue_vue_type_template_id_34467287_lang$1 = image_vue_vue_type_template_id_34467287_lang;
  image_vue_vue_type_script_lang$1["default"].render = image_vue_vue_type_template_id_34467287_lang$1.render;
  image_vue_vue_type_script_lang$1["default"].__file = "packages/components/image/src/image.vue";
  exports["default"] = image_vue_vue_type_script_lang$1["default"];
})(image2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var image3 = image$1;
  var image_vue_vue_type_script_lang$1 = image_vue_vue_type_script_lang;
  const ElImage = withInstall2.withInstall(image_vue_vue_type_script_lang$1["default"]);
  exports.imageEmits = image3.imageEmits;
  exports.imageProps = image3.imageProps;
  exports.ElImage = ElImage;
  exports["default"] = ElImage;
})(image$2);
var inputNumber$2 = {};
var inputNumber2 = {};
var inputNumber_vue_vue_type_script_lang = {};
var inputNumber$1 = {};
Object.defineProperty(inputNumber$1, "__esModule", { value: true });
var props$j = props$N;
var util$9 = util$l;
const inputNumberProps = props$j.buildProps({
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: {
    type: Boolean,
    default: false
  },
  max: {
    type: Number,
    default: Infinity
  },
  min: {
    type: Number,
    default: -Infinity
  },
  modelValue: {
    type: Number,
    required: true
  },
  disabled: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    values: props$j.componentSize
  },
  controls: {
    type: Boolean,
    default: true
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (val) => val >= 0 && val === parseInt(`${val}`, 10)
  }
});
const inputNumberEmits = {
  change: (prev2, cur) => prev2 !== cur,
  blur: (e) => e instanceof FocusEvent,
  focus: (e) => e instanceof FocusEvent,
  input: (val) => util$9.isNumber(val),
  "update:modelValue": (val) => util$9.isNumber(val)
};
inputNumber$1.inputNumberEmits = inputNumberEmits;
inputNumber$1.inputNumberProps = inputNumberProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index$110 = icon$4;
  var index2 = input$2;
  var util2 = util$l;
  var error2 = error$5;
  var iconsVue2 = require$$3;
  var inputNumber3 = inputNumber$1;
  var index$22 = repeatClick;
  var index$32 = useCommonProps;
  var script2 = vue2.defineComponent({
    name: "ElInputNumber",
    components: {
      ElInput: index2.ElInput,
      ElIcon: index$110.ElIcon,
      ArrowUp: iconsVue2.ArrowUp,
      ArrowDown: iconsVue2.ArrowDown,
      Plus: iconsVue2.Plus,
      Minus: iconsVue2.Minus
    },
    directives: {
      RepeatClick: index$22["default"]
    },
    props: inputNumber3.inputNumberProps,
    emits: inputNumber3.inputNumberEmits,
    setup(props2, { emit }) {
      const input3 = vue2.ref();
      const data2 = vue2.reactive({
        currentValue: props2.modelValue,
        userInput: null
      });
      const minDisabled = vue2.computed(() => _decrease(props2.modelValue) < props2.min);
      const maxDisabled = vue2.computed(() => _increase(props2.modelValue) > props2.max);
      const numPrecision = vue2.computed(() => {
        const stepPrecision = getPrecision(props2.step);
        if (props2.precision !== void 0) {
          if (stepPrecision > props2.precision) {
            error2.debugWarn("InputNumber", "precision should not be less than the decimal places of step");
          }
          return props2.precision;
        } else {
          return Math.max(getPrecision(props2.modelValue), stepPrecision);
        }
      });
      const controlsAtRight = vue2.computed(() => {
        return props2.controls && props2.controlsPosition === "right";
      });
      const inputNumberSize = index$32.useSize();
      const inputNumberDisabled = index$32.useDisabled();
      const displayValue = vue2.computed(() => {
        if (data2.userInput !== null) {
          return data2.userInput;
        }
        let currentValue = data2.currentValue;
        if (util2.isNumber(currentValue)) {
          if (Number.isNaN(currentValue))
            return "";
          if (props2.precision !== void 0) {
            currentValue = currentValue.toFixed(props2.precision);
          }
        }
        return currentValue;
      });
      const toPrecision = (num, pre) => {
        if (pre === void 0)
          pre = numPrecision.value;
        return parseFloat(`${Math.round(num * Math.pow(10, pre)) / Math.pow(10, pre)}`);
      };
      const getPrecision = (value) => {
        if (value === void 0)
          return 0;
        const valueString = value.toString();
        const dotPosition = valueString.indexOf(".");
        let precision = 0;
        if (dotPosition !== -1) {
          precision = valueString.length - dotPosition - 1;
        }
        return precision;
      };
      const _increase = (val) => {
        if (!util2.isNumber(val))
          return data2.currentValue;
        const precisionFactor = Math.pow(10, numPrecision.value);
        val = util2.isNumber(val) ? val : NaN;
        return toPrecision((precisionFactor * val + precisionFactor * props2.step) / precisionFactor);
      };
      const _decrease = (val) => {
        if (!util2.isNumber(val))
          return data2.currentValue;
        const precisionFactor = Math.pow(10, numPrecision.value);
        val = util2.isNumber(val) ? val : NaN;
        return toPrecision((precisionFactor * val - precisionFactor * props2.step) / precisionFactor);
      };
      const increase = () => {
        if (inputNumberDisabled.value || maxDisabled.value)
          return;
        const value = props2.modelValue || 0;
        const newVal = _increase(value);
        setCurrentValue(newVal);
      };
      const decrease = () => {
        if (inputNumberDisabled.value || minDisabled.value)
          return;
        const value = props2.modelValue || 0;
        const newVal = _decrease(value);
        setCurrentValue(newVal);
      };
      const setCurrentValue = (newVal) => {
        const oldVal = data2.currentValue;
        if (typeof newVal === "number" && props2.precision !== void 0) {
          newVal = toPrecision(newVal, props2.precision);
        }
        if (newVal !== void 0 && newVal >= props2.max)
          newVal = props2.max;
        if (newVal !== void 0 && newVal <= props2.min)
          newVal = props2.min;
        if (oldVal === newVal)
          return;
        if (!util2.isNumber(newVal)) {
          newVal = NaN;
        }
        data2.userInput = null;
        emit("update:modelValue", newVal);
        emit("input", newVal);
        emit("change", newVal, oldVal);
        data2.currentValue = newVal;
      };
      const handleInput = (value) => {
        return data2.userInput = value;
      };
      const handleInputChange = (value) => {
        const newVal = Number(value);
        if (util2.isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
          setCurrentValue(newVal);
        }
        data2.userInput = null;
      };
      const focus = () => {
        var _a, _b;
        (_b = (_a = input3.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      };
      const blur = () => {
        var _a, _b;
        (_b = (_a = input3.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
      };
      vue2.watch(() => props2.modelValue, (value) => {
        let newVal = Number(value);
        if (newVal !== void 0) {
          if (isNaN(newVal))
            return;
          if (props2.stepStrictly) {
            const stepPrecision = getPrecision(props2.step);
            const precisionFactor = Math.pow(10, stepPrecision);
            newVal = Math.round(newVal / props2.step) * precisionFactor * props2.step / precisionFactor;
          }
          if (props2.precision !== void 0) {
            newVal = toPrecision(newVal, props2.precision);
          }
        }
        if (newVal !== void 0 && newVal > props2.max) {
          newVal = props2.max;
          emit("update:modelValue", newVal);
        }
        if (newVal !== void 0 && newVal < props2.min) {
          newVal = props2.min;
          emit("update:modelValue", newVal);
        }
        data2.currentValue = newVal;
        data2.userInput = null;
      }, { immediate: true });
      vue2.onMounted(() => {
        var _a;
        const innerInput = (_a = input3.value) == null ? void 0 : _a.input;
        innerInput.setAttribute("role", "spinbutton");
        innerInput.setAttribute("aria-valuemax", String(props2.max));
        innerInput.setAttribute("aria-valuemin", String(props2.min));
        innerInput.setAttribute("aria-valuenow", String(data2.currentValue));
        innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
        if (!util2.isNumber(props2.modelValue)) {
          emit("update:modelValue", Number(props2.modelValue));
        }
      });
      vue2.onUpdated(() => {
        var _a;
        const innerInput = (_a = input3.value) == null ? void 0 : _a.input;
        innerInput.setAttribute("aria-valuenow", data2.currentValue);
      });
      return {
        input: input3,
        displayValue,
        handleInput,
        handleInputChange,
        controlsAtRight,
        decrease,
        increase,
        inputNumberSize,
        inputNumberDisabled,
        maxDisabled,
        minDisabled,
        focus,
        blur
      };
    }
  });
  exports["default"] = script2;
})(inputNumber_vue_vue_type_script_lang);
var inputNumber_vue_vue_type_template_id_dec60af6_lang = {};
Object.defineProperty(inputNumber_vue_vue_type_template_id_dec60af6_lang, "__esModule", { value: true });
var vue$1b = require$$0$1;
function render$N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_down = vue$1b.resolveComponent("arrow-down");
  const _component_minus = vue$1b.resolveComponent("minus");
  const _component_el_icon = vue$1b.resolveComponent("el-icon");
  const _component_arrow_up = vue$1b.resolveComponent("arrow-up");
  const _component_plus = vue$1b.resolveComponent("plus");
  const _component_el_input = vue$1b.resolveComponent("el-input");
  const _directive_repeat_click = vue$1b.resolveDirective("repeat-click");
  return vue$1b.openBlock(), vue$1b.createElementBlock("div", {
    class: vue$1b.normalizeClass([
      "el-input-number",
      _ctx.inputNumberSize ? "el-input-number--" + _ctx.inputNumberSize : "",
      { "is-disabled": _ctx.inputNumberDisabled },
      { "is-without-controls": !_ctx.controls },
      { "is-controls-right": _ctx.controlsAtRight }
    ]),
    onDragstart: _cache[4] || (_cache[4] = vue$1b.withModifiers(() => {
    }, ["prevent"]))
  }, [
    _ctx.controls ? vue$1b.withDirectives((vue$1b.openBlock(), vue$1b.createElementBlock("span", {
      key: 0,
      class: vue$1b.normalizeClass(["el-input-number__decrease", { "is-disabled": _ctx.minDisabled }]),
      role: "button",
      onKeydown: _cache[0] || (_cache[0] = vue$1b.withKeys((...args) => _ctx.decrease && _ctx.decrease(...args), ["enter"]))
    }, [
      vue$1b.createVNode(_component_el_icon, null, {
        default: vue$1b.withCtx(() => [
          _ctx.controlsAtRight ? (vue$1b.openBlock(), vue$1b.createBlock(_component_arrow_down, { key: 0 })) : (vue$1b.openBlock(), vue$1b.createBlock(_component_minus, { key: 1 }))
        ]),
        _: 1
      })
    ], 34)), [
      [_directive_repeat_click, _ctx.decrease]
    ]) : vue$1b.createCommentVNode("v-if", true),
    _ctx.controls ? vue$1b.withDirectives((vue$1b.openBlock(), vue$1b.createElementBlock("span", {
      key: 1,
      class: vue$1b.normalizeClass(["el-input-number__increase", { "is-disabled": _ctx.maxDisabled }]),
      role: "button",
      onKeydown: _cache[1] || (_cache[1] = vue$1b.withKeys((...args) => _ctx.increase && _ctx.increase(...args), ["enter"]))
    }, [
      vue$1b.createVNode(_component_el_icon, null, {
        default: vue$1b.withCtx(() => [
          _ctx.controlsAtRight ? (vue$1b.openBlock(), vue$1b.createBlock(_component_arrow_up, { key: 0 })) : (vue$1b.openBlock(), vue$1b.createBlock(_component_plus, { key: 1 }))
        ]),
        _: 1
      })
    ], 34)), [
      [_directive_repeat_click, _ctx.increase]
    ]) : vue$1b.createCommentVNode("v-if", true),
    vue$1b.createVNode(_component_el_input, {
      ref: "input",
      type: "number",
      step: _ctx.step,
      "model-value": _ctx.displayValue,
      placeholder: _ctx.placeholder,
      disabled: _ctx.inputNumberDisabled,
      size: _ctx.inputNumberSize,
      max: _ctx.max,
      min: _ctx.min,
      name: _ctx.name,
      label: _ctx.label,
      onKeydown: [
        vue$1b.withKeys(vue$1b.withModifiers(_ctx.increase, ["prevent"]), ["up"]),
        vue$1b.withKeys(vue$1b.withModifiers(_ctx.decrease, ["prevent"]), ["down"])
      ],
      onBlur: _cache[2] || (_cache[2] = (event) => _ctx.$emit("blur", event)),
      onFocus: _cache[3] || (_cache[3] = (event) => _ctx.$emit("focus", event)),
      onInput: _ctx.handleInput,
      onChange: _ctx.handleInputChange
    }, null, 8, ["step", "model-value", "placeholder", "disabled", "size", "max", "min", "name", "label", "onKeydown", "onInput", "onChange"])
  ], 34);
}
inputNumber_vue_vue_type_template_id_dec60af6_lang.render = render$N;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var inputNumber_vue_vue_type_script_lang$1 = inputNumber_vue_vue_type_script_lang;
  var inputNumber_vue_vue_type_template_id_dec60af6_lang$1 = inputNumber_vue_vue_type_template_id_dec60af6_lang;
  inputNumber_vue_vue_type_script_lang$1["default"].render = inputNumber_vue_vue_type_template_id_dec60af6_lang$1.render;
  inputNumber_vue_vue_type_script_lang$1["default"].__file = "packages/components/input-number/src/input-number.vue";
  exports["default"] = inputNumber_vue_vue_type_script_lang$1["default"];
})(inputNumber2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var inputNumber3 = inputNumber$1;
  var inputNumber_vue_vue_type_script_lang$1 = inputNumber_vue_vue_type_script_lang;
  const ElInputNumber = withInstall2.withInstall(inputNumber_vue_vue_type_script_lang$1["default"]);
  exports.inputNumberEmits = inputNumber3.inputNumberEmits;
  exports.inputNumberProps = inputNumber3.inputNumberProps;
  exports.ElInputNumber = ElInputNumber;
  exports["default"] = ElInputNumber;
})(inputNumber$2);
var link$2 = {};
var link2 = {};
var link_vue_vue_type_script_lang = {};
var link$1 = {};
Object.defineProperty(link$1, "__esModule", { value: true });
var props$i = props$N;
const linkProps = props$i.buildProps({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: "default"
  },
  underline: {
    type: Boolean,
    default: true
  },
  disabled: { type: Boolean, default: false },
  href: { type: String, default: "" },
  icon: {
    type: props$i.definePropType([String, Object]),
    default: ""
  }
});
const linkEmits = {
  click: (evt) => evt instanceof MouseEvent
};
link$1.linkEmits = linkEmits;
link$1.linkProps = linkProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var link3 = link$1;
  var script2 = vue2.defineComponent({
    name: "ElLink",
    components: { ElIcon: index2.ElIcon },
    props: link3.linkProps,
    emits: link3.linkEmits,
    setup(props2, { emit }) {
      function handleClick(event) {
        if (!props2.disabled)
          emit("click", event);
      }
      return {
        handleClick
      };
    }
  });
  exports["default"] = script2;
})(link_vue_vue_type_script_lang);
var link_vue_vue_type_template_id_6a422645_lang = {};
Object.defineProperty(link_vue_vue_type_template_id_6a422645_lang, "__esModule", { value: true });
var vue$1a = require$$0$1;
const _hoisted_1$A = ["href"];
const _hoisted_2$r = {
  key: 1,
  class: "el-link--inner"
};
function render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$1a.resolveComponent("el-icon");
  return vue$1a.openBlock(), vue$1a.createElementBlock("a", {
    class: vue$1a.normalizeClass([
      "el-link",
      _ctx.type ? `el-link--${_ctx.type}` : "",
      _ctx.disabled && "is-disabled",
      _ctx.underline && !_ctx.disabled && "is-underline"
    ]),
    href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.icon ? (vue$1a.openBlock(), vue$1a.createBlock(_component_el_icon, { key: 0 }, {
      default: vue$1a.withCtx(() => [
        (vue$1a.openBlock(), vue$1a.createBlock(vue$1a.resolveDynamicComponent(_ctx.icon)))
      ]),
      _: 1
    })) : vue$1a.createCommentVNode("v-if", true),
    _ctx.$slots.default ? (vue$1a.openBlock(), vue$1a.createElementBlock("span", _hoisted_2$r, [
      vue$1a.renderSlot(_ctx.$slots, "default")
    ])) : vue$1a.createCommentVNode("v-if", true),
    _ctx.$slots.icon ? vue$1a.renderSlot(_ctx.$slots, "icon", { key: 2 }) : vue$1a.createCommentVNode("v-if", true)
  ], 10, _hoisted_1$A);
}
link_vue_vue_type_template_id_6a422645_lang.render = render$M;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var link_vue_vue_type_script_lang$1 = link_vue_vue_type_script_lang;
  var link_vue_vue_type_template_id_6a422645_lang$1 = link_vue_vue_type_template_id_6a422645_lang;
  link_vue_vue_type_script_lang$1["default"].render = link_vue_vue_type_template_id_6a422645_lang$1.render;
  link_vue_vue_type_script_lang$1["default"].__file = "packages/components/link/src/link.vue";
  exports["default"] = link_vue_vue_type_script_lang$1["default"];
})(link2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var link3 = link$1;
  var link_vue_vue_type_script_lang$1 = link_vue_vue_type_script_lang;
  const ElLink = withInstall2.withInstall(link_vue_vue_type_script_lang$1["default"]);
  exports.linkEmits = link3.linkEmits;
  exports.linkProps = link3.linkProps;
  exports.ElLink = ElLink;
  exports["default"] = ElLink;
})(link$2);
var menu$2 = {};
var menu$1 = {};
var menuBar = {};
var menuItem$2 = {};
var submenu = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var aria2 = aria$5;
  class SubMenu2 {
    constructor(parent, domNode) {
      this.parent = parent;
      this.domNode = domNode;
      this.subIndex = 0;
      this.subIndex = 0;
      this.init();
    }
    init() {
      this.subMenuItems = this.domNode.querySelectorAll("li");
      this.addListeners();
    }
    gotoSubIndex(idx) {
      if (idx === this.subMenuItems.length) {
        idx = 0;
      } else if (idx < 0) {
        idx = this.subMenuItems.length - 1;
      }
      this.subMenuItems[idx].focus();
      this.subIndex = idx;
    }
    addListeners() {
      const parentNode = this.parent.domNode;
      Array.prototype.forEach.call(this.subMenuItems, (el) => {
        el.addEventListener("keydown", (event) => {
          let prevDef = false;
          switch (event.code) {
            case aria2.EVENT_CODE.down: {
              this.gotoSubIndex(this.subIndex + 1);
              prevDef = true;
              break;
            }
            case aria2.EVENT_CODE.up: {
              this.gotoSubIndex(this.subIndex - 1);
              prevDef = true;
              break;
            }
            case aria2.EVENT_CODE.tab: {
              aria2.triggerEvent(parentNode, "mouseleave");
              break;
            }
            case aria2.EVENT_CODE.enter:
            case aria2.EVENT_CODE.space: {
              prevDef = true;
              event.currentTarget.click();
              break;
            }
          }
          if (prevDef) {
            event.preventDefault();
            event.stopPropagation();
          }
          return false;
        });
      });
    }
  }
  exports["default"] = SubMenu2;
})(submenu);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var aria2 = aria$5;
  var submenu$1 = submenu;
  class MenuItem2 {
    constructor(domNode) {
      this.domNode = domNode;
      this.submenu = null;
      this.submenu = null;
      this.init();
    }
    init() {
      this.domNode.setAttribute("tabindex", "0");
      const menuChild = this.domNode.querySelector(".el-menu");
      if (menuChild) {
        this.submenu = new submenu$1["default"](this, menuChild);
      }
      this.addListeners();
    }
    addListeners() {
      this.domNode.addEventListener("keydown", (event) => {
        let prevDef = false;
        switch (event.code) {
          case aria2.EVENT_CODE.down: {
            aria2.triggerEvent(event.currentTarget, "mouseenter");
            this.submenu && this.submenu.gotoSubIndex(0);
            prevDef = true;
            break;
          }
          case aria2.EVENT_CODE.up: {
            aria2.triggerEvent(event.currentTarget, "mouseenter");
            this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
            prevDef = true;
            break;
          }
          case aria2.EVENT_CODE.tab: {
            aria2.triggerEvent(event.currentTarget, "mouseleave");
            break;
          }
          case aria2.EVENT_CODE.enter:
          case aria2.EVENT_CODE.space: {
            prevDef = true;
            event.currentTarget.click();
            break;
          }
        }
        if (prevDef) {
          event.preventDefault();
        }
      });
    }
  }
  exports["default"] = MenuItem2;
})(menuItem$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var menuItem3 = menuItem$2;
  class Menu2 {
    constructor(domNode) {
      this.domNode = domNode;
      this.init();
    }
    init() {
      const menuChildren = this.domNode.childNodes;
      Array.from(menuChildren, (child) => {
        if (child.nodeType === 1) {
          new menuItem3["default"](child);
        }
      });
    }
  }
  exports["default"] = Menu2;
})(menuBar);
var menuCollapseTransition = {};
var menuCollapseTransition_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var script2 = vue2.defineComponent({
    name: "ElMenuCollapseTransition",
    setup() {
      const listeners = {
        onBeforeEnter: (el) => el.style.opacity = "0.2",
        onEnter(el, done) {
          dom2.addClass(el, "el-opacity-transition");
          el.style.opacity = "1";
          done();
        },
        onAfterEnter(el) {
          dom2.removeClass(el, "el-opacity-transition");
          el.style.opacity = "";
        },
        onBeforeLeave(el) {
          if (!el.dataset) {
            el.dataset = {};
          }
          if (dom2.hasClass(el, "el-menu--collapse")) {
            dom2.removeClass(el, "el-menu--collapse");
            el.dataset.oldOverflow = el.style.overflow;
            el.dataset.scrollWidth = el.clientWidth.toString();
            dom2.addClass(el, "el-menu--collapse");
          } else {
            dom2.addClass(el, "el-menu--collapse");
            el.dataset.oldOverflow = el.style.overflow;
            el.dataset.scrollWidth = el.clientWidth.toString();
            dom2.removeClass(el, "el-menu--collapse");
          }
          el.style.width = `${el.scrollWidth}px`;
          el.style.overflow = "hidden";
        },
        onLeave(el) {
          dom2.addClass(el, "horizontal-collapse-transition");
          el.style.width = `${el.dataset.scrollWidth}px`;
        }
      };
      return {
        listeners
      };
    }
  });
  exports["default"] = script2;
})(menuCollapseTransition_vue_vue_type_script_lang);
var menuCollapseTransition_vue_vue_type_template_id_db8e3ce6_lang = {};
Object.defineProperty(menuCollapseTransition_vue_vue_type_template_id_db8e3ce6_lang, "__esModule", { value: true });
var vue$19 = require$$0$1;
function render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$19.openBlock(), vue$19.createBlock(vue$19.Transition, vue$19.mergeProps({ mode: "out-in" }, _ctx.listeners), {
    default: vue$19.withCtx(() => [
      vue$19.renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
menuCollapseTransition_vue_vue_type_template_id_db8e3ce6_lang.render = render$L;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var menuCollapseTransition_vue_vue_type_script_lang$1 = menuCollapseTransition_vue_vue_type_script_lang;
  var menuCollapseTransition_vue_vue_type_template_id_db8e3ce6_lang$1 = menuCollapseTransition_vue_vue_type_template_id_db8e3ce6_lang;
  menuCollapseTransition_vue_vue_type_script_lang$1["default"].render = menuCollapseTransition_vue_vue_type_template_id_db8e3ce6_lang$1.render;
  menuCollapseTransition_vue_vue_type_script_lang$1["default"].__file = "packages/components/menu/src/menu-collapse-transition.vue";
  exports["default"] = menuCollapseTransition_vue_vue_type_script_lang$1["default"];
})(menuCollapseTransition);
var subMenu$1 = {};
var useMenu = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var error2 = error$5;
  function useMenu2(instance, currentIndex) {
    const rootMenu = vue2.inject("rootMenu");
    if (!rootMenu)
      error2.throwError("useMenu", "can not inject root menu");
    const indexPath = vue2.computed(() => {
      let parent = instance.parent;
      const path = [currentIndex.value];
      while (parent.type.name !== "ElMenu") {
        if (parent.props.index) {
          path.unshift(parent.props.index);
        }
        parent = parent.parent;
      }
      return path;
    });
    const parentMenu = vue2.computed(() => {
      let parent = instance.parent;
      while (parent && !["ElMenu", "ElSubMenu"].includes(parent.type.name)) {
        parent = parent.parent;
      }
      return parent;
    });
    const paddingStyle = vue2.computed(() => {
      let parent = instance.parent;
      if (rootMenu.props.mode !== "vertical")
        return {};
      let padding = 20;
      if (rootMenu.props.collapse) {
        padding = 20;
      } else {
        while (parent && parent.type.name !== "ElMenu") {
          if (parent.type.name === "ElSubMenu") {
            padding += 20;
          }
          parent = parent.parent;
        }
      }
      return { paddingLeft: `${padding}px` };
    });
    return {
      parentMenu,
      paddingStyle,
      indexPath
    };
  }
  exports["default"] = useMenu2;
})(useMenu);
var useMenuCssVar$1 = {};
var useMenuColor$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var color2 = color$1;
  function useMenuColor2(props2) {
    const menuBarColor = vue2.computed(() => {
      const color$12 = props2.backgroundColor;
      if (!color$12) {
        return "";
      } else {
        return color2.darken(color$12);
      }
    });
    return menuBarColor;
  }
  exports["default"] = useMenuColor2;
})(useMenuColor$1);
Object.defineProperty(useMenuCssVar$1, "__esModule", { value: true });
var vue$18 = require$$0$1;
var useMenuColor = useMenuColor$1;
const useMenuCssVar = (props2) => {
  return vue$18.computed(() => {
    return {
      "--el-menu-text-color": props2.textColor || "",
      "--el-menu-hover-text-color": props2.textColor || "",
      "--el-menu-bg-color": props2.backgroundColor || "",
      "--el-menu-hover-bg-color": useMenuColor["default"](props2).value || "",
      "--el-menu-active-color": props2.activeTextColor || ""
    };
  });
};
useMenuCssVar$1.useMenuCssVar = useMenuCssVar;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var index$22 = collapseTransition$1;
  var index$110 = popper$3;
  var props2 = props$N;
  var error2 = error$5;
  var iconsVue2 = require$$3;
  var index2 = icon$4;
  var useMenu$12 = useMenu;
  var useMenuCssVar2 = useMenuCssVar$1;
  const subMenuProps = props2.buildProps({
    index: {
      type: String,
      required: true
    },
    showTimeout: {
      type: Number,
      default: 300
    },
    hideTimeout: {
      type: Number,
      default: 300
    },
    popperClass: String,
    disabled: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: void 0
    }
  });
  const COMPONENT_NAME = "ElSubMenu";
  var SubMenu2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    props: subMenuProps,
    setup(props3, { slots, expose }) {
      const instance = vue2.getCurrentInstance();
      const { paddingStyle, indexPath, parentMenu } = useMenu$12["default"](instance, vue2.computed(() => props3.index));
      const rootMenu = vue2.inject("rootMenu");
      if (!rootMenu)
        error2.throwError(COMPONENT_NAME, "can not inject root menu");
      const subMenu2 = vue2.inject(`subMenu:${parentMenu.value.uid}`);
      if (!subMenu2)
        error2.throwError(COMPONENT_NAME, "can not inject sub menu");
      const items = vue2.ref({});
      const subMenus = vue2.ref({});
      let timeout;
      const currentPlacement = vue2.ref("");
      const mouseInChild = vue2.ref(false);
      const verticalTitleRef = vue2.ref();
      const vPopper = vue2.ref();
      const subMenuTitleIcon = vue2.computed(() => {
        return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? iconsVue2.ArrowDown : iconsVue2.ArrowRight;
      });
      const isFirstLevel = vue2.computed(() => {
        let isFirstLevel2 = true;
        let parent = instance.parent;
        while (parent && parent.type.name !== "ElMenu") {
          if (["ElSubMenu", "ElMenuItemGroup"].includes(parent.type.name)) {
            isFirstLevel2 = false;
            break;
          } else {
            parent = parent.parent;
          }
        }
        return isFirstLevel2;
      });
      const appendToBody = vue2.computed(() => {
        return props3.popperAppendToBody === void 0 ? isFirstLevel.value : Boolean(props3.popperAppendToBody);
      });
      const menuTransitionName = vue2.computed(() => rootMenu.props.collapse ? "el-zoom-in-left" : "el-zoom-in-top");
      const fallbackPlacements = vue2.computed(() => mode.value === "horizontal" && isFirstLevel.value ? [
        "bottom-start",
        "bottom-end",
        "top-start",
        "top-end",
        "right-start",
        "left-start"
      ] : [
        "right-start",
        "left-start",
        "bottom-start",
        "bottom-end",
        "top-start",
        "top-end"
      ]);
      const opened = vue2.computed(() => rootMenu.openedMenus.includes(props3.index));
      const active = vue2.computed(() => {
        let isActive = false;
        Object.values(items.value).forEach((item22) => {
          if (item22.active) {
            isActive = true;
          }
        });
        Object.values(subMenus.value).forEach((subItem) => {
          if (subItem.active) {
            isActive = true;
          }
        });
        return isActive;
      });
      const backgroundColor = vue2.computed(() => rootMenu.props.backgroundColor || "");
      const activeTextColor = vue2.computed(() => rootMenu.props.activeTextColor || "");
      const textColor = vue2.computed(() => rootMenu.props.textColor || "");
      const mode = vue2.computed(() => rootMenu.props.mode);
      const item2 = vue2.reactive({
        index: props3.index,
        indexPath,
        active
      });
      const titleStyle = vue2.computed(() => {
        if (mode.value !== "horizontal") {
          return {
            color: textColor.value
          };
        }
        return {
          borderBottomColor: active.value ? rootMenu.props.activeTextColor ? activeTextColor.value : "" : "transparent",
          color: active.value ? activeTextColor.value : textColor.value
        };
      });
      const doDestroy = () => {
        var _a;
        return (_a = vPopper.value) == null ? void 0 : _a.doDestroy();
      };
      const handleCollapseToggle = (value) => {
        if (value) {
          updatePlacement();
        } else {
          doDestroy();
        }
      };
      const handleClick = () => {
        if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props3.disabled)
          return;
        rootMenu.handleSubMenuClick({
          index: props3.index,
          indexPath: indexPath.value,
          active: active.value
        });
      };
      const handleMouseenter = (event, showTimeout = props3.showTimeout) => {
        var _a;
        if (event.type === "focus" && !event.relatedTarget) {
          return;
        }
        if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props3.disabled) {
          return;
        }
        mouseInChild.value = true;
        timeout == null ? void 0 : timeout();
        ({ stop: timeout } = core2.useTimeoutFn(() => rootMenu.openMenu(props3.index, indexPath.value), showTimeout));
        if (appendToBody.value) {
          (_a = parentMenu.value.vnode.el) == null ? void 0 : _a.dispatchEvent(new MouseEvent("mouseenter"));
        }
      };
      const handleMouseleave = (deepDispatch = false) => {
        var _a, _b;
        if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") {
          return;
        }
        mouseInChild.value = false;
        timeout == null ? void 0 : timeout();
        ({ stop: timeout } = core2.useTimeoutFn(() => !mouseInChild.value && rootMenu.closeMenu(props3.index, indexPath.value), props3.hideTimeout));
        if (appendToBody.value && deepDispatch) {
          if (((_a = instance.parent) == null ? void 0 : _a.type.name) === "ElSubMenu") {
            (_b = subMenu2.handleMouseleave) == null ? void 0 : _b.call(subMenu2, true);
          }
        }
      };
      const updatePlacement = () => {
        currentPlacement.value = mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start";
      };
      vue2.watch(() => rootMenu.props.collapse, (value) => handleCollapseToggle(Boolean(value)));
      {
        const addSubMenu = (item22) => {
          subMenus.value[item22.index] = item22;
        };
        const removeSubMenu = (item22) => {
          delete subMenus.value[item22.index];
        };
        vue2.provide(`subMenu:${instance.uid}`, {
          addSubMenu,
          removeSubMenu,
          handleMouseleave
        });
      }
      expose({
        opened
      });
      vue2.onMounted(() => {
        rootMenu.addSubMenu(item2);
        subMenu2.addSubMenu(item2);
        updatePlacement();
      });
      vue2.onBeforeUnmount(() => {
        subMenu2.removeSubMenu(item2);
        rootMenu.removeSubMenu(item2);
      });
      return () => {
        var _a;
        const titleTag = [
          (_a = slots.title) == null ? void 0 : _a.call(slots),
          vue2.h(index2.ElIcon, {
            class: ["el-sub-menu__icon-arrow"]
          }, { default: () => vue2.h(subMenuTitleIcon.value) })
        ];
        const ulStyle = useMenuCssVar2.useMenuCssVar(rootMenu.props);
        const child = rootMenu.isMenuPopup ? vue2.h(index$110["default"], {
          ref: vPopper,
          manualMode: true,
          visible: opened.value,
          effect: "light",
          pure: true,
          offset: 6,
          showArrow: false,
          popperClass: props3.popperClass,
          placement: currentPlacement.value,
          appendToBody: appendToBody.value,
          fallbackPlacements: fallbackPlacements.value,
          transition: menuTransitionName.value,
          gpuAcceleration: false
        }, {
          default: () => {
            var _a2;
            return vue2.h("div", {
              class: [`el-menu--${mode.value}`, props3.popperClass],
              onMouseenter: (evt) => handleMouseenter(evt, 100),
              onMouseleave: () => handleMouseleave(true),
              onFocus: (evt) => handleMouseenter(evt, 100)
            }, [
              vue2.h("ul", {
                class: [
                  "el-menu el-menu--popup",
                  `el-menu--popup-${currentPlacement.value}`
                ],
                style: ulStyle.value
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])
            ]);
          },
          trigger: () => vue2.h("div", {
            class: "el-sub-menu__title",
            style: [
              paddingStyle.value,
              titleStyle.value,
              { backgroundColor: backgroundColor.value }
            ],
            onClick: handleClick
          }, titleTag)
        }) : vue2.h(vue2.Fragment, {}, [
          vue2.h("div", {
            class: "el-sub-menu__title",
            style: [
              paddingStyle.value,
              titleStyle.value,
              { backgroundColor: backgroundColor.value }
            ],
            ref: verticalTitleRef,
            onClick: handleClick
          }, titleTag),
          vue2.h(index$22["default"], {}, {
            default: () => {
              var _a2;
              return vue2.withDirectives(vue2.h("ul", {
                role: "menu",
                class: "el-menu el-menu--inline",
                style: ulStyle.value
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vue2.vShow, opened.value]]);
            }
          })
        ]);
        return vue2.h("li", {
          class: [
            "el-sub-menu",
            {
              "is-active": active.value,
              "is-opened": opened.value,
              "is-disabled": props3.disabled
            }
          ],
          role: "menuitem",
          ariaHaspopup: true,
          ariaExpanded: opened.value,
          onMouseenter: handleMouseenter,
          onMouseleave: () => handleMouseleave(true),
          onFocus: handleMouseenter
        }, [child]);
      };
    }
  });
  exports["default"] = SubMenu2;
  exports.subMenuProps = subMenuProps;
})(subMenu$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index$110 = icon$4;
  var iconsVue2 = require$$3;
  var menuBar$1 = menuBar;
  var props2 = props$N;
  var subMenu2 = subMenu$1;
  var useMenuCssVar2 = useMenuCssVar$1;
  var shared2 = require$$1$1;
  var index2 = resize;
  var menuCollapseTransition_vue_vue_type_script_lang$1 = menuCollapseTransition_vue_vue_type_script_lang;
  const menuProps = props2.buildProps({
    mode: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "vertical"
    },
    defaultActive: {
      type: String,
      default: ""
    },
    defaultOpeneds: {
      type: props2.definePropType(Array),
      default: () => props2.mutable([])
    },
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
      type: String,
      values: ["hover", "click"],
      default: "hover"
    },
    collapse: Boolean,
    backgroundColor: String,
    textColor: String,
    activeTextColor: String,
    collapseTransition: {
      type: Boolean,
      default: true
    },
    ellipsis: {
      type: Boolean,
      default: true
    }
  });
  const checkIndexPath = (indexPath) => Array.isArray(indexPath) && indexPath.every((path) => shared2.isString(path));
  const menuEmits = {
    close: (index3, indexPath) => shared2.isString(index3) && checkIndexPath(indexPath),
    open: (index3, indexPath) => shared2.isString(index3) && checkIndexPath(indexPath),
    select: (index3, indexPath, item2, routerResult) => shared2.isString(index3) && checkIndexPath(indexPath) && shared2.isObject(item2) && (routerResult === void 0 || routerResult instanceof Promise)
  };
  var Menu2 = vue2.defineComponent({
    name: "ElMenu",
    props: menuProps,
    emits: menuEmits,
    setup(props3, { emit, slots, expose }) {
      const instance = vue2.getCurrentInstance();
      const router = instance.appContext.config.globalProperties.$router;
      const menu2 = vue2.ref();
      const openedMenus = vue2.ref(props3.defaultOpeneds && !props3.collapse ? props3.defaultOpeneds.slice(0) : []);
      const activeIndex = vue2.ref(props3.defaultActive);
      const items = vue2.ref({});
      const subMenus = vue2.ref({});
      const alteredCollapse = vue2.ref(false);
      const isMenuPopup = vue2.computed(() => {
        return props3.mode === "horizontal" || props3.mode === "vertical" && props3.collapse;
      });
      const initMenu = () => {
        const activeItem = activeIndex.value && items.value[activeIndex.value];
        if (!activeItem || props3.mode === "horizontal" || props3.collapse)
          return;
        const indexPath = activeItem.indexPath;
        indexPath.forEach((index3) => {
          const subMenu3 = subMenus.value[index3];
          subMenu3 && openMenu(index3, subMenu3.indexPath);
        });
      };
      const openMenu = (index3, indexPath) => {
        if (openedMenus.value.includes(index3))
          return;
        if (props3.uniqueOpened) {
          openedMenus.value = openedMenus.value.filter((index22) => indexPath.includes(index22));
        }
        openedMenus.value.push(index3);
        emit("open", index3, indexPath);
      };
      const closeMenu = (index3, indexPath) => {
        const i = openedMenus.value.indexOf(index3);
        if (i !== -1) {
          openedMenus.value.splice(i, 1);
        }
        emit("close", index3, indexPath);
      };
      const handleSubMenuClick = ({
        index: index3,
        indexPath
      }) => {
        const isOpened = openedMenus.value.includes(index3);
        if (isOpened) {
          closeMenu(index3, indexPath);
        } else {
          openMenu(index3, indexPath);
        }
      };
      const handleMenuItemClick = (menuItem3) => {
        if (props3.mode === "horizontal" || props3.collapse) {
          openedMenus.value = [];
        }
        const { index: index3, indexPath } = menuItem3;
        if (index3 === void 0 || indexPath === void 0)
          return;
        if (props3.router && router) {
          const route = menuItem3.route || index3;
          const routerResult = router.push(route).then((res) => {
            if (!res)
              activeIndex.value = index3;
            return res;
          });
          emit("select", index3, indexPath, { index: index3, indexPath, route }, routerResult);
        } else {
          activeIndex.value = index3;
          emit("select", index3, indexPath, { index: index3, indexPath });
        }
      };
      const updateActiveIndex = (val) => {
        const itemsInData = items.value;
        const item2 = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props3.defaultActive];
        if (item2) {
          activeIndex.value = item2.index;
          initMenu();
        } else {
          if (!alteredCollapse.value) {
            activeIndex.value = void 0;
          } else {
            alteredCollapse.value = false;
          }
        }
      };
      const handleResize = () => {
        vue2.nextTick(() => instance.proxy.$forceUpdate());
      };
      vue2.watch(() => props3.defaultActive, (currentActive) => {
        if (!items.value[currentActive]) {
          activeIndex.value = "";
        }
        updateActiveIndex(currentActive);
      });
      vue2.watch(items.value, () => initMenu());
      vue2.watch(() => props3.collapse, (value, prev2) => {
        if (value !== prev2) {
          alteredCollapse.value = true;
        }
        if (value)
          openedMenus.value = [];
      });
      {
        const addSubMenu = (item2) => {
          subMenus.value[item2.index] = item2;
        };
        const removeSubMenu = (item2) => {
          delete subMenus.value[item2.index];
        };
        const addMenuItem = (item2) => {
          items.value[item2.index] = item2;
        };
        const removeMenuItem = (item2) => {
          delete items.value[item2.index];
        };
        vue2.provide("rootMenu", vue2.reactive({
          props: props3,
          openedMenus,
          items,
          subMenus,
          activeIndex,
          isMenuPopup,
          addMenuItem,
          removeMenuItem,
          addSubMenu,
          removeSubMenu,
          openMenu,
          closeMenu,
          handleMenuItemClick,
          handleSubMenuClick
        }));
        vue2.provide(`subMenu:${instance.uid}`, {
          addSubMenu,
          removeSubMenu
        });
      }
      vue2.onMounted(() => {
        initMenu();
        if (props3.mode === "horizontal") {
          new menuBar$1["default"](instance.vnode.el);
        }
      });
      {
        const open2 = (index3) => {
          const { indexPath } = subMenus.value[index3];
          indexPath.forEach((i) => openMenu(i, indexPath));
        };
        expose({
          open: open2,
          close: closeMenu,
          handleResize
        });
      }
      const flattedChildren = (children) => {
        const vnodes = Array.isArray(children) ? children : [children];
        const result3 = [];
        vnodes.forEach((child) => {
          if (Array.isArray(child.children)) {
            result3.push(...flattedChildren(child.children));
          } else {
            result3.push(child);
          }
        });
        return result3;
      };
      const useVNodeResize = (vnode2) => props3.mode === "horizontal" ? vue2.withDirectives(vnode2, [[index2["default"], handleResize]]) : vnode2;
      return () => {
        var _a, _b, _c, _d;
        let slot = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
        const vShowMore = [];
        if (props3.mode === "horizontal" && menu2.value) {
          const items2 = Array.from((_d = (_c = menu2.value) == null ? void 0 : _c.childNodes) != null ? _d : []).filter((item2) => item2.nodeName !== "#text" || item2.nodeValue);
          const originalSlot = flattedChildren(slot);
          const moreItemWidth = 64;
          const paddingLeft = parseInt(getComputedStyle(menu2.value).paddingLeft, 10);
          const paddingRight = parseInt(getComputedStyle(menu2.value).paddingRight, 10);
          const menuWidth = menu2.value.clientWidth - paddingLeft - paddingRight;
          let calcWidth = 0;
          let sliceIndex = 0;
          items2.forEach((item2, index3) => {
            calcWidth += item2.offsetWidth || 0;
            if (calcWidth <= menuWidth - moreItemWidth) {
              sliceIndex = index3 + 1;
            }
          });
          const slotDefault = originalSlot.slice(0, sliceIndex);
          const slotMore = originalSlot.slice(sliceIndex);
          if ((slotMore == null ? void 0 : slotMore.length) && props3.ellipsis) {
            slot = slotDefault;
            vShowMore.push(vue2.h(subMenu2["default"], {
              index: "sub-menu-more",
              class: "el-sub-menu__hide-arrow"
            }, {
              title: () => vue2.h(index$110.ElIcon, {
                class: ["el-sub-menu__icon-more"]
              }, { default: () => vue2.h(iconsVue2.More) }),
              default: () => slotMore
            }));
          }
        }
        const ulStyle = useMenuCssVar2.useMenuCssVar(props3);
        const resizeMenu = (vNode) => props3.ellipsis ? useVNodeResize(vNode) : vNode;
        const vMenu = resizeMenu(vue2.h("ul", {
          key: String(props3.collapse),
          role: "menubar",
          ref: menu2,
          style: ulStyle.value,
          class: {
            "el-menu": true,
            "el-menu--horizontal": props3.mode === "horizontal",
            "el-menu--collapse": props3.collapse
          }
        }, [...slot.map((vnode2) => resizeMenu(vnode2)), ...vShowMore]));
        if (props3.collapseTransition && props3.mode === "vertical") {
          return vue2.h(menuCollapseTransition_vue_vue_type_script_lang$1["default"], () => vMenu);
        }
        return vMenu;
      };
    }
  });
  exports["default"] = Menu2;
  exports.menuEmits = menuEmits;
  exports.menuProps = menuProps;
})(menu$1);
var menuItem2 = {};
var menuItem_vue_vue_type_script_lang = {};
var tooltip = {};
var src$8 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = popper$3;
  var constants2 = constants$f;
  var error2 = error$5;
  var vnode2 = vnode$1;
  var defaults2 = defaults$d;
  var Tooltip = vue2.defineComponent({
    name: "ElTooltip",
    components: {
      ElPopper: index2["default"]
    },
    props: __spreadProps(__spreadValues({}, defaults2["default"]), {
      manual: {
        type: Boolean,
        default: false
      },
      modelValue: {
        type: Boolean,
        validator: (val) => {
          return typeof val === "boolean";
        },
        default: void 0
      },
      openDelay: {
        type: Number,
        default: 0
      },
      visibleArrow: {
        type: Boolean,
        default: true
      },
      tabindex: {
        type: [String, Number],
        default: "0"
      }
    }),
    emits: [constants2.UPDATE_MODEL_EVENT],
    setup(props2, ctx) {
      if (props2.manual && typeof props2.modelValue === "undefined") {
        error2.throwError("[ElTooltip]", "You need to pass a v-model to el-tooltip when `manual` is true");
      }
      const popper2 = vue2.ref(null);
      const onUpdateVisible = (val) => {
        ctx.emit(constants2.UPDATE_MODEL_EVENT, val);
      };
      const updatePopper = () => {
        return popper2.value.update();
      };
      return {
        popper: popper2,
        onUpdateVisible,
        updatePopper
      };
    },
    render() {
      const {
        $slots,
        content,
        manual,
        openDelay,
        onUpdateVisible,
        showAfter,
        visibleArrow,
        modelValue,
        tabindex,
        fallbackPlacements
      } = this;
      const throwErrorTip = () => {
        error2.throwError("[ElTooltip]", "you need to provide a valid default slot.");
      };
      const popper2 = vue2.h(index2["default"], __spreadProps(__spreadValues({}, Object.keys(defaults2["default"]).reduce((result3, key2) => {
        return __spreadProps(__spreadValues({}, result3), { [key2]: this[key2] });
      }, {})), {
        ref: "popper",
        manualMode: manual,
        showAfter: openDelay || showAfter,
        showArrow: visibleArrow,
        visible: modelValue,
        "onUpdate:visible": onUpdateVisible,
        fallbackPlacements: fallbackPlacements.length ? fallbackPlacements : ["bottom-start", "top-start", "right", "left"]
      }), {
        default: () => $slots.content ? $slots.content() : content,
        trigger: () => {
          if ($slots.default) {
            const firstVnode = vnode2.getFirstValidNode($slots.default(), 1);
            if (!firstVnode)
              throwErrorTip();
            return vue2.cloneVNode(firstVnode, { tabindex }, true);
          }
          throwErrorTip();
        }
      });
      return popper2;
    }
  });
  exports["default"] = Tooltip;
})(src$8);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index2 = src$8;
  index2["default"].install = (app) => {
    app.component(index2["default"].name, index2["default"]);
  };
  const _Tooltip = index2["default"];
  const ElTooltip = _Tooltip;
  exports.ElTooltip = ElTooltip;
  exports["default"] = _Tooltip;
})(tooltip);
var menuItem$1 = {};
Object.defineProperty(menuItem$1, "__esModule", { value: true });
var props$h = props$N;
var shared$8 = require$$1$1;
const menuItemProps = props$h.buildProps({
  index: {
    type: props$h.definePropType([String, null]),
    default: null
  },
  route: {
    type: props$h.definePropType([String, Object])
  },
  disabled: Boolean
});
const menuItemEmits = {
  click: (item2) => shared$8.isString(item2.index) && Array.isArray(item2.indexPath)
};
menuItem$1.menuItemEmits = menuItemEmits;
menuItem$1.menuItemProps = menuItemProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = tooltip;
  var error2 = error$5;
  var useMenu$12 = useMenu;
  var menuItem3 = menuItem$1;
  var defaults2 = defaults$d;
  const COMPONENT_NAME = "ElMenuItem";
  var script2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    components: {
      ElTooltip: index2["default"]
    },
    props: menuItem3.menuItemProps,
    emits: menuItem3.menuItemEmits,
    setup(props2, { emit }) {
      const instance = vue2.getCurrentInstance();
      const rootMenu = vue2.inject("rootMenu");
      if (!rootMenu)
        error2.throwError(COMPONENT_NAME, "can not inject root menu");
      const { parentMenu, paddingStyle, indexPath } = useMenu$12["default"](instance, vue2.toRef(props2, "index"));
      const subMenu2 = vue2.inject(`subMenu:${parentMenu.value.uid}`);
      if (!subMenu2)
        error2.throwError(COMPONENT_NAME, "can not inject sub menu");
      const active = vue2.computed(() => props2.index === rootMenu.activeIndex);
      const item2 = vue2.reactive({
        index: props2.index,
        indexPath,
        active
      });
      const handleClick = () => {
        if (!props2.disabled) {
          rootMenu.handleMenuItemClick({
            index: props2.index,
            indexPath: indexPath.value,
            route: props2.route
          });
          emit("click", item2);
        }
      };
      vue2.onMounted(() => {
        subMenu2.addSubMenu(item2);
        rootMenu.addMenuItem(item2);
      });
      vue2.onBeforeUnmount(() => {
        subMenu2.removeSubMenu(item2);
        rootMenu.removeMenuItem(item2);
      });
      return {
        Effect: defaults2.Effect,
        parentMenu,
        rootMenu,
        paddingStyle,
        active,
        handleClick
      };
    }
  });
  exports["default"] = script2;
})(menuItem_vue_vue_type_script_lang);
var menuItem_vue_vue_type_template_id_aa755baa_lang = {};
Object.defineProperty(menuItem_vue_vue_type_template_id_aa755baa_lang, "__esModule", { value: true });
var vue$17 = require$$0$1;
const _hoisted_1$z = { style: {
  position: "absolute",
  left: 0,
  top: 0,
  height: "100%",
  width: "100%",
  display: "inline-block",
  boxSizing: "border-box",
  padding: "0 20px"
} };
function render$K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = vue$17.resolveComponent("el-tooltip");
  return vue$17.openBlock(), vue$17.createElementBlock("li", {
    class: vue$17.normalizeClass(["el-menu-item", {
      "is-active": _ctx.active,
      "is-disabled": _ctx.disabled
    }]),
    role: "menuitem",
    tabindex: "-1",
    style: vue$17.normalizeStyle(_ctx.paddingStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.$slots.title ? (vue$17.openBlock(), vue$17.createBlock(_component_el_tooltip, {
      key: 0,
      effect: _ctx.Effect.DARK,
      placement: "right"
    }, {
      content: vue$17.withCtx(() => [
        vue$17.renderSlot(_ctx.$slots, "title")
      ]),
      default: vue$17.withCtx(() => [
        vue$17.createElementVNode("div", _hoisted_1$z, [
          vue$17.renderSlot(_ctx.$slots, "default")
        ])
      ]),
      _: 3
    }, 8, ["effect"])) : (vue$17.openBlock(), vue$17.createElementBlock(vue$17.Fragment, { key: 1 }, [
      vue$17.renderSlot(_ctx.$slots, "default"),
      vue$17.renderSlot(_ctx.$slots, "title")
    ], 64))
  ], 6);
}
menuItem_vue_vue_type_template_id_aa755baa_lang.render = render$K;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var menuItem_vue_vue_type_script_lang$1 = menuItem_vue_vue_type_script_lang;
  var menuItem_vue_vue_type_template_id_aa755baa_lang$1 = menuItem_vue_vue_type_template_id_aa755baa_lang;
  menuItem_vue_vue_type_script_lang$1["default"].render = menuItem_vue_vue_type_template_id_aa755baa_lang$1.render;
  menuItem_vue_vue_type_script_lang$1["default"].__file = "packages/components/menu/src/menu-item.vue";
  exports["default"] = menuItem_vue_vue_type_script_lang$1["default"];
})(menuItem2);
var menuItemGroup2 = {};
var menuItemGroup_vue_vue_type_script_lang = {};
var menuItemGroup$1 = {};
Object.defineProperty(menuItemGroup$1, "__esModule", { value: true });
const menuItemGroupProps = {
  title: String
};
menuItemGroup$1.menuItemGroupProps = menuItemGroupProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var error2 = error$5;
  var menuItemGroup3 = menuItemGroup$1;
  const COMPONENT_NAME = "ElMenuItemGroup";
  var script2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    props: menuItemGroup3.menuItemGroupProps,
    setup() {
      const instance = vue2.getCurrentInstance();
      const menu2 = vue2.inject("rootMenu");
      if (!menu2)
        error2.throwError(COMPONENT_NAME, "can not inject root menu");
      const levelPadding = vue2.computed(() => {
        if (menu2.props.collapse)
          return 20;
        let padding = 20;
        let parent = instance.parent;
        while (parent && parent.type.name !== "ElMenu") {
          if (parent.type.name === "ElSubMenu") {
            padding += 20;
          }
          parent = parent.parent;
        }
        return padding;
      });
      return {
        levelPadding
      };
    }
  });
  exports["default"] = script2;
})(menuItemGroup_vue_vue_type_script_lang);
var menuItemGroup_vue_vue_type_template_id_67a2995d_lang = {};
Object.defineProperty(menuItemGroup_vue_vue_type_template_id_67a2995d_lang, "__esModule", { value: true });
var vue$16 = require$$0$1;
const _hoisted_1$y = { class: "el-menu-item-group" };
function render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$16.openBlock(), vue$16.createElementBlock("li", _hoisted_1$y, [
    vue$16.createElementVNode("div", {
      class: "el-menu-item-group__title",
      style: vue$16.normalizeStyle({ paddingLeft: `${_ctx.levelPadding}px` })
    }, [
      !_ctx.$slots.title ? (vue$16.openBlock(), vue$16.createElementBlock(vue$16.Fragment, { key: 0 }, [
        vue$16.createTextVNode(vue$16.toDisplayString(_ctx.title), 1)
      ], 2112)) : vue$16.renderSlot(_ctx.$slots, "title", { key: 1 })
    ], 4),
    vue$16.createElementVNode("ul", null, [
      vue$16.renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
menuItemGroup_vue_vue_type_template_id_67a2995d_lang.render = render$J;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var menuItemGroup_vue_vue_type_script_lang$1 = menuItemGroup_vue_vue_type_script_lang;
  var menuItemGroup_vue_vue_type_template_id_67a2995d_lang$1 = menuItemGroup_vue_vue_type_template_id_67a2995d_lang;
  menuItemGroup_vue_vue_type_script_lang$1["default"].render = menuItemGroup_vue_vue_type_template_id_67a2995d_lang$1.render;
  menuItemGroup_vue_vue_type_script_lang$1["default"].__file = "packages/components/menu/src/menu-item-group.vue";
  exports["default"] = menuItemGroup_vue_vue_type_script_lang$1["default"];
})(menuItemGroup2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var menu2 = menu$1;
  var subMenu2 = subMenu$1;
  var menuItem3 = menuItem$1;
  var menuItemGroup3 = menuItemGroup$1;
  var menuItem_vue_vue_type_script_lang$1 = menuItem_vue_vue_type_script_lang;
  var menuItemGroup_vue_vue_type_script_lang$1 = menuItemGroup_vue_vue_type_script_lang;
  const ElMenu = withInstall2.withInstall(menu2["default"], {
    MenuItem: menuItem_vue_vue_type_script_lang$1["default"],
    MenuItemGroup: menuItemGroup_vue_vue_type_script_lang$1["default"],
    SubMenu: subMenu2["default"]
  });
  const ElMenuItem = withInstall2.withNoopInstall(menuItem_vue_vue_type_script_lang$1["default"]);
  const ElMenuItemGroup = withInstall2.withNoopInstall(menuItemGroup_vue_vue_type_script_lang$1["default"]);
  const ElSubMenu = withInstall2.withNoopInstall(subMenu2["default"]);
  exports.menuEmits = menu2.menuEmits;
  exports.menuProps = menu2.menuProps;
  exports.subMenuProps = subMenu2.subMenuProps;
  exports.menuItemEmits = menuItem3.menuItemEmits;
  exports.menuItemProps = menuItem3.menuItemProps;
  exports.menuItemGroupProps = menuItemGroup3.menuItemGroupProps;
  exports.ElMenu = ElMenu;
  exports.ElMenuItem = ElMenuItem;
  exports.ElMenuItemGroup = ElMenuItemGroup;
  exports.ElSubMenu = ElSubMenu;
  exports["default"] = ElMenu;
})(menu$2);
var pageHeader$2 = {};
var pageHeader2 = {};
var pageHeader_vue_vue_type_script_lang = {};
var pageHeader$1 = {};
Object.defineProperty(pageHeader$1, "__esModule", { value: true });
var iconsVue$5 = require$$3;
const pageHeaderProps = {
  icon: {
    type: [String, Object],
    default: iconsVue$5.Back
  },
  title: String,
  content: {
    type: String,
    default: ""
  }
};
const pageHeaderEmits = {
  back: () => true
};
pageHeader$1.pageHeaderEmits = pageHeaderEmits;
pageHeader$1.pageHeaderProps = pageHeaderProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var pageHeader3 = pageHeader$1;
  var index$110 = useLocale$1;
  var script2 = vue2.defineComponent({
    name: "ElPageHeader",
    components: {
      ElIcon: index2.ElIcon
    },
    props: pageHeader3.pageHeaderProps,
    emits: pageHeader3.pageHeaderEmits,
    setup(_2, { emit }) {
      const { t } = index$110.useLocale();
      function handleClick() {
        emit("back");
      }
      return {
        handleClick,
        t
      };
    }
  });
  exports["default"] = script2;
})(pageHeader_vue_vue_type_script_lang);
var pageHeader_vue_vue_type_template_id_d12fb4b2_lang = {};
Object.defineProperty(pageHeader_vue_vue_type_template_id_d12fb4b2_lang, "__esModule", { value: true });
var vue$15 = require$$0$1;
const _hoisted_1$x = { class: "el-page-header" };
const _hoisted_2$q = {
  key: 0,
  class: "el-page-header__icon"
};
const _hoisted_3$l = { class: "el-page-header__title" };
const _hoisted_4$d = { class: "el-page-header__content" };
function render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$15.resolveComponent("el-icon");
  return vue$15.openBlock(), vue$15.createElementBlock("div", _hoisted_1$x, [
    vue$15.createElementVNode("div", {
      class: "el-page-header__left",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.icon || _ctx.$slots.icon ? (vue$15.openBlock(), vue$15.createElementBlock("div", _hoisted_2$q, [
        vue$15.renderSlot(_ctx.$slots, "icon", {}, () => [
          _ctx.icon ? (vue$15.openBlock(), vue$15.createBlock(_component_el_icon, { key: 0 }, {
            default: vue$15.withCtx(() => [
              (vue$15.openBlock(), vue$15.createBlock(vue$15.resolveDynamicComponent(_ctx.icon)))
            ]),
            _: 1
          })) : vue$15.createCommentVNode("v-if", true)
        ])
      ])) : vue$15.createCommentVNode("v-if", true),
      vue$15.createElementVNode("div", _hoisted_3$l, [
        vue$15.renderSlot(_ctx.$slots, "title", {}, () => [
          vue$15.createTextVNode(vue$15.toDisplayString(_ctx.title || _ctx.t("el.pageHeader.title")), 1)
        ])
      ])
    ]),
    vue$15.createElementVNode("div", _hoisted_4$d, [
      vue$15.renderSlot(_ctx.$slots, "content", {}, () => [
        vue$15.createTextVNode(vue$15.toDisplayString(_ctx.content), 1)
      ])
    ])
  ]);
}
pageHeader_vue_vue_type_template_id_d12fb4b2_lang.render = render$I;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var pageHeader_vue_vue_type_script_lang$1 = pageHeader_vue_vue_type_script_lang;
  var pageHeader_vue_vue_type_template_id_d12fb4b2_lang$1 = pageHeader_vue_vue_type_template_id_d12fb4b2_lang;
  pageHeader_vue_vue_type_script_lang$1["default"].render = pageHeader_vue_vue_type_template_id_d12fb4b2_lang$1.render;
  pageHeader_vue_vue_type_script_lang$1["default"].__file = "packages/components/page-header/src/page-header.vue";
  exports["default"] = pageHeader_vue_vue_type_script_lang$1["default"];
})(pageHeader2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var pageHeader3 = pageHeader$1;
  var pageHeader_vue_vue_type_script_lang$1 = pageHeader_vue_vue_type_script_lang;
  const ElPageHeader = withInstall2.withInstall(pageHeader_vue_vue_type_script_lang$1["default"]);
  exports.pageHeaderEmits = pageHeader3.pageHeaderEmits;
  exports.pageHeaderProps = pageHeader3.pageHeaderProps;
  exports.ElPageHeader = ElPageHeader;
  exports["default"] = ElPageHeader;
})(pageHeader$2);
var pagination$3 = {};
var pagination$2 = {};
var prev = {};
var prev_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  const paginationPrevProps = {
    disabled: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    prevText: {
      type: String,
      default: ""
    }
  };
  var script2 = vue2.defineComponent({
    name: "ElPaginationPrev",
    components: {
      ElIcon: index2.ElIcon,
      ArrowLeft: iconsVue2.ArrowLeft
    },
    props: paginationPrevProps,
    emits: ["click"],
    setup(props2) {
      const internalDisabled = vue2.computed(() => props2.disabled || props2.currentPage <= 1);
      return {
        internalDisabled
      };
    }
  });
  exports["default"] = script2;
})(prev_vue_vue_type_script_lang);
var prev_vue_vue_type_template_id_15259d71_lang = {};
Object.defineProperty(prev_vue_vue_type_template_id_15259d71_lang, "__esModule", { value: true });
var vue$14 = require$$0$1;
const _hoisted_1$w = ["disabled", "aria-disabled"];
const _hoisted_2$p = { key: 0 };
function render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_left = vue$14.resolveComponent("arrow-left");
  const _component_el_icon = vue$14.resolveComponent("el-icon");
  return vue$14.openBlock(), vue$14.createElementBlock("button", {
    type: "button",
    class: "btn-prev",
    disabled: _ctx.internalDisabled,
    "aria-disabled": _ctx.internalDisabled,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }, [
    _ctx.prevText ? (vue$14.openBlock(), vue$14.createElementBlock("span", _hoisted_2$p, vue$14.toDisplayString(_ctx.prevText), 1)) : (vue$14.openBlock(), vue$14.createBlock(_component_el_icon, { key: 1 }, {
      default: vue$14.withCtx(() => [
        vue$14.createVNode(_component_arrow_left)
      ]),
      _: 1
    }))
  ], 8, _hoisted_1$w);
}
prev_vue_vue_type_template_id_15259d71_lang.render = render$H;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var prev_vue_vue_type_script_lang$1 = prev_vue_vue_type_script_lang;
  var prev_vue_vue_type_template_id_15259d71_lang$1 = prev_vue_vue_type_template_id_15259d71_lang;
  prev_vue_vue_type_script_lang$1["default"].render = prev_vue_vue_type_template_id_15259d71_lang$1.render;
  prev_vue_vue_type_script_lang$1["default"].__file = "packages/components/pagination/src/components/prev.vue";
  exports["default"] = prev_vue_vue_type_script_lang$1["default"];
})(prev);
var next = {};
var next_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  const paginationNextProps = {
    disabled: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      default: 50
    },
    nextText: {
      type: String,
      default: ""
    }
  };
  var script2 = vue2.defineComponent({
    name: "ElPaginationNext",
    components: {
      ElIcon: index2.ElIcon,
      ArrowRight: iconsVue2.ArrowRight
    },
    props: paginationNextProps,
    emits: ["click"],
    setup(props2) {
      const internalDisabled = vue2.computed(() => props2.disabled || props2.currentPage === props2.pageCount || props2.pageCount === 0);
      return {
        internalDisabled
      };
    }
  });
  exports["default"] = script2;
})(next_vue_vue_type_script_lang);
var next_vue_vue_type_template_id_93fbb39e_lang = {};
Object.defineProperty(next_vue_vue_type_template_id_93fbb39e_lang, "__esModule", { value: true });
var vue$13 = require$$0$1;
const _hoisted_1$v = ["disabled", "aria-disabled"];
const _hoisted_2$o = { key: 0 };
function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_right = vue$13.resolveComponent("arrow-right");
  const _component_el_icon = vue$13.resolveComponent("el-icon");
  return vue$13.openBlock(), vue$13.createElementBlock("button", {
    type: "button",
    class: "btn-next",
    disabled: _ctx.internalDisabled,
    "aria-disabled": _ctx.internalDisabled,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }, [
    _ctx.nextText ? (vue$13.openBlock(), vue$13.createElementBlock("span", _hoisted_2$o, vue$13.toDisplayString(_ctx.nextText), 1)) : (vue$13.openBlock(), vue$13.createBlock(_component_el_icon, { key: 1 }, {
      default: vue$13.withCtx(() => [
        vue$13.createVNode(_component_arrow_right)
      ]),
      _: 1
    }))
  ], 8, _hoisted_1$v);
}
next_vue_vue_type_template_id_93fbb39e_lang.render = render$G;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var next_vue_vue_type_script_lang$1 = next_vue_vue_type_script_lang;
  var next_vue_vue_type_template_id_93fbb39e_lang$1 = next_vue_vue_type_template_id_93fbb39e_lang;
  next_vue_vue_type_script_lang$1["default"].render = next_vue_vue_type_template_id_93fbb39e_lang$1.render;
  next_vue_vue_type_script_lang$1["default"].__file = "packages/components/pagination/src/components/next.vue";
  exports["default"] = next_vue_vue_type_script_lang$1["default"];
})(next);
var sizes = {};
var sizes_vue_vue_type_script_lang = {};
var select$2 = {};
var select$1 = {};
var select_vue_vue_type_script_lang$1 = {};
var option = {};
var option_vue_vue_type_script_lang = {};
var useOption$3 = {};
var token$4 = {};
Object.defineProperty(token$4, "__esModule", { value: true });
const selectGroupKey = "ElSelectGroup";
const selectKey = "ElSelect";
token$4.selectGroupKey = selectGroupKey;
token$4.selectKey = selectKey;
Object.defineProperty(useOption$3, "__esModule", { value: true });
var vue$12 = require$$0$1;
var util$8 = util$l;
var token$3 = token$4;
function useOption$2(props2, states) {
  const select2 = vue$12.inject(token$3.selectKey);
  const selectGroup = vue$12.inject(token$3.selectGroupKey, { disabled: false });
  const isObject2 = vue$12.computed(() => {
    return Object.prototype.toString.call(props2.value).toLowerCase() === "[object object]";
  });
  const itemSelected = vue$12.computed(() => {
    if (!select2.props.multiple) {
      return isEqual2(props2.value, select2.props.modelValue);
    } else {
      return contains2(select2.props.modelValue, props2.value);
    }
  });
  const limitReached = vue$12.computed(() => {
    if (select2.props.multiple) {
      const modelValue = select2.props.modelValue || [];
      return !itemSelected.value && modelValue.length >= select2.props.multipleLimit && select2.props.multipleLimit > 0;
    } else {
      return false;
    }
  });
  const currentLabel = vue$12.computed(() => {
    return props2.label || (isObject2.value ? "" : props2.value);
  });
  const currentValue = vue$12.computed(() => {
    return props2.value || props2.label || "";
  });
  const isDisabled = vue$12.computed(() => {
    return props2.disabled || states.groupDisabled || limitReached.value;
  });
  const instance = vue$12.getCurrentInstance();
  const contains2 = (arr = [], target2) => {
    if (!isObject2.value) {
      return arr && arr.indexOf(target2) > -1;
    } else {
      const valueKey = select2.props.valueKey;
      return arr && arr.some((item2) => {
        return util$8.getValueByPath(item2, valueKey) === util$8.getValueByPath(target2, valueKey);
      });
    }
  };
  const isEqual2 = (a2, b2) => {
    if (!isObject2.value) {
      return a2 === b2;
    } else {
      const { valueKey } = select2.props;
      return util$8.getValueByPath(a2, valueKey) === util$8.getValueByPath(b2, valueKey);
    }
  };
  const hoverItem = () => {
    if (!props2.disabled && !selectGroup.disabled) {
      select2.hoverIndex = select2.optionsArray.indexOf(instance);
    }
  };
  vue$12.watch(() => currentLabel.value, () => {
    if (!props2.created && !select2.props.remote)
      select2.setSelected();
  });
  vue$12.watch(() => props2.value, (val, oldVal) => {
    const { remote, valueKey } = select2.props;
    if (!props2.created && !remote) {
      if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
        return;
      }
      select2.setSelected();
    }
  });
  vue$12.watch(() => selectGroup.disabled, () => {
    states.groupDisabled = selectGroup.disabled;
  }, { immediate: true });
  const { queryChange } = vue$12.toRaw(select2);
  vue$12.watch(queryChange, (changes) => {
    const { query } = vue$12.unref(changes);
    const regexp4 = new RegExp(util$8.escapeRegexpString(query), "i");
    states.visible = regexp4.test(currentLabel.value) || props2.created;
    if (!states.visible) {
      select2.filteredOptionsCount--;
    }
  });
  return {
    select: select2,
    currentLabel,
    currentValue,
    itemSelected,
    isDisabled,
    hoverItem
  };
}
useOption$3.useOption = useOption$2;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var useOption2 = useOption$3;
  var script2 = vue2.defineComponent({
    name: "ElOption",
    componentName: "ElOption",
    props: {
      value: {
        required: true,
        type: [String, Number, Boolean, Object]
      },
      label: [String, Number],
      created: Boolean,
      disabled: {
        type: Boolean,
        default: false
      }
    },
    setup(props2) {
      const states = vue2.reactive({
        index: -1,
        groupDisabled: false,
        visible: true,
        hitState: false,
        hover: false
      });
      const { currentLabel, itemSelected, isDisabled, select: select2, hoverItem } = useOption2.useOption(props2, states);
      const { visible, hover } = vue2.toRefs(states);
      const vm = vue2.getCurrentInstance().proxy;
      const key2 = vm.value;
      select2.onOptionCreate(vm);
      vue2.onBeforeUnmount(() => {
        const { selected } = select2;
        const selectedOptions = select2.props.multiple ? selected : [selected];
        const doesExist = select2.cachedOptions.has(key2);
        const doesSelected = selectedOptions.some((item2) => {
          return item2.value === vm.value;
        });
        if (doesExist && !doesSelected) {
          select2.cachedOptions.delete(key2);
        }
        select2.onOptionDestroy(key2);
      });
      function selectOptionClick() {
        if (props2.disabled !== true && states.groupDisabled !== true) {
          select2.handleOptionSelect(vm, true);
        }
      }
      return {
        currentLabel,
        itemSelected,
        isDisabled,
        select: select2,
        hoverItem,
        visible,
        hover,
        selectOptionClick,
        states
      };
    }
  });
  exports["default"] = script2;
})(option_vue_vue_type_script_lang);
var option_vue_vue_type_template_id_2feb8304_lang = {};
Object.defineProperty(option_vue_vue_type_template_id_2feb8304_lang, "__esModule", { value: true });
var vue$11 = require$$0$1;
function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$11.withDirectives((vue$11.openBlock(), vue$11.createElementBlock("li", {
    class: vue$11.normalizeClass(["el-select-dropdown__item", {
      selected: _ctx.itemSelected,
      "is-disabled": _ctx.isDisabled,
      hover: _ctx.hover
    }]),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = vue$11.withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [
    vue$11.renderSlot(_ctx.$slots, "default", {}, () => [
      vue$11.createElementVNode("span", null, vue$11.toDisplayString(_ctx.currentLabel), 1)
    ])
  ], 34)), [
    [vue$11.vShow, _ctx.visible]
  ]);
}
option_vue_vue_type_template_id_2feb8304_lang.render = render$F;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var option_vue_vue_type_script_lang$1 = option_vue_vue_type_script_lang;
  var option_vue_vue_type_template_id_2feb8304_lang$1 = option_vue_vue_type_template_id_2feb8304_lang;
  option_vue_vue_type_script_lang$1["default"].render = option_vue_vue_type_template_id_2feb8304_lang$1.render;
  option_vue_vue_type_script_lang$1["default"].__file = "packages/components/select/src/option.vue";
  exports["default"] = option_vue_vue_type_script_lang$1["default"];
})(option);
var selectDropdown$1 = {};
var selectDropdown_vue_vue_type_script_lang$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var resizeEvent$1 = resizeEvent;
  var token2 = token$4;
  var script2 = vue2.defineComponent({
    name: "ElSelectDropdown",
    componentName: "ElSelectDropdown",
    setup() {
      const select2 = vue2.inject(token2.selectKey);
      const popperClass = vue2.computed(() => select2.props.popperClass);
      const isMultiple = vue2.computed(() => select2.props.multiple);
      const isFitInputWidth = vue2.computed(() => select2.props.fitInputWidth);
      const minWidth = vue2.ref("");
      function updateMinWidth() {
        var _a;
        minWidth.value = `${(_a = select2.selectWrapper) == null ? void 0 : _a.getBoundingClientRect().width}px`;
      }
      vue2.onMounted(() => {
        resizeEvent$1.addResizeListener(select2.selectWrapper, updateMinWidth);
      });
      vue2.onBeforeUnmount(() => {
        resizeEvent$1.removeResizeListener(select2.selectWrapper, updateMinWidth);
      });
      return {
        minWidth,
        popperClass,
        isMultiple,
        isFitInputWidth
      };
    }
  });
  exports["default"] = script2;
})(selectDropdown_vue_vue_type_script_lang$1);
var selectDropdown_vue_vue_type_template_id_46cf6eee_lang = {};
Object.defineProperty(selectDropdown_vue_vue_type_template_id_46cf6eee_lang, "__esModule", { value: true });
var vue$10 = require$$0$1;
function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$10.openBlock(), vue$10.createElementBlock("div", {
    class: vue$10.normalizeClass(["el-select-dropdown", [{ "is-multiple": _ctx.isMultiple }, _ctx.popperClass]]),
    style: vue$10.normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
  }, [
    vue$10.renderSlot(_ctx.$slots, "default")
  ], 6);
}
selectDropdown_vue_vue_type_template_id_46cf6eee_lang.render = render$E;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var selectDropdown_vue_vue_type_script_lang2 = selectDropdown_vue_vue_type_script_lang$1;
  var selectDropdown_vue_vue_type_template_id_46cf6eee_lang$1 = selectDropdown_vue_vue_type_template_id_46cf6eee_lang;
  selectDropdown_vue_vue_type_script_lang2["default"].render = selectDropdown_vue_vue_type_template_id_46cf6eee_lang$1.render;
  selectDropdown_vue_vue_type_script_lang2["default"].__file = "packages/components/select/src/select-dropdown.vue";
  exports["default"] = selectDropdown_vue_vue_type_script_lang2["default"];
})(selectDropdown$1);
var useSelect$2 = {};
Object.defineProperty(useSelect$2, "__esModule", { value: true });
var vue$$ = require$$0$1;
var shared$7 = require$$1$1;
var debounce$2 = debounce_1;
var isEqual$1 = isEqual_1;
var constants$7 = constants$f;
var aria$1 = aria$5;
var isServer$1 = isServer$8;
var scrollIntoView = scrollIntoView$1;
var isDef$1 = isDef$2;
var util$7 = util$l;
var index$1a = useLocale$1;
var form$1 = form$7;
var index$1$2 = useCommonProps;
function _interopDefaultLegacy$3(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
var debounce__default$2 = /* @__PURE__ */ _interopDefaultLegacy$3(debounce$2);
var isEqual__default = /* @__PURE__ */ _interopDefaultLegacy$3(isEqual$1);
function useSelectStates(props2) {
  const { t } = index$1a.useLocale();
  return vue$$.reactive({
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    createdLabel: null,
    createdSelected: false,
    selected: props2.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    initialInputHeight: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: false,
    softFocus: false,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: false,
    cachedPlaceHolder: "",
    currentPlaceholder: t("el.select.placeholder"),
    menuVisibleOnFocus: false,
    isOnComposition: false,
    isSilentBlur: false,
    prefixWidth: null,
    tagInMultiLine: false
  });
}
const useSelect$1 = (props2, states, ctx) => {
  const { t } = index$1a.useLocale();
  const reference2 = vue$$.ref(null);
  const input3 = vue$$.ref(null);
  const popper2 = vue$$.ref(null);
  const tags = vue$$.ref(null);
  const selectWrapper = vue$$.ref(null);
  const scrollbar3 = vue$$.ref(null);
  const hoverOption = vue$$.ref(-1);
  const queryChange = vue$$.shallowRef({ query: "" });
  const groupQueryChange = vue$$.shallowRef("");
  const elForm = vue$$.inject(form$1.elFormKey, {});
  const elFormItem = vue$$.inject(form$1.elFormItemKey, {});
  const readonly2 = vue$$.computed(() => !props2.filterable || props2.multiple || !states.visible);
  const selectDisabled = vue$$.computed(() => props2.disabled || elForm.disabled);
  const showClose = vue$$.computed(() => {
    const hasValue = props2.multiple ? Array.isArray(props2.modelValue) && props2.modelValue.length > 0 : props2.modelValue !== void 0 && props2.modelValue !== null && props2.modelValue !== "";
    const criteria = props2.clearable && !selectDisabled.value && states.inputHovering && hasValue;
    return criteria;
  });
  const iconComponent = vue$$.computed(() => props2.remote && props2.filterable ? "" : props2.suffixIcon);
  const iconReverse = vue$$.computed(() => iconComponent.value && states.visible ? "is-reverse" : "");
  const debounce2 = vue$$.computed(() => props2.remote ? 300 : 0);
  const emptyText = vue$$.computed(() => {
    if (props2.loading) {
      return props2.loadingText || t("el.select.loading");
    } else {
      if (props2.remote && states.query === "" && states.options.size === 0)
        return false;
      if (props2.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
        return props2.noMatchText || t("el.select.noMatch");
      }
      if (states.options.size === 0) {
        return props2.noDataText || t("el.select.noData");
      }
    }
    return null;
  });
  const optionsArray = vue$$.computed(() => Array.from(states.options.values()));
  const cachedOptionsArray = vue$$.computed(() => Array.from(states.cachedOptions.values()));
  const showNewOption = vue$$.computed(() => {
    const hasExistingOption = optionsArray.value.filter((option2) => {
      return !option2.created;
    }).some((option2) => {
      return option2.currentLabel === states.query;
    });
    return props2.filterable && props2.allowCreate && states.query !== "" && !hasExistingOption;
  });
  const selectSize = index$1$2.useSize();
  const collapseTagSize = vue$$.computed(() => ["small", "mini"].indexOf(selectSize.value) > -1 ? "mini" : "small");
  const dropMenuVisible = vue$$.computed(() => states.visible && emptyText.value !== false);
  vue$$.watch(() => selectDisabled.value, () => {
    vue$$.nextTick(() => {
      resetInputHeight();
    });
  });
  vue$$.watch(() => props2.placeholder, (val) => {
    states.cachedPlaceHolder = states.currentPlaceholder = val;
  });
  vue$$.watch(() => props2.modelValue, (val, oldVal) => {
    var _a;
    if (props2.multiple) {
      resetInputHeight();
      if (val && val.length > 0 || input3.value && states.query !== "") {
        states.currentPlaceholder = "";
      } else {
        states.currentPlaceholder = states.cachedPlaceHolder;
      }
      if (props2.filterable && !props2.reserveKeyword) {
        states.query = "";
        handleQueryChange(states.query);
      }
    }
    setSelected2();
    if (props2.filterable && !props2.multiple) {
      states.inputLength = 20;
    }
    if (!isEqual__default["default"](val, oldVal)) {
      (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change");
    }
  }, {
    flush: "post",
    deep: true
  });
  vue$$.watch(() => states.visible, (val) => {
    var _a, _b;
    if (!val) {
      input3.value && input3.value.blur();
      states.query = "";
      states.previousQuery = null;
      states.selectedLabel = "";
      states.inputLength = 20;
      states.menuVisibleOnFocus = false;
      resetHoverIndex();
      vue$$.nextTick(() => {
        if (input3.value && input3.value.value === "" && states.selected.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      });
      if (!props2.multiple) {
        if (states.selected) {
          if (props2.filterable && props2.allowCreate && states.createdSelected && states.createdLabel) {
            states.selectedLabel = states.createdLabel;
          } else {
            states.selectedLabel = states.selected.currentLabel;
          }
          if (props2.filterable)
            states.query = states.selectedLabel;
        }
        if (props2.filterable) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      }
    } else {
      (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      if (props2.filterable) {
        states.filteredOptionsCount = states.optionsCount;
        states.query = props2.remote ? "" : states.selectedLabel;
        if (props2.multiple) {
          input3.value.focus();
        } else {
          if (states.selectedLabel) {
            states.currentPlaceholder = states.selectedLabel;
            states.selectedLabel = "";
          }
        }
        handleQueryChange(states.query);
        if (!props2.multiple && !props2.remote) {
          queryChange.value.query = "";
          vue$$.triggerRef(queryChange);
          vue$$.triggerRef(groupQueryChange);
        }
      }
    }
    ctx.emit("visible-change", val);
  });
  vue$$.watch(() => states.options.entries(), () => {
    var _a, _b, _c;
    if (isServer$1["default"])
      return;
    (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    if (props2.multiple) {
      resetInputHeight();
    }
    const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
    if ([].indexOf.call(inputs, document.activeElement) === -1) {
      setSelected2();
    }
    if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  }, {
    flush: "post"
  });
  vue$$.watch(() => states.hoverIndex, (val) => {
    if (typeof val === "number" && val > -1) {
      hoverOption.value = optionsArray.value[val] || {};
    }
    optionsArray.value.forEach((option2) => {
      option2.hover = hoverOption.value === option2;
    });
  });
  const resetInputHeight = () => {
    if (props2.collapseTags && !props2.filterable)
      return;
    vue$$.nextTick(() => {
      var _a, _b;
      if (!reference2.value)
        return;
      const inputChildNodes = reference2.value.$el.childNodes;
      const input22 = [].filter.call(inputChildNodes, (item2) => item2.tagName === "INPUT")[0];
      const _tags = tags.value;
      const sizeInMap = states.initialInputHeight || 40;
      input22.style.height = states.selected.length === 0 ? `${sizeInMap}px` : `${Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)}px`;
      states.tagInMultiLine = parseFloat(input22.style.height) > sizeInMap;
      if (states.visible && emptyText.value !== false) {
        (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      }
    });
  };
  const handleQueryChange = (val) => {
    if (states.previousQuery === val || states.isOnComposition)
      return;
    if (states.previousQuery === null && (typeof props2.filterMethod === "function" || typeof props2.remoteMethod === "function")) {
      states.previousQuery = val;
      return;
    }
    states.previousQuery = val;
    vue$$.nextTick(() => {
      var _a, _b;
      if (states.visible)
        (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    });
    states.hoverIndex = -1;
    if (props2.multiple && props2.filterable) {
      vue$$.nextTick(() => {
        const length = input3.value.length * 15 + 20;
        states.inputLength = props2.collapseTags ? Math.min(50, length) : length;
        managePlaceholder();
        resetInputHeight();
      });
    }
    if (props2.remote && typeof props2.remoteMethod === "function") {
      states.hoverIndex = -1;
      props2.remoteMethod(val);
    } else if (typeof props2.filterMethod === "function") {
      props2.filterMethod(val);
      vue$$.triggerRef(groupQueryChange);
    } else {
      states.filteredOptionsCount = states.optionsCount;
      queryChange.value.query = val;
      vue$$.triggerRef(queryChange);
      vue$$.triggerRef(groupQueryChange);
    }
    if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  };
  const managePlaceholder = () => {
    if (states.currentPlaceholder !== "") {
      states.currentPlaceholder = input3.value.value ? "" : states.cachedPlaceHolder;
    }
  };
  const checkDefaultFirstOption = () => {
    const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
    const userCreatedOption = optionsInDropdown.filter((n) => n.created)[0];
    const firstOriginOption = optionsInDropdown[0];
    states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
  };
  const setSelected2 = () => {
    var _a;
    if (!props2.multiple) {
      const option2 = getOption(props2.modelValue);
      if ((_a = option2.props) == null ? void 0 : _a.created) {
        states.createdLabel = option2.props.value;
        states.createdSelected = true;
      } else {
        states.createdSelected = false;
      }
      states.selectedLabel = option2.currentLabel;
      states.selected = option2;
      if (props2.filterable)
        states.query = states.selectedLabel;
      return;
    }
    const result3 = [];
    if (Array.isArray(props2.modelValue)) {
      props2.modelValue.forEach((value) => {
        result3.push(getOption(value));
      });
    }
    states.selected = result3;
    vue$$.nextTick(() => {
      resetInputHeight();
    });
  };
  const getOption = (value) => {
    let option2;
    const isObjectValue = shared$7.toRawType(value).toLowerCase() === "object";
    const isNull = shared$7.toRawType(value).toLowerCase() === "null";
    const isUndefined2 = shared$7.toRawType(value).toLowerCase() === "undefined";
    for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
      const cachedOption = cachedOptionsArray.value[i];
      const isEqualValue = isObjectValue ? util$7.getValueByPath(cachedOption.value, props2.valueKey) === util$7.getValueByPath(value, props2.valueKey) : cachedOption.value === value;
      if (isEqualValue) {
        option2 = {
          value,
          currentLabel: cachedOption.currentLabel,
          isDisabled: cachedOption.isDisabled
        };
        break;
      }
    }
    if (option2)
      return option2;
    const label = !isObjectValue && !isNull && !isUndefined2 ? value : "";
    const newOption = {
      value,
      currentLabel: label
    };
    if (props2.multiple) {
      newOption.hitState = false;
    }
    return newOption;
  };
  const resetHoverIndex = () => {
    setTimeout(() => {
      const valueKey = props2.valueKey;
      if (!props2.multiple) {
        states.hoverIndex = optionsArray.value.findIndex((item2) => {
          return getValueKey(item2) === getValueKey(states.selected);
        });
      } else {
        if (states.selected.length > 0) {
          states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
            return optionsArray.value.findIndex((item2) => {
              return util$7.getValueByPath(item2, valueKey) === util$7.getValueByPath(selected, valueKey);
            });
          }));
        } else {
          states.hoverIndex = -1;
        }
      }
    }, 300);
  };
  const handleResize = () => {
    var _a, _b;
    resetInputWidth();
    (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    if (props2.multiple)
      resetInputHeight();
  };
  const resetInputWidth = () => {
    var _a;
    states.inputWidth = (_a = reference2.value) == null ? void 0 : _a.$el.getBoundingClientRect().width;
  };
  const onInputChange = () => {
    if (props2.filterable && states.query !== states.selectedLabel) {
      states.query = states.selectedLabel;
      handleQueryChange(states.query);
    }
  };
  const debouncedOnInputChange = debounce__default$2["default"](() => {
    onInputChange();
  }, debounce2.value);
  const debouncedQueryChange = debounce__default$2["default"]((e) => {
    handleQueryChange(e.target.value);
  }, debounce2.value);
  const emitChange = (val) => {
    if (!isEqual__default["default"](props2.modelValue, val)) {
      ctx.emit(constants$7.CHANGE_EVENT, val);
    }
  };
  const deletePrevTag = (e) => {
    if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
      const value = props2.modelValue.slice();
      value.pop();
      ctx.emit(constants$7.UPDATE_MODEL_EVENT, value);
      emitChange(value);
    }
    if (e.target.value.length === 1 && props2.modelValue.length === 0) {
      states.currentPlaceholder = states.cachedPlaceHolder;
    }
  };
  const deleteTag = (event, tag3) => {
    const index2 = states.selected.indexOf(tag3);
    if (index2 > -1 && !selectDisabled.value) {
      const value = props2.modelValue.slice();
      value.splice(index2, 1);
      ctx.emit(constants$7.UPDATE_MODEL_EVENT, value);
      emitChange(value);
      ctx.emit("remove-tag", tag3.value);
    }
    event.stopPropagation();
  };
  const deleteSelected = (event) => {
    event.stopPropagation();
    const value = props2.multiple ? [] : "";
    if (typeof value !== "string") {
      for (const item2 of states.selected) {
        if (item2.isDisabled)
          value.push(item2.value);
      }
    }
    ctx.emit(constants$7.UPDATE_MODEL_EVENT, value);
    emitChange(value);
    states.visible = false;
    ctx.emit("clear");
  };
  const handleOptionSelect = (option2, byClick) => {
    if (props2.multiple) {
      const value = (props2.modelValue || []).slice();
      const optionIndex = getValueIndex(value, option2.value);
      if (optionIndex > -1) {
        value.splice(optionIndex, 1);
      } else if (props2.multipleLimit <= 0 || value.length < props2.multipleLimit) {
        value.push(option2.value);
      }
      ctx.emit(constants$7.UPDATE_MODEL_EVENT, value);
      emitChange(value);
      if (option2.created) {
        states.query = "";
        handleQueryChange("");
        states.inputLength = 20;
      }
      if (props2.filterable)
        input3.value.focus();
    } else {
      ctx.emit(constants$7.UPDATE_MODEL_EVENT, option2.value);
      emitChange(option2.value);
      states.visible = false;
    }
    states.isSilentBlur = byClick;
    setSoftFocus();
    if (states.visible)
      return;
    vue$$.nextTick(() => {
      scrollToOption(option2);
    });
  };
  const getValueIndex = (arr = [], value) => {
    if (!shared$7.isObject(value))
      return arr.indexOf(value);
    const valueKey = props2.valueKey;
    let index2 = -1;
    arr.some((item2, i) => {
      if (util$7.getValueByPath(item2, valueKey) === util$7.getValueByPath(value, valueKey)) {
        index2 = i;
        return true;
      }
      return false;
    });
    return index2;
  };
  const setSoftFocus = () => {
    states.softFocus = true;
    const _input = input3.value || reference2.value;
    if (_input) {
      _input.focus();
    }
  };
  const scrollToOption = (option2) => {
    var _a, _b, _c, _d;
    const targetOption = Array.isArray(option2) ? option2[0] : option2;
    let target2 = null;
    if (targetOption == null ? void 0 : targetOption.value) {
      const options = optionsArray.value.filter((item2) => item2.value === targetOption.value);
      if (options.length > 0) {
        target2 = options[0].$el;
      }
    }
    if (popper2.value && target2) {
      const menu2 = (_c = (_b = (_a = popper2.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.querySelector) == null ? void 0 : _c.call(_b, ".el-select-dropdown__wrap");
      if (menu2) {
        scrollIntoView["default"](menu2, target2);
      }
    }
    (_d = scrollbar3.value) == null ? void 0 : _d.handleScroll();
  };
  const onOptionCreate = (vm) => {
    states.optionsCount++;
    states.filteredOptionsCount++;
    states.options.set(vm.value, vm);
    states.cachedOptions.set(vm.value, vm);
  };
  const onOptionDestroy = (key2) => {
    states.optionsCount--;
    states.filteredOptionsCount--;
    states.options.delete(key2);
  };
  const resetInputState = (e) => {
    if (e.code !== aria$1.EVENT_CODE.backspace)
      toggleLastOptionHitState(false);
    states.inputLength = input3.value.length * 15 + 20;
    resetInputHeight();
  };
  const toggleLastOptionHitState = (hit) => {
    if (!Array.isArray(states.selected))
      return;
    const option2 = states.selected[states.selected.length - 1];
    if (!option2)
      return;
    if (hit === true || hit === false) {
      option2.hitState = hit;
      return hit;
    }
    option2.hitState = !option2.hitState;
    return option2.hitState;
  };
  const handleComposition = (event) => {
    const text = event.target.value;
    if (event.type === "compositionend") {
      states.isOnComposition = false;
      vue$$.nextTick(() => handleQueryChange(text));
    } else {
      const lastCharacter = text[text.length - 1] || "";
      states.isOnComposition = !isDef$1.isKorean(lastCharacter);
    }
  };
  const handleMenuEnter = () => {
    vue$$.nextTick(() => scrollToOption(states.selected));
  };
  const handleFocus = (event) => {
    if (!states.softFocus) {
      if (props2.automaticDropdown || props2.filterable) {
        states.visible = true;
        if (props2.filterable) {
          states.menuVisibleOnFocus = true;
        }
      }
      ctx.emit("focus", event);
    } else {
      states.softFocus = false;
    }
  };
  const blur = () => {
    states.visible = false;
    reference2.value.blur();
  };
  const handleBlur = (event) => {
    vue$$.nextTick(() => {
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        ctx.emit("blur", event);
      }
    });
    states.softFocus = false;
  };
  const handleClearClick = (event) => {
    deleteSelected(event);
  };
  const handleClose = () => {
    states.visible = false;
  };
  const toggleMenu = () => {
    if (props2.automaticDropdown)
      return;
    if (!selectDisabled.value) {
      if (states.menuVisibleOnFocus) {
        states.menuVisibleOnFocus = false;
      } else {
        states.visible = !states.visible;
      }
      if (states.visible) {
        (input3.value || reference2.value).focus();
      }
    }
  };
  const selectOption = () => {
    if (!states.visible) {
      toggleMenu();
    } else {
      if (optionsArray.value[states.hoverIndex]) {
        handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);
      }
    }
  };
  const getValueKey = (item2) => {
    return shared$7.isObject(item2.value) ? util$7.getValueByPath(item2.value, props2.valueKey) : item2.value;
  };
  const optionsAllDisabled = vue$$.computed(() => optionsArray.value.filter((option2) => option2.visible).every((option2) => option2.disabled));
  const navigateOptions = (direction2) => {
    if (!states.visible) {
      states.visible = true;
      return;
    }
    if (states.options.size === 0 || states.filteredOptionsCount === 0)
      return;
    if (states.isOnComposition)
      return;
    if (!optionsAllDisabled.value) {
      if (direction2 === "next") {
        states.hoverIndex++;
        if (states.hoverIndex === states.options.size) {
          states.hoverIndex = 0;
        }
      } else if (direction2 === "prev") {
        states.hoverIndex--;
        if (states.hoverIndex < 0) {
          states.hoverIndex = states.options.size - 1;
        }
      }
      const option2 = optionsArray.value[states.hoverIndex];
      if (option2.disabled === true || option2.states.groupDisabled === true || !option2.visible) {
        navigateOptions(direction2);
      }
      vue$$.nextTick(() => scrollToOption(hoverOption.value));
    }
  };
  return {
    optionsArray,
    selectSize,
    handleResize,
    debouncedOnInputChange,
    debouncedQueryChange,
    deletePrevTag,
    deleteTag,
    deleteSelected,
    handleOptionSelect,
    scrollToOption,
    readonly: readonly2,
    resetInputHeight,
    showClose,
    iconComponent,
    iconReverse,
    showNewOption,
    collapseTagSize,
    setSelected: setSelected2,
    managePlaceholder,
    selectDisabled,
    emptyText,
    toggleLastOptionHitState,
    resetInputState,
    handleComposition,
    onOptionCreate,
    onOptionDestroy,
    handleMenuEnter,
    handleFocus,
    blur,
    handleBlur,
    handleClearClick,
    handleClose,
    toggleMenu,
    selectOption,
    getValueKey,
    navigateOptions,
    dropMenuVisible,
    queryChange,
    groupQueryChange,
    reference: reference2,
    input: input3,
    popper: popper2,
    tags,
    selectWrapper,
    scrollbar: scrollbar3
  };
};
useSelect$2.useSelect = useSelect$1;
useSelect$2.useSelectStates = useSelectStates;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = input$2;
  var index$32 = popper$3;
  var index$22 = scrollbar$3;
  var index$110 = tag$2;
  var index$42 = icon$4;
  var constants2 = constants$f;
  var resizeEvent$1 = resizeEvent;
  var validators2 = validators$6;
  var iconsVue2 = require$$3;
  var useSelect2 = useSelect$2;
  var token2 = token$4;
  var selectDropdown_vue_vue_type_script_lang2 = selectDropdown_vue_vue_type_script_lang$1;
  var option_vue_vue_type_script_lang$1 = option_vue_vue_type_script_lang;
  var index$52 = clickOutside;
  var index$62 = useLocale$1;
  var index$72 = useFocus$1;
  var defaults2 = defaults$d;
  var script2 = vue2.defineComponent({
    name: "ElSelect",
    componentName: "ElSelect",
    components: {
      ElInput: index2.ElInput,
      ElSelectMenu: selectDropdown_vue_vue_type_script_lang2["default"],
      ElOption: option_vue_vue_type_script_lang$1["default"],
      ElTag: index$110.ElTag,
      ElScrollbar: index$22.ElScrollbar,
      ElPopper: index$32["default"],
      ElIcon: index$42.ElIcon
    },
    directives: { ClickOutside: index$52["default"] },
    props: {
      name: String,
      id: String,
      modelValue: {
        type: [Array, String, Number, Boolean, Object],
        default: void 0
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      automaticDropdown: Boolean,
      size: {
        type: String,
        validator: validators2.isValidComponentSize
      },
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      allowCreate: Boolean,
      loading: Boolean,
      popperClass: {
        type: String,
        default: ""
      },
      remote: Boolean,
      loadingText: String,
      noMatchText: String,
      noDataText: String,
      remoteMethod: Function,
      filterMethod: Function,
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0
      },
      placeholder: {
        type: String
      },
      defaultFirstOption: Boolean,
      reserveKeyword: Boolean,
      valueKey: {
        type: String,
        default: "value"
      },
      collapseTags: Boolean,
      popperAppendToBody: {
        type: Boolean,
        default: true
      },
      clearIcon: {
        type: [String, Object],
        default: iconsVue2.CircleClose
      },
      fitInputWidth: {
        type: Boolean,
        default: false
      },
      suffixIcon: {
        type: [String, Object],
        default: iconsVue2.ArrowUp
      },
      tagType: {
        type: String,
        default: "info"
      }
    },
    emits: [
      constants2.UPDATE_MODEL_EVENT,
      constants2.CHANGE_EVENT,
      "remove-tag",
      "clear",
      "visible-change",
      "focus",
      "blur"
    ],
    setup(props2, ctx) {
      const { t } = index$62.useLocale();
      const states = useSelect2.useSelectStates(props2);
      const {
        optionsArray,
        selectSize,
        readonly: readonly2,
        handleResize,
        collapseTagSize,
        debouncedOnInputChange,
        debouncedQueryChange,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        setSelected: setSelected2,
        resetInputHeight,
        managePlaceholder,
        showClose,
        selectDisabled,
        iconComponent,
        iconReverse,
        showNewOption,
        emptyText,
        toggleLastOptionHitState,
        resetInputState,
        handleComposition,
        onOptionCreate,
        onOptionDestroy,
        handleMenuEnter,
        handleFocus,
        blur,
        handleBlur,
        handleClearClick,
        handleClose,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropMenuVisible,
        reference: reference2,
        input: input3,
        popper: popper2,
        tags,
        selectWrapper,
        scrollbar: scrollbar3,
        queryChange,
        groupQueryChange
      } = useSelect2.useSelect(props2, states, ctx);
      const { focus } = index$72.useFocus(reference2);
      const {
        inputWidth,
        selected,
        inputLength,
        filteredOptionsCount,
        visible,
        softFocus,
        selectedLabel,
        hoverIndex,
        query,
        inputHovering,
        currentPlaceholder,
        menuVisibleOnFocus,
        isOnComposition,
        isSilentBlur,
        options,
        cachedOptions,
        optionsCount,
        prefixWidth,
        tagInMultiLine
      } = vue2.toRefs(states);
      vue2.provide(token2.selectKey, vue2.reactive({
        props: props2,
        options,
        optionsArray,
        cachedOptions,
        optionsCount,
        filteredOptionsCount,
        hoverIndex,
        handleOptionSelect,
        onOptionCreate,
        onOptionDestroy,
        selectWrapper,
        selected,
        setSelected: setSelected2,
        queryChange,
        groupQueryChange
      }));
      vue2.onMounted(() => {
        states.cachedPlaceHolder = currentPlaceholder.value = props2.placeholder || t("el.select.placeholder");
        if (props2.multiple && Array.isArray(props2.modelValue) && props2.modelValue.length > 0) {
          currentPlaceholder.value = "";
        }
        resizeEvent$1.addResizeListener(selectWrapper.value, handleResize);
        if (reference2.value && reference2.value.$el) {
          const sizeMap = {
            medium: 36,
            small: 32,
            mini: 28
          };
          const input22 = reference2.value.input;
          states.initialInputHeight = input22.getBoundingClientRect().height || sizeMap[selectSize.value];
        }
        if (props2.remote && props2.multiple) {
          resetInputHeight();
        }
        vue2.nextTick(() => {
          if (reference2.value.$el) {
            inputWidth.value = reference2.value.$el.getBoundingClientRect().width;
          }
          if (ctx.slots.prefix) {
            const inputChildNodes = reference2.value.$el.childNodes;
            const input22 = [].filter.call(inputChildNodes, (item2) => item2.tagName === "INPUT")[0];
            const prefix = reference2.value.$el.querySelector(".el-input__prefix");
            prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);
            if (states.prefixWidth) {
              input22.style.paddingLeft = `${Math.max(states.prefixWidth, 30)}px`;
            }
          }
        });
        setSelected2();
      });
      vue2.onBeforeUnmount(() => {
        resizeEvent$1.removeResizeListener(selectWrapper.value, handleResize);
      });
      if (props2.multiple && !Array.isArray(props2.modelValue)) {
        ctx.emit(constants2.UPDATE_MODEL_EVENT, []);
      }
      if (!props2.multiple && Array.isArray(props2.modelValue)) {
        ctx.emit(constants2.UPDATE_MODEL_EVENT, "");
      }
      const popperPaneRef = vue2.computed(() => {
        var _a;
        return (_a = popper2.value) == null ? void 0 : _a.popperRef;
      });
      return {
        Effect: defaults2.Effect,
        tagInMultiLine,
        prefixWidth,
        selectSize,
        readonly: readonly2,
        handleResize,
        collapseTagSize,
        debouncedOnInputChange,
        debouncedQueryChange,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        inputWidth,
        selected,
        inputLength,
        filteredOptionsCount,
        visible,
        softFocus,
        selectedLabel,
        hoverIndex,
        query,
        inputHovering,
        currentPlaceholder,
        menuVisibleOnFocus,
        isOnComposition,
        isSilentBlur,
        options,
        resetInputHeight,
        managePlaceholder,
        showClose,
        selectDisabled,
        iconComponent,
        iconReverse,
        showNewOption,
        emptyText,
        toggleLastOptionHitState,
        resetInputState,
        handleComposition,
        handleMenuEnter,
        handleFocus,
        blur,
        handleBlur,
        handleClearClick,
        handleClose,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropMenuVisible,
        focus,
        reference: reference2,
        input: input3,
        popper: popper2,
        popperPaneRef,
        tags,
        selectWrapper,
        scrollbar: scrollbar3
      };
    }
  });
  exports["default"] = script2;
})(select_vue_vue_type_script_lang$1);
var select_vue_vue_type_template_id_33774f85_lang = {};
Object.defineProperty(select_vue_vue_type_template_id_33774f85_lang, "__esModule", { value: true });
var vue$_ = require$$0$1;
const _hoisted_1$u = { class: "select-trigger" };
const _hoisted_2$n = { key: 0 };
const _hoisted_3$k = { class: "el-select__tags-text" };
const _hoisted_4$c = ["disabled", "autocomplete"];
const _hoisted_5$a = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
const _hoisted_6$8 = {
  key: 1,
  class: "el-select-dropdown__empty"
};
function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = vue$_.resolveComponent("el-tag");
  const _component_el_icon = vue$_.resolveComponent("el-icon");
  const _component_el_input = vue$_.resolveComponent("el-input");
  const _component_el_option = vue$_.resolveComponent("el-option");
  const _component_el_scrollbar = vue$_.resolveComponent("el-scrollbar");
  const _component_el_select_menu = vue$_.resolveComponent("el-select-menu");
  const _component_el_popper = vue$_.resolveComponent("el-popper");
  const _directive_click_outside = vue$_.resolveDirective("click-outside");
  return vue$_.withDirectives((vue$_.openBlock(), vue$_.createElementBlock("div", {
    ref: "selectWrapper",
    class: vue$_.normalizeClass(["el-select", [_ctx.selectSize ? "el-select--" + _ctx.selectSize : ""]]),
    onClick: _cache[24] || (_cache[24] = vue$_.withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
  }, [
    vue$_.createVNode(_component_el_popper, {
      ref: "popper",
      visible: _ctx.dropMenuVisible,
      "onUpdate:visible": _cache[23] || (_cache[23] = ($event) => _ctx.dropMenuVisible = $event),
      placement: "bottom-start",
      "append-to-body": _ctx.popperAppendToBody,
      "popper-class": `el-select__popper ${_ctx.popperClass}`,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      "manual-mode": "",
      effect: _ctx.Effect.LIGHT,
      pure: "",
      trigger: "click",
      transition: "el-zoom-in-top",
      "stop-popper-mouse-event": false,
      "gpu-acceleration": false,
      onBeforeEnter: _ctx.handleMenuEnter
    }, {
      trigger: vue$_.withCtx(() => [
        vue$_.createElementVNode("div", _hoisted_1$u, [
          _ctx.multiple ? (vue$_.openBlock(), vue$_.createElementBlock("div", {
            key: 0,
            ref: "tags",
            class: "el-select__tags",
            style: vue$_.normalizeStyle({ maxWidth: _ctx.inputWidth - 32 + "px", width: "100%" })
          }, [
            _ctx.collapseTags && _ctx.selected.length ? (vue$_.openBlock(), vue$_.createElementBlock("span", _hoisted_2$n, [
              vue$_.createVNode(_component_el_tag, {
                closable: !_ctx.selectDisabled && !_ctx.selected[0].isDisabled,
                size: _ctx.collapseTagSize,
                hit: _ctx.selected[0].hitState,
                type: _ctx.tagType,
                "disable-transitions": "",
                onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.selected[0]))
              }, {
                default: vue$_.withCtx(() => [
                  vue$_.createElementVNode("span", {
                    class: "el-select__tags-text",
                    style: vue$_.normalizeStyle({ maxWidth: _ctx.inputWidth - 123 + "px" })
                  }, vue$_.toDisplayString(_ctx.selected[0].currentLabel), 5)
                ]),
                _: 1
              }, 8, ["closable", "size", "hit", "type"]),
              _ctx.selected.length > 1 ? (vue$_.openBlock(), vue$_.createBlock(_component_el_tag, {
                key: 0,
                closable: false,
                size: _ctx.collapseTagSize,
                type: _ctx.tagType,
                "disable-transitions": ""
              }, {
                default: vue$_.withCtx(() => [
                  vue$_.createElementVNode("span", _hoisted_3$k, "+ " + vue$_.toDisplayString(_ctx.selected.length - 1), 1)
                ]),
                _: 1
              }, 8, ["size", "type"])) : vue$_.createCommentVNode("v-if", true)
            ])) : vue$_.createCommentVNode("v-if", true),
            vue$_.createCommentVNode(" <div> "),
            !_ctx.collapseTags ? (vue$_.openBlock(), vue$_.createBlock(vue$_.Transition, {
              key: 1,
              onAfterLeave: _ctx.resetInputHeight
            }, {
              default: vue$_.withCtx(() => [
                vue$_.createElementVNode("span", {
                  style: vue$_.normalizeStyle({
                    marginLeft: _ctx.prefixWidth && _ctx.selected.length ? `${_ctx.prefixWidth}px` : null
                  })
                }, [
                  (vue$_.openBlock(true), vue$_.createElementBlock(vue$_.Fragment, null, vue$_.renderList(_ctx.selected, (item2) => {
                    return vue$_.openBlock(), vue$_.createBlock(_component_el_tag, {
                      key: _ctx.getValueKey(item2),
                      closable: !_ctx.selectDisabled && !item2.isDisabled,
                      size: _ctx.collapseTagSize,
                      hit: item2.hitState,
                      type: _ctx.tagType,
                      "disable-transitions": "",
                      onClose: ($event) => _ctx.deleteTag($event, item2)
                    }, {
                      default: vue$_.withCtx(() => [
                        vue$_.createElementVNode("span", {
                          class: "el-select__tags-text",
                          style: vue$_.normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
                        }, vue$_.toDisplayString(item2.currentLabel), 5)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                  }), 128))
                ], 4)
              ]),
              _: 1
            }, 8, ["onAfterLeave"])) : vue$_.createCommentVNode("v-if", true),
            vue$_.createCommentVNode(" </div> "),
            _ctx.filterable ? vue$_.withDirectives((vue$_.openBlock(), vue$_.createElementBlock("input", {
              key: 2,
              ref: "input",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.query = $event),
              type: "text",
              class: vue$_.normalizeClass(["el-select__input", [_ctx.selectSize ? `is-${_ctx.selectSize}` : ""]]),
              disabled: _ctx.selectDisabled,
              autocomplete: _ctx.autocomplete,
              style: vue$_.normalizeStyle({
                marginLeft: _ctx.prefixWidth && !_ctx.selected.length || _ctx.tagInMultiLine ? `${_ctx.prefixWidth}px` : null,
                flexGrow: "1",
                width: `${_ctx.inputLength / (_ctx.inputWidth - 32)}%`,
                maxWidth: `${_ctx.inputWidth - 42}px`
              }),
              onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
              onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
              onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
              onKeydown: [
                _cache[5] || (_cache[5] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                _cache[6] || (_cache[6] = vue$_.withKeys(vue$_.withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                _cache[7] || (_cache[7] = vue$_.withKeys(vue$_.withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                _cache[8] || (_cache[8] = vue$_.withKeys(vue$_.withModifiers(($event) => _ctx.visible = false, ["stop", "prevent"]), ["esc"])),
                _cache[9] || (_cache[9] = vue$_.withKeys(vue$_.withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                _cache[10] || (_cache[10] = vue$_.withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                _cache[11] || (_cache[11] = vue$_.withKeys(($event) => _ctx.visible = false, ["tab"]))
              ],
              onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onInput: _cache[15] || (_cache[15] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
            }, null, 46, _hoisted_4$c)), [
              [vue$_.vModelText, _ctx.query]
            ]) : vue$_.createCommentVNode("v-if", true)
          ], 4)) : vue$_.createCommentVNode("v-if", true),
          vue$_.createVNode(_component_el_input, {
            id: _ctx.id,
            ref: "reference",
            modelValue: _ctx.selectedLabel,
            "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.selectedLabel = $event),
            type: "text",
            placeholder: _ctx.currentPlaceholder,
            name: _ctx.name,
            autocomplete: _ctx.autocomplete,
            size: _ctx.selectSize,
            disabled: _ctx.selectDisabled,
            readonly: _ctx.readonly,
            "validate-event": false,
            class: vue$_.normalizeClass({ "is-focus": _ctx.visible }),
            tabindex: _ctx.multiple && _ctx.filterable ? "-1" : null,
            onFocus: _ctx.handleFocus,
            onBlur: _ctx.handleBlur,
            onInput: _ctx.debouncedOnInputChange,
            onPaste: _ctx.debouncedOnInputChange,
            onCompositionstart: _ctx.handleComposition,
            onCompositionupdate: _ctx.handleComposition,
            onCompositionend: _ctx.handleComposition,
            onKeydown: [
              _cache[17] || (_cache[17] = vue$_.withKeys(vue$_.withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
              _cache[18] || (_cache[18] = vue$_.withKeys(vue$_.withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
              vue$_.withKeys(vue$_.withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
              _cache[19] || (_cache[19] = vue$_.withKeys(vue$_.withModifiers(($event) => _ctx.visible = false, ["stop", "prevent"]), ["esc"])),
              _cache[20] || (_cache[20] = vue$_.withKeys(($event) => _ctx.visible = false, ["tab"]))
            ],
            onMouseenter: _cache[21] || (_cache[21] = ($event) => _ctx.inputHovering = true),
            onMouseleave: _cache[22] || (_cache[22] = ($event) => _ctx.inputHovering = false)
          }, vue$_.createSlots({
            suffix: vue$_.withCtx(() => [
              _ctx.iconComponent ? vue$_.withDirectives((vue$_.openBlock(), vue$_.createBlock(_component_el_icon, {
                key: 0,
                class: vue$_.normalizeClass(["el-select__caret", "el-input__icon", _ctx.iconReverse])
              }, {
                default: vue$_.withCtx(() => [
                  (vue$_.openBlock(), vue$_.createBlock(vue$_.resolveDynamicComponent(_ctx.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])), [
                [vue$_.vShow, !_ctx.showClose]
              ]) : vue$_.createCommentVNode("v-if", true),
              _ctx.showClose && _ctx.clearIcon ? (vue$_.openBlock(), vue$_.createBlock(_component_el_icon, {
                key: 1,
                class: "el-select__caret el-input__icon",
                onClick: _ctx.handleClearClick
              }, {
                default: vue$_.withCtx(() => [
                  (vue$_.openBlock(), vue$_.createBlock(vue$_.resolveDynamicComponent(_ctx.clearIcon)))
                ]),
                _: 1
              }, 8, ["onClick"])) : vue$_.createCommentVNode("v-if", true)
            ]),
            _: 2
          }, [
            _ctx.$slots.prefix ? {
              name: "prefix",
              fn: vue$_.withCtx(() => [
                vue$_.createElementVNode("div", _hoisted_5$a, [
                  vue$_.renderSlot(_ctx.$slots, "prefix")
                ])
              ])
            } : void 0
          ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
        ])
      ]),
      default: vue$_.withCtx(() => [
        vue$_.createVNode(_component_el_select_menu, null, {
          default: vue$_.withCtx(() => [
            vue$_.withDirectives(vue$_.createVNode(_component_el_scrollbar, {
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": "el-select-dropdown__wrap",
              "view-class": "el-select-dropdown__list",
              class: vue$_.normalizeClass({
                "is-empty": !_ctx.allowCreate && _ctx.query && _ctx.filteredOptionsCount === 0
              })
            }, {
              default: vue$_.withCtx(() => [
                _ctx.showNewOption ? (vue$_.openBlock(), vue$_.createBlock(_component_el_option, {
                  key: 0,
                  value: _ctx.query,
                  created: true
                }, null, 8, ["value"])) : vue$_.createCommentVNode("v-if", true),
                vue$_.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]), [
              [vue$_.vShow, _ctx.options.size > 0 && !_ctx.loading]
            ]),
            _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (vue$_.openBlock(), vue$_.createElementBlock(vue$_.Fragment, { key: 0 }, [
              _ctx.$slots.empty ? vue$_.renderSlot(_ctx.$slots, "empty", { key: 0 }) : (vue$_.openBlock(), vue$_.createElementBlock("p", _hoisted_6$8, vue$_.toDisplayString(_ctx.emptyText), 1))
            ], 2112)) : vue$_.createCommentVNode("v-if", true)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["visible", "append-to-body", "popper-class", "effect", "onBeforeEnter"])
  ], 2)), [
    [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
  ]);
}
select_vue_vue_type_template_id_33774f85_lang.render = render$D;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var select_vue_vue_type_script_lang2 = select_vue_vue_type_script_lang$1;
  var select_vue_vue_type_template_id_33774f85_lang$1 = select_vue_vue_type_template_id_33774f85_lang;
  select_vue_vue_type_script_lang2["default"].render = select_vue_vue_type_template_id_33774f85_lang$1.render;
  select_vue_vue_type_script_lang2["default"].__file = "packages/components/select/src/select.vue";
  exports["default"] = select_vue_vue_type_script_lang2["default"];
})(select$1);
var optionGroup = {};
var optionGroup_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var token2 = token$4;
  var script2 = vue2.defineComponent({
    name: "ElOptionGroup",
    componentName: "ElOptionGroup",
    props: {
      label: String,
      disabled: {
        type: Boolean,
        default: false
      }
    },
    setup(props2) {
      const visible = vue2.ref(true);
      const instance = vue2.getCurrentInstance();
      const children = vue2.ref([]);
      vue2.provide(token2.selectGroupKey, vue2.reactive(__spreadValues({}, vue2.toRefs(props2))));
      const select2 = vue2.inject(token2.selectKey);
      vue2.onMounted(() => {
        children.value = flattedChildren(instance.subTree);
      });
      const flattedChildren = (node3) => {
        const children2 = [];
        if (Array.isArray(node3.children)) {
          node3.children.forEach((child) => {
            var _a;
            if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
              children2.push(child.component.proxy);
            } else if ((_a = child.children) == null ? void 0 : _a.length) {
              children2.push(...flattedChildren(child));
            }
          });
        }
        return children2;
      };
      const { groupQueryChange } = vue2.toRaw(select2);
      vue2.watch(groupQueryChange, () => {
        visible.value = children.value.some((option2) => option2.visible === true);
      });
      return {
        visible
      };
    }
  });
  exports["default"] = script2;
})(optionGroup_vue_vue_type_script_lang);
var optionGroup_vue_vue_type_template_id_072bbb70_lang = {};
Object.defineProperty(optionGroup_vue_vue_type_template_id_072bbb70_lang, "__esModule", { value: true });
var vue$Z = require$$0$1;
const _hoisted_1$t = { class: "el-select-group__wrap" };
const _hoisted_2$m = { class: "el-select-group__title" };
const _hoisted_3$j = { class: "el-select-group" };
function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$Z.withDirectives((vue$Z.openBlock(), vue$Z.createElementBlock("ul", _hoisted_1$t, [
    vue$Z.createElementVNode("li", _hoisted_2$m, vue$Z.toDisplayString(_ctx.label), 1),
    vue$Z.createElementVNode("li", null, [
      vue$Z.createElementVNode("ul", _hoisted_3$j, [
        vue$Z.renderSlot(_ctx.$slots, "default")
      ])
    ])
  ], 512)), [
    [vue$Z.vShow, _ctx.visible]
  ]);
}
optionGroup_vue_vue_type_template_id_072bbb70_lang.render = render$C;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var optionGroup_vue_vue_type_script_lang$1 = optionGroup_vue_vue_type_script_lang;
  var optionGroup_vue_vue_type_template_id_072bbb70_lang$1 = optionGroup_vue_vue_type_template_id_072bbb70_lang;
  optionGroup_vue_vue_type_script_lang$1["default"].render = optionGroup_vue_vue_type_template_id_072bbb70_lang$1.render;
  optionGroup_vue_vue_type_script_lang$1["default"].__file = "packages/components/select/src/option-group.vue";
  exports["default"] = optionGroup_vue_vue_type_script_lang$1["default"];
})(optionGroup);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var token2 = token$4;
  var select_vue_vue_type_script_lang2 = select_vue_vue_type_script_lang$1;
  var option_vue_vue_type_script_lang$1 = option_vue_vue_type_script_lang;
  var optionGroup_vue_vue_type_script_lang$1 = optionGroup_vue_vue_type_script_lang;
  const ElSelect = withInstall2.withInstall(select_vue_vue_type_script_lang2["default"], {
    Option: option_vue_vue_type_script_lang$1["default"],
    OptionGroup: optionGroup_vue_vue_type_script_lang$1["default"]
  });
  const ElOption = withInstall2.withNoopInstall(option_vue_vue_type_script_lang$1["default"]);
  const ElOptionGroup = withInstall2.withNoopInstall(optionGroup_vue_vue_type_script_lang$1["default"]);
  exports.selectGroupKey = token2.selectGroupKey;
  exports.selectKey = token2.selectKey;
  exports.ElOption = ElOption;
  exports.ElOptionGroup = ElOptionGroup;
  exports.ElSelect = ElSelect;
  exports["default"] = ElSelect;
})(select$2);
var usePagination$1 = {};
Object.defineProperty(usePagination$1, "__esModule", { value: true });
var vue$Y = require$$0$1;
var pagination$1 = pagination$4;
const usePagination = () => vue$Y.inject(pagination$1.elPaginationKey, {});
usePagination$1.usePagination = usePagination;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var isEqual2 = isEqual_1;
  var index2 = select$2;
  var props2 = props$N;
  var usePagination2 = usePagination$1;
  var index$110 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var isEqual__default2 = /* @__PURE__ */ _interopDefaultLegacy2(isEqual2);
  const paginationSizesProps = props2.buildProps({
    pageSize: {
      type: Number,
      required: true
    },
    pageSizes: {
      type: props2.definePropType(Array),
      default: () => props2.mutable([10, 20, 30, 40, 50, 100])
    },
    popperClass: {
      type: String,
      default: ""
    },
    disabled: Boolean
  });
  var script2 = vue2.defineComponent({
    name: "ElPaginationSizes",
    components: {
      ElSelect: index2.ElSelect,
      ElOption: index2.ElOption
    },
    props: paginationSizesProps,
    emits: ["page-size-change"],
    setup(props3, { emit }) {
      const { t } = index$110.useLocale();
      const pagination2 = usePagination2.usePagination();
      const innerPageSize = vue2.ref(props3.pageSize);
      vue2.watch(() => props3.pageSizes, (newVal, oldVal) => {
        if (isEqual__default2["default"](newVal, oldVal))
          return;
        if (Array.isArray(newVal)) {
          const pageSize = newVal.indexOf(props3.pageSize) > -1 ? props3.pageSize : props3.pageSizes[0];
          emit("page-size-change", pageSize);
        }
      });
      vue2.watch(() => props3.pageSize, (newVal) => {
        innerPageSize.value = newVal;
      });
      const innerPagesizes = vue2.computed(() => props3.pageSizes);
      function handleChange(val) {
        var _a;
        if (val !== innerPageSize.value) {
          innerPageSize.value = val;
          (_a = pagination2.handleSizeChange) == null ? void 0 : _a.call(pagination2, Number(val));
        }
      }
      return {
        innerPagesizes,
        innerPageSize,
        t,
        handleChange
      };
    }
  });
  exports["default"] = script2;
})(sizes_vue_vue_type_script_lang);
var sizes_vue_vue_type_template_id_3a063678_lang = {};
Object.defineProperty(sizes_vue_vue_type_template_id_3a063678_lang, "__esModule", { value: true });
var vue$X = require$$0$1;
const _hoisted_1$s = { class: "el-pagination__sizes" };
function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = vue$X.resolveComponent("el-option");
  const _component_el_select = vue$X.resolveComponent("el-select");
  return vue$X.openBlock(), vue$X.createElementBlock("span", _hoisted_1$s, [
    vue$X.createVNode(_component_el_select, {
      "model-value": _ctx.innerPageSize,
      disabled: _ctx.disabled,
      "popper-class": _ctx.popperClass,
      size: "mini",
      onChange: _ctx.handleChange
    }, {
      default: vue$X.withCtx(() => [
        (vue$X.openBlock(true), vue$X.createElementBlock(vue$X.Fragment, null, vue$X.renderList(_ctx.innerPagesizes, (item2) => {
          return vue$X.openBlock(), vue$X.createBlock(_component_el_option, {
            key: item2,
            value: item2,
            label: item2 + _ctx.t("el.pagination.pagesize")
          }, null, 8, ["value", "label"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["model-value", "disabled", "popper-class", "onChange"])
  ]);
}
sizes_vue_vue_type_template_id_3a063678_lang.render = render$B;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var sizes_vue_vue_type_script_lang$1 = sizes_vue_vue_type_script_lang;
  var sizes_vue_vue_type_template_id_3a063678_lang$1 = sizes_vue_vue_type_template_id_3a063678_lang;
  sizes_vue_vue_type_script_lang$1["default"].render = sizes_vue_vue_type_template_id_3a063678_lang$1.render;
  sizes_vue_vue_type_script_lang$1["default"].__file = "packages/components/pagination/src/components/sizes.vue";
  exports["default"] = sizes_vue_vue_type_script_lang$1["default"];
})(sizes);
var jumper = {};
var jumper_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = input$2;
  var usePagination2 = usePagination$1;
  var index$110 = useLocale$1;
  var script2 = vue2.defineComponent({
    name: "ElPaginationJumper",
    components: {
      ElInput: index2.ElInput
    },
    setup() {
      const { t } = index$110.useLocale();
      const { pageCount, disabled, currentPage, changeEvent } = usePagination2.usePagination();
      const userInput = vue2.ref();
      const innerValue = vue2.computed(() => {
        var _a;
        return (_a = userInput.value) != null ? _a : currentPage == null ? void 0 : currentPage.value;
      });
      function handleInput(val) {
        userInput.value = +val;
      }
      function handleChange(val) {
        changeEvent == null ? void 0 : changeEvent(+val);
        userInput.value = void 0;
      }
      return {
        pageCount,
        disabled,
        innerValue,
        t,
        handleInput,
        handleChange
      };
    }
  });
  exports["default"] = script2;
})(jumper_vue_vue_type_script_lang);
var jumper_vue_vue_type_template_id_772239ce_lang = {};
Object.defineProperty(jumper_vue_vue_type_template_id_772239ce_lang, "__esModule", { value: true });
var vue$W = require$$0$1;
const _hoisted_1$r = { class: "el-pagination__jump" };
function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = vue$W.resolveComponent("el-input");
  return vue$W.openBlock(), vue$W.createElementBlock("span", _hoisted_1$r, [
    vue$W.createTextVNode(vue$W.toDisplayString(_ctx.t("el.pagination.goto")) + " ", 1),
    vue$W.createVNode(_component_el_input, {
      size: "mini",
      class: "el-pagination__editor is-in-pagination",
      min: 1,
      max: _ctx.pageCount,
      disabled: _ctx.disabled,
      "model-value": _ctx.innerValue,
      type: "number",
      "onUpdate:modelValue": _ctx.handleInput,
      onChange: _ctx.handleChange
    }, null, 8, ["max", "disabled", "model-value", "onUpdate:modelValue", "onChange"]),
    vue$W.createTextVNode(" " + vue$W.toDisplayString(_ctx.t("el.pagination.pageClassifier")), 1)
  ]);
}
jumper_vue_vue_type_template_id_772239ce_lang.render = render$A;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var jumper_vue_vue_type_script_lang$1 = jumper_vue_vue_type_script_lang;
  var jumper_vue_vue_type_template_id_772239ce_lang$1 = jumper_vue_vue_type_template_id_772239ce_lang;
  jumper_vue_vue_type_script_lang$1["default"].render = jumper_vue_vue_type_template_id_772239ce_lang$1.render;
  jumper_vue_vue_type_script_lang$1["default"].__file = "packages/components/pagination/src/components/jumper.vue";
  exports["default"] = jumper_vue_vue_type_script_lang$1["default"];
})(jumper);
var total$1 = {};
var total_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = useLocale$1;
  const paginationTotalProps = {
    total: {
      type: Number,
      default: 1e3
    }
  };
  var script2 = vue2.defineComponent({
    name: "ElPaginationTotal",
    props: paginationTotalProps,
    setup() {
      const { t } = index2.useLocale();
      return {
        t
      };
    }
  });
  exports["default"] = script2;
})(total_vue_vue_type_script_lang);
var total_vue_vue_type_template_id_bc261314_lang = {};
Object.defineProperty(total_vue_vue_type_template_id_bc261314_lang, "__esModule", { value: true });
var vue$V = require$$0$1;
const _hoisted_1$q = { class: "el-pagination__total" };
function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$V.openBlock(), vue$V.createElementBlock("span", _hoisted_1$q, vue$V.toDisplayString(_ctx.t("el.pagination.total", {
    total: _ctx.total
  })), 1);
}
total_vue_vue_type_template_id_bc261314_lang.render = render$z;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var total_vue_vue_type_script_lang$1 = total_vue_vue_type_script_lang;
  var total_vue_vue_type_template_id_bc261314_lang$1 = total_vue_vue_type_template_id_bc261314_lang;
  total_vue_vue_type_script_lang$1["default"].render = total_vue_vue_type_template_id_bc261314_lang$1.render;
  total_vue_vue_type_script_lang$1["default"].__file = "packages/components/pagination/src/components/total.vue";
  exports["default"] = total_vue_vue_type_script_lang$1["default"];
})(total$1);
var pager = {};
var pager_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var iconsVue2 = require$$3;
  const paginationPagerProps = {
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      required: true
    },
    pagerCount: {
      type: Number,
      default: 7
    },
    disabled: Boolean
  };
  var script2 = vue2.defineComponent({
    name: "ElPaginationPager",
    components: {
      DArrowLeft: iconsVue2.DArrowLeft,
      DArrowRight: iconsVue2.DArrowRight,
      MoreFilled: iconsVue2.MoreFilled
    },
    props: paginationPagerProps,
    emits: ["change"],
    setup(props2, { emit }) {
      const showPrevMore = vue2.ref(false);
      const showNextMore = vue2.ref(false);
      const quickPrevHover = vue2.ref(false);
      const quickNextHover = vue2.ref(false);
      const pagers = vue2.computed(() => {
        const pagerCount = props2.pagerCount;
        const halfPagerCount = (pagerCount - 1) / 2;
        const currentPage = Number(props2.currentPage);
        const pageCount = Number(props2.pageCount);
        let showPrevMore2 = false;
        let showNextMore2 = false;
        if (pageCount > pagerCount) {
          if (currentPage > pagerCount - halfPagerCount) {
            showPrevMore2 = true;
          }
          if (currentPage < pageCount - halfPagerCount) {
            showNextMore2 = true;
          }
        }
        const array4 = [];
        if (showPrevMore2 && !showNextMore2) {
          const startPage = pageCount - (pagerCount - 2);
          for (let i = startPage; i < pageCount; i++) {
            array4.push(i);
          }
        } else if (!showPrevMore2 && showNextMore2) {
          for (let i = 2; i < pagerCount; i++) {
            array4.push(i);
          }
        } else if (showPrevMore2 && showNextMore2) {
          const offset2 = Math.floor(pagerCount / 2) - 1;
          for (let i = currentPage - offset2; i <= currentPage + offset2; i++) {
            array4.push(i);
          }
        } else {
          for (let i = 2; i < pageCount; i++) {
            array4.push(i);
          }
        }
        return array4;
      });
      vue2.watchEffect(() => {
        const halfPagerCount = (props2.pagerCount - 1) / 2;
        showPrevMore.value = false;
        showNextMore.value = false;
        if (props2.pageCount > props2.pagerCount) {
          if (props2.currentPage > props2.pagerCount - halfPagerCount) {
            showPrevMore.value = true;
          }
          if (props2.currentPage < props2.pageCount - halfPagerCount) {
            showNextMore.value = true;
          }
        }
      });
      function onMouseenter(direction2) {
        if (props2.disabled)
          return;
        if (direction2 === "left") {
          quickPrevHover.value = true;
        } else {
          quickNextHover.value = true;
        }
      }
      function onEnter(e) {
        const target2 = e.target;
        if (target2.tagName.toLowerCase() === "li" && Array.from(target2.classList).includes("number")) {
          const newPage = Number(target2.textContent);
          if (newPage !== props2.currentPage) {
            emit("change", newPage);
          }
        }
      }
      function onPagerClick(event) {
        const target2 = event.target;
        if (target2.tagName.toLowerCase() === "ul" || props2.disabled) {
          return;
        }
        let newPage = Number(target2.textContent);
        const pageCount = props2.pageCount;
        const currentPage = props2.currentPage;
        const pagerCountOffset = props2.pagerCount - 2;
        if (target2.className.includes("more")) {
          if (target2.className.includes("quickprev")) {
            newPage = currentPage - pagerCountOffset;
          } else if (target2.className.includes("quicknext")) {
            newPage = currentPage + pagerCountOffset;
          }
        }
        if (!isNaN(newPage)) {
          if (newPage < 1) {
            newPage = 1;
          }
          if (newPage > pageCount) {
            newPage = pageCount;
          }
        }
        if (newPage !== currentPage) {
          emit("change", newPage);
        }
      }
      return {
        showPrevMore,
        showNextMore,
        quickPrevHover,
        quickNextHover,
        pagers,
        onMouseenter,
        onPagerClick,
        onEnter
      };
    }
  });
  exports["default"] = script2;
})(pager_vue_vue_type_script_lang);
var pager_vue_vue_type_template_id_0bfc9916_lang = {};
Object.defineProperty(pager_vue_vue_type_template_id_0bfc9916_lang, "__esModule", { value: true });
var vue$U = require$$0$1;
const _hoisted_1$p = ["aria-current"];
const _hoisted_2$l = ["aria-current"];
const _hoisted_3$i = ["aria-current"];
function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_d_arrow_left = vue$U.resolveComponent("d-arrow-left");
  const _component_more_filled = vue$U.resolveComponent("more-filled");
  const _component_d_arrow_right = vue$U.resolveComponent("d-arrow-right");
  return vue$U.openBlock(), vue$U.createElementBlock("ul", {
    class: "el-pager",
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onPagerClick && _ctx.onPagerClick(...args)),
    onKeyup: _cache[5] || (_cache[5] = vue$U.withKeys((...args) => _ctx.onEnter && _ctx.onEnter(...args), ["enter"]))
  }, [
    _ctx.pageCount > 0 ? (vue$U.openBlock(), vue$U.createElementBlock("li", {
      key: 0,
      class: vue$U.normalizeClass([{ active: _ctx.currentPage === 1, disabled: _ctx.disabled }, "number"]),
      "aria-current": _ctx.currentPage === 1,
      tabindex: "0"
    }, " 1 ", 10, _hoisted_1$p)) : vue$U.createCommentVNode("v-if", true),
    _ctx.showPrevMore ? (vue$U.openBlock(), vue$U.createElementBlock("li", {
      key: 1,
      class: vue$U.normalizeClass(["el-icon more btn-quickprev", { disabled: _ctx.disabled }]),
      onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.onMouseenter("left")),
      onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.quickPrevHover = false)
    }, [
      _ctx.quickPrevHover ? (vue$U.openBlock(), vue$U.createBlock(_component_d_arrow_left, { key: 0 })) : (vue$U.openBlock(), vue$U.createBlock(_component_more_filled, { key: 1 }))
    ], 34)) : vue$U.createCommentVNode("v-if", true),
    (vue$U.openBlock(true), vue$U.createElementBlock(vue$U.Fragment, null, vue$U.renderList(_ctx.pagers, (pager2) => {
      return vue$U.openBlock(), vue$U.createElementBlock("li", {
        key: pager2,
        class: vue$U.normalizeClass([{ active: _ctx.currentPage === pager2, disabled: _ctx.disabled }, "number"]),
        "aria-current": _ctx.currentPage === pager2,
        tabindex: "0"
      }, vue$U.toDisplayString(pager2), 11, _hoisted_2$l);
    }), 128)),
    _ctx.showNextMore ? (vue$U.openBlock(), vue$U.createElementBlock("li", {
      key: 2,
      class: vue$U.normalizeClass(["el-icon more btn-quicknext", { disabled: _ctx.disabled }]),
      onMouseenter: _cache[2] || (_cache[2] = ($event) => _ctx.onMouseenter("right")),
      onMouseleave: _cache[3] || (_cache[3] = ($event) => _ctx.quickNextHover = false)
    }, [
      _ctx.quickNextHover ? (vue$U.openBlock(), vue$U.createBlock(_component_d_arrow_right, { key: 0 })) : (vue$U.openBlock(), vue$U.createBlock(_component_more_filled, { key: 1 }))
    ], 34)) : vue$U.createCommentVNode("v-if", true),
    _ctx.pageCount > 1 ? (vue$U.openBlock(), vue$U.createElementBlock("li", {
      key: 3,
      class: vue$U.normalizeClass([{ active: _ctx.currentPage === _ctx.pageCount, disabled: _ctx.disabled }, "number"]),
      "aria-current": _ctx.currentPage === _ctx.pageCount,
      tabindex: "0"
    }, vue$U.toDisplayString(_ctx.pageCount), 11, _hoisted_3$i)) : vue$U.createCommentVNode("v-if", true)
  ], 32);
}
pager_vue_vue_type_template_id_0bfc9916_lang.render = render$y;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var pager_vue_vue_type_script_lang$1 = pager_vue_vue_type_script_lang;
  var pager_vue_vue_type_template_id_0bfc9916_lang$1 = pager_vue_vue_type_template_id_0bfc9916_lang;
  pager_vue_vue_type_script_lang$1["default"].render = pager_vue_vue_type_template_id_0bfc9916_lang$1.render;
  pager_vue_vue_type_script_lang$1["default"].__file = "packages/components/pagination/src/components/pager.vue";
  exports["default"] = pager_vue_vue_type_script_lang$1["default"];
})(pager);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var error2 = error$5;
  var props2 = props$N;
  var index2 = useLocale$1;
  var pagination2 = pagination$4;
  var prev_vue_vue_type_script_lang$1 = prev_vue_vue_type_script_lang;
  var jumper_vue_vue_type_script_lang$1 = jumper_vue_vue_type_script_lang;
  var pager_vue_vue_type_script_lang$1 = pager_vue_vue_type_script_lang;
  var next_vue_vue_type_script_lang$1 = next_vue_vue_type_script_lang;
  var sizes_vue_vue_type_script_lang$1 = sizes_vue_vue_type_script_lang;
  var total_vue_vue_type_script_lang$1 = total_vue_vue_type_script_lang;
  const isAbsent = (v2) => typeof v2 !== "number";
  const paginationProps = props2.buildProps({
    total: Number,
    pageSize: Number,
    defaultPageSize: Number,
    currentPage: Number,
    defaultCurrentPage: Number,
    pageCount: Number,
    pagerCount: {
      type: Number,
      validator: (value) => {
        return typeof value === "number" && (value | 0) === value && value > 4 && value < 22 && value % 2 === 1;
      },
      default: 7
    },
    layout: {
      type: String,
      default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
    },
    pageSizes: {
      type: props2.definePropType(Array),
      default: () => props2.mutable([10, 20, 30, 40, 50, 100])
    },
    popperClass: {
      type: String,
      default: ""
    },
    prevText: {
      type: String,
      default: ""
    },
    nextText: {
      type: String,
      default: ""
    },
    small: Boolean,
    background: Boolean,
    disabled: Boolean,
    hideOnSinglePage: Boolean
  });
  const paginationEmits = {
    "update:current-page": (val) => typeof val === "number",
    "update:page-size": (val) => typeof val === "number",
    "size-change": (val) => typeof val === "number",
    "current-change": (val) => typeof val === "number",
    "prev-click": (val) => typeof val === "number",
    "next-click": (val) => typeof val === "number"
  };
  const componentName = "ElPagination";
  var Pagination = vue2.defineComponent({
    name: componentName,
    props: paginationProps,
    emits: paginationEmits,
    setup(props3, { emit, slots }) {
      const { t } = index2.useLocale();
      const vnodeProps = vue2.getCurrentInstance().vnode.props || {};
      const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
      const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
      const assertValidUsage = vue2.computed(() => {
        if (isAbsent(props3.total) && isAbsent(props3.pageCount))
          return false;
        if (!isAbsent(props3.currentPage) && !hasCurrentPageListener)
          return false;
        if (props3.layout.includes("sizes")) {
          if (!isAbsent(props3.pageCount)) {
            if (!hasPageSizeListener)
              return false;
          } else if (!isAbsent(props3.total)) {
            if (!isAbsent(props3.pageSize)) {
              if (!hasPageSizeListener) {
                return false;
              }
            }
          }
        }
        return true;
      });
      const innerPageSize = vue2.ref(isAbsent(props3.defaultPageSize) ? 10 : props3.defaultPageSize);
      const innerCurrentPage = vue2.ref(isAbsent(props3.defaultCurrentPage) ? 1 : props3.defaultCurrentPage);
      const pageSizeBridge = vue2.computed({
        get() {
          return isAbsent(props3.pageSize) ? innerPageSize.value : props3.pageSize;
        },
        set(v2) {
          if (isAbsent(props3.pageSize)) {
            innerPageSize.value = v2;
          }
          if (hasPageSizeListener) {
            emit("update:page-size", v2);
            emit("size-change", v2);
          }
        }
      });
      const pageCountBridge = vue2.computed(() => {
        let pageCount = 0;
        if (!isAbsent(props3.pageCount)) {
          pageCount = props3.pageCount;
        } else if (!isAbsent(props3.total)) {
          pageCount = Math.max(1, Math.ceil(props3.total / pageSizeBridge.value));
        }
        return pageCount;
      });
      const currentPageBridge = vue2.computed({
        get() {
          return isAbsent(props3.currentPage) ? innerCurrentPage.value : props3.currentPage;
        },
        set(v2) {
          let newCurrentPage = v2;
          if (v2 < 1) {
            newCurrentPage = 1;
          } else if (v2 > pageCountBridge.value) {
            newCurrentPage = pageCountBridge.value;
          }
          if (isAbsent(props3.currentPage)) {
            innerCurrentPage.value = newCurrentPage;
          }
          if (hasCurrentPageListener) {
            emit("update:current-page", newCurrentPage);
            emit("current-change", newCurrentPage);
          }
        }
      });
      vue2.watch(pageCountBridge, (val) => {
        if (currentPageBridge.value > val)
          currentPageBridge.value = val;
      });
      function handleCurrentChange(val) {
        currentPageBridge.value = val;
      }
      function handleSizeChange(val) {
        pageSizeBridge.value = val;
        const newPageCount = pageCountBridge.value;
        if (currentPageBridge.value > newPageCount) {
          currentPageBridge.value = newPageCount;
        }
      }
      function prev2() {
        if (props3.disabled)
          return;
        currentPageBridge.value -= 1;
        emit("prev-click", currentPageBridge.value);
      }
      function next2() {
        if (props3.disabled)
          return;
        currentPageBridge.value += 1;
        emit("next-click", currentPageBridge.value);
      }
      vue2.provide(pagination2.elPaginationKey, {
        pageCount: pageCountBridge,
        disabled: vue2.computed(() => props3.disabled),
        currentPage: currentPageBridge,
        changeEvent: handleCurrentChange,
        handleSizeChange
      });
      return () => {
        var _a, _b;
        if (!assertValidUsage.value) {
          error2.debugWarn(componentName, t("el.pagination.deprecationWarning"));
          return null;
        }
        if (!props3.layout)
          return null;
        if (props3.hideOnSinglePage && pageCountBridge.value <= 1)
          return null;
        const rootChildren = [];
        const rightWrapperChildren = [];
        const rightWrapperRoot = vue2.h("div", { class: "el-pagination__rightwrapper" }, rightWrapperChildren);
        const TEMPLATE_MAP = {
          prev: vue2.h(prev_vue_vue_type_script_lang$1["default"], {
            disabled: props3.disabled,
            currentPage: currentPageBridge.value,
            prevText: props3.prevText,
            onClick: prev2
          }),
          jumper: vue2.h(jumper_vue_vue_type_script_lang$1["default"]),
          pager: vue2.h(pager_vue_vue_type_script_lang$1["default"], {
            currentPage: currentPageBridge.value,
            pageCount: pageCountBridge.value,
            pagerCount: props3.pagerCount,
            onChange: handleCurrentChange,
            disabled: props3.disabled
          }),
          next: vue2.h(next_vue_vue_type_script_lang$1["default"], {
            disabled: props3.disabled,
            currentPage: currentPageBridge.value,
            pageCount: pageCountBridge.value,
            nextText: props3.nextText,
            onClick: next2
          }),
          sizes: vue2.h(sizes_vue_vue_type_script_lang$1["default"], {
            pageSize: pageSizeBridge.value,
            pageSizes: props3.pageSizes,
            popperClass: props3.popperClass,
            disabled: props3.disabled
          }),
          slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null,
          total: vue2.h(total_vue_vue_type_script_lang$1["default"], { total: isAbsent(props3.total) ? 0 : props3.total })
        };
        const components2 = props3.layout.split(",").map((item2) => item2.trim());
        let haveRightWrapper = false;
        components2.forEach((c2) => {
          if (c2 === "->") {
            haveRightWrapper = true;
            return;
          }
          if (!haveRightWrapper) {
            rootChildren.push(TEMPLATE_MAP[c2]);
          } else {
            rightWrapperChildren.push(TEMPLATE_MAP[c2]);
          }
        });
        if (haveRightWrapper && rightWrapperChildren.length > 0) {
          rootChildren.unshift(rightWrapperRoot);
        }
        return vue2.h("div", {
          role: "pagination",
          "aria-label": "pagination",
          class: [
            "el-pagination",
            {
              "is-background": props3.background,
              "el-pagination--small": props3.small
            }
          ]
        }, rootChildren);
      };
    }
  });
  exports["default"] = Pagination;
  exports.paginationEmits = paginationEmits;
  exports.paginationProps = paginationProps;
})(pagination$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var pagination2 = pagination$2;
  const ElPagination = withInstall2.withInstall(pagination2["default"]);
  exports.paginationEmits = pagination2.paginationEmits;
  exports.paginationProps = pagination2.paginationProps;
  exports.ElPagination = ElPagination;
  exports["default"] = ElPagination;
})(pagination$3);
var popconfirm$2 = {};
var popconfirm2 = {};
var popconfirm_vue_vue_type_script_lang = {};
var popconfirm$1 = {};
Object.defineProperty(popconfirm$1, "__esModule", { value: true });
var iconsVue$4 = require$$3;
var props$g = props$N;
var button$2 = button$4;
const popconfirmProps = props$g.buildProps({
  title: {
    type: String
  },
  confirmButtonText: {
    type: String
  },
  cancelButtonText: {
    type: String
  },
  confirmButtonType: {
    type: String,
    values: button$2.buttonType,
    default: "primary"
  },
  cancelButtonType: {
    type: String,
    values: button$2.buttonType,
    default: "text"
  },
  icon: {
    type: props$g.definePropType([String, Object]),
    default: iconsVue$4.QuestionFilled
  },
  iconColor: {
    type: String,
    default: "#f90"
  },
  hideIcon: {
    type: Boolean,
    default: false
  }
});
const popconfirmEmits = {
  confirm: () => true,
  cancel: () => true
};
popconfirm$1.popconfirmEmits = popconfirmEmits;
popconfirm$1.popconfirmProps = popconfirmProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = button$5;
  var index$22 = icon$4;
  var index$110 = popper$3;
  var popconfirm3 = popconfirm$1;
  var index$32 = useLocale$1;
  var defaults2 = defaults$d;
  var script2 = vue2.defineComponent({
    name: "ElPopconfirm",
    components: {
      ElButton: index2.ElButton,
      ElPopper: index$110["default"],
      ElIcon: index$22.ElIcon
    },
    props: popconfirm3.popconfirmProps,
    emits: popconfirm3.popconfirmEmits,
    setup(props2, { emit }) {
      const { t } = index$32.useLocale();
      const visible = vue2.ref(false);
      const confirm = () => {
        visible.value = false;
        emit("confirm");
      };
      const cancel = () => {
        visible.value = false;
        emit("cancel");
      };
      const finalConfirmButtonText = vue2.computed(() => props2.confirmButtonText || t("el.popconfirm.confirmButtonText"));
      const finalCancelButtonText = vue2.computed(() => props2.cancelButtonText || t("el.popconfirm.cancelButtonText"));
      return {
        Effect: defaults2.Effect,
        visible,
        finalConfirmButtonText,
        finalCancelButtonText,
        confirm,
        cancel
      };
    }
  });
  exports["default"] = script2;
})(popconfirm_vue_vue_type_script_lang);
var popconfirm_vue_vue_type_template_id_16409d25_lang = {};
Object.defineProperty(popconfirm_vue_vue_type_template_id_16409d25_lang, "__esModule", { value: true });
var vue$T = require$$0$1;
const _hoisted_1$o = { class: "el-popconfirm" };
const _hoisted_2$k = { class: "el-popconfirm__main" };
const _hoisted_3$h = { class: "el-popconfirm__action" };
function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$T.resolveComponent("el-icon");
  const _component_el_button = vue$T.resolveComponent("el-button");
  const _component_el_popper = vue$T.resolveComponent("el-popper");
  return vue$T.openBlock(), vue$T.createBlock(_component_el_popper, {
    visible: _ctx.visible,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.visible = $event),
    trigger: "click",
    effect: _ctx.Effect.LIGHT,
    "popper-class": "el-popover",
    "append-to-body": "",
    "fallback-placements": ["bottom", "top", "right", "left"]
  }, {
    trigger: vue$T.withCtx(() => [
      vue$T.renderSlot(_ctx.$slots, "reference")
    ]),
    default: vue$T.withCtx(() => [
      vue$T.createElementVNode("div", _hoisted_1$o, [
        vue$T.createElementVNode("div", _hoisted_2$k, [
          !_ctx.hideIcon && _ctx.icon ? (vue$T.openBlock(), vue$T.createBlock(_component_el_icon, {
            key: 0,
            class: "el-popconfirm__icon",
            style: vue$T.normalizeStyle({ color: _ctx.iconColor })
          }, {
            default: vue$T.withCtx(() => [
              (vue$T.openBlock(), vue$T.createBlock(vue$T.resolveDynamicComponent(_ctx.icon)))
            ]),
            _: 1
          }, 8, ["style"])) : vue$T.createCommentVNode("v-if", true),
          vue$T.createTextVNode(" " + vue$T.toDisplayString(_ctx.title), 1)
        ]),
        vue$T.createElementVNode("div", _hoisted_3$h, [
          vue$T.createVNode(_component_el_button, {
            size: "mini",
            type: _ctx.cancelButtonType,
            onClick: _ctx.cancel
          }, {
            default: vue$T.withCtx(() => [
              vue$T.createTextVNode(vue$T.toDisplayString(_ctx.finalCancelButtonText), 1)
            ]),
            _: 1
          }, 8, ["type", "onClick"]),
          vue$T.createVNode(_component_el_button, {
            size: "mini",
            type: _ctx.confirmButtonType,
            onClick: _ctx.confirm
          }, {
            default: vue$T.withCtx(() => [
              vue$T.createTextVNode(vue$T.toDisplayString(_ctx.finalConfirmButtonText), 1)
            ]),
            _: 1
          }, 8, ["type", "onClick"])
        ])
      ])
    ]),
    _: 3
  }, 8, ["visible", "effect"]);
}
popconfirm_vue_vue_type_template_id_16409d25_lang.render = render$x;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var popconfirm_vue_vue_type_script_lang$1 = popconfirm_vue_vue_type_script_lang;
  var popconfirm_vue_vue_type_template_id_16409d25_lang$1 = popconfirm_vue_vue_type_template_id_16409d25_lang;
  popconfirm_vue_vue_type_script_lang$1["default"].render = popconfirm_vue_vue_type_template_id_16409d25_lang$1.render;
  popconfirm_vue_vue_type_script_lang$1["default"].__file = "packages/components/popconfirm/src/popconfirm.vue";
  exports["default"] = popconfirm_vue_vue_type_script_lang$1["default"];
})(popconfirm2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var popconfirm3 = popconfirm$1;
  var popconfirm_vue_vue_type_script_lang$1 = popconfirm_vue_vue_type_script_lang;
  const ElPopconfirm = withInstall2.withInstall(popconfirm_vue_vue_type_script_lang$1["default"]);
  exports.popconfirmEmits = popconfirm3.popconfirmEmits;
  exports.popconfirmProps = popconfirm3.popconfirmProps;
  exports.ElPopconfirm = ElPopconfirm;
  exports["default"] = ElPopconfirm;
})(popconfirm$2);
var popover = {};
var src$7 = {};
var index_vue_vue_type_script_lang$6 = {};
var usePopover = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var popupManager2 = popupManager$3;
  var shared2 = require$$1$1;
  var index2 = usePopper;
  const SHOW_EVENT = "show";
  const HIDE_EVENT = "hide";
  function usePopover2(props2, ctx) {
    const zIndex2 = vue2.ref(popupManager2["default"].nextZIndex());
    const width = vue2.computed(() => {
      if (shared2.isString(props2.width)) {
        return props2.width;
      }
      return `${props2.width}px`;
    });
    const popperStyle = vue2.computed(() => {
      return {
        width: width.value,
        zIndex: zIndex2.value
      };
    });
    const popperProps = index2["default"](props2, ctx);
    vue2.watch(popperProps.visibility, (val) => {
      if (val) {
        zIndex2.value = popupManager2["default"].nextZIndex();
      }
      ctx.emit(val ? SHOW_EVENT : HIDE_EVENT);
    });
    return __spreadProps(__spreadValues({}, popperProps), {
      popperStyle
    });
  }
  exports.HIDE_EVENT = HIDE_EVENT;
  exports.SHOW_EVENT = SHOW_EVENT;
  exports["default"] = usePopover2;
})(usePopover);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = popper$3;
  var error2 = error$5;
  var vnode2 = vnode$1;
  var usePopover$1 = usePopover;
  var defaults2 = defaults$d;
  var popper2 = popper$2;
  var arrow2 = arrow$2;
  var trigger2 = trigger$2;
  var index$110 = clickOutside;
  const emits = [
    "update:visible",
    "after-enter",
    "after-leave",
    usePopover$1.SHOW_EVENT,
    usePopover$1.HIDE_EVENT
  ];
  const NAME = "ElPopover";
  const _hoist = { key: 0, class: "el-popover__title", role: "title" };
  var script2 = vue2.defineComponent({
    name: NAME,
    components: {
      ElPopper: index2["default"]
    },
    props: __spreadProps(__spreadValues({}, defaults2["default"]), {
      content: {
        type: String
      },
      trigger: {
        type: String,
        default: "click"
      },
      title: {
        type: String
      },
      transition: {
        type: String,
        default: "fade-in-linear"
      },
      width: {
        type: [String, Number],
        default: 150
      },
      appendToBody: {
        type: Boolean,
        default: true
      },
      tabindex: [String, Number]
    }),
    emits,
    setup(props2, ctx) {
      if (props2.visible && !ctx.slots.reference) {
        error2.debugWarn(NAME, `
        You cannot init popover without given reference
      `);
      }
      const states = usePopover$1["default"](props2, ctx);
      return states;
    },
    render() {
      const { $slots } = this;
      const trigger$12 = $slots.reference ? $slots.reference() : null;
      const title = vnode2.renderIf(!!this.title, "div", _hoist, vue2.toDisplayString(this.title), vnode2.PatchFlags.TEXT);
      const content = vue2.renderSlot($slots, "default", {}, () => [
        vue2.createTextVNode(vue2.toDisplayString(this.content), vnode2.PatchFlags.TEXT)
      ]);
      const {
        events,
        onAfterEnter,
        onAfterLeave,
        onPopperMouseEnter,
        onPopperMouseLeave,
        popperStyle,
        popperId,
        popperClass,
        showArrow,
        transition,
        visibility,
        tabindex
      } = this;
      const kls = [
        this.content ? "el-popover--plain" : "",
        "el-popover",
        popperClass
      ].join(" ");
      const popover2 = popper2["default"]({
        effect: defaults2.Effect.LIGHT,
        name: transition,
        popperClass: kls,
        popperStyle,
        popperId,
        visibility,
        onMouseenter: onPopperMouseEnter,
        onMouseleave: onPopperMouseLeave,
        onAfterEnter,
        onAfterLeave,
        stopPopperMouseEvent: false
      }, [title, content, arrow2["default"](showArrow)]);
      const _trigger = trigger$12 ? trigger2["default"](trigger$12, __spreadValues({
        ariaDescribedby: popperId,
        ref: "triggerRef",
        tabindex
      }, events)) : vue2.createCommentVNode("v-if", true);
      return vue2.h(vue2.Fragment, null, [
        this.trigger === "click" ? vue2.withDirectives(_trigger, [[index$110["default"], this.hide]]) : _trigger,
        vue2.h(vue2.Teleport, {
          disabled: !this.appendToBody,
          to: "body"
        }, [popover2])
      ]);
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$6);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$6;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/popover/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$7);
var directive$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dom2 = dom$8;
  const attachEvents = (el, binding, vnode2) => {
    const _ref = binding.arg || binding.value;
    const popover2 = vnode2.dirs[0].instance.$refs[_ref];
    if (popover2) {
      popover2.triggerRef = el;
      el.setAttribute("tabindex", popover2.tabindex);
      Object.entries(popover2.events).forEach(([eventName, e]) => {
        dom2.on(el, eventName.toLowerCase().slice(2), e);
      });
    }
  };
  var PopoverDirective = {
    mounted(el, binding, vnode2) {
      attachEvents(el, binding, vnode2);
    },
    updated(el, binding, vnode2) {
      attachEvents(el, binding, vnode2);
    }
  };
  const VPopover = "popover";
  exports.VPopover = VPopover;
  exports["default"] = PopoverDirective;
})(directive$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var directive2 = directive$1;
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$6;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  directive2["default"].install = (app) => {
    app.directive(directive2.VPopover, directive2["default"]);
  };
  const _PopoverDirective = directive2["default"];
  index_vue_vue_type_script_lang2["default"].directive = _PopoverDirective;
  const _Popover = index_vue_vue_type_script_lang2["default"];
  const ElPopover = _Popover;
  const ElPopoverDirective = _PopoverDirective;
  exports.ElPopover = ElPopover;
  exports.ElPopoverDirective = ElPopoverDirective;
  exports["default"] = _Popover;
})(popover);
var progress$2 = {};
var progress2 = {};
var progress_vue_vue_type_script_lang = {};
var progress$1 = {};
Object.defineProperty(progress$1, "__esModule", { value: true });
var props$f = props$N;
const progressProps = props$f.buildProps({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (val) => val >= 0 && val <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: props$f.definePropType(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: false
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: true
  },
  color: {
    type: props$f.definePropType([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  format: {
    type: props$f.definePropType(Function),
    default: (percentage) => `${percentage}%`
  }
});
progress$1.progressProps = progressProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var progress3 = progress$1;
  var script2 = vue2.defineComponent({
    name: "ElProgress",
    components: {
      ElIcon: index2.ElIcon,
      CircleCheck: iconsVue2.CircleCheck,
      CircleClose: iconsVue2.CircleClose,
      Check: iconsVue2.Check,
      Close: iconsVue2.Close,
      WarningFilled: iconsVue2.WarningFilled
    },
    props: progress3.progressProps,
    setup(props2) {
      const barStyle = vue2.computed(() => ({
        width: `${props2.percentage}%`,
        animationDuration: `${props2.duration}s`,
        backgroundColor: getCurrentColor(props2.percentage)
      }));
      const relativeStrokeWidth = vue2.computed(() => (props2.strokeWidth / props2.width * 100).toFixed(1));
      const radius = vue2.computed(() => {
        if (props2.type === "circle" || props2.type === "dashboard") {
          return parseInt(`${50 - parseFloat(relativeStrokeWidth.value) / 2}`, 10);
        } else {
          return 0;
        }
      });
      const trackPath = vue2.computed(() => {
        const r = radius.value;
        const isDashboard = props2.type === "dashboard";
        return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
      });
      const perimeter = vue2.computed(() => 2 * Math.PI * radius.value);
      const rate3 = vue2.computed(() => props2.type === "dashboard" ? 0.75 : 1);
      const strokeDashoffset = vue2.computed(() => {
        const offset2 = -1 * perimeter.value * (1 - rate3.value) / 2;
        return `${offset2}px`;
      });
      const trailPathStyle = vue2.computed(() => ({
        strokeDasharray: `${perimeter.value * rate3.value}px, ${perimeter.value}px`,
        strokeDashoffset: strokeDashoffset.value
      }));
      const circlePathStyle = vue2.computed(() => ({
        strokeDasharray: `${perimeter.value * rate3.value * (props2.percentage / 100)}px, ${perimeter.value}px`,
        strokeDashoffset: strokeDashoffset.value,
        transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease"
      }));
      const stroke = vue2.computed(() => {
        let ret;
        if (props2.color) {
          ret = getCurrentColor(props2.percentage);
        } else {
          switch (props2.status) {
            case "success":
              ret = "#13ce66";
              break;
            case "exception":
              ret = "#ff4949";
              break;
            case "warning":
              ret = "#e6a23c";
              break;
            default:
              ret = "#20a0ff";
          }
        }
        return ret;
      });
      const statusIcon = vue2.computed(() => {
        if (props2.status === "warning") {
          return iconsVue2.WarningFilled;
        }
        if (props2.type === "line") {
          return props2.status === "success" ? iconsVue2.CircleCheck : iconsVue2.CircleClose;
        } else {
          return props2.status === "success" ? iconsVue2.Check : iconsVue2.Close;
        }
      });
      const progressTextSize = vue2.computed(() => {
        return props2.type === "line" ? 12 + props2.strokeWidth * 0.4 : props2.width * 0.111111 + 2;
      });
      const content = vue2.computed(() => props2.format(props2.percentage));
      const getCurrentColor = (percentage) => {
        var _a;
        const { color: color2 } = props2;
        if (typeof color2 === "function") {
          return color2(percentage);
        } else if (typeof color2 === "string") {
          return color2;
        } else {
          const span = 100 / color2.length;
          const seriesColors = color2.map((seriesColor, index3) => {
            if (typeof seriesColor === "string") {
              return {
                color: seriesColor,
                percentage: (index3 + 1) * span
              };
            }
            return seriesColor;
          });
          const colors = seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
          for (const color22 of colors) {
            if (color22.percentage > percentage)
              return color22.color;
          }
          return (_a = colors[colors.length - 1]) == null ? void 0 : _a.color;
        }
      };
      const slotData = vue2.computed(() => {
        return {
          percentage: props2.percentage
        };
      });
      return {
        barStyle,
        relativeStrokeWidth,
        radius,
        trackPath,
        perimeter,
        rate: rate3,
        strokeDashoffset,
        trailPathStyle,
        circlePathStyle,
        stroke,
        statusIcon,
        progressTextSize,
        content,
        slotData
      };
    }
  });
  exports["default"] = script2;
})(progress_vue_vue_type_script_lang);
var progress_vue_vue_type_template_id_9158c3b6_lang = {};
Object.defineProperty(progress_vue_vue_type_template_id_9158c3b6_lang, "__esModule", { value: true });
var vue$S = require$$0$1;
const _hoisted_1$n = ["aria-valuenow"];
const _hoisted_2$j = {
  key: 0,
  class: "el-progress-bar"
};
const _hoisted_3$g = {
  key: 0,
  class: "el-progress-bar__innerText"
};
const _hoisted_4$b = { viewBox: "0 0 100 100" };
const _hoisted_5$9 = ["d", "stroke-width"];
const _hoisted_6$7 = ["d", "stroke", "stroke-linecap", "stroke-width"];
const _hoisted_7$5 = { key: 0 };
function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$S.resolveComponent("el-icon");
  return vue$S.openBlock(), vue$S.createElementBlock("div", {
    class: vue$S.normalizeClass(["el-progress", [
      `el-progress--${_ctx.type}`,
      _ctx.status ? `is-${_ctx.status}` : "",
      {
        "el-progress--without-text": !_ctx.showText,
        "el-progress--text-inside": _ctx.textInside
      }
    ]]),
    role: "progressbar",
    "aria-valuenow": _ctx.percentage,
    "aria-valuemin": "0",
    "aria-valuemax": "100"
  }, [
    _ctx.type === "line" ? (vue$S.openBlock(), vue$S.createElementBlock("div", _hoisted_2$j, [
      vue$S.createElementVNode("div", {
        class: "el-progress-bar__outer",
        style: vue$S.normalizeStyle({ height: `${_ctx.strokeWidth}px` })
      }, [
        vue$S.createElementVNode("div", {
          class: vue$S.normalizeClass([
            "el-progress-bar__inner",
            { "el-progress-bar__inner--indeterminate": _ctx.indeterminate }
          ]),
          style: vue$S.normalizeStyle(_ctx.barStyle)
        }, [
          (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (vue$S.openBlock(), vue$S.createElementBlock("div", _hoisted_3$g, [
            vue$S.renderSlot(_ctx.$slots, "default", vue$S.normalizeProps(vue$S.guardReactiveProps(_ctx.slotData)), () => [
              vue$S.createElementVNode("span", null, vue$S.toDisplayString(_ctx.content), 1)
            ])
          ])) : vue$S.createCommentVNode("v-if", true)
        ], 6)
      ], 4)
    ])) : (vue$S.openBlock(), vue$S.createElementBlock("div", {
      key: 1,
      class: "el-progress-circle",
      style: vue$S.normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
    }, [
      (vue$S.openBlock(), vue$S.createElementBlock("svg", _hoisted_4$b, [
        vue$S.createElementVNode("path", {
          class: "el-progress-circle__track",
          d: _ctx.trackPath,
          stroke: "#e5e9f2",
          "stroke-width": _ctx.relativeStrokeWidth,
          fill: "none",
          style: vue$S.normalizeStyle(_ctx.trailPathStyle)
        }, null, 12, _hoisted_5$9),
        vue$S.createElementVNode("path", {
          class: "el-progress-circle__path",
          d: _ctx.trackPath,
          stroke: _ctx.stroke,
          fill: "none",
          "stroke-linecap": _ctx.strokeLinecap,
          "stroke-width": _ctx.percentage ? _ctx.relativeStrokeWidth : 0,
          style: vue$S.normalizeStyle(_ctx.circlePathStyle)
        }, null, 12, _hoisted_6$7)
      ]))
    ], 4)),
    (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (vue$S.openBlock(), vue$S.createElementBlock("div", {
      key: 2,
      class: "el-progress__text",
      style: vue$S.normalizeStyle({ fontSize: `${_ctx.progressTextSize}px` })
    }, [
      vue$S.renderSlot(_ctx.$slots, "default", vue$S.normalizeProps(vue$S.guardReactiveProps(_ctx.slotData)), () => [
        !_ctx.status ? (vue$S.openBlock(), vue$S.createElementBlock("span", _hoisted_7$5, vue$S.toDisplayString(_ctx.content), 1)) : (vue$S.openBlock(), vue$S.createBlock(_component_el_icon, { key: 1 }, {
          default: vue$S.withCtx(() => [
            (vue$S.openBlock(), vue$S.createBlock(vue$S.resolveDynamicComponent(_ctx.statusIcon)))
          ]),
          _: 1
        }))
      ])
    ], 4)) : vue$S.createCommentVNode("v-if", true)
  ], 10, _hoisted_1$n);
}
progress_vue_vue_type_template_id_9158c3b6_lang.render = render$w;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var progress_vue_vue_type_script_lang$1 = progress_vue_vue_type_script_lang;
  var progress_vue_vue_type_template_id_9158c3b6_lang$1 = progress_vue_vue_type_template_id_9158c3b6_lang;
  progress_vue_vue_type_script_lang$1["default"].render = progress_vue_vue_type_template_id_9158c3b6_lang$1.render;
  progress_vue_vue_type_script_lang$1["default"].__file = "packages/components/progress/src/progress.vue";
  exports["default"] = progress_vue_vue_type_script_lang$1["default"];
})(progress2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var progress3 = progress$1;
  var progress_vue_vue_type_script_lang$1 = progress_vue_vue_type_script_lang;
  const ElProgress = withInstall2.withInstall(progress_vue_vue_type_script_lang$1["default"]);
  exports.progressProps = progress3.progressProps;
  exports.ElProgress = ElProgress;
  exports["default"] = ElProgress;
})(progress$2);
var rate$2 = {};
var rate2 = {};
var rate_vue_vue_type_script_lang = {};
var rate$1 = {};
Object.defineProperty(rate$1, "__esModule", { value: true });
var iconsVue$3 = require$$3;
var constants$6 = constants$f;
var props$e = props$N;
const rateProps = props$e.buildProps({
  modelValue: {
    type: Number,
    default: 0
  },
  lowThreshold: {
    type: Number,
    default: 2
  },
  highThreshold: {
    type: Number,
    default: 4
  },
  max: {
    type: Number,
    default: 5
  },
  colors: {
    type: props$e.definePropType([Array, Object]),
    default: () => props$e.mutable(["#F7BA2A", "#F7BA2A", "#F7BA2A"])
  },
  voidColor: {
    type: String,
    default: "#C6D1DE"
  },
  disabledVoidColor: {
    type: String,
    default: "#EFF2F7"
  },
  icons: {
    type: props$e.definePropType([Array, Object]),
    default: () => [iconsVue$3.StarFilled, iconsVue$3.StarFilled, iconsVue$3.StarFilled]
  },
  voidIcon: {
    type: props$e.definePropType([String, Object]),
    default: () => iconsVue$3.Star
  },
  disabledvoidIcon: {
    type: props$e.definePropType([String, Object]),
    default: () => iconsVue$3.StarFilled
  },
  disabled: {
    type: Boolean,
    default: false
  },
  allowHalf: {
    type: Boolean,
    default: false
  },
  showText: {
    type: Boolean,
    default: false
  },
  showScore: {
    type: Boolean,
    default: false
  },
  textColor: {
    type: String,
    default: "#1f2d3d"
  },
  texts: {
    type: props$e.definePropType([Array]),
    default: () => props$e.mutable([
      "Extremely bad",
      "Disappointed",
      "Fair",
      "Satisfied",
      "Surprise"
    ])
  },
  scoreTemplate: {
    type: String,
    default: "{value}"
  }
});
const rateEmits = {
  change: (value) => typeof value === "number",
  [constants$6.UPDATE_MODEL_EVENT]: (value) => typeof value === "number"
};
rate$1.rateEmits = rateEmits;
rate$1.rateProps = rateProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var dom2 = dom$8;
  var aria2 = aria$5;
  var constants2 = constants$f;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var rate3 = rate$1;
  var form2 = form$7;
  function getValueFromMap(value, map) {
    const isExcludedObject = (val) => shared2.isObject(val);
    const matchedKeys = Object.keys(map).map((key2) => +key2).filter((key2) => {
      const val = map[key2];
      const excluded = isExcludedObject(val) ? val.excluded : false;
      return excluded ? value < key2 : value <= key2;
    }).sort((a2, b2) => a2 - b2);
    const matchedValue = map[matchedKeys[0]];
    return isExcludedObject(matchedValue) && matchedValue.value || matchedValue;
  }
  var script2 = vue2.defineComponent({
    name: "ElRate",
    components: {
      ElIcon: index2.ElIcon,
      StarFilled: iconsVue2.StarFilled,
      Star: iconsVue2.Star
    },
    props: rate3.rateProps,
    emits: rate3.rateEmits,
    setup(props2, { emit }) {
      const elForm = vue2.inject(form2.elFormKey, {});
      const currentValue = vue2.ref(props2.modelValue);
      const hoverIndex = vue2.ref(-1);
      const pointerAtLeftHalf = vue2.ref(true);
      const rateDisabled = vue2.computed(() => props2.disabled || elForm.disabled);
      const text = vue2.computed(() => {
        let result3 = "";
        if (props2.showScore) {
          result3 = props2.scoreTemplate.replace(/\{\s*value\s*\}/, rateDisabled.value ? `${props2.modelValue}` : `${currentValue.value}`);
        } else if (props2.showText) {
          result3 = props2.texts[Math.ceil(currentValue.value) - 1];
        }
        return result3;
      });
      const valueDecimal = vue2.computed(() => props2.modelValue * 100 - Math.floor(props2.modelValue) * 100);
      const colorMap = vue2.computed(() => shared2.isArray(props2.colors) ? {
        [props2.lowThreshold]: props2.colors[0],
        [props2.highThreshold]: { value: props2.colors[1], excluded: true },
        [props2.max]: props2.colors[2]
      } : props2.colors);
      const activeColor = vue2.computed(() => getValueFromMap(currentValue.value, colorMap.value));
      const decimalStyle = vue2.computed(() => {
        let width = "";
        if (rateDisabled.value) {
          width = `${valueDecimal.value}%`;
        } else if (props2.allowHalf) {
          width = "50%";
        }
        return {
          color: activeColor.value,
          width
        };
      });
      const componentMap = vue2.computed(() => shared2.isArray(props2.icons) ? {
        [props2.lowThreshold]: props2.icons[0],
        [props2.highThreshold]: {
          value: props2.icons[1],
          excluded: true
        },
        [props2.max]: props2.icons[2]
      } : props2.icons);
      const decimalIconComponent = vue2.computed(() => getValueFromMap(props2.modelValue, componentMap.value));
      const voidComponent = vue2.computed(() => rateDisabled.value ? props2.disabledvoidIcon : props2.voidIcon);
      const activeComponent = vue2.computed(() => getValueFromMap(currentValue.value, componentMap.value));
      const iconComponents = vue2.computed(() => {
        const result3 = Array(props2.max);
        const threshold = currentValue.value;
        result3.fill(activeComponent.value, 0, threshold);
        result3.fill(voidComponent.value, threshold, props2.max);
        return result3;
      });
      function showDecimalIcon(item2) {
        const showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item2 - 1 < props2.modelValue && item2 > props2.modelValue;
        const showWhenAllowHalf = props2.allowHalf && pointerAtLeftHalf.value && item2 - 0.5 <= currentValue.value && item2 > currentValue.value;
        return showWhenDisabled || showWhenAllowHalf;
      }
      function getIconStyle(item2) {
        const voidColor = rateDisabled.value ? props2.disabledVoidColor : props2.voidColor;
        return {
          color: item2 <= currentValue.value ? activeColor.value : voidColor
        };
      }
      function selectValue(value) {
        if (rateDisabled.value) {
          return;
        }
        if (props2.allowHalf && pointerAtLeftHalf.value) {
          emit(constants2.UPDATE_MODEL_EVENT, currentValue.value);
          if (props2.modelValue !== currentValue.value) {
            emit("change", currentValue.value);
          }
        } else {
          emit(constants2.UPDATE_MODEL_EVENT, value);
          if (props2.modelValue !== value) {
            emit("change", value);
          }
        }
      }
      function handleKey(e) {
        if (rateDisabled.value) {
          return;
        }
        let _currentValue = currentValue.value;
        const code2 = e.code;
        if (code2 === aria2.EVENT_CODE.up || code2 === aria2.EVENT_CODE.right) {
          if (props2.allowHalf) {
            _currentValue += 0.5;
          } else {
            _currentValue += 1;
          }
          e.stopPropagation();
          e.preventDefault();
        } else if (code2 === aria2.EVENT_CODE.left || code2 === aria2.EVENT_CODE.down) {
          if (props2.allowHalf) {
            _currentValue -= 0.5;
          } else {
            _currentValue -= 1;
          }
          e.stopPropagation();
          e.preventDefault();
        }
        _currentValue = _currentValue < 0 ? 0 : _currentValue;
        _currentValue = _currentValue > props2.max ? props2.max : _currentValue;
        emit(constants2.UPDATE_MODEL_EVENT, _currentValue);
        emit("change", _currentValue);
        return _currentValue;
      }
      function setCurrentValue(value, event) {
        if (rateDisabled.value) {
          return;
        }
        if (props2.allowHalf) {
          let target2 = event.target;
          if (dom2.hasClass(target2, "el-rate__item")) {
            target2 = target2.querySelector(".el-rate__icon");
          }
          if (target2.clientWidth === 0 || dom2.hasClass(target2, "el-rate__decimal")) {
            target2 = target2.parentNode;
          }
          pointerAtLeftHalf.value = event.offsetX * 2 <= target2.clientWidth;
          currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
        } else {
          currentValue.value = value;
        }
        hoverIndex.value = value;
      }
      function resetCurrentValue() {
        if (rateDisabled.value) {
          return;
        }
        if (props2.allowHalf) {
          pointerAtLeftHalf.value = props2.modelValue !== Math.floor(props2.modelValue);
        }
        currentValue.value = props2.modelValue;
        hoverIndex.value = -1;
      }
      vue2.watch(() => props2.modelValue, (val) => {
        currentValue.value = val;
        pointerAtLeftHalf.value = props2.modelValue !== Math.floor(props2.modelValue);
      });
      if (!props2.modelValue) {
        emit(constants2.UPDATE_MODEL_EVENT, 0);
      }
      return {
        hoverIndex,
        currentValue,
        rateDisabled,
        text,
        decimalStyle,
        decimalIconComponent,
        iconComponents,
        showDecimalIcon,
        getIconStyle,
        selectValue,
        handleKey,
        setCurrentValue,
        resetCurrentValue
      };
    }
  });
  exports["default"] = script2;
})(rate_vue_vue_type_script_lang);
var rate_vue_vue_type_template_id_38c42df6_lang = {};
Object.defineProperty(rate_vue_vue_type_template_id_38c42df6_lang, "__esModule", { value: true });
var vue$R = require$$0$1;
const _hoisted_1$m = ["aria-valuenow", "aria-valuetext", "aria-valuemax"];
const _hoisted_2$i = ["onMousemove", "onClick"];
function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$R.resolveComponent("el-icon");
  return vue$R.openBlock(), vue$R.createElementBlock("div", {
    class: "el-rate",
    role: "slider",
    "aria-valuenow": _ctx.currentValue,
    "aria-valuetext": _ctx.text,
    "aria-valuemin": "0",
    "aria-valuemax": _ctx.max,
    tabindex: "0",
    onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.handleKey && _ctx.handleKey(...args))
  }, [
    (vue$R.openBlock(true), vue$R.createElementBlock(vue$R.Fragment, null, vue$R.renderList(_ctx.max, (item2, key2) => {
      return vue$R.openBlock(), vue$R.createElementBlock("span", {
        key: key2,
        class: "el-rate__item",
        style: vue$R.normalizeStyle({ cursor: _ctx.rateDisabled ? "auto" : "pointer" }),
        onMousemove: ($event) => _ctx.setCurrentValue(item2, $event),
        onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.resetCurrentValue && _ctx.resetCurrentValue(...args)),
        onClick: ($event) => _ctx.selectValue(item2)
      }, [
        vue$R.createVNode(_component_el_icon, {
          class: vue$R.normalizeClass([[{ hover: _ctx.hoverIndex === item2 }], "el-rate__icon"]),
          style: vue$R.normalizeStyle(_ctx.getIconStyle(item2))
        }, {
          default: vue$R.withCtx(() => [
            (vue$R.openBlock(), vue$R.createBlock(vue$R.resolveDynamicComponent(_ctx.iconComponents[item2 - 1]))),
            _ctx.showDecimalIcon(item2) ? (vue$R.openBlock(), vue$R.createBlock(_component_el_icon, {
              key: 0,
              style: vue$R.normalizeStyle(_ctx.decimalStyle),
              class: "el-rate__icon el-rate__decimal"
            }, {
              default: vue$R.withCtx(() => [
                (vue$R.openBlock(), vue$R.createBlock(vue$R.resolveDynamicComponent(_ctx.decimalIconComponent)))
              ]),
              _: 1
            }, 8, ["style"])) : vue$R.createCommentVNode("v-if", true)
          ]),
          _: 2
        }, 1032, ["class", "style"])
      ], 44, _hoisted_2$i);
    }), 128)),
    _ctx.showText || _ctx.showScore ? (vue$R.openBlock(), vue$R.createElementBlock("span", {
      key: 0,
      class: "el-rate__text",
      style: vue$R.normalizeStyle({ color: _ctx.textColor })
    }, vue$R.toDisplayString(_ctx.text), 5)) : vue$R.createCommentVNode("v-if", true)
  ], 40, _hoisted_1$m);
}
rate_vue_vue_type_template_id_38c42df6_lang.render = render$v;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var rate_vue_vue_type_script_lang$1 = rate_vue_vue_type_script_lang;
  var rate_vue_vue_type_template_id_38c42df6_lang$1 = rate_vue_vue_type_template_id_38c42df6_lang;
  rate_vue_vue_type_script_lang$1["default"].render = rate_vue_vue_type_template_id_38c42df6_lang$1.render;
  rate_vue_vue_type_script_lang$1["default"].__file = "packages/components/rate/src/rate.vue";
  exports["default"] = rate_vue_vue_type_script_lang$1["default"];
})(rate2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var rate3 = rate$1;
  var rate_vue_vue_type_script_lang$1 = rate_vue_vue_type_script_lang;
  const ElRate = withInstall2.withInstall(rate_vue_vue_type_script_lang$1["default"]);
  exports.rateEmits = rate3.rateEmits;
  exports.rateProps = rate3.rateProps;
  exports.ElRate = ElRate;
  exports["default"] = ElRate;
})(rate$2);
var result$2 = {};
var result2 = {};
var result_vue_vue_type_script_lang = {};
var result$1 = {};
Object.defineProperty(result$1, "__esModule", { value: true });
var props$d = props$N;
var iconsVue$2 = require$$3;
const IconMap = {
  success: "icon-success",
  warning: "icon-warning",
  error: "icon-error",
  info: "icon-info"
};
const IconComponentMap = {
  [IconMap.success]: iconsVue$2.CircleCheckFilled,
  [IconMap.warning]: iconsVue$2.WarningFilled,
  [IconMap.error]: iconsVue$2.CircleCloseFilled,
  [IconMap.info]: iconsVue$2.InfoFilled
};
const resultProps = props$d.buildProps({
  title: {
    type: String,
    default: ""
  },
  subTitle: {
    type: String,
    default: ""
  },
  icon: {
    values: ["success", "warning", "info", "error"],
    default: "info"
  }
});
result$1.IconComponentMap = IconComponentMap;
result$1.IconMap = IconMap;
result$1.resultProps = resultProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var result3 = result$1;
  var script2 = vue2.defineComponent({
    name: "ElResult",
    props: result3.resultProps,
    setup(props2) {
      const resultIcon = vue2.computed(() => {
        const icon3 = props2.icon;
        const iconClass = icon3 && result3.IconMap[icon3] ? result3.IconMap[icon3] : "icon-info";
        const iconComponent = result3.IconComponentMap[iconClass] || result3.IconComponentMap["icon-info"];
        return {
          class: iconClass,
          component: iconComponent
        };
      });
      return {
        resultIcon
      };
    }
  });
  exports["default"] = script2;
})(result_vue_vue_type_script_lang);
var result_vue_vue_type_template_id_263c10e5_lang = {};
Object.defineProperty(result_vue_vue_type_template_id_263c10e5_lang, "__esModule", { value: true });
var vue$Q = require$$0$1;
const _hoisted_1$l = { class: "el-result" };
const _hoisted_2$h = { class: "el-result__icon" };
const _hoisted_3$f = {
  key: 0,
  class: "el-result__title"
};
const _hoisted_4$a = {
  key: 1,
  class: "el-result__subtitle"
};
const _hoisted_5$8 = {
  key: 2,
  class: "el-result__extra"
};
function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$Q.openBlock(), vue$Q.createElementBlock("div", _hoisted_1$l, [
    vue$Q.createElementVNode("div", _hoisted_2$h, [
      vue$Q.renderSlot(_ctx.$slots, "icon", {}, () => [
        _ctx.resultIcon.component ? (vue$Q.openBlock(), vue$Q.createBlock(vue$Q.resolveDynamicComponent(_ctx.resultIcon.component), {
          key: 0,
          class: vue$Q.normalizeClass(_ctx.resultIcon.class)
        }, null, 8, ["class"])) : vue$Q.createCommentVNode("v-if", true)
      ])
    ]),
    _ctx.title || _ctx.$slots.title ? (vue$Q.openBlock(), vue$Q.createElementBlock("div", _hoisted_3$f, [
      vue$Q.renderSlot(_ctx.$slots, "title", {}, () => [
        vue$Q.createElementVNode("p", null, vue$Q.toDisplayString(_ctx.title), 1)
      ])
    ])) : vue$Q.createCommentVNode("v-if", true),
    _ctx.subTitle || _ctx.$slots.subTitle ? (vue$Q.openBlock(), vue$Q.createElementBlock("div", _hoisted_4$a, [
      vue$Q.renderSlot(_ctx.$slots, "subTitle", {}, () => [
        vue$Q.createElementVNode("p", null, vue$Q.toDisplayString(_ctx.subTitle), 1)
      ])
    ])) : vue$Q.createCommentVNode("v-if", true),
    _ctx.$slots.extra ? (vue$Q.openBlock(), vue$Q.createElementBlock("div", _hoisted_5$8, [
      vue$Q.renderSlot(_ctx.$slots, "extra")
    ])) : vue$Q.createCommentVNode("v-if", true)
  ]);
}
result_vue_vue_type_template_id_263c10e5_lang.render = render$u;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var result_vue_vue_type_script_lang$1 = result_vue_vue_type_script_lang;
  var result_vue_vue_type_template_id_263c10e5_lang$1 = result_vue_vue_type_template_id_263c10e5_lang;
  result_vue_vue_type_script_lang$1["default"].render = result_vue_vue_type_template_id_263c10e5_lang$1.render;
  result_vue_vue_type_script_lang$1["default"].__file = "packages/components/result/src/result.vue";
  exports["default"] = result_vue_vue_type_script_lang$1["default"];
})(result2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var result3 = result$1;
  var result_vue_vue_type_script_lang$1 = result_vue_vue_type_script_lang;
  const ElResult = withInstall2.withInstall(result_vue_vue_type_script_lang$1["default"]);
  exports.IconComponentMap = result3.IconComponentMap;
  exports.IconMap = result3.IconMap;
  exports.resultProps = result3.resultProps;
  exports.ElResult = ElResult;
  exports["default"] = ElResult;
})(result$2);
var row$2 = {};
var row$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var props2 = props$N;
  const rowProps = props2.buildProps({
    tag: {
      type: String,
      default: "div"
    },
    gutter: {
      type: Number,
      default: 0
    },
    justify: {
      type: String,
      values: ["start", "center", "end", "space-around", "space-between"],
      default: "start"
    },
    align: {
      type: String,
      values: ["top", "middle", "bottom"],
      default: "top"
    }
  });
  var Row = vue2.defineComponent({
    name: "ElRow",
    props: rowProps,
    setup(props3, { slots }) {
      const gutter = vue2.computed(() => props3.gutter);
      vue2.provide("ElRow", {
        gutter
      });
      const style = vue2.computed(() => {
        const ret = {
          marginLeft: "",
          marginRight: ""
        };
        if (props3.gutter) {
          ret.marginLeft = `-${props3.gutter / 2}px`;
          ret.marginRight = ret.marginLeft;
        }
        return ret;
      });
      return () => {
        var _a;
        return vue2.h(props3.tag, {
          class: [
            "el-row",
            props3.justify !== "start" ? `is-justify-${props3.justify}` : "",
            props3.align !== "top" ? `is-align-${props3.align}` : ""
          ],
          style: style.value
        }, (_a = slots.default) == null ? void 0 : _a.call(slots));
      };
    }
  });
  exports["default"] = Row;
  exports.rowProps = rowProps;
})(row$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var row2 = row$1;
  const ElRow = withInstall2.withInstall(row2["default"]);
  exports.rowProps = row2.rowProps;
  exports.ElRow = ElRow;
  exports["default"] = ElRow;
})(row$2);
var selectV2 = {};
var select = {};
var select_vue_vue_type_script_lang = {};
var selectDropdown = {};
var selectDropdown_vue_vue_type_script_lang = {};
var virtualList = {};
var fixedSizeList$2 = {};
var buildList = {};
var useCache$1 = {};
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear2() {
    cache2 = null;
  };
  return memoized;
}
var memoizeOne_esm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": memoizeOne
});
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(memoizeOne_esm);
Object.defineProperty(useCache$1, "__esModule", { value: true });
var vue$P = require$$0$1;
var memo = memoize_1;
var memoOne = require$$2;
function _interopDefaultLegacy$2(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
var memo__default = /* @__PURE__ */ _interopDefaultLegacy$2(memo);
var memoOne__default = /* @__PURE__ */ _interopDefaultLegacy$2(memoOne);
const useCache = () => {
  const vm = vue$P.getCurrentInstance();
  const props2 = vm.proxy.$props;
  return vue$P.computed(() => {
    const _getItemStyleCache = (_2, __, ___) => ({});
    return props2.perfMode ? memo__default["default"](_getItemStyleCache) : memoOne__default["default"](_getItemStyleCache);
  });
};
useCache$1.useCache = useCache;
var useWheel = {};
var raf$1 = {};
Object.defineProperty(raf$1, "__esModule", { value: true });
var isServer = isServer$8;
raf$1.rAF = (fn3) => setTimeout(fn3, 16);
raf$1.cAF = (handle) => clearTimeout(handle);
if (!isServer["default"]) {
  raf$1.rAF = (fn3) => window.requestAnimationFrame(fn3);
  raf$1.cAF = (handle) => window.cancelAnimationFrame(handle);
}
var utils$f = {};
var defaults$c = {};
Object.defineProperty(defaults$c, "__esModule", { value: true });
const DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
const ITEM_RENDER_EVT = "item-rendered";
const SCROLL_EVT = "scroll";
const FORWARD = "forward";
const BACKWARD = "backward";
const AUTO_ALIGNMENT = "auto";
const SMART_ALIGNMENT = "smart";
const START_ALIGNMENT = "start";
const CENTERED_ALIGNMENT = "center";
const END_ALIGNMENT = "end";
const HORIZONTAL = "horizontal";
const VERTICAL = "vertical";
const LTR = "ltr";
const RTL = "rtl";
const RTL_OFFSET_NAG = "negative";
const RTL_OFFSET_POS_ASC = "positive-ascending";
const RTL_OFFSET_POS_DESC = "positive-descending";
const PageKey = {
  [HORIZONTAL]: "pageX",
  [VERTICAL]: "pageY"
};
const ScrollbarSizeKey = {
  [HORIZONTAL]: "height",
  [VERTICAL]: "width"
};
const ScrollbarDirKey = {
  [HORIZONTAL]: "left",
  [VERTICAL]: "top"
};
const SCROLLBAR_MIN_SIZE = 20;
defaults$c.AUTO_ALIGNMENT = AUTO_ALIGNMENT;
defaults$c.BACKWARD = BACKWARD;
defaults$c.CENTERED_ALIGNMENT = CENTERED_ALIGNMENT;
defaults$c.DEFAULT_DYNAMIC_LIST_ITEM_SIZE = DEFAULT_DYNAMIC_LIST_ITEM_SIZE;
defaults$c.END_ALIGNMENT = END_ALIGNMENT;
defaults$c.FORWARD = FORWARD;
defaults$c.HORIZONTAL = HORIZONTAL;
defaults$c.ITEM_RENDER_EVT = ITEM_RENDER_EVT;
defaults$c.LTR = LTR;
defaults$c.PageKey = PageKey;
defaults$c.RTL = RTL;
defaults$c.RTL_OFFSET_NAG = RTL_OFFSET_NAG;
defaults$c.RTL_OFFSET_POS_ASC = RTL_OFFSET_POS_ASC;
defaults$c.RTL_OFFSET_POS_DESC = RTL_OFFSET_POS_DESC;
defaults$c.SCROLLBAR_MIN_SIZE = SCROLLBAR_MIN_SIZE;
defaults$c.SCROLL_EVT = SCROLL_EVT;
defaults$c.SMART_ALIGNMENT = SMART_ALIGNMENT;
defaults$c.START_ALIGNMENT = START_ALIGNMENT;
defaults$c.ScrollbarDirKey = ScrollbarDirKey;
defaults$c.ScrollbarSizeKey = ScrollbarSizeKey;
defaults$c.VERTICAL = VERTICAL;
Object.defineProperty(utils$f, "__esModule", { value: true });
var shared$6 = require$$1$1;
var defaults$b = defaults$c;
const getScrollDir = (prev2, cur) => prev2 < cur ? defaults$b.FORWARD : defaults$b.BACKWARD;
const isHorizontal = (dir) => dir === defaults$b.LTR || dir === defaults$b.RTL || dir === defaults$b.HORIZONTAL;
const isRTL = (dir) => dir === defaults$b.RTL;
let cachedRTLResult = null;
function getRTLOffsetType(recalculate = false) {
  if (cachedRTLResult === null || recalculate) {
    const outerDiv = document.createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = document.createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = defaults$b.RTL_OFFSET_POS_DESC;
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = defaults$b.RTL_OFFSET_NAG;
      } else {
        cachedRTLResult = defaults$b.RTL_OFFSET_POS_ASC;
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
const getRelativePos = (e, layout2) => {
  return "touches" in e ? e.touches[0][defaults$b.PageKey[layout2]] : e[defaults$b.PageKey[layout2]];
};
function renderThumbStyle({ move, size: size2, bar: bar3 }, layout2) {
  const style = {};
  const translate2 = `translate${bar3.axis}(${move}px)`;
  style[bar3.size] = size2;
  style.transform = translate2;
  style.msTransform = translate2;
  style.webkitTransform = translate2;
  if (layout2 === "horizontal") {
    style.height = "100%";
  } else {
    style.width = "100%";
  }
  return style;
}
const isFF = typeof navigator !== "undefined" && shared$6.isObject(navigator) && /Firefox/i.test(navigator.userAgent);
utils$f.getRTLOffsetType = getRTLOffsetType;
utils$f.getRelativePos = getRelativePos;
utils$f.getScrollDir = getScrollDir;
utils$f.isFF = isFF;
utils$f.isHorizontal = isHorizontal;
utils$f.isRTL = isRTL;
utils$f.renderThumbStyle = renderThumbStyle;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var raf2 = raf$1;
  var utils2 = utils$f;
  var defaults2 = defaults$c;
  const LayoutKeys = {
    [defaults2.HORIZONTAL]: "deltaX",
    [defaults2.VERTICAL]: "deltaY"
  };
  const useWheel2 = ({ atEndEdge, atStartEdge, layout: layout2 }, onWheelDelta) => {
    let frameHandle;
    let offset2 = 0;
    const hasReachedEdge = (offset22) => {
      const edgeReached = offset22 < 0 && atStartEdge.value || offset22 > 0 && atEndEdge.value;
      return edgeReached;
    };
    const onWheel = (e) => {
      raf2.cAF(frameHandle);
      const newOffset = e[LayoutKeys[layout2.value]];
      if (hasReachedEdge(offset2) && hasReachedEdge(offset2 + newOffset))
        return;
      offset2 += newOffset;
      if (!utils2.isFF) {
        e.preventDefault();
      }
      frameHandle = raf2.rAF(() => {
        onWheelDelta(offset2);
        offset2 = 0;
      });
    };
    return {
      hasReachedEdge,
      onWheel
    };
  };
  exports["default"] = useWheel2;
})(useWheel);
var scrollbar$1 = {};
var props$c = {};
Object.defineProperty(props$c, "__esModule", { value: true });
var props$b = props$N;
var defaults$a = defaults$c;
const itemSize = props$b.buildProp({
  type: props$b.definePropType([Number, Function]),
  required: true
});
const estimatedItemSize = props$b.buildProp({
  type: Number
});
const cache$1 = props$b.buildProp({
  type: Number,
  default: 2
});
const direction = props$b.buildProp({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
});
const initScrollOffset = props$b.buildProp({
  type: Number,
  default: 0
});
const total = props$b.buildProp({
  type: Number,
  required: true
});
const layout = props$b.buildProp({
  type: String,
  values: ["horizontal", "vertical"],
  default: defaults$a.VERTICAL
});
const virtualizedProps = props$b.buildProps({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: props$b.definePropType([String, Object]),
    default: "div"
  },
  data: {
    type: props$b.definePropType(Array),
    default: () => props$b.mutable([])
  },
  direction,
  height: {
    type: [String, Number],
    required: true
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  style: {
    type: props$b.definePropType([Object, String, Array])
  },
  useIsScrolling: {
    type: Boolean,
    default: false
  },
  width: {
    type: [Number, String],
    required: false
  },
  perfMode: {
    type: Boolean,
    default: true
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: false
  }
});
const virtualizedListProps = props$b.buildProps(__spreadValues({
  cache: cache$1,
  estimatedItemSize,
  layout,
  initScrollOffset,
  total,
  itemSize
}, virtualizedProps));
const virtualizedGridProps = props$b.buildProps(__spreadValues({
  columnCache: cache$1,
  columnWidth: itemSize,
  estimatedColumnWidth: estimatedItemSize,
  estimatedRowHeight: estimatedItemSize,
  initScrollLeft: initScrollOffset,
  initScrollTop: initScrollOffset,
  rowCache: cache$1,
  rowHeight: itemSize,
  totalColumn: total,
  totalRow: total
}, virtualizedProps));
const virtualizedScrollbarProps = props$b.buildProps({
  layout,
  total,
  ratio: {
    type: Number,
    required: true
  },
  clientSize: {
    type: Number,
    required: true
  },
  scrollFrom: {
    type: Number,
    required: true
  },
  visible: Boolean
});
props$c.virtualizedGridProps = virtualizedGridProps;
props$c.virtualizedListProps = virtualizedListProps;
props$c.virtualizedProps = virtualizedProps;
props$c.virtualizedScrollbarProps = virtualizedScrollbarProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var raf2 = raf$1;
  var isServer2 = isServer$8;
  var defaults2 = defaults$c;
  var props2 = props$c;
  var utils2 = utils$f;
  var util2 = util$g;
  const ScrollBar = vue2.defineComponent({
    name: "ElVirtualScrollBar",
    props: props2.virtualizedScrollbarProps,
    emits: ["scroll", "start-move", "stop-move"],
    setup(props3, { emit }) {
      const GAP = 4;
      const trackRef = vue2.ref();
      const thumbRef = vue2.ref();
      let frameHandle = null;
      let onselectstartStore = null;
      const state = vue2.reactive({
        isDragging: false,
        traveled: 0
      });
      const bar3 = vue2.computed(() => util2.BAR_MAP[props3.layout]);
      const trackSize = vue2.computed(() => props3.clientSize - GAP);
      const trackStyle = vue2.computed(() => ({
        position: "absolute",
        width: defaults2.HORIZONTAL === props3.layout ? `${trackSize.value}px` : "6px",
        height: defaults2.HORIZONTAL === props3.layout ? "6px" : `${trackSize.value}px`,
        [defaults2.ScrollbarDirKey[props3.layout]]: "2px",
        right: "2px",
        bottom: "2px",
        borderRadius: "4px"
      }));
      const thumbSize = vue2.computed(() => {
        const ratio = props3.ratio;
        const clientSize = props3.clientSize;
        if (ratio >= 100) {
          return Number.POSITIVE_INFINITY;
        }
        if (ratio >= 50) {
          return ratio * clientSize / 100;
        }
        const SCROLLBAR_MAX_SIZE = clientSize / 3;
        return Math.floor(Math.min(Math.max(ratio * clientSize, defaults2.SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
      });
      const thumbStyle = vue2.computed(() => {
        if (!Number.isFinite(thumbSize.value)) {
          return {
            display: "none"
          };
        }
        const thumb = `${thumbSize.value}px`;
        const style = utils2.renderThumbStyle({
          bar: bar3.value,
          size: thumb,
          move: state.traveled
        }, props3.layout);
        return style;
      });
      const totalSteps = vue2.computed(() => Math.floor(props3.clientSize - thumbSize.value - GAP));
      const attachEvents = () => {
        dom2.on(window, "mousemove", onMouseMove);
        dom2.on(window, "mouseup", onMouseUp);
        const thumbEl = vue2.unref(thumbRef);
        if (!thumbEl)
          return;
        onselectstartStore = document.onselectstart;
        document.onselectstart = () => false;
        dom2.on(thumbEl, "touchmove", onMouseMove);
        dom2.on(thumbEl, "touchend", onMouseUp);
      };
      const detachEvents = () => {
        dom2.off(window, "mousemove", onMouseMove);
        dom2.off(window, "mouseup", onMouseUp);
        document.onselectstart = onselectstartStore;
        onselectstartStore = null;
        const thumbEl = vue2.unref(thumbRef);
        if (!thumbEl)
          return;
        dom2.off(thumbEl, "touchmove", onMouseMove);
        dom2.off(thumbEl, "touchend", onMouseUp);
      };
      const onThumbMouseDown = (e) => {
        e.stopImmediatePropagation();
        if (e.ctrlKey || [1, 2].includes(e.button)) {
          return;
        }
        state.isDragging = true;
        state[bar3.value.axis] = e.currentTarget[bar3.value.offset] - (e[bar3.value.client] - e.currentTarget.getBoundingClientRect()[bar3.value.direction]);
        emit("start-move");
        attachEvents();
      };
      const onMouseUp = () => {
        state.isDragging = false;
        state[bar3.value.axis] = 0;
        emit("stop-move");
        detachEvents();
      };
      const onMouseMove = (e) => {
        const { isDragging } = state;
        if (!isDragging)
          return;
        if (!thumbRef.value || !trackRef.value)
          return;
        const prevPage = state[bar3.value.axis];
        if (!prevPage)
          return;
        raf2.cAF(frameHandle);
        const offset2 = (trackRef.value.getBoundingClientRect()[bar3.value.direction] - e[bar3.value.client]) * -1;
        const thumbClickPosition = thumbRef.value[bar3.value.offset] - prevPage;
        const distance = offset2 - thumbClickPosition;
        frameHandle = raf2.rAF(() => {
          state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
          emit("scroll", distance, totalSteps.value);
        });
      };
      const clickTrackHandler = (e) => {
        const offset2 = Math.abs(e.target.getBoundingClientRect()[bar3.value.direction] - e[bar3.value.client]);
        const thumbHalf = thumbRef.value[bar3.value.offset] / 2;
        const distance = offset2 - thumbHalf;
        state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
        emit("scroll", distance, totalSteps.value);
      };
      const onScrollbarTouchStart = (e) => e.preventDefault();
      vue2.watch(() => props3.scrollFrom, (v2) => {
        if (state.isDragging)
          return;
        state.traveled = Math.ceil(v2 * totalSteps.value);
      });
      vue2.onMounted(() => {
        if (isServer2["default"])
          return;
        dom2.on(trackRef.value, "touchstart", onScrollbarTouchStart);
        dom2.on(thumbRef.value, "touchstart", onThumbMouseDown);
      });
      vue2.onBeforeUnmount(() => {
        dom2.off(trackRef.value, "touchstart", onScrollbarTouchStart);
        detachEvents();
      });
      return () => {
        return vue2.h("div", {
          role: "presentation",
          ref: trackRef,
          class: "el-virtual-scrollbar",
          style: trackStyle.value,
          onMousedown: vue2.withModifiers(clickTrackHandler, ["stop", "prevent"])
        }, vue2.h("div", {
          ref: thumbRef,
          class: "el-scrollbar__thumb",
          style: thumbStyle.value,
          onMousedown: onThumbMouseDown
        }, []));
      };
    }
  });
  exports["default"] = ScrollBar;
})(scrollbar$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var util2 = util$l;
  var isServer2 = isServer$8;
  var useCache2 = useCache$1;
  var useWheel$1 = useWheel;
  var scrollbar3 = scrollbar$1;
  var utils2 = utils$f;
  var props2 = props$c;
  var defaults2 = defaults$c;
  const createList = ({
    name,
    getOffset,
    getItemSize,
    getItemOffset,
    getEstimatedTotalSize,
    getStartIndexForOffset,
    getStopIndexForStartIndex,
    initCache,
    clearCache,
    validateProps
  }) => {
    return vue2.defineComponent({
      name: name != null ? name : "ElVirtualList",
      props: props2.virtualizedListProps,
      emits: [defaults2.ITEM_RENDER_EVT, defaults2.SCROLL_EVT],
      setup(props3, { emit, expose }) {
        validateProps(props3);
        const instance = vue2.getCurrentInstance();
        const dynamicSizeCache = vue2.ref(initCache(props3, instance));
        const getItemStyleCache = useCache2.useCache();
        const windowRef = vue2.ref();
        const innerRef = vue2.ref();
        const scrollbarRef = vue2.ref();
        const states = vue2.ref({
          isScrolling: false,
          scrollDir: "forward",
          scrollOffset: util2.isNumber(props3.initScrollOffset) ? props3.initScrollOffset : 0,
          updateRequested: false,
          isScrollbarDragging: false,
          scrollbarAlwaysOn: props3.scrollbarAlwaysOn
        });
        const itemsToRender = vue2.computed(() => {
          const { total: total2, cache: cache2 } = props3;
          const { isScrolling, scrollDir, scrollOffset } = vue2.unref(states);
          if (total2 === 0) {
            return [0, 0, 0, 0];
          }
          const startIndex = getStartIndexForOffset(props3, scrollOffset, vue2.unref(dynamicSizeCache));
          const stopIndex = getStopIndexForStartIndex(props3, startIndex, scrollOffset, vue2.unref(dynamicSizeCache));
          const cacheBackward = !isScrolling || scrollDir === defaults2.BACKWARD ? Math.max(1, cache2) : 1;
          const cacheForward = !isScrolling || scrollDir === defaults2.FORWARD ? Math.max(1, cache2) : 1;
          return [
            Math.max(0, startIndex - cacheBackward),
            Math.max(0, Math.min(total2 - 1, stopIndex + cacheForward)),
            startIndex,
            stopIndex
          ];
        });
        const estimatedTotalSize = vue2.computed(() => getEstimatedTotalSize(props3, vue2.unref(dynamicSizeCache)));
        const _isHorizontal = vue2.computed(() => utils2.isHorizontal(props3.layout));
        const windowStyle = vue2.computed(() => [
          {
            position: "relative",
            overflow: "hidden",
            WebkitOverflowScrolling: "touch",
            willChange: "transform"
          },
          {
            direction: props3.direction,
            height: util2.isNumber(props3.height) ? `${props3.height}px` : props3.height,
            width: util2.isNumber(props3.width) ? `${props3.width}px` : props3.width
          },
          props3.style
        ]);
        const innerStyle = vue2.computed(() => {
          const size2 = vue2.unref(estimatedTotalSize);
          const horizontal = vue2.unref(_isHorizontal);
          return {
            height: horizontal ? "100%" : `${size2}px`,
            pointerEvents: vue2.unref(states).isScrolling ? "none" : void 0,
            width: horizontal ? `${size2}px` : "100%"
          };
        });
        const clientSize = vue2.computed(() => _isHorizontal.value ? props3.width : props3.height);
        const { onWheel } = useWheel$1["default"]({
          atStartEdge: vue2.computed(() => states.value.scrollOffset <= 0),
          atEndEdge: vue2.computed(() => states.value.scrollOffset >= estimatedTotalSize.value),
          layout: vue2.computed(() => props3.layout)
        }, (offset2) => {
          var _a, _b;
          (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);
          scrollTo(Math.min(states.value.scrollOffset + offset2, estimatedTotalSize.value - clientSize.value));
        });
        const emitEvents = () => {
          const { total: total2 } = props3;
          if (total2 > 0) {
            const [cacheStart, cacheEnd, visibleStart, visibleEnd] = vue2.unref(itemsToRender);
            emit(defaults2.ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
          }
          const { scrollDir, scrollOffset, updateRequested } = vue2.unref(states);
          emit(defaults2.SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
        };
        const scrollVertically = (e) => {
          const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;
          const _states = vue2.unref(states);
          if (_states.scrollOffset === scrollTop) {
            return;
          }
          const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          states.value = __spreadProps(__spreadValues({}, _states), {
            isScrolling: true,
            scrollDir: utils2.getScrollDir(_states.scrollOffset, scrollOffset),
            scrollOffset,
            updateRequested: false
          });
          vue2.nextTick(resetIsScrolling);
        };
        const scrollHorizontally = (e) => {
          const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;
          const _states = vue2.unref(states);
          if (_states.scrollOffset === scrollLeft) {
            return;
          }
          const { direction: direction2 } = props3;
          let scrollOffset = scrollLeft;
          if (direction2 === defaults2.RTL) {
            switch (utils2.getRTLOffsetType()) {
              case defaults2.RTL_OFFSET_NAG: {
                scrollOffset = -scrollLeft;
                break;
              }
              case defaults2.RTL_OFFSET_POS_DESC: {
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
              }
            }
          }
          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          states.value = __spreadProps(__spreadValues({}, _states), {
            isScrolling: true,
            scrollDir: utils2.getScrollDir(_states.scrollOffset, scrollOffset),
            scrollOffset,
            updateRequested: false
          });
          vue2.nextTick(resetIsScrolling);
        };
        const onScroll = (e) => {
          vue2.unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);
          emitEvents();
        };
        const onScrollbarScroll = (distanceToGo, totalSteps) => {
          const offset2 = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
          scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset2));
        };
        const scrollTo = (offset2) => {
          offset2 = Math.max(offset2, 0);
          if (offset2 === vue2.unref(states).scrollOffset) {
            return;
          }
          states.value = __spreadProps(__spreadValues({}, vue2.unref(states)), {
            scrollOffset: offset2,
            scrollDir: utils2.getScrollDir(vue2.unref(states).scrollOffset, offset2),
            updateRequested: true
          });
          vue2.nextTick(resetIsScrolling);
        };
        const scrollToItem = (idx, alignment = defaults2.AUTO_ALIGNMENT) => {
          const { scrollOffset } = vue2.unref(states);
          idx = Math.max(0, Math.min(idx, props3.total - 1));
          scrollTo(getOffset(props3, idx, alignment, scrollOffset, vue2.unref(dynamicSizeCache)));
        };
        const getItemStyle = (idx) => {
          const { direction: direction2, itemSize: itemSize2, layout: layout2 } = props3;
          const itemStyleCache = getItemStyleCache.value(clearCache && itemSize2, clearCache && layout2, clearCache && direction2);
          let style;
          if (shared2.hasOwn(itemStyleCache, String(idx))) {
            style = itemStyleCache[idx];
          } else {
            const offset2 = getItemOffset(props3, idx, vue2.unref(dynamicSizeCache));
            const size2 = getItemSize(props3, idx, vue2.unref(dynamicSizeCache));
            const horizontal = vue2.unref(_isHorizontal);
            const isRtl = direction2 === defaults2.RTL;
            const offsetHorizontal = horizontal ? offset2 : 0;
            itemStyleCache[idx] = style = {
              position: "absolute",
              left: isRtl ? void 0 : `${offsetHorizontal}px`,
              right: isRtl ? `${offsetHorizontal}px` : void 0,
              top: !horizontal ? `${offset2}px` : 0,
              height: !horizontal ? `${size2}px` : "100%",
              width: horizontal ? `${size2}px` : "100%"
            };
          }
          return style;
        };
        const resetIsScrolling = () => {
          states.value.isScrolling = false;
          vue2.nextTick(() => {
            getItemStyleCache.value(-1, null, null);
          });
        };
        const resetScrollTop = () => {
          const window2 = windowRef.value;
          if (window2) {
            window2.scrollTop = 0;
          }
        };
        vue2.onMounted(() => {
          if (isServer2["default"])
            return;
          const { initScrollOffset: initScrollOffset2 } = props3;
          const windowElement = vue2.unref(windowRef);
          if (util2.isNumber(initScrollOffset2) && windowElement) {
            if (vue2.unref(_isHorizontal)) {
              windowElement.scrollLeft = initScrollOffset2;
            } else {
              windowElement.scrollTop = initScrollOffset2;
            }
          }
          emitEvents();
        });
        vue2.onUpdated(() => {
          const { direction: direction2, layout: layout2 } = props3;
          const { scrollOffset, updateRequested } = vue2.unref(states);
          const windowElement = vue2.unref(windowRef);
          if (updateRequested && windowElement) {
            if (layout2 === defaults2.HORIZONTAL) {
              if (direction2 === defaults2.RTL) {
                switch (utils2.getRTLOffsetType()) {
                  case "negative": {
                    windowElement.scrollLeft = -scrollOffset;
                    break;
                  }
                  case "positive-ascending": {
                    windowElement.scrollLeft = scrollOffset;
                    break;
                  }
                  default: {
                    const { clientWidth, scrollWidth } = windowElement;
                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                    break;
                  }
                }
              } else {
                windowElement.scrollLeft = scrollOffset;
              }
            } else {
              windowElement.scrollTop = scrollOffset;
            }
          }
        });
        const api = {
          clientSize,
          estimatedTotalSize,
          windowStyle,
          windowRef,
          innerRef,
          innerStyle,
          itemsToRender,
          scrollbarRef,
          states,
          getItemStyle,
          onScroll,
          onScrollbarScroll,
          onWheel,
          scrollTo,
          scrollToItem,
          resetScrollTop
        };
        expose({
          windowRef,
          innerRef,
          getItemStyleCache,
          scrollTo,
          scrollToItem,
          resetScrollTop,
          states
        });
        return api;
      },
      render(ctx) {
        var _a;
        const {
          $slots,
          className,
          clientSize,
          containerElement,
          data: data2,
          getItemStyle,
          innerElement,
          itemsToRender,
          innerStyle,
          layout: layout2,
          total: total2,
          onScroll,
          onScrollbarScroll,
          onWheel,
          states,
          useIsScrolling,
          windowStyle
        } = ctx;
        const [start2, end2] = itemsToRender;
        const Container = vue2.resolveDynamicComponent(containerElement);
        const Inner = vue2.resolveDynamicComponent(innerElement);
        const children = [];
        if (total2 > 0) {
          for (let i = start2; i <= end2; i++) {
            children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {
              data: data2,
              key: i,
              index: i,
              isScrolling: useIsScrolling ? states.isScrolling : void 0,
              style: getItemStyle(i)
            }));
          }
        }
        const InnerNode = [
          vue2.h(Inner, {
            style: innerStyle,
            ref: "innerRef"
          }, !shared2.isString(Inner) ? {
            default: () => children
          } : children)
        ];
        const scrollbar$12 = vue2.h(scrollbar3["default"], {
          ref: "scrollbarRef",
          clientSize,
          layout: layout2,
          onScroll: onScrollbarScroll,
          ratio: clientSize * 100 / this.estimatedTotalSize,
          scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
          total: total2
        });
        const listContainer = vue2.h(Container, {
          class: className,
          style: windowStyle,
          onScroll,
          onWheel,
          ref: "windowRef",
          key: 0
        }, !shared2.isString(Container) ? { default: () => [InnerNode] } : [InnerNode]);
        return vue2.h("div", {
          key: 0,
          class: [
            "el-vl__wrapper",
            states.scrollbarAlwaysOn ? "always-on" : ""
          ]
        }, [listContainer, scrollbar$12]);
      }
    });
  };
  exports["default"] = createList;
})(buildList);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var buildList$1 = buildList;
  var utils2 = utils$f;
  var defaults2 = defaults$c;
  const FixedSizeList = buildList$1["default"]({
    name: "ElFixedSizeList",
    getItemOffset: ({ itemSize: itemSize2 }, index2) => index2 * itemSize2,
    getItemSize: ({ itemSize: itemSize2 }) => itemSize2,
    getEstimatedTotalSize: ({ total: total2, itemSize: itemSize2 }) => itemSize2 * total2,
    getOffset: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, index2, alignment, scrollOffset) => {
      const size2 = utils2.isHorizontal(layout2) ? width : height;
      const lastItemOffset = Math.max(0, total2 * itemSize2 - size2);
      const maxOffset = Math.min(lastItemOffset, index2 * itemSize2);
      const minOffset = Math.max(0, (index2 + 1) * itemSize2 - size2);
      if (alignment === defaults2.SMART_ALIGNMENT) {
        if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
          alignment = defaults2.AUTO_ALIGNMENT;
        } else {
          alignment = defaults2.CENTERED_ALIGNMENT;
        }
      }
      switch (alignment) {
        case defaults2.START_ALIGNMENT: {
          return maxOffset;
        }
        case defaults2.END_ALIGNMENT: {
          return minOffset;
        }
        case defaults2.CENTERED_ALIGNMENT: {
          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
          if (middleOffset < Math.ceil(size2 / 2)) {
            return 0;
          } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
            return lastItemOffset;
          } else {
            return middleOffset;
          }
        }
        case defaults2.AUTO_ALIGNMENT:
        default: {
          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
            return scrollOffset;
          } else if (scrollOffset < minOffset) {
            return minOffset;
          } else {
            return maxOffset;
          }
        }
      }
    },
    getStartIndexForOffset: ({ total: total2, itemSize: itemSize2 }, offset2) => Math.max(0, Math.min(total2 - 1, Math.floor(offset2 / itemSize2))),
    getStopIndexForStartIndex: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, startIndex, scrollOffset) => {
      const offset2 = startIndex * itemSize2;
      const size2 = utils2.isHorizontal(layout2) ? width : height;
      const numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize2);
      return Math.max(0, Math.min(total2 - 1, startIndex + numVisibleItems - 1));
    },
    initCache() {
      return void 0;
    },
    clearCache: true,
    validateProps() {
    }
  });
  exports["default"] = FixedSizeList;
})(fixedSizeList$2);
var dynamicSizeList$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var buildList$1 = buildList;
  var utils2 = utils$f;
  var defaults2 = defaults$c;
  const getItemFromCache = (props2, index2, listCache) => {
    const { itemSize: itemSize2 } = props2;
    const { items, lastVisitedIndex } = listCache;
    if (index2 > lastVisitedIndex) {
      let offset2 = 0;
      if (lastVisitedIndex >= 0) {
        const item2 = items[lastVisitedIndex];
        offset2 = item2.offset + item2.size;
      }
      for (let i = lastVisitedIndex + 1; i <= index2; i++) {
        const size2 = itemSize2(i);
        items[i] = {
          offset: offset2,
          size: size2
        };
        offset2 += size2;
      }
      listCache.lastVisitedIndex = index2;
    }
    return items[index2];
  };
  const findItem = (props2, listCache, offset2) => {
    const { items, lastVisitedIndex } = listCache;
    const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
    if (lastVisitedOffset >= offset2) {
      return bs(props2, listCache, 0, lastVisitedIndex, offset2);
    }
    return es2(props2, listCache, Math.max(0, lastVisitedIndex), offset2);
  };
  const bs = (props2, listCache, low, high, offset2) => {
    while (low <= high) {
      const mid = low + Math.floor((high - low) / 2);
      const currentOffset = getItemFromCache(props2, mid, listCache).offset;
      if (currentOffset === offset2) {
        return mid;
      } else if (currentOffset < offset2) {
        low = mid + 1;
      } else if (currentOffset > offset2) {
        high = mid - 1;
      }
    }
    return Math.max(0, low - 1);
  };
  const es2 = (props2, listCache, index2, offset2) => {
    const { total: total2 } = props2;
    let exponent = 1;
    while (index2 < total2 && getItemFromCache(props2, index2, listCache).offset < offset2) {
      index2 += exponent;
      exponent *= 2;
    }
    return bs(props2, listCache, Math.floor(index2 / 2), Math.min(index2, total2 - 1), offset2);
  };
  const getEstimatedTotalSize = ({ total: total2 }, { items, estimatedItemSize: estimatedItemSize2, lastVisitedIndex }) => {
    let totalSizeOfMeasuredItems = 0;
    if (lastVisitedIndex >= total2) {
      lastVisitedIndex = total2 - 1;
    }
    if (lastVisitedIndex >= 0) {
      const item2 = items[lastVisitedIndex];
      totalSizeOfMeasuredItems = item2.offset + item2.size;
    }
    const numUnmeasuredItems = total2 - lastVisitedIndex - 1;
    const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize2;
    return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
  };
  const DynamicSizeList = buildList$1["default"]({
    name: "ElDynamicSizeList",
    getItemOffset: (props2, index2, listCache) => getItemFromCache(props2, index2, listCache).offset,
    getItemSize: (_2, index2, { items }) => items[index2].size,
    getEstimatedTotalSize,
    getOffset: (props2, index2, alignment, scrollOffset, listCache) => {
      const { height, layout: layout2, width } = props2;
      const size2 = utils2.isHorizontal(layout2) ? width : height;
      const item2 = getItemFromCache(props2, index2, listCache);
      const estimatedTotalSize = getEstimatedTotalSize(props2, listCache);
      const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, item2.offset));
      const minOffset = Math.max(0, item2.offset - size2 + item2.size);
      if (alignment === defaults2.SMART_ALIGNMENT) {
        if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
          alignment = defaults2.AUTO_ALIGNMENT;
        } else {
          alignment = defaults2.CENTERED_ALIGNMENT;
        }
      }
      switch (alignment) {
        case defaults2.START_ALIGNMENT: {
          return maxOffset;
        }
        case defaults2.END_ALIGNMENT: {
          return minOffset;
        }
        case defaults2.CENTERED_ALIGNMENT: {
          return Math.round(minOffset + (maxOffset - minOffset) / 2);
        }
        case defaults2.AUTO_ALIGNMENT:
        default: {
          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
            return scrollOffset;
          } else if (scrollOffset < minOffset) {
            return minOffset;
          } else {
            return maxOffset;
          }
        }
      }
    },
    getStartIndexForOffset: (props2, offset2, listCache) => findItem(props2, listCache, offset2),
    getStopIndexForStartIndex: (props2, startIndex, scrollOffset, listCache) => {
      const { height, total: total2, layout: layout2, width } = props2;
      const size2 = utils2.isHorizontal(layout2) ? width : height;
      const item2 = getItemFromCache(props2, startIndex, listCache);
      const maxOffset = scrollOffset + size2;
      let offset2 = item2.offset + item2.size;
      let stopIndex = startIndex;
      while (stopIndex < total2 - 1 && offset2 < maxOffset) {
        stopIndex++;
        offset2 += getItemFromCache(props2, stopIndex, listCache).size;
      }
      return stopIndex;
    },
    initCache({ estimatedItemSize: estimatedItemSize2 = defaults2.DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
      const cache2 = {
        items: {},
        estimatedItemSize: estimatedItemSize2,
        lastVisitedIndex: -1
      };
      cache2.clearCacheAfterIndex = (index2, forceUpdate = true) => {
        var _a, _b;
        cache2.lastVisitedIndex = Math.min(cache2.lastVisitedIndex, index2 - 1);
        (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);
        if (forceUpdate) {
          (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
        }
      };
      return cache2;
    },
    clearCache: false,
    validateProps: ({ itemSize: itemSize2 }) => {
    }
  });
  exports["default"] = DynamicSizeList;
})(dynamicSizeList$2);
var fixedSizeGrid$2 = {};
var buildGrid = {};
var useGridWheel$1 = {};
Object.defineProperty(useGridWheel$1, "__esModule", { value: true });
var raf = raf$1;
var utils$e = utils$f;
const useGridWheel = ({ atXEndEdge, atXStartEdge, atYEndEdge, atYStartEdge }, onWheelDelta) => {
  let frameHandle = null;
  let xOffset = 0;
  let yOffset = 0;
  const hasReachedEdge = (x2, y) => {
    const xEdgeReached = x2 < 0 && atXStartEdge.value || x2 > 0 && atXEndEdge.value;
    const yEdgeReached = y < 0 && atYStartEdge.value || y > 0 && atYEndEdge.value;
    return xEdgeReached && yEdgeReached;
  };
  const onWheel = (e) => {
    raf.cAF(frameHandle);
    const x2 = e.deltaX;
    const y = e.deltaY;
    if (hasReachedEdge(xOffset, yOffset) && hasReachedEdge(xOffset + x2, yOffset + y))
      return;
    xOffset += x2;
    yOffset += y;
    if (!utils$e.isFF) {
      e.preventDefault();
    }
    frameHandle = raf.rAF(() => {
      onWheelDelta(xOffset, yOffset);
      xOffset = 0;
      yOffset = 0;
    });
  };
  return {
    hasReachedEdge,
    onWheel
  };
};
useGridWheel$1.useGridWheel = useGridWheel;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var util2 = util$l;
  var isServer2 = isServer$8;
  var scrollbarWidth2 = scrollbarWidth$1;
  var scrollbar3 = scrollbar$1;
  var useGridWheel2 = useGridWheel$1;
  var useCache2 = useCache$1;
  var props2 = props$c;
  var utils2 = utils$f;
  var defaults2 = defaults$c;
  const createGrid = ({
    name,
    clearCache,
    getColumnPosition,
    getColumnStartIndexForOffset,
    getColumnStopIndexForStartIndex,
    getEstimatedTotalHeight,
    getEstimatedTotalWidth,
    getColumnOffset,
    getRowOffset,
    getRowPosition,
    getRowStartIndexForOffset,
    getRowStopIndexForStartIndex,
    initCache,
    validateProps
  }) => {
    return vue2.defineComponent({
      name: name != null ? name : "ElVirtualList",
      props: props2.virtualizedGridProps,
      emits: [defaults2.ITEM_RENDER_EVT, defaults2.SCROLL_EVT],
      setup(props3, { emit, expose, slots }) {
        validateProps(props3);
        const instance = vue2.getCurrentInstance();
        const cache2 = vue2.ref(initCache(props3, instance));
        const windowRef = vue2.ref();
        const hScrollbar = vue2.ref();
        const vScrollbar = vue2.ref();
        const innerRef = vue2.ref(null);
        const states = vue2.ref({
          isScrolling: false,
          scrollLeft: util2.isNumber(props3.initScrollLeft) ? props3.initScrollLeft : 0,
          scrollTop: util2.isNumber(props3.initScrollTop) ? props3.initScrollTop : 0,
          updateRequested: false,
          xAxisScrollDir: defaults2.FORWARD,
          yAxisScrollDir: defaults2.FORWARD
        });
        const getItemStyleCache = useCache2.useCache();
        const parsedHeight = vue2.computed(() => parseInt(`${props3.height}`, 10));
        const parsedWidth = vue2.computed(() => parseInt(`${props3.width}`, 10));
        const columnsToRender = vue2.computed(() => {
          const { totalColumn, totalRow, columnCache } = props3;
          const { isScrolling, xAxisScrollDir, scrollLeft } = vue2.unref(states);
          if (totalColumn === 0 || totalRow === 0) {
            return [0, 0, 0, 0];
          }
          const startIndex = getColumnStartIndexForOffset(props3, scrollLeft, vue2.unref(cache2));
          const stopIndex = getColumnStopIndexForStartIndex(props3, startIndex, scrollLeft, vue2.unref(cache2));
          const cacheBackward = !isScrolling || xAxisScrollDir === defaults2.BACKWARD ? Math.max(1, columnCache) : 1;
          const cacheForward = !isScrolling || xAxisScrollDir === defaults2.FORWARD ? Math.max(1, columnCache) : 1;
          return [
            Math.max(0, startIndex - cacheBackward),
            Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),
            startIndex,
            stopIndex
          ];
        });
        const rowsToRender = vue2.computed(() => {
          const { totalColumn, totalRow, rowCache } = props3;
          const { isScrolling, yAxisScrollDir, scrollTop } = vue2.unref(states);
          if (totalColumn === 0 || totalRow === 0) {
            return [0, 0, 0, 0];
          }
          const startIndex = getRowStartIndexForOffset(props3, scrollTop, vue2.unref(cache2));
          const stopIndex = getRowStopIndexForStartIndex(props3, startIndex, scrollTop, vue2.unref(cache2));
          const cacheBackward = !isScrolling || yAxisScrollDir === defaults2.BACKWARD ? Math.max(1, rowCache) : 1;
          const cacheForward = !isScrolling || yAxisScrollDir === defaults2.FORWARD ? Math.max(1, rowCache) : 1;
          return [
            Math.max(0, startIndex - cacheBackward),
            Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),
            startIndex,
            stopIndex
          ];
        });
        const estimatedTotalHeight = vue2.computed(() => getEstimatedTotalHeight(props3, vue2.unref(cache2)));
        const estimatedTotalWidth = vue2.computed(() => getEstimatedTotalWidth(props3, vue2.unref(cache2)));
        const windowStyle = vue2.computed(() => {
          var _a;
          return [
            {
              position: "relative",
              overflow: "hidden",
              WebkitOverflowScrolling: "touch",
              willChange: "transform"
            },
            {
              direction: props3.direction,
              height: util2.isNumber(props3.height) ? `${props3.height}px` : props3.height,
              width: util2.isNumber(props3.width) ? `${props3.width}px` : props3.width
            },
            (_a = props3.style) != null ? _a : {}
          ];
        });
        const innerStyle = vue2.computed(() => {
          const width = `${vue2.unref(estimatedTotalWidth)}px`;
          const height = `${vue2.unref(estimatedTotalHeight)}px`;
          return {
            height,
            pointerEvents: vue2.unref(states).isScrolling ? "none" : void 0,
            width
          };
        });
        const emitEvents = () => {
          const { totalColumn, totalRow } = props3;
          if (totalColumn > 0 && totalRow > 0) {
            const [
              columnCacheStart,
              columnCacheEnd,
              columnVisibleStart,
              columnVisibleEnd
            ] = vue2.unref(columnsToRender);
            const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = vue2.unref(rowsToRender);
            emit(defaults2.ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);
          }
          const {
            scrollLeft,
            scrollTop,
            updateRequested,
            xAxisScrollDir,
            yAxisScrollDir
          } = vue2.unref(states);
          emit(defaults2.SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);
        };
        const onScroll = (e) => {
          const {
            clientHeight,
            clientWidth,
            scrollHeight,
            scrollLeft,
            scrollTop,
            scrollWidth
          } = e.currentTarget;
          const _states = vue2.unref(states);
          if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {
            return;
          }
          let _scrollLeft = scrollLeft;
          if (utils2.isRTL(props3.direction)) {
            switch (utils2.getRTLOffsetType()) {
              case defaults2.RTL_OFFSET_NAG:
                _scrollLeft = -scrollLeft;
                break;
              case defaults2.RTL_OFFSET_POS_DESC:
                _scrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          states.value = __spreadProps(__spreadValues({}, _states), {
            isScrolling: true,
            scrollLeft: _scrollLeft,
            scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),
            updateRequested: false,
            xAxisScrollDir: utils2.getScrollDir(_states.scrollLeft, _scrollLeft),
            yAxisScrollDir: utils2.getScrollDir(_states.scrollTop, scrollTop)
          });
          vue2.nextTick(resetIsScrolling);
          emitEvents();
        };
        const onVerticalScroll = (distance, totalSteps) => {
          const height = vue2.unref(parsedHeight);
          const offset2 = (estimatedTotalHeight.value - height) / totalSteps * distance;
          scrollTo({
            scrollTop: Math.min(estimatedTotalHeight.value - height, offset2)
          });
        };
        const onHorizontalScroll = (distance, totalSteps) => {
          const width = vue2.unref(parsedWidth);
          const offset2 = (estimatedTotalWidth.value - width) / totalSteps * distance;
          scrollTo({
            scrollLeft: Math.min(estimatedTotalWidth.value - width, offset2)
          });
        };
        const { onWheel } = useGridWheel2.useGridWheel({
          atXStartEdge: vue2.computed(() => states.value.scrollLeft <= 0),
          atXEndEdge: vue2.computed(() => states.value.scrollLeft >= estimatedTotalWidth.value),
          atYStartEdge: vue2.computed(() => states.value.scrollTop <= 0),
          atYEndEdge: vue2.computed(() => states.value.scrollTop >= estimatedTotalHeight.value)
        }, (x2, y) => {
          var _a, _b, _c, _d;
          (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);
          (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);
          const width = vue2.unref(parsedWidth);
          const height = vue2.unref(parsedHeight);
          scrollTo({
            scrollLeft: Math.min(states.value.scrollLeft + x2, estimatedTotalWidth.value - width),
            scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)
          });
        });
        const scrollTo = ({
          scrollLeft = states.value.scrollLeft,
          scrollTop = states.value.scrollTop
        }) => {
          scrollLeft = Math.max(scrollLeft, 0);
          scrollTop = Math.max(scrollTop, 0);
          const _states = vue2.unref(states);
          if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {
            return;
          }
          states.value = __spreadProps(__spreadValues({}, _states), {
            xAxisScrollDir: utils2.getScrollDir(_states.scrollLeft, scrollLeft),
            yAxisScrollDir: utils2.getScrollDir(_states.scrollTop, scrollTop),
            scrollLeft,
            scrollTop,
            updateRequested: true
          });
          vue2.nextTick(resetIsScrolling);
        };
        const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = defaults2.AUTO_ALIGNMENT) => {
          const _states = vue2.unref(states);
          columnIdx = Math.max(0, Math.min(columnIdx, props3.totalColumn - 1));
          rowIndex = Math.max(0, Math.min(rowIndex, props3.totalRow - 1));
          const scrollBarWidth = scrollbarWidth2["default"]();
          const _cache = vue2.unref(cache2);
          const estimatedHeight = getEstimatedTotalHeight(props3, _cache);
          const estimatedWidth = getEstimatedTotalWidth(props3, _cache);
          scrollTo({
            scrollLeft: getColumnOffset(props3, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props3.width ? scrollBarWidth : 0),
            scrollTop: getRowOffset(props3, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props3.height ? scrollBarWidth : 0)
          });
        };
        const getItemStyle = (rowIndex, columnIndex) => {
          const { columnWidth, direction: direction2, rowHeight } = props3;
          const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction2);
          const key2 = `${rowIndex},${columnIndex}`;
          if (shared2.hasOwn(itemStyleCache, key2)) {
            return itemStyleCache[key2];
          } else {
            const [, left2] = getColumnPosition(props3, columnIndex, vue2.unref(cache2));
            const _cache = vue2.unref(cache2);
            const rtl = utils2.isRTL(direction2);
            const [height, top2] = getRowPosition(props3, rowIndex, _cache);
            const [width] = getColumnPosition(props3, columnIndex, _cache);
            itemStyleCache[key2] = {
              position: "absolute",
              left: rtl ? void 0 : `${left2}px`,
              right: rtl ? `${left2}px` : void 0,
              top: `${top2}px`,
              height: `${height}px`,
              width: `${width}px`
            };
            return itemStyleCache[key2];
          }
        };
        const resetIsScrolling = () => {
          states.value.isScrolling = false;
          vue2.nextTick(() => {
            getItemStyleCache.value(-1, null, null);
          });
        };
        vue2.onMounted(() => {
          if (isServer2["default"])
            return;
          const { initScrollLeft, initScrollTop } = props3;
          const windowElement = vue2.unref(windowRef);
          if (windowElement) {
            if (util2.isNumber(initScrollLeft)) {
              windowElement.scrollLeft = initScrollLeft;
            }
            if (util2.isNumber(initScrollTop)) {
              windowElement.scrollTop = initScrollTop;
            }
          }
          emitEvents();
        });
        vue2.onUpdated(() => {
          const { direction: direction2 } = props3;
          const { scrollLeft, scrollTop, updateRequested } = vue2.unref(states);
          const windowElement = vue2.unref(windowRef);
          if (updateRequested && windowElement) {
            if (direction2 === defaults2.RTL) {
              switch (utils2.getRTLOffsetType()) {
                case defaults2.RTL_OFFSET_NAG: {
                  windowElement.scrollLeft = -scrollLeft;
                  break;
                }
                case defaults2.RTL_OFFSET_POS_ASC: {
                  windowElement.scrollLeft = scrollLeft;
                  break;
                }
                default: {
                  const { clientWidth, scrollWidth } = windowElement;
                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;
                  break;
                }
              }
            } else {
              windowElement.scrollLeft = Math.max(0, scrollLeft);
            }
            windowElement.scrollTop = Math.max(0, scrollTop);
          }
        });
        expose({
          windowRef,
          innerRef,
          getItemStyleCache,
          scrollTo,
          scrollToItem,
          states
        });
        const renderScrollbars = () => {
          const { totalColumn, totalRow } = props3;
          const width = vue2.unref(parsedWidth);
          const height = vue2.unref(parsedHeight);
          const estimatedWidth = vue2.unref(estimatedTotalWidth);
          const estimatedHeight = vue2.unref(estimatedTotalHeight);
          const { scrollLeft, scrollTop } = vue2.unref(states);
          const horizontalScrollbar = vue2.h(scrollbar3["default"], {
            ref: hScrollbar,
            clientSize: width,
            layout: "horizontal",
            onScroll: onHorizontalScroll,
            ratio: width * 100 / estimatedWidth,
            scrollFrom: scrollLeft / (estimatedWidth - width),
            total: totalRow,
            visible: true
          });
          const verticalScrollbar = vue2.h(scrollbar3["default"], {
            ref: vScrollbar,
            clientSize: height,
            layout: "vertical",
            onScroll: onVerticalScroll,
            ratio: height * 100 / estimatedHeight,
            scrollFrom: scrollTop / (estimatedHeight - height),
            total: totalColumn,
            visible: true
          });
          return {
            horizontalScrollbar,
            verticalScrollbar
          };
        };
        const renderItems = () => {
          var _a;
          const [columnStart, columnEnd] = vue2.unref(columnsToRender);
          const [rowStart, rowEnd] = vue2.unref(rowsToRender);
          const { data: data2, totalColumn, totalRow, useIsScrolling } = props3;
          const children = [];
          if (totalRow > 0 && totalColumn > 0) {
            for (let row2 = rowStart; row2 <= rowEnd; row2++) {
              for (let column = columnStart; column <= columnEnd; column++) {
                children.push((_a = slots.default) == null ? void 0 : _a.call(slots, {
                  columnIndex: column,
                  data: data2,
                  key: column,
                  isScrolling: useIsScrolling ? vue2.unref(states).isScrolling : void 0,
                  style: getItemStyle(row2, column),
                  rowIndex: row2
                }));
              }
            }
          }
          return children;
        };
        const renderInner = () => {
          const Inner = vue2.resolveDynamicComponent(props3.innerElement);
          const children = renderItems();
          return [
            vue2.h(Inner, {
              style: vue2.unref(innerStyle),
              ref: innerRef
            }, !shared2.isString(Inner) ? {
              default: () => children
            } : children)
          ];
        };
        const renderWindow = () => {
          const Container = vue2.resolveDynamicComponent(props3.containerElement);
          const { horizontalScrollbar, verticalScrollbar } = renderScrollbars();
          const Inner = renderInner();
          return vue2.h("div", {
            key: 0,
            class: "el-vg__wrapper"
          }, [
            vue2.h(Container, {
              class: props3.className,
              style: vue2.unref(windowStyle),
              onScroll,
              onWheel,
              ref: windowRef
            }, !shared2.isString(Container) ? { default: () => Inner } : Inner),
            horizontalScrollbar,
            verticalScrollbar
          ]);
        };
        return renderWindow;
      }
    });
  };
  exports["default"] = createGrid;
})(buildGrid);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var buildGrid$1 = buildGrid;
  var defaults2 = defaults$c;
  const FixedSizeGrid = buildGrid$1["default"]({
    name: "ElFixedSizeGrid",
    getColumnPosition: ({ columnWidth }, index2) => [
      columnWidth,
      index2 * columnWidth
    ],
    getRowPosition: ({ rowHeight }, index2) => [
      rowHeight,
      index2 * rowHeight
    ],
    getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,
    getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,
    getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _2, scrollBarWidth) => {
      width = Number(width);
      const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);
      const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
      const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);
      if (alignment === "smart") {
        if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
          alignment = defaults2.AUTO_ALIGNMENT;
        } else {
          alignment = defaults2.CENTERED_ALIGNMENT;
        }
      }
      switch (alignment) {
        case defaults2.START_ALIGNMENT:
          return maxOffset;
        case defaults2.END_ALIGNMENT:
          return minOffset;
        case defaults2.CENTERED_ALIGNMENT: {
          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
          if (middleOffset < Math.ceil(width / 2)) {
            return 0;
          } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
            return lastColumnOffset;
          } else {
            return middleOffset;
          }
        }
        case defaults2.AUTO_ALIGNMENT:
        default:
          if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
            return scrollLeft;
          } else if (minOffset > maxOffset) {
            return minOffset;
          } else if (scrollLeft < minOffset) {
            return minOffset;
          } else {
            return maxOffset;
          }
      }
    },
    getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _2, scrollBarWidth) => {
      height = Number(height);
      const lastRowOffset = Math.max(0, totalRow * rowHeight - height);
      const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
      const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);
      if (align === defaults2.SMART_ALIGNMENT) {
        if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
          align = defaults2.AUTO_ALIGNMENT;
        } else {
          align = defaults2.CENTERED_ALIGNMENT;
        }
      }
      switch (align) {
        case defaults2.START_ALIGNMENT:
          return maxOffset;
        case defaults2.END_ALIGNMENT:
          return minOffset;
        case defaults2.CENTERED_ALIGNMENT: {
          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
          if (middleOffset < Math.ceil(height / 2)) {
            return 0;
          } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
            return lastRowOffset;
          } else {
            return middleOffset;
          }
        }
        case defaults2.AUTO_ALIGNMENT:
        default:
          if (scrollTop >= minOffset && scrollTop <= maxOffset) {
            return scrollTop;
          } else if (minOffset > maxOffset) {
            return minOffset;
          } else if (scrollTop < minOffset) {
            return minOffset;
          } else {
            return maxOffset;
          }
      }
    },
    getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),
    getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {
      const left2 = startIndex * columnWidth;
      const visibleColumnsCount = Math.ceil((width + scrollLeft - left2) / columnWidth);
      return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));
    },
    getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),
    getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {
      const top2 = startIndex * rowHeight;
      const numVisibleRows = Math.ceil((height + scrollTop - top2) / rowHeight);
      return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));
    },
    initCache: () => void 0,
    clearCache: true,
    validateProps: ({ columnWidth, rowHeight }) => {
    }
  });
  exports["default"] = FixedSizeGrid;
})(fixedSizeGrid$2);
var dynamicSizeGrid$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var buildGrid$1 = buildGrid;
  var defaults2 = defaults$c;
  const { max: max2, min: min2, floor } = Math;
  const ACCESS_SIZER_KEY_MAP = {
    column: "columnWidth",
    row: "rowHeight"
  };
  const ACCESS_LAST_VISITED_KEY_MAP = {
    column: "lastVisitedColumnIndex",
    row: "lastVisitedRowIndex"
  };
  const getItemFromCache = (props2, index2, gridCache, type4) => {
    const [cachedItems, sizer, lastVisited] = [
      gridCache[type4],
      props2[ACCESS_SIZER_KEY_MAP[type4]],
      gridCache[ACCESS_LAST_VISITED_KEY_MAP[type4]]
    ];
    if (index2 > lastVisited) {
      let offset2 = 0;
      if (lastVisited >= 0) {
        const item2 = cachedItems[lastVisited];
        offset2 = item2.offset + item2.size;
      }
      for (let i = lastVisited + 1; i <= index2; i++) {
        const size2 = sizer(i);
        cachedItems[i] = {
          offset: offset2,
          size: size2
        };
        offset2 += size2;
      }
      gridCache[ACCESS_LAST_VISITED_KEY_MAP[type4]] = index2;
    }
    return cachedItems[index2];
  };
  const bs = (props2, gridCache, low, high, offset2, type4) => {
    while (low <= high) {
      const mid = low + floor((high - low) / 2);
      const currentOffset = getItemFromCache(props2, mid, gridCache, type4).offset;
      if (currentOffset === offset2) {
        return mid;
      } else if (currentOffset < offset2) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return max2(0, low - 1);
  };
  const es2 = (props2, gridCache, idx, offset2, type4) => {
    const total2 = type4 === "column" ? props2.totalColumn : props2.totalRow;
    let exponent = 1;
    while (idx < total2 && getItemFromCache(props2, idx, gridCache, type4).offset < offset2) {
      idx += exponent;
      exponent *= 2;
    }
    return bs(props2, gridCache, floor(idx / 2), min2(idx, total2 - 1), offset2, type4);
  };
  const findItem = (props2, gridCache, offset2, type4) => {
    const [cache2, lastVisitedIndex] = [
      gridCache[type4],
      gridCache[ACCESS_LAST_VISITED_KEY_MAP[type4]]
    ];
    const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache2[lastVisitedIndex].offset : 0;
    if (lastVisitedItemOffset >= offset2) {
      return bs(props2, gridCache, 0, lastVisitedIndex, offset2, type4);
    }
    return es2(props2, gridCache, max2(0, lastVisitedIndex), offset2, type4);
  };
  const getEstimatedTotalHeight = ({ totalRow }, { estimatedRowHeight, lastVisitedRowIndex, row: row2 }) => {
    let sizeOfVisitedRows = 0;
    if (lastVisitedRowIndex >= totalRow) {
      lastVisitedRowIndex = totalRow - 1;
    }
    if (lastVisitedRowIndex >= 0) {
      const item2 = row2[lastVisitedRowIndex];
      sizeOfVisitedRows = item2.offset + item2.size;
    }
    const unvisitedItems = totalRow - lastVisitedRowIndex - 1;
    const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;
    return sizeOfVisitedRows + sizeOfUnvisitedItems;
  };
  const getEstimatedTotalWidth = ({ totalColumn }, { column, estimatedColumnWidth, lastVisitedColumnIndex }) => {
    let sizeOfVisitedColumns = 0;
    if (lastVisitedColumnIndex > totalColumn) {
      lastVisitedColumnIndex = totalColumn - 1;
    }
    if (lastVisitedColumnIndex >= 0) {
      const item2 = column[lastVisitedColumnIndex];
      sizeOfVisitedColumns = item2.offset + item2.size;
    }
    const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;
    const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;
    return sizeOfVisitedColumns + sizeOfUnvisitedItems;
  };
  const ACCESS_ESTIMATED_SIZE_KEY_MAP = {
    column: getEstimatedTotalWidth,
    row: getEstimatedTotalHeight
  };
  const getOffset = (props2, index2, alignment, scrollOffset, cache2, type4, scrollBarWidth) => {
    const [size2, estimatedSizeAssociates] = [
      type4 === "row" ? props2.height : props2.width,
      ACCESS_ESTIMATED_SIZE_KEY_MAP[type4]
    ];
    const item2 = getItemFromCache(props2, index2, cache2, type4);
    const estimatedSize = estimatedSizeAssociates(props2, cache2);
    const maxOffset = max2(0, min2(estimatedSize - size2, item2.offset));
    const minOffset = max2(0, item2.offset - size2 + scrollBarWidth + item2.size);
    if (alignment === defaults2.SMART_ALIGNMENT) {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        alignment = defaults2.AUTO_ALIGNMENT;
      } else {
        alignment = defaults2.CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case defaults2.START_ALIGNMENT: {
        return maxOffset;
      }
      case defaults2.END_ALIGNMENT: {
        return minOffset;
      }
      case defaults2.CENTERED_ALIGNMENT: {
        return Math.round(minOffset + (maxOffset - minOffset) / 2);
      }
      case defaults2.AUTO_ALIGNMENT:
      default: {
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
      }
    }
  };
  const FixedSizeGrid = buildGrid$1["default"]({
    name: "ElDynamicSizeGrid",
    getColumnPosition: (props2, idx, cache2) => {
      const item2 = getItemFromCache(props2, idx, cache2, "column");
      return [item2.size, item2.offset];
    },
    getRowPosition: (props2, idx, cache2) => {
      const item2 = getItemFromCache(props2, idx, cache2, "row");
      return [item2.size, item2.offset];
    },
    getColumnOffset: (props2, columnIndex, alignment, scrollLeft, cache2, scrollBarWidth) => getOffset(props2, columnIndex, alignment, scrollLeft, cache2, "column", scrollBarWidth),
    getRowOffset: (props2, rowIndex, alignment, scrollTop, cache2, scrollBarWidth) => getOffset(props2, rowIndex, alignment, scrollTop, cache2, "row", scrollBarWidth),
    getColumnStartIndexForOffset: (props2, scrollLeft, cache2) => findItem(props2, cache2, scrollLeft, "column"),
    getColumnStopIndexForStartIndex: (props2, startIndex, scrollLeft, cache2) => {
      const item2 = getItemFromCache(props2, startIndex, cache2, "column");
      const maxOffset = scrollLeft + props2.width;
      let offset2 = item2.offset + item2.size;
      let stopIndex = startIndex;
      while (stopIndex < props2.totalColumn - 1 && offset2 < maxOffset) {
        stopIndex++;
        offset2 += getItemFromCache(props2, startIndex, cache2, "column").size;
      }
      return stopIndex;
    },
    getEstimatedTotalHeight,
    getEstimatedTotalWidth,
    getRowStartIndexForOffset: (props2, scrollTop, cache2) => findItem(props2, cache2, scrollTop, "row"),
    getRowStopIndexForStartIndex: (props2, startIndex, scrollTop, cache2) => {
      const { totalRow, height } = props2;
      const item2 = getItemFromCache(props2, startIndex, cache2, "row");
      const maxOffset = scrollTop + height;
      let offset2 = item2.size + item2.offset;
      let stopIndex = startIndex;
      while (stopIndex < totalRow - 1 && offset2 < maxOffset) {
        stopIndex++;
        offset2 += getItemFromCache(props2, stopIndex, cache2, "row").size;
      }
      return stopIndex;
    },
    initCache: ({
      estimatedColumnWidth = defaults2.DEFAULT_DYNAMIC_LIST_ITEM_SIZE,
      estimatedRowHeight = defaults2.DEFAULT_DYNAMIC_LIST_ITEM_SIZE
    }) => {
      const cache2 = {
        column: {},
        estimatedColumnWidth,
        estimatedRowHeight,
        lastVisitedColumnIndex: -1,
        lastVisitedRowIndex: -1,
        row: {}
      };
      return cache2;
    },
    clearCache: true,
    validateProps: ({ columnWidth, rowHeight }) => {
    }
  });
  exports["default"] = FixedSizeGrid;
})(dynamicSizeGrid$2);
Object.defineProperty(virtualList, "__esModule", { value: true });
var fixedSizeList$1 = fixedSizeList$2;
var dynamicSizeList$1 = dynamicSizeList$2;
var fixedSizeGrid$1 = fixedSizeGrid$2;
var dynamicSizeGrid$1 = dynamicSizeGrid$2;
var props$a = props$c;
virtualList.FixedSizeList = fixedSizeList$1["default"];
virtualList.DynamicSizeList = dynamicSizeList$1["default"];
virtualList.FixedSizeGrid = fixedSizeGrid$1["default"];
virtualList.DynamicSizeGrid = dynamicSizeGrid$1["default"];
virtualList.virtualizedGridProps = props$a.virtualizedGridProps;
virtualList.virtualizedListProps = props$a.virtualizedListProps;
virtualList.virtualizedProps = props$a.virtualizedProps;
virtualList.virtualizedScrollbarProps = props$a.virtualizedScrollbarProps;
var groupItem = {};
var groupItem_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    props: {
      item: {
        type: Object,
        required: true
      },
      style: Object,
      height: Number
    }
  });
  exports["default"] = script2;
})(groupItem_vue_vue_type_script_lang);
var groupItem_vue_vue_type_template_id_bef7365a_lang = {};
Object.defineProperty(groupItem_vue_vue_type_template_id_bef7365a_lang, "__esModule", { value: true });
var vue$O = require$$0$1;
function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.item.isTitle ? (vue$O.openBlock(), vue$O.createElementBlock("div", {
    key: 0,
    class: "el-select-group__title",
    style: vue$O.normalizeStyle([_ctx.style, { lineHeight: `${_ctx.height}px` }])
  }, vue$O.toDisplayString(_ctx.item.label), 5)) : (vue$O.openBlock(), vue$O.createElementBlock("div", {
    key: 1,
    class: "el-select-group__split",
    style: vue$O.normalizeStyle(_ctx.style)
  }, [
    vue$O.createElementVNode("span", {
      class: "el-select-group__split-dash",
      style: vue$O.normalizeStyle({ top: `${_ctx.height / 2}px` })
    }, null, 4)
  ], 4));
}
groupItem_vue_vue_type_template_id_bef7365a_lang.render = render$t;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var groupItem_vue_vue_type_script_lang$1 = groupItem_vue_vue_type_script_lang;
  var groupItem_vue_vue_type_template_id_bef7365a_lang$1 = groupItem_vue_vue_type_template_id_bef7365a_lang;
  groupItem_vue_vue_type_script_lang$1["default"].render = groupItem_vue_vue_type_template_id_bef7365a_lang$1.render;
  groupItem_vue_vue_type_script_lang$1["default"].__file = "packages/components/select-v2/src/group-item.vue";
  exports["default"] = groupItem_vue_vue_type_script_lang$1["default"];
})(groupItem);
var optionItem = {};
var optionItem_vue_vue_type_script_lang = {};
var useOption$1 = {};
Object.defineProperty(useOption$1, "__esModule", { value: true });
function useOption(props2, { emit }) {
  return {
    hoverItem: () => {
      if (!props2.disabled) {
        emit("hover", props2.index);
      }
    },
    selectOptionClick: () => {
      if (!props2.disabled) {
        emit("select", props2.item, props2.index);
      }
    }
  };
}
useOption$1.useOption = useOption;
var defaults$9 = {};
Object.defineProperty(defaults$9, "__esModule", { value: true });
var validators$2 = validators$6;
var iconsVue$1 = require$$3;
const SelectProps = {
  allowCreate: Boolean,
  autocomplete: {
    type: String,
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: [String, Object],
    default: iconsVue$1.CircleClose
  },
  collapseTags: Boolean,
  defaultFirstOption: Boolean,
  disabled: Boolean,
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: Function,
  height: {
    type: Number,
    default: 170
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  label: String,
  modelValue: [Array, String, Number, Boolean, Object],
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: Function,
  reserveKeyword: Boolean,
  options: {
    type: Array,
    required: true
  },
  placeholder: {
    type: String
  },
  popperAppendToBody: {
    type: Boolean,
    default: true
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  remote: Boolean,
  size: {
    type: String,
    validator: validators$2.isValidComponentSize
  },
  valueKey: {
    type: String,
    default: "value"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: false
  }
};
const OptionProps = {
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: Object,
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
};
defaults$9.OptionProps = OptionProps;
defaults$9.SelectProps = SelectProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var useOption2 = useOption$1;
  var defaults2 = defaults$9;
  var script2 = vue2.defineComponent({
    props: defaults2.OptionProps,
    emits: ["select", "hover"],
    setup(props2, { emit }) {
      const { hoverItem, selectOptionClick } = useOption2.useOption(props2, { emit });
      return {
        hoverItem,
        selectOptionClick
      };
    }
  });
  exports["default"] = script2;
})(optionItem_vue_vue_type_script_lang);
var optionItem_vue_vue_type_template_id_119b30a9_lang = {};
Object.defineProperty(optionItem_vue_vue_type_template_id_119b30a9_lang, "__esModule", { value: true });
var vue$N = require$$0$1;
const _hoisted_1$k = ["aria-selected"];
function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$N.openBlock(), vue$N.createElementBlock("li", {
    "aria-selected": _ctx.selected,
    style: vue$N.normalizeStyle(_ctx.style),
    class: vue$N.normalizeClass({
      "el-select-dropdown__option-item": true,
      "is-selected": _ctx.selected,
      "is-disabled": _ctx.disabled,
      "is-created": _ctx.created,
      hover: _ctx.hovering
    }),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = vue$N.withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [
    vue$N.renderSlot(_ctx.$slots, "default", {
      item: _ctx.item,
      index: _ctx.index,
      disabled: _ctx.disabled
    }, () => [
      vue$N.createElementVNode("span", null, vue$N.toDisplayString(_ctx.item.label), 1)
    ])
  ], 46, _hoisted_1$k);
}
optionItem_vue_vue_type_template_id_119b30a9_lang.render = render$s;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var optionItem_vue_vue_type_script_lang$1 = optionItem_vue_vue_type_script_lang;
  var optionItem_vue_vue_type_template_id_119b30a9_lang$1 = optionItem_vue_vue_type_template_id_119b30a9_lang;
  optionItem_vue_vue_type_script_lang$1["default"].render = optionItem_vue_vue_type_template_id_119b30a9_lang$1.render;
  optionItem_vue_vue_type_script_lang$1["default"].__file = "packages/components/select-v2/src/option-item.vue";
  exports["default"] = optionItem_vue_vue_type_script_lang$1["default"];
})(optionItem);
var token$2 = {};
Object.defineProperty(token$2, "__esModule", { value: true });
const selectV2InjectionKey = "ElSelectV2Injection";
token$2.selectV2InjectionKey = selectV2InjectionKey;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$l;
  var token2 = token$2;
  var shared2 = require$$1$1;
  var fixedSizeList2 = fixedSizeList$2;
  var dynamicSizeList2 = dynamicSizeList$2;
  var groupItem_vue_vue_type_script_lang$1 = groupItem_vue_vue_type_script_lang;
  var optionItem_vue_vue_type_script_lang$1 = optionItem_vue_vue_type_script_lang;
  var script2 = vue2.defineComponent({
    name: "ElSelectDropdown",
    props: {
      data: Array,
      hoveringIndex: Number,
      width: Number
    },
    setup(props2) {
      const select2 = vue2.inject(token2.selectV2InjectionKey);
      const cachedHeights = vue2.ref([]);
      const listRef = vue2.ref(null);
      const isSized = vue2.computed(() => util2.isUndefined(select2.props.estimatedOptionHeight));
      const listProps = vue2.computed(() => {
        if (isSized.value) {
          return {
            itemSize: select2.props.itemHeight
          };
        }
        return {
          estimatedSize: select2.props.estimatedOptionHeight,
          itemSize: (idx) => cachedHeights.value[idx]
        };
      });
      const contains2 = (arr = [], target2) => {
        const {
          props: { valueKey }
        } = select2;
        if (!shared2.isObject(target2)) {
          return arr.includes(target2);
        }
        return arr && arr.some((item2) => {
          return util2.getValueByPath(item2, valueKey) === util2.getValueByPath(target2, valueKey);
        });
      };
      const isEqual2 = (selected, target2) => {
        if (!shared2.isObject(target2)) {
          return selected === target2;
        } else {
          const { valueKey } = select2.props;
          return util2.getValueByPath(selected, valueKey) === util2.getValueByPath(target2, valueKey);
        }
      };
      const isItemSelected = (modelValue, target2) => {
        if (select2.props.multiple) {
          return contains2(modelValue, target2.value);
        }
        return isEqual2(modelValue, target2.value);
      };
      const isItemDisabled = (modelValue, selected) => {
        const { disabled, multiple, multipleLimit } = select2.props;
        return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
      };
      const isItemHovering = (target2) => props2.hoveringIndex === target2;
      const scrollToItem = (index2) => {
        const list2 = listRef.value;
        if (list2) {
          list2.scrollToItem(index2);
        }
      };
      const resetScrollTop = () => {
        const list2 = listRef.value;
        if (list2) {
          list2.resetScrollTop();
        }
      };
      return {
        select: select2,
        listProps,
        listRef,
        isSized,
        isItemDisabled,
        isItemHovering,
        isItemSelected,
        scrollToItem,
        resetScrollTop
      };
    },
    render(_ctx, _cache) {
      var _a;
      const {
        $slots,
        data: data2,
        listProps,
        select: select2,
        isSized,
        width,
        isItemDisabled,
        isItemHovering,
        isItemSelected
      } = _ctx;
      const Comp = isSized ? fixedSizeList2["default"] : dynamicSizeList2["default"];
      const {
        props: selectProps,
        onSelect,
        onHover,
        onKeyboardNavigate,
        onKeyboardSelect
      } = select2;
      const { height, modelValue, multiple } = selectProps;
      if (data2.length === 0) {
        return vue2.h("div", {
          class: "el-select-dropdown",
          style: {
            width: `${width}px`
          }
        }, (_a = $slots.empty) == null ? void 0 : _a.call($slots));
      }
      const ListItem = vue2.withCtx((scoped) => {
        const { index: index2, data: data22 } = scoped;
        const item2 = data22[index2];
        if (data22[index2].type === "Group") {
          return vue2.h(groupItem_vue_vue_type_script_lang$1["default"], {
            item: item2,
            style: scoped.style,
            height: isSized ? listProps.itemSize : listProps.estimatedSize
          });
        }
        const selected = isItemSelected(modelValue, item2);
        const itemDisabled = isItemDisabled(modelValue, selected);
        return vue2.h(optionItem_vue_vue_type_script_lang$1["default"], __spreadProps(__spreadValues({}, scoped), {
          selected,
          disabled: item2.disabled || itemDisabled,
          created: !!item2.created,
          hovering: isItemHovering(index2),
          item: item2,
          onSelect,
          onHover
        }), {
          default: vue2.withCtx((props2) => {
            return vue2.renderSlot($slots, "default", props2, () => [
              vue2.h("span", item2.label)
            ]);
          })
        });
      });
      const List2 = vue2.h(Comp, __spreadValues({
        ref: "listRef",
        className: "el-select-dropdown__list",
        data: data2,
        height,
        width,
        total: data2.length,
        scrollbarAlwaysOn: selectProps.scrollbarAlwaysOn,
        onKeydown: [
          _cache[1] || (_cache[1] = vue2.withKeys(vue2.withModifiers(() => onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
          _cache[2] || (_cache[2] = vue2.withKeys(vue2.withModifiers(() => onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
          _cache[3] || (_cache[3] = vue2.withKeys(vue2.withModifiers(onKeyboardSelect, ["stop", "prevent"]), ["enter"])),
          _cache[4] || (_cache[4] = vue2.withKeys(vue2.withModifiers(() => select2.expanded = false, ["stop", "prevent"]), ["esc"])),
          _cache[5] || (_cache[5] = vue2.withKeys(() => select2.expanded = false, ["tab"]))
        ]
      }, listProps), {
        default: ListItem
      });
      return vue2.h("div", {
        class: {
          "is-multiple": multiple,
          "el-select-dropdown": true
        }
      }, [List2]);
    }
  });
  exports["default"] = script2;
})(selectDropdown_vue_vue_type_script_lang);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var selectDropdown_vue_vue_type_script_lang$12 = selectDropdown_vue_vue_type_script_lang;
  selectDropdown_vue_vue_type_script_lang$12["default"].__file = "packages/components/select-v2/src/select-dropdown.vue";
  exports["default"] = selectDropdown_vue_vue_type_script_lang$12["default"];
})(selectDropdown);
var useSelect = {};
var useAllowCreate$1 = {};
Object.defineProperty(useAllowCreate$1, "__esModule", { value: true });
var vue$M = require$$0$1;
function useAllowCreate(props2, states) {
  const createOptionCount = vue$M.ref(0);
  const cachedSelectedOption = vue$M.ref(null);
  const enableAllowCreateMode = vue$M.computed(() => {
    return props2.allowCreate && props2.filterable;
  });
  function hasExistingOption(query) {
    const hasValue = (option2) => option2.value === query;
    return props2.options && props2.options.some(hasValue) || states.createdOptions.some(hasValue);
  }
  function selectNewOption(option2) {
    if (!enableAllowCreateMode.value) {
      return;
    }
    if (props2.multiple && option2.created) {
      createOptionCount.value++;
    } else {
      cachedSelectedOption.value = option2;
    }
  }
  function createNewOption(query) {
    if (enableAllowCreateMode.value) {
      if (query && query.length > 0 && !hasExistingOption(query)) {
        const newOption = {
          value: query,
          label: query,
          created: true,
          disabled: false
        };
        if (states.createdOptions.length >= createOptionCount.value) {
          states.createdOptions[createOptionCount.value] = newOption;
        } else {
          states.createdOptions.push(newOption);
        }
      } else {
        if (props2.multiple) {
          states.createdOptions.length = createOptionCount.value;
        } else {
          const selectedOption = cachedSelectedOption.value;
          states.createdOptions.length = 0;
          if (selectedOption && selectedOption.created) {
            states.createdOptions.push(selectedOption);
          }
        }
      }
    }
  }
  function removeNewOption(option2) {
    if (!enableAllowCreateMode.value || !option2 || !option2.created) {
      return;
    }
    const idx = states.createdOptions.findIndex((it) => it.value === option2.value);
    if (~idx) {
      states.createdOptions.splice(idx, 1);
      createOptionCount.value--;
    }
  }
  function clearAllNewOption() {
    if (enableAllowCreateMode.value) {
      states.createdOptions.length = 0;
      createOptionCount.value = 0;
    }
  }
  return {
    createNewOption,
    removeNewOption,
    selectNewOption,
    clearAllNewOption
  };
}
useAllowCreate$1.useAllowCreate = useAllowCreate;
var util$6 = {};
Object.defineProperty(util$6, "__esModule", { value: true });
var shared$5 = require$$1$1;
const flattenOptions = (options) => {
  const flattened = [];
  options.map((option2) => {
    if (shared$5.isArray(option2.options)) {
      flattened.push({
        label: option2.label,
        isTitle: true,
        type: "Group"
      });
      option2.options.forEach((o2) => {
        flattened.push(o2);
      });
      flattened.push({
        type: "Group"
      });
    } else {
      flattened.push(option2);
    }
  });
  return flattened;
};
util$6.flattenOptions = flattenOptions;
var useInput$1 = {};
Object.defineProperty(useInput$1, "__esModule", { value: true });
var vue$L = require$$0$1;
var shared$4 = require$$1$1;
var isDef = isDef$2;
function useInput(handleInput) {
  const isComposing = vue$L.ref(false);
  const handleCompositionStart = () => {
    isComposing.value = true;
  };
  const handleCompositionUpdate = (event) => {
    const text = event.target.value;
    const lastCharacter = text[text.length - 1] || "";
    isComposing.value = !isDef.isKorean(lastCharacter);
  };
  const handleCompositionEnd = (event) => {
    if (isComposing.value) {
      isComposing.value = false;
      if (shared$4.isFunction(handleInput)) {
        handleInput(event);
      }
    }
  };
  return {
    handleCompositionStart,
    handleCompositionUpdate,
    handleCompositionEnd
  };
}
useInput$1.useInput = useInput;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var isEqual2 = isEqual_1;
  var debounce2 = debounce_1;
  var constants2 = constants$f;
  var resizeEvent$1 = resizeEvent;
  var util$12 = util$l;
  var iconsVue2 = require$$3;
  var useAllowCreate2 = useAllowCreate$1;
  var util2 = util$6;
  var useInput2 = useInput$1;
  var index2 = useLocale$1;
  var form2 = form$7;
  var index$110 = useCommonProps;
  var defaults2 = defaults$d;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var isEqual__default2 = /* @__PURE__ */ _interopDefaultLegacy2(isEqual2);
  var debounce__default2 = /* @__PURE__ */ _interopDefaultLegacy2(debounce2);
  const DEFAULT_INPUT_PLACEHOLDER = "";
  const MINIMUM_INPUT_WIDTH = 11;
  const TAG_BASE_WIDTH = {
    small: 42,
    mini: 33
  };
  const useSelect2 = (props2, emit) => {
    const { t } = index2.useLocale();
    const elForm = vue2.inject(form2.elFormKey, {});
    const states = vue2.reactive({
      inputValue: DEFAULT_INPUT_PLACEHOLDER,
      displayInputValue: DEFAULT_INPUT_PLACEHOLDER,
      calculatedWidth: 0,
      cachedPlaceholder: "",
      cachedOptions: [],
      createdOptions: [],
      createdLabel: "",
      createdSelected: false,
      currentPlaceholder: "",
      hoveringIndex: -1,
      comboBoxHovering: false,
      isOnComposition: false,
      isSilentBlur: false,
      isComposing: false,
      inputLength: 20,
      selectWidth: 200,
      initialInputHeight: 0,
      previousQuery: null,
      previousValue: "",
      query: "",
      selectedLabel: "",
      softFocus: false,
      tagInMultiLine: false
    });
    const selectedIndex = vue2.ref(-1);
    const popperSize = vue2.ref(-1);
    const controlRef = vue2.ref(null);
    const inputRef = vue2.ref(null);
    const menuRef = vue2.ref(null);
    const popper2 = vue2.ref(null);
    const selectRef = vue2.ref(null);
    const selectionRef = vue2.ref(null);
    const calculatorRef = vue2.ref(null);
    const expanded = vue2.ref(false);
    const selectDisabled = vue2.computed(() => props2.disabled || elForm.disabled);
    const popupHeight = vue2.computed(() => {
      const totalHeight = filteredOptions.value.length * 34;
      return totalHeight > props2.height ? props2.height : totalHeight;
    });
    const hasModelValue = vue2.computed(() => {
      return props2.modelValue !== void 0 && props2.modelValue !== null && props2.modelValue !== "";
    });
    const showClearBtn = vue2.computed(() => {
      const hasValue = props2.multiple ? Array.isArray(props2.modelValue) && props2.modelValue.length > 0 : hasModelValue.value;
      const criteria = props2.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;
      return criteria;
    });
    const iconComponent = vue2.computed(() => props2.remote && props2.filterable ? "" : iconsVue2.ArrowUp);
    const iconReverse = vue2.computed(() => iconComponent.value && expanded.value ? "is-reverse" : "");
    const debounce3 = vue2.computed(() => props2.remote ? 300 : 0);
    const emptyText = vue2.computed(() => {
      const options = filteredOptions.value;
      if (props2.loading) {
        return props2.loadingText || t("el.select.loading");
      } else {
        if (props2.remote && states.inputValue === "" && options.length === 0)
          return false;
        if (props2.filterable && states.inputValue && options.length > 0) {
          return props2.noMatchText || t("el.select.noMatch");
        }
        if (options.length === 0) {
          return props2.noDataText || t("el.select.noData");
        }
      }
      return null;
    });
    const filteredOptions = vue2.computed(() => {
      const isValidOption = (o2) => {
        const query = states.inputValue;
        const containsQueryString = query ? o2.label.includes(query) : true;
        return containsQueryString;
      };
      if (props2.loading) {
        return [];
      }
      return util2.flattenOptions(props2.options.concat(states.createdOptions).map((v2) => {
        if (shared2.isArray(v2.options)) {
          const filtered = v2.options.filter(isValidOption);
          if (filtered.length > 0) {
            return __spreadProps(__spreadValues({}, v2), {
              options: filtered
            });
          }
        } else {
          if (props2.remote || isValidOption(v2)) {
            return v2;
          }
        }
        return null;
      }).filter((v2) => v2 !== null));
    });
    const optionsAllDisabled = vue2.computed(() => filteredOptions.value.every((option2) => option2.disabled));
    const selectSize = index$110.useSize();
    const collapseTagSize = vue2.computed(() => ["small", "mini"].indexOf(selectSize.value) > -1 ? "mini" : "small");
    const tagMaxWidth = vue2.computed(() => {
      const select2 = selectionRef.value;
      const size2 = collapseTagSize.value;
      const paddingLeft = select2 ? parseInt(getComputedStyle(select2).paddingLeft) : 0;
      const paddingRight = select2 ? parseInt(getComputedStyle(select2).paddingRight) : 0;
      return states.selectWidth - paddingRight - paddingLeft - TAG_BASE_WIDTH[size2];
    });
    const calculatePopperSize = () => {
      var _a, _b, _c;
      popperSize.value = ((_c = (_b = (_a = selectRef.value) == null ? void 0 : _a.getBoundingClientRect) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.width) || 200;
    };
    const inputWrapperStyle = vue2.computed(() => {
      return {
        width: `${states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH}px`
      };
    });
    const shouldShowPlaceholder = vue2.computed(() => {
      if (shared2.isArray(props2.modelValue)) {
        return props2.modelValue.length === 0 && !states.displayInputValue;
      }
      return props2.filterable ? states.displayInputValue.length === 0 : true;
    });
    const currentPlaceholder = vue2.computed(() => {
      const _placeholder = props2.placeholder || t("el.select.placeholder");
      return props2.multiple ? _placeholder : states.selectedLabel || _placeholder;
    });
    const popperRef = vue2.computed(() => {
      var _a;
      return (_a = popper2.value) == null ? void 0 : _a.popperRef;
    });
    const indexRef = vue2.computed(() => {
      if (props2.multiple) {
        const len = props2.modelValue.length;
        if (props2.modelValue.length > 0) {
          return filteredOptions.value.findIndex((o2) => o2.value === props2.modelValue[len - 1]);
        }
      } else {
        if (props2.modelValue) {
          return filteredOptions.value.findIndex((o2) => o2.value === props2.modelValue);
        }
      }
      return -1;
    });
    const dropdownMenuVisible = vue2.computed(() => {
      return expanded.value && emptyText.value !== false;
    });
    const {
      createNewOption,
      removeNewOption,
      selectNewOption,
      clearAllNewOption
    } = useAllowCreate2.useAllowCreate(props2, states);
    const {
      handleCompositionStart,
      handleCompositionUpdate,
      handleCompositionEnd
    } = useInput2.useInput((e) => onInput(e));
    const focusAndUpdatePopup = () => {
      var _a, _b, _c, _d;
      (_b = (_a = inputRef.value).focus) == null ? void 0 : _b.call(_a);
      (_d = (_c = popper2.value).update) == null ? void 0 : _d.call(_c);
    };
    const toggleMenu = () => {
      if (props2.automaticDropdown)
        return;
      if (!selectDisabled.value) {
        if (states.isComposing)
          states.softFocus = true;
        return vue2.nextTick(() => {
          var _a, _b;
          expanded.value = !expanded.value;
          (_b = (_a = inputRef.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
        });
      }
    };
    const onInputChange = () => {
      if (props2.filterable && states.inputValue !== states.selectedLabel) {
        states.query = states.selectedLabel;
      }
      handleQueryChange(states.inputValue);
      return vue2.nextTick(() => {
        createNewOption(states.inputValue);
      });
    };
    const debouncedOnInputChange = debounce__default2["default"](onInputChange, debounce3.value);
    const handleQueryChange = (val) => {
      if (states.previousQuery === val) {
        return;
      }
      states.previousQuery = val;
      if (props2.filterable && shared2.isFunction(props2.filterMethod)) {
        props2.filterMethod(val);
      } else if (props2.filterable && props2.remote && shared2.isFunction(props2.remoteMethod)) {
        props2.remoteMethod(val);
      }
    };
    const emitChange = (val) => {
      if (!isEqual__default2["default"](props2.modelValue, val)) {
        emit(constants2.CHANGE_EVENT, val);
      }
    };
    const update3 = (val) => {
      emit(constants2.UPDATE_MODEL_EVENT, val);
      emitChange(val);
      states.previousValue = val.toString();
    };
    const getValueIndex = (arr = [], value) => {
      if (!shared2.isObject(value)) {
        return arr.indexOf(value);
      }
      const valueKey = props2.valueKey;
      let index3 = -1;
      arr.some((item2, i) => {
        if (util$12.getValueByPath(item2, valueKey) === util$12.getValueByPath(value, valueKey)) {
          index3 = i;
          return true;
        }
        return false;
      });
      return index3;
    };
    const getValueKey = (item2) => {
      return shared2.isObject(item2) ? util$12.getValueByPath(item2, props2.valueKey) : item2;
    };
    const getLabel = (item2) => {
      return shared2.isObject(item2) ? item2.label : item2;
    };
    const resetInputHeight = () => {
      if (props2.collapseTags && !props2.filterable) {
        return;
      }
      return vue2.nextTick(() => {
        var _a, _b;
        if (!inputRef.value)
          return;
        const selection = selectionRef.value;
        selectRef.value.height = selection.offsetHeight;
        if (expanded.value && emptyText.value !== false) {
          (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
        }
      });
    };
    const handleResize = () => {
      var _a, _b;
      resetInputWidth();
      calculatePopperSize();
      (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      if (props2.multiple) {
        return resetInputHeight();
      }
    };
    const resetInputWidth = () => {
      const select2 = selectionRef.value;
      if (select2) {
        states.selectWidth = select2.getBoundingClientRect().width;
      }
    };
    const onSelect = (option2, idx, byClick = true) => {
      var _a, _b;
      if (props2.multiple) {
        let selectedOptions = props2.modelValue.slice();
        const index3 = getValueIndex(selectedOptions, getValueKey(option2));
        if (index3 > -1) {
          selectedOptions = [
            ...selectedOptions.slice(0, index3),
            ...selectedOptions.slice(index3 + 1)
          ];
          states.cachedOptions.splice(index3, 1);
          removeNewOption(option2);
        } else if (props2.multipleLimit <= 0 || selectedOptions.length < props2.multipleLimit) {
          selectedOptions = [...selectedOptions, getValueKey(option2)];
          states.cachedOptions.push(option2);
          selectNewOption(option2);
          updateHoveringIndex(idx);
        }
        update3(selectedOptions);
        if (option2.created) {
          states.query = "";
          handleQueryChange("");
          states.inputLength = 20;
        }
        if (props2.filterable) {
          (_b = (_a = inputRef.value).focus) == null ? void 0 : _b.call(_a);
          onUpdateInputValue("");
        }
        if (props2.filterable) {
          states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
        }
        resetInputHeight();
        setSoftFocus();
      } else {
        selectedIndex.value = idx;
        states.selectedLabel = option2.label;
        update3(getValueKey(option2));
        expanded.value = false;
        states.isComposing = false;
        states.isSilentBlur = byClick;
        selectNewOption(option2);
        if (!option2.created) {
          clearAllNewOption();
        }
        updateHoveringIndex(idx);
      }
    };
    const deleteTag = (event, tag3) => {
      const index3 = props2.modelValue.indexOf(tag3.value);
      if (index3 > -1 && !selectDisabled.value) {
        const value = [
          ...props2.modelValue.slice(0, index3),
          ...props2.modelValue.slice(index3 + 1)
        ];
        states.cachedOptions.splice(index3, 1);
        update3(value);
        emit("remove-tag", tag3.value);
        states.softFocus = true;
        removeNewOption(tag3);
        return vue2.nextTick(focusAndUpdatePopup);
      }
      event.stopPropagation();
    };
    const handleFocus = (event) => {
      const focused = states.isComposing;
      states.isComposing = true;
      if (!states.softFocus) {
        if (!focused)
          emit("focus", event);
      } else {
        states.softFocus = false;
      }
    };
    const handleBlur = () => {
      states.softFocus = false;
      return vue2.nextTick(() => {
        var _a, _b;
        (_b = (_a = inputRef.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
        if (calculatorRef.value) {
          states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
        }
        if (states.isSilentBlur) {
          states.isSilentBlur = false;
        } else {
          if (states.isComposing) {
            emit("blur");
          }
        }
        states.isComposing = false;
      });
    };
    const handleEsc = () => {
      if (states.displayInputValue.length > 0) {
        onUpdateInputValue("");
      } else {
        expanded.value = false;
      }
    };
    const handleDel = (e) => {
      if (states.displayInputValue.length === 0) {
        e.preventDefault();
        const selected = props2.modelValue.slice();
        selected.pop();
        removeNewOption(states.cachedOptions.pop());
        update3(selected);
      }
    };
    const handleClear = () => {
      let emptyValue;
      if (shared2.isArray(props2.modelValue)) {
        emptyValue = [];
      } else {
        emptyValue = "";
      }
      states.softFocus = true;
      if (props2.multiple) {
        states.cachedOptions = [];
      } else {
        states.selectedLabel = "";
      }
      expanded.value = false;
      update3(emptyValue);
      emit("clear");
      clearAllNewOption();
      return vue2.nextTick(focusAndUpdatePopup);
    };
    const onUpdateInputValue = (val) => {
      states.displayInputValue = val;
      states.inputValue = val;
    };
    const onKeyboardNavigate = (direction2, hoveringIndex = void 0) => {
      const options = filteredOptions.value;
      if (!["forward", "backward"].includes(direction2) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value) {
        return;
      }
      if (!expanded.value) {
        return toggleMenu();
      }
      if (hoveringIndex === void 0) {
        hoveringIndex = states.hoveringIndex;
      }
      let newIndex = -1;
      if (direction2 === "forward") {
        newIndex = hoveringIndex + 1;
        if (newIndex >= options.length) {
          newIndex = 0;
        }
      } else if (direction2 === "backward") {
        newIndex = hoveringIndex - 1;
        if (newIndex < 0) {
          newIndex = options.length - 1;
        }
      }
      const option2 = options[newIndex];
      if (option2.disabled || option2.type === "Group") {
        return onKeyboardNavigate(direction2, newIndex);
      } else {
        updateHoveringIndex(newIndex);
        scrollToItem(newIndex);
      }
    };
    const onKeyboardSelect = () => {
      if (!expanded.value) {
        return toggleMenu();
      } else if (~states.hoveringIndex) {
        onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);
      }
    };
    const updateHoveringIndex = (idx) => {
      states.hoveringIndex = idx;
    };
    const resetHoveringIndex = () => {
      states.hoveringIndex = -1;
    };
    const setSoftFocus = () => {
      var _a;
      const _input = inputRef.value;
      if (_input) {
        (_a = _input.focus) == null ? void 0 : _a.call(_input);
      }
    };
    const onInput = (event) => {
      const value = event.target.value;
      onUpdateInputValue(value);
      if (states.displayInputValue.length > 0 && !expanded.value) {
        expanded.value = true;
      }
      states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
      if (props2.multiple) {
        resetInputHeight();
      }
      if (props2.remote) {
        debouncedOnInputChange();
      } else {
        return onInputChange();
      }
    };
    const handleClickOutside = () => {
      expanded.value = false;
      return handleBlur();
    };
    const handleMenuEnter = () => {
      states.inputValue = states.displayInputValue;
      return vue2.nextTick(() => {
        if (~indexRef.value) {
          updateHoveringIndex(indexRef.value);
          scrollToItem(states.hoveringIndex);
        }
      });
    };
    const scrollToItem = (index3) => {
      menuRef.value.scrollToItem(index3);
    };
    const initStates = () => {
      resetHoveringIndex();
      if (props2.multiple) {
        if (props2.modelValue.length > 0) {
          let initHovering = false;
          states.cachedOptions.length = 0;
          props2.modelValue.map((selected) => {
            const itemIndex = filteredOptions.value.findIndex((option2) => getValueKey(option2) === selected);
            if (~itemIndex) {
              states.cachedOptions.push(filteredOptions.value[itemIndex]);
              if (!initHovering) {
                updateHoveringIndex(itemIndex);
              }
              initHovering = true;
            }
          });
        } else {
          states.cachedOptions = [];
        }
      } else {
        if (hasModelValue.value) {
          const options = filteredOptions.value;
          const selectedItemIndex = options.findIndex((option2) => getValueKey(option2) === props2.modelValue);
          if (~selectedItemIndex) {
            states.selectedLabel = options[selectedItemIndex].label;
            updateHoveringIndex(selectedItemIndex);
          } else {
            states.selectedLabel = `${props2.modelValue}`;
          }
        } else {
          states.selectedLabel = "";
        }
      }
      calculatePopperSize();
    };
    vue2.watch(expanded, (val) => {
      var _a, _b;
      emit("visible-change", val);
      if (val) {
        (_b = (_a = popper2.value).update) == null ? void 0 : _b.call(_a);
      } else {
        states.displayInputValue = "";
        createNewOption("");
      }
    });
    vue2.watch(() => props2.modelValue, (val) => {
      if (!val || val.toString() !== states.previousValue) {
        initStates();
      }
    }, {
      deep: true
    });
    vue2.watch(() => props2.options, () => {
      const input3 = inputRef.value;
      if (!input3 || input3 && document.activeElement !== input3) {
        initStates();
      }
    }, {
      deep: true
    });
    vue2.watch(filteredOptions, () => {
      return vue2.nextTick(menuRef.value.resetScrollTop);
    });
    vue2.onMounted(() => {
      initStates();
      resizeEvent$1.addResizeListener(selectRef.value, handleResize);
    });
    vue2.onBeforeMount(() => {
      resizeEvent$1.removeResizeListener(selectRef.value, handleResize);
    });
    return {
      collapseTagSize,
      currentPlaceholder,
      expanded,
      emptyText,
      popupHeight,
      debounce: debounce3,
      filteredOptions,
      iconComponent,
      iconReverse,
      inputWrapperStyle,
      popperSize,
      dropdownMenuVisible,
      hasModelValue,
      shouldShowPlaceholder,
      selectDisabled,
      selectSize,
      showClearBtn,
      states,
      tagMaxWidth,
      calculatorRef,
      controlRef,
      inputRef,
      menuRef,
      popper: popper2,
      selectRef,
      selectionRef,
      popperRef,
      Effect: defaults2.Effect,
      debouncedOnInputChange,
      deleteTag,
      getLabel,
      getValueKey,
      handleBlur,
      handleClear,
      handleClickOutside,
      handleDel,
      handleEsc,
      handleFocus,
      handleMenuEnter,
      handleResize,
      toggleMenu,
      scrollTo: scrollToItem,
      onInput,
      onKeyboardNavigate,
      onKeyboardSelect,
      onSelect,
      onHover: updateHoveringIndex,
      onUpdateInputValue,
      handleCompositionStart,
      handleCompositionEnd,
      handleCompositionUpdate
    };
  };
  exports["default"] = useSelect2;
})(useSelect);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index$110 = popper$3;
  var index2 = tag$2;
  var index$22 = icon$4;
  var constants2 = constants$f;
  var useSelect$12 = useSelect;
  var token2 = token$2;
  var defaults2 = defaults$9;
  var selectDropdown_vue_vue_type_script_lang$12 = selectDropdown_vue_vue_type_script_lang;
  var index$32 = clickOutside;
  var script2 = vue2.defineComponent({
    name: "ElSelectV2",
    components: {
      ElSelectMenu: selectDropdown_vue_vue_type_script_lang$12["default"],
      ElTag: index2.ElTag,
      ElPopper: index$110["default"],
      ElIcon: index$22.ElIcon
    },
    directives: { ClickOutside: index$32["default"], ModelText: vue2.vModelText },
    props: defaults2.SelectProps,
    emits: [
      constants2.UPDATE_MODEL_EVENT,
      constants2.CHANGE_EVENT,
      "remove-tag",
      "clear",
      "visible-change",
      "focus",
      "blur"
    ],
    setup(props2, { emit }) {
      const API = useSelect$12["default"](props2, emit);
      vue2.provide(token2.selectV2InjectionKey, {
        props: vue2.reactive(__spreadProps(__spreadValues({}, vue2.toRefs(props2)), {
          height: API.popupHeight
        })),
        onSelect: API.onSelect,
        onHover: API.onHover,
        onKeyboardNavigate: API.onKeyboardNavigate,
        onKeyboardSelect: API.onKeyboardSelect
      });
      return API;
    }
  });
  exports["default"] = script2;
})(select_vue_vue_type_script_lang);
var select_vue_vue_type_template_id_13e598a4_lang = {};
Object.defineProperty(select_vue_vue_type_template_id_13e598a4_lang, "__esModule", { value: true });
var vue$K = require$$0$1;
const _hoisted_1$j = { key: 0 };
const _hoisted_2$g = {
  key: 1,
  class: "el-select-v2__selection"
};
const _hoisted_3$e = {
  key: 0,
  class: "el-select-v2__selected-item"
};
const _hoisted_4$9 = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"];
const _hoisted_5$7 = ["textContent"];
const _hoisted_6$6 = { class: "el-select-v2__selected-item el-select-v2__input-wrapper" };
const _hoisted_7$4 = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"];
const _hoisted_8$4 = ["textContent"];
const _hoisted_9$2 = { class: "el-select-v2__suffix" };
const _hoisted_10$2 = { class: "el-select-v2__empty" };
function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = vue$K.resolveComponent("el-tag");
  const _component_el_icon = vue$K.resolveComponent("el-icon");
  const _component_el_select_menu = vue$K.resolveComponent("el-select-menu");
  const _component_el_popper = vue$K.resolveComponent("el-popper");
  const _directive_model_text = vue$K.resolveDirective("model-text");
  const _directive_click_outside = vue$K.resolveDirective("click-outside");
  return vue$K.withDirectives((vue$K.openBlock(), vue$K.createElementBlock("div", {
    ref: "selectRef",
    class: vue$K.normalizeClass([[_ctx.selectSize ? "el-select-v2--" + _ctx.selectSize : ""], "el-select-v2"]),
    onClick: _cache[24] || (_cache[24] = vue$K.withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"])),
    onMouseenter: _cache[25] || (_cache[25] = ($event) => _ctx.states.comboBoxHovering = true),
    onMouseleave: _cache[26] || (_cache[26] = ($event) => _ctx.states.comboBoxHovering = false)
  }, [
    vue$K.createVNode(_component_el_popper, {
      ref: "popper",
      visible: _ctx.dropdownMenuVisible,
      "onUpdate:visible": _cache[22] || (_cache[22] = ($event) => _ctx.dropdownMenuVisible = $event),
      "append-to-body": _ctx.popperAppendToBody,
      "popper-class": `el-select-v2__popper ${_ctx.popperClass}`,
      "gpu-acceleration": false,
      "stop-popper-mouse-event": false,
      "popper-options": _ctx.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: _ctx.Effect.LIGHT,
      "manual-mode": "",
      placement: "bottom-start",
      pure: "",
      transition: "el-zoom-in-top",
      trigger: "click",
      onBeforeEnter: _ctx.handleMenuEnter,
      onAfterLeave: _cache[23] || (_cache[23] = ($event) => _ctx.states.inputValue = _ctx.states.displayInputValue)
    }, {
      trigger: vue$K.withCtx(() => {
        var _a;
        return [
          vue$K.createElementVNode("div", {
            ref: "selectionRef",
            class: vue$K.normalizeClass(["el-select-v2__wrapper", {
              "is-focused": _ctx.states.isComposing,
              "is-hovering": _ctx.states.comboBoxHovering,
              "is-filterable": _ctx.filterable,
              "is-disabled": _ctx.disabled
            }])
          }, [
            _ctx.$slots.prefix ? (vue$K.openBlock(), vue$K.createElementBlock("div", _hoisted_1$j, [
              vue$K.renderSlot(_ctx.$slots, "prefix")
            ])) : vue$K.createCommentVNode("v-if", true),
            _ctx.multiple ? (vue$K.openBlock(), vue$K.createElementBlock("div", _hoisted_2$g, [
              _ctx.collapseTags && _ctx.modelValue.length > 0 ? (vue$K.openBlock(), vue$K.createElementBlock("div", _hoisted_3$e, [
                vue$K.createVNode(_component_el_tag, {
                  closable: !_ctx.selectDisabled && !((_a = _ctx.states.cachedOptions[0]) == null ? void 0 : _a.disable),
                  size: _ctx.collapseTagSize,
                  type: "info",
                  "disable-transitions": "",
                  onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.states.cachedOptions[0]))
                }, {
                  default: vue$K.withCtx(() => {
                    var _a2;
                    return [
                      vue$K.createElementVNode("span", {
                        class: "el-select-v2__tags-text",
                        style: vue$K.normalizeStyle({
                          maxWidth: `${_ctx.tagMaxWidth}px`
                        })
                      }, vue$K.toDisplayString((_a2 = _ctx.states.cachedOptions[0]) == null ? void 0 : _a2.label), 5)
                    ];
                  }),
                  _: 1
                }, 8, ["closable", "size"]),
                _ctx.modelValue.length > 1 ? (vue$K.openBlock(), vue$K.createBlock(_component_el_tag, {
                  key: 0,
                  closable: false,
                  size: _ctx.collapseTagSize,
                  type: "info",
                  "disable-transitions": ""
                }, {
                  default: vue$K.withCtx(() => [
                    vue$K.createElementVNode("span", {
                      class: "el-select-v2__tags-text",
                      style: vue$K.normalizeStyle({
                        maxWidth: `${_ctx.tagMaxWidth}px`
                      })
                    }, "+ " + vue$K.toDisplayString(_ctx.modelValue.length - 1), 5)
                  ]),
                  _: 1
                }, 8, ["size"])) : vue$K.createCommentVNode("v-if", true)
              ])) : (vue$K.openBlock(true), vue$K.createElementBlock(vue$K.Fragment, { key: 1 }, vue$K.renderList(_ctx.states.cachedOptions, (selected, idx) => {
                return vue$K.openBlock(), vue$K.createElementBlock("div", {
                  key: idx,
                  class: "el-select-v2__selected-item"
                }, [
                  vue$K.createVNode(_component_el_tag, {
                    key: _ctx.getValueKey(selected),
                    closable: !_ctx.selectDisabled && !selected.disabled,
                    size: _ctx.collapseTagSize,
                    type: "info",
                    "disable-transitions": "",
                    onClose: ($event) => _ctx.deleteTag($event, selected)
                  }, {
                    default: vue$K.withCtx(() => [
                      vue$K.createElementVNode("span", {
                        class: "el-select-v2__tags-text",
                        style: vue$K.normalizeStyle({
                          maxWidth: `${_ctx.tagMaxWidth}px`
                        })
                      }, vue$K.toDisplayString(_ctx.getLabel(selected)), 5)
                    ]),
                    _: 2
                  }, 1032, ["closable", "size", "onClose"])
                ]);
              }), 128)),
              vue$K.createElementVNode("div", {
                class: "el-select-v2__selected-item el-select-v2__input-wrapper",
                style: vue$K.normalizeStyle(_ctx.inputWrapperStyle)
              }, [
                vue$K.withDirectives(vue$K.createElementVNode("input", {
                  id: _ctx.id,
                  ref: "inputRef",
                  autocomplete: _ctx.autocomplete,
                  "aria-autocomplete": "list",
                  "aria-haspopup": "listbox",
                  autocapitalize: "off",
                  "aria-expanded": _ctx.expanded,
                  "aria-labelledby": _ctx.label,
                  class: vue$K.normalizeClass(["el-select-v2__combobox-input", [_ctx.selectSize ? `is-${_ctx.selectSize}` : ""]]),
                  disabled: _ctx.disabled,
                  role: "combobox",
                  readonly: !_ctx.filterable,
                  spellcheck: "false",
                  type: "text",
                  name: _ctx.name,
                  unselectable: _ctx.expanded ? "on" : void 0,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)),
                  onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  onInput: _cache[3] || (_cache[3] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                  onCompositionstart: _cache[4] || (_cache[4] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                  onCompositionupdate: _cache[5] || (_cache[5] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                  onCompositionend: _cache[6] || (_cache[6] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                  onKeydown: [
                    _cache[7] || (_cache[7] = vue$K.withKeys(vue$K.withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                    _cache[8] || (_cache[8] = vue$K.withKeys(vue$K.withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                    _cache[9] || (_cache[9] = vue$K.withKeys(vue$K.withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                    _cache[10] || (_cache[10] = vue$K.withKeys(vue$K.withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                    _cache[11] || (_cache[11] = vue$K.withKeys(vue$K.withModifiers((...args) => _ctx.handleDel && _ctx.handleDel(...args), ["stop"]), ["delete"]))
                  ]
                }, null, 42, _hoisted_4$9), [
                  [_directive_model_text, _ctx.states.displayInputValue]
                ]),
                _ctx.filterable ? (vue$K.openBlock(), vue$K.createElementBlock("span", {
                  key: 0,
                  ref: "calculatorRef",
                  "aria-hidden": "true",
                  class: "el-select-v2__input-calculator",
                  textContent: vue$K.toDisplayString(_ctx.states.displayInputValue)
                }, null, 8, _hoisted_5$7)) : vue$K.createCommentVNode("v-if", true)
              ], 4)
            ])) : (vue$K.openBlock(), vue$K.createElementBlock(vue$K.Fragment, { key: 2 }, [
              vue$K.createElementVNode("div", _hoisted_6$6, [
                vue$K.withDirectives(vue$K.createElementVNode("input", {
                  id: _ctx.id,
                  ref: "inputRef",
                  "aria-autocomplete": "list",
                  "aria-haspopup": "listbox",
                  "aria-labelledby": _ctx.label,
                  "aria-expanded": _ctx.expanded,
                  autocapitalize: "off",
                  autocomplete: _ctx.autocomplete,
                  class: "el-select-v2__combobox-input",
                  disabled: _ctx.disabled,
                  name: _ctx.name,
                  role: "combobox",
                  readonly: !_ctx.filterable,
                  spellcheck: "false",
                  type: "text",
                  unselectable: _ctx.expanded ? "on" : void 0,
                  onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                  onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                  onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                  onFocus: _cache[15] || (_cache[15] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  onInput: _cache[16] || (_cache[16] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                  onKeydown: [
                    _cache[17] || (_cache[17] = vue$K.withKeys(vue$K.withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                    _cache[18] || (_cache[18] = vue$K.withKeys(vue$K.withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                    _cache[19] || (_cache[19] = vue$K.withKeys(vue$K.withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                    _cache[20] || (_cache[20] = vue$K.withKeys(vue$K.withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"]))
                  ],
                  "onUpdate:modelValue": _cache[21] || (_cache[21] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args))
                }, null, 40, _hoisted_7$4), [
                  [_directive_model_text, _ctx.states.displayInputValue]
                ])
              ]),
              _ctx.filterable ? (vue$K.openBlock(), vue$K.createElementBlock("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: "el-select-v2__selected-item el-select-v2__input-calculator",
                textContent: vue$K.toDisplayString(_ctx.states.displayInputValue)
              }, null, 8, _hoisted_8$4)) : vue$K.createCommentVNode("v-if", true)
            ], 64)),
            _ctx.shouldShowPlaceholder ? (vue$K.openBlock(), vue$K.createElementBlock("span", {
              key: 3,
              class: vue$K.normalizeClass({
                "el-select-v2__placeholder": true,
                "is-transparent": _ctx.states.isComposing || (_ctx.placeholder && _ctx.multiple ? _ctx.modelValue.length === 0 : !_ctx.hasModelValue)
              })
            }, vue$K.toDisplayString(_ctx.currentPlaceholder), 3)) : vue$K.createCommentVNode("v-if", true),
            vue$K.createElementVNode("span", _hoisted_9$2, [
              _ctx.iconComponent ? vue$K.withDirectives((vue$K.openBlock(), vue$K.createBlock(_component_el_icon, {
                key: 0,
                class: vue$K.normalizeClass(["el-select-v2__caret", "el-input__icon", _ctx.iconReverse])
              }, {
                default: vue$K.withCtx(() => [
                  (vue$K.openBlock(), vue$K.createBlock(vue$K.resolveDynamicComponent(_ctx.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])), [
                [vue$K.vShow, !_ctx.showClearBtn]
              ]) : vue$K.createCommentVNode("v-if", true),
              _ctx.showClearBtn && _ctx.clearIcon ? (vue$K.openBlock(), vue$K.createBlock(_component_el_icon, {
                key: 1,
                class: "el-select-v2__caret el-input__icon",
                onClick: vue$K.withModifiers(_ctx.handleClear, ["prevent", "stop"])
              }, {
                default: vue$K.withCtx(() => [
                  (vue$K.openBlock(), vue$K.createBlock(vue$K.resolveDynamicComponent(_ctx.clearIcon)))
                ]),
                _: 1
              }, 8, ["onClick"])) : vue$K.createCommentVNode("v-if", true)
            ])
          ], 2)
        ];
      }),
      default: vue$K.withCtx(() => [
        vue$K.createVNode(_component_el_select_menu, {
          ref: "menuRef",
          data: _ctx.filteredOptions,
          width: _ctx.popperSize,
          "hovering-index": _ctx.states.hoveringIndex,
          "scrollbar-always-on": _ctx.scrollbarAlwaysOn
        }, {
          default: vue$K.withCtx((scope) => [
            vue$K.renderSlot(_ctx.$slots, "default", vue$K.normalizeProps(vue$K.guardReactiveProps(scope)))
          ]),
          empty: vue$K.withCtx(() => [
            vue$K.renderSlot(_ctx.$slots, "empty", {}, () => [
              vue$K.createElementVNode("p", _hoisted_10$2, vue$K.toDisplayString(_ctx.emptyText ? _ctx.emptyText : ""), 1)
            ])
          ]),
          _: 3
        }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])
      ]),
      _: 3
    }, 8, ["visible", "append-to-body", "popper-class", "popper-options", "effect", "onBeforeEnter"])
  ], 34)), [
    [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
  ]);
}
select_vue_vue_type_template_id_13e598a4_lang.render = render$r;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var select_vue_vue_type_script_lang$12 = select_vue_vue_type_script_lang;
  var select_vue_vue_type_template_id_13e598a4_lang$1 = select_vue_vue_type_template_id_13e598a4_lang;
  select_vue_vue_type_script_lang$12["default"].render = select_vue_vue_type_template_id_13e598a4_lang$1.render;
  select_vue_vue_type_script_lang$12["default"].__file = "packages/components/select-v2/src/select.vue";
  exports["default"] = select_vue_vue_type_script_lang$12["default"];
})(select);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var token2 = token$2;
  var select_vue_vue_type_script_lang$12 = select_vue_vue_type_script_lang;
  select_vue_vue_type_script_lang$12["default"].install = (app) => {
    app.component(select_vue_vue_type_script_lang$12["default"].name, select_vue_vue_type_script_lang$12["default"]);
  };
  const _Select = select_vue_vue_type_script_lang$12["default"];
  const ElSelectV2 = _Select;
  exports.selectV2InjectionKey = token2.selectV2InjectionKey;
  exports.ElSelectV2 = ElSelectV2;
  exports["default"] = _Select;
})(selectV2);
var skeleton$2 = {};
var skeleton2 = {};
var skeleton_vue_vue_type_script_lang = {};
var skeletonItem2 = {};
var skeletonItem_vue_vue_type_script_lang = {};
var imagePlaceholder = {};
var imagePlaceholder_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ImgPlaceholder"
  });
  exports["default"] = script2;
})(imagePlaceholder_vue_vue_type_script_lang);
var imagePlaceholder_vue_vue_type_template_id_f0b3074e_lang = {};
Object.defineProperty(imagePlaceholder_vue_vue_type_template_id_f0b3074e_lang, "__esModule", { value: true });
var vue$J = require$$0$1;
const _hoisted_1$i = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$f = /* @__PURE__ */ vue$J.createElementVNode("path", { d: "M64 896V128h896v768H64z m64-128l192-192 116.352 116.352L640 448l256 307.2V192H128v576z m224-480a96 96 0 1 1-0.064 192.064A96 96 0 0 1 352 288z" }, null, -1);
const _hoisted_3$d = [
  _hoisted_2$f
];
function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$J.openBlock(), vue$J.createElementBlock("svg", _hoisted_1$i, _hoisted_3$d);
}
imagePlaceholder_vue_vue_type_template_id_f0b3074e_lang.render = render$q;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var imagePlaceholder_vue_vue_type_script_lang$1 = imagePlaceholder_vue_vue_type_script_lang;
  var imagePlaceholder_vue_vue_type_template_id_f0b3074e_lang$1 = imagePlaceholder_vue_vue_type_template_id_f0b3074e_lang;
  imagePlaceholder_vue_vue_type_script_lang$1["default"].render = imagePlaceholder_vue_vue_type_template_id_f0b3074e_lang$1.render;
  imagePlaceholder_vue_vue_type_script_lang$1["default"].__file = "packages/components/skeleton/src/image-placeholder.vue";
  exports["default"] = imagePlaceholder_vue_vue_type_script_lang$1["default"];
})(imagePlaceholder);
var skeletonItem$1 = {};
Object.defineProperty(skeletonItem$1, "__esModule", { value: true });
var props$9 = props$N;
const skeletonItemProps = props$9.buildProps({
  variant: {
    type: String,
    values: [
      "circle",
      "rect",
      "h1",
      "h3",
      "text",
      "caption",
      "p",
      "image",
      "button"
    ],
    default: "text"
  }
});
skeletonItem$1.skeletonItemProps = skeletonItemProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var skeletonItem3 = skeletonItem$1;
  var imagePlaceholder_vue_vue_type_script_lang$1 = imagePlaceholder_vue_vue_type_script_lang;
  var script2 = vue2.defineComponent({
    name: "ElSkeletonItem",
    components: {
      ImgPlaceholder: imagePlaceholder_vue_vue_type_script_lang$1["default"]
    },
    props: skeletonItem3.skeletonItemProps
  });
  exports["default"] = script2;
})(skeletonItem_vue_vue_type_script_lang);
var skeletonItem_vue_vue_type_template_id_7e70bfeb_lang = {};
Object.defineProperty(skeletonItem_vue_vue_type_template_id_7e70bfeb_lang, "__esModule", { value: true });
var vue$I = require$$0$1;
function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_img_placeholder = vue$I.resolveComponent("img-placeholder");
  return vue$I.openBlock(), vue$I.createElementBlock("div", {
    class: vue$I.normalizeClass(["el-skeleton__item", `el-skeleton__${_ctx.variant}`])
  }, [
    _ctx.variant === "image" ? (vue$I.openBlock(), vue$I.createBlock(_component_img_placeholder, { key: 0 })) : vue$I.createCommentVNode("v-if", true)
  ], 2);
}
skeletonItem_vue_vue_type_template_id_7e70bfeb_lang.render = render$p;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var skeletonItem_vue_vue_type_script_lang$1 = skeletonItem_vue_vue_type_script_lang;
  var skeletonItem_vue_vue_type_template_id_7e70bfeb_lang$1 = skeletonItem_vue_vue_type_template_id_7e70bfeb_lang;
  skeletonItem_vue_vue_type_script_lang$1["default"].render = skeletonItem_vue_vue_type_template_id_7e70bfeb_lang$1.render;
  skeletonItem_vue_vue_type_script_lang$1["default"].__file = "packages/components/skeleton/src/skeleton-item.vue";
  exports["default"] = skeletonItem_vue_vue_type_script_lang$1["default"];
})(skeletonItem2);
var skeleton$1 = {};
Object.defineProperty(skeleton$1, "__esModule", { value: true });
var props$8 = props$N;
const skeletonProps = props$8.buildProps({
  animated: {
    type: Boolean,
    default: false
  },
  count: {
    type: Number,
    default: 1
  },
  rows: {
    type: Number,
    default: 3
  },
  loading: {
    type: Boolean,
    default: true
  },
  throttle: {
    type: Number
  }
});
skeleton$1.skeletonProps = skeletonProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var skeleton3 = skeleton$1;
  var skeletonItem_vue_vue_type_script_lang$1 = skeletonItem_vue_vue_type_script_lang;
  var index2 = useThrottleRender$1;
  var script2 = vue2.defineComponent({
    name: "ElSkeleton",
    components: {
      [skeletonItem_vue_vue_type_script_lang$1["default"].name]: skeletonItem_vue_vue_type_script_lang$1["default"]
    },
    props: skeleton3.skeletonProps,
    setup(props2) {
      const innerLoading = vue2.computed(() => {
        return props2.loading;
      });
      const uiLoading = index2.useThrottleRender(innerLoading, props2.throttle);
      return {
        uiLoading
      };
    }
  });
  exports["default"] = script2;
})(skeleton_vue_vue_type_script_lang);
var skeleton_vue_vue_type_template_id_26fa9225_lang = {};
Object.defineProperty(skeleton_vue_vue_type_template_id_26fa9225_lang, "__esModule", { value: true });
var vue$H = require$$0$1;
function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_skeleton_item = vue$H.resolveComponent("el-skeleton-item");
  return _ctx.uiLoading ? (vue$H.openBlock(), vue$H.createElementBlock("div", vue$H.mergeProps({
    key: 0,
    class: ["el-skeleton", _ctx.animated ? "is-animated" : ""]
  }, _ctx.$attrs), [
    (vue$H.openBlock(true), vue$H.createElementBlock(vue$H.Fragment, null, vue$H.renderList(_ctx.count, (i) => {
      return vue$H.openBlock(), vue$H.createElementBlock(vue$H.Fragment, { key: i }, [
        _ctx.loading ? vue$H.renderSlot(_ctx.$slots, "template", { key: i }, () => [
          vue$H.createVNode(_component_el_skeleton_item, {
            class: "is-first",
            variant: "p"
          }),
          (vue$H.openBlock(true), vue$H.createElementBlock(vue$H.Fragment, null, vue$H.renderList(_ctx.rows, (item2) => {
            return vue$H.openBlock(), vue$H.createBlock(_component_el_skeleton_item, {
              key: item2,
              class: vue$H.normalizeClass({
                "el-skeleton__paragraph": true,
                "is-last": item2 === _ctx.rows && _ctx.rows > 1
              }),
              variant: "p"
            }, null, 8, ["class"]);
          }), 128))
        ]) : vue$H.createCommentVNode("v-if", true)
      ], 64);
    }), 128))
  ], 16)) : vue$H.renderSlot(_ctx.$slots, "default", vue$H.normalizeProps(vue$H.mergeProps({ key: 1 }, _ctx.$attrs)));
}
skeleton_vue_vue_type_template_id_26fa9225_lang.render = render$o;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var skeleton_vue_vue_type_script_lang$1 = skeleton_vue_vue_type_script_lang;
  var skeleton_vue_vue_type_template_id_26fa9225_lang$1 = skeleton_vue_vue_type_template_id_26fa9225_lang;
  skeleton_vue_vue_type_script_lang$1["default"].render = skeleton_vue_vue_type_template_id_26fa9225_lang$1.render;
  skeleton_vue_vue_type_script_lang$1["default"].__file = "packages/components/skeleton/src/skeleton.vue";
  exports["default"] = skeleton_vue_vue_type_script_lang$1["default"];
})(skeleton2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var skeleton3 = skeleton$1;
  var skeletonItem3 = skeletonItem$1;
  var skeleton_vue_vue_type_script_lang$1 = skeleton_vue_vue_type_script_lang;
  var skeletonItem_vue_vue_type_script_lang$1 = skeletonItem_vue_vue_type_script_lang;
  const ElSkeleton = withInstall2.withInstall(skeleton_vue_vue_type_script_lang$1["default"], {
    SkeletonItem: skeletonItem_vue_vue_type_script_lang$1["default"]
  });
  const ElSkeletonItem = withInstall2.withNoopInstall(skeletonItem_vue_vue_type_script_lang$1["default"]);
  exports.skeletonProps = skeleton3.skeletonProps;
  exports.skeletonItemProps = skeletonItem3.skeletonItemProps;
  exports.ElSkeleton = ElSkeleton;
  exports.ElSkeletonItem = ElSkeletonItem;
  exports["default"] = ElSkeleton;
})(skeleton$2);
var slider = {};
var src$6 = {};
var index_vue_vue_type_script_lang$5 = {};
var button$1 = {};
var button_vue_vue_type_script_lang = {};
var useSliderButton$1 = {};
Object.defineProperty(useSliderButton$1, "__esModule", { value: true });
var vue$G = require$$0$1;
var debounce$1 = debounce_1;
var constants$5 = constants$f;
var dom$4 = dom$8;
function _interopDefaultLegacy$1(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
var debounce__default$1 = /* @__PURE__ */ _interopDefaultLegacy$1(debounce$1);
const useTooltip = (props2, formatTooltip, showTooltip) => {
  const tooltip2 = vue$G.ref(null);
  const tooltipVisible = vue$G.ref(false);
  const enableFormat = vue$G.computed(() => {
    return formatTooltip.value instanceof Function;
  });
  const formatValue = vue$G.computed(() => {
    return enableFormat.value && formatTooltip.value(props2.modelValue) || props2.modelValue;
  });
  const displayTooltip = debounce__default$1["default"](() => {
    showTooltip.value && (tooltipVisible.value = true);
  }, 50);
  const hideTooltip = debounce__default$1["default"](() => {
    showTooltip.value && (tooltipVisible.value = false);
  }, 50);
  return {
    tooltip: tooltip2,
    tooltipVisible,
    formatValue,
    displayTooltip,
    hideTooltip
  };
};
const useSliderButton = (props2, initData, emit) => {
  const {
    disabled,
    min: min2,
    max: max2,
    step,
    showTooltip,
    precision,
    sliderSize,
    formatTooltip,
    emitChange,
    resetSize,
    updateDragging
  } = vue$G.inject("SliderProvider");
  const { tooltip: tooltip2, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props2, formatTooltip, showTooltip);
  const currentPosition = vue$G.computed(() => {
    return `${(props2.modelValue - min2.value) / (max2.value - min2.value) * 100}%`;
  });
  const wrapperStyle = vue$G.computed(() => {
    return props2.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
  });
  const handleMouseEnter = () => {
    initData.hovering = true;
    displayTooltip();
  };
  const handleMouseLeave = () => {
    initData.hovering = false;
    if (!initData.dragging) {
      hideTooltip();
    }
  };
  const onButtonDown = (event) => {
    if (disabled.value)
      return;
    event.preventDefault();
    onDragStart(event);
    dom$4.on(window, "mousemove", onDragging);
    dom$4.on(window, "touchmove", onDragging);
    dom$4.on(window, "mouseup", onDragEnd);
    dom$4.on(window, "touchend", onDragEnd);
    dom$4.on(window, "contextmenu", onDragEnd);
  };
  const onLeftKeyDown = () => {
    if (disabled.value)
      return;
    initData.newPosition = parseFloat(currentPosition.value) - step.value / (max2.value - min2.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };
  const onRightKeyDown = () => {
    if (disabled.value)
      return;
    initData.newPosition = parseFloat(currentPosition.value) + step.value / (max2.value - min2.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };
  const getClientXY2 = (event) => {
    let clientX;
    let clientY;
    if (event.type.startsWith("touch")) {
      clientY = event.touches[0].clientY;
      clientX = event.touches[0].clientX;
    } else {
      clientY = event.clientY;
      clientX = event.clientX;
    }
    return {
      clientX,
      clientY
    };
  };
  const onDragStart = (event) => {
    initData.dragging = true;
    initData.isClick = true;
    const { clientX, clientY } = getClientXY2(event);
    if (props2.vertical) {
      initData.startY = clientY;
    } else {
      initData.startX = clientX;
    }
    initData.startPosition = parseFloat(currentPosition.value);
    initData.newPosition = initData.startPosition;
  };
  const onDragging = (event) => {
    if (initData.dragging) {
      initData.isClick = false;
      displayTooltip();
      resetSize();
      let diff;
      const { clientX, clientY } = getClientXY2(event);
      if (props2.vertical) {
        initData.currentY = clientY;
        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
      } else {
        initData.currentX = clientX;
        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
      }
      initData.newPosition = initData.startPosition + diff;
      setPosition(initData.newPosition);
    }
  };
  const onDragEnd = () => {
    if (initData.dragging) {
      setTimeout(() => {
        initData.dragging = false;
        if (!initData.hovering) {
          hideTooltip();
        }
        if (!initData.isClick) {
          setPosition(initData.newPosition);
          emitChange();
        }
      }, 0);
      dom$4.off(window, "mousemove", onDragging);
      dom$4.off(window, "touchmove", onDragging);
      dom$4.off(window, "mouseup", onDragEnd);
      dom$4.off(window, "touchend", onDragEnd);
      dom$4.off(window, "contextmenu", onDragEnd);
    }
  };
  const setPosition = async (newPosition) => {
    if (newPosition === null || isNaN(newPosition))
      return;
    if (newPosition < 0) {
      newPosition = 0;
    } else if (newPosition > 100) {
      newPosition = 100;
    }
    const lengthPerStep = 100 / ((max2.value - min2.value) / step.value);
    const steps2 = Math.round(newPosition / lengthPerStep);
    let value = steps2 * lengthPerStep * (max2.value - min2.value) * 0.01 + min2.value;
    value = parseFloat(value.toFixed(precision.value));
    emit(constants$5.UPDATE_MODEL_EVENT, value);
    if (!initData.dragging && props2.modelValue !== initData.oldValue) {
      initData.oldValue = props2.modelValue;
    }
    await vue$G.nextTick();
    initData.dragging && displayTooltip();
    tooltip2.value.updatePopper();
  };
  vue$G.watch(() => initData.dragging, (val) => {
    updateDragging(val);
  });
  return {
    tooltip: tooltip2,
    tooltipVisible,
    showTooltip,
    wrapperStyle,
    formatValue,
    handleMouseEnter,
    handleMouseLeave,
    onButtonDown,
    onLeftKeyDown,
    onRightKeyDown,
    setPosition
  };
};
useSliderButton$1.useSliderButton = useSliderButton;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = tooltip;
  var constants2 = constants$f;
  var useSliderButton2 = useSliderButton$1;
  var script2 = vue2.defineComponent({
    name: "ElSliderButton",
    components: {
      ElTooltip: index2["default"]
    },
    props: {
      modelValue: {
        type: Number,
        default: 0
      },
      vertical: {
        type: Boolean,
        default: false
      },
      tooltipClass: {
        type: String,
        default: ""
      }
    },
    emits: [constants2.UPDATE_MODEL_EVENT],
    setup(props2, { emit }) {
      const initData = vue2.reactive({
        hovering: false,
        dragging: false,
        isClick: false,
        startX: 0,
        currentX: 0,
        startY: 0,
        currentY: 0,
        startPosition: 0,
        newPosition: 0,
        oldValue: props2.modelValue
      });
      const {
        tooltip: tooltip2,
        showTooltip,
        tooltipVisible,
        wrapperStyle,
        formatValue,
        handleMouseEnter,
        handleMouseLeave,
        onButtonDown,
        onLeftKeyDown,
        onRightKeyDown,
        setPosition
      } = useSliderButton2.useSliderButton(props2, initData, emit);
      const { hovering, dragging } = vue2.toRefs(initData);
      return {
        tooltip: tooltip2,
        tooltipVisible,
        showTooltip,
        wrapperStyle,
        formatValue,
        handleMouseEnter,
        handleMouseLeave,
        onButtonDown,
        onLeftKeyDown,
        onRightKeyDown,
        setPosition,
        hovering,
        dragging
      };
    }
  });
  exports["default"] = script2;
})(button_vue_vue_type_script_lang);
var button_vue_vue_type_template_id_9cd3e794_lang = {};
Object.defineProperty(button_vue_vue_type_template_id_9cd3e794_lang, "__esModule", { value: true });
var vue$F = require$$0$1;
function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = vue$F.resolveComponent("el-tooltip");
  return vue$F.openBlock(), vue$F.createElementBlock("div", {
    ref: "button",
    class: vue$F.normalizeClass(["el-slider__button-wrapper", { hover: _ctx.hovering, dragging: _ctx.dragging }]),
    style: vue$F.normalizeStyle(_ctx.wrapperStyle),
    tabindex: "0",
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.onButtonDown && _ctx.onButtonDown(...args)),
    onTouchstart: _cache[4] || (_cache[4] = (...args) => _ctx.onButtonDown && _ctx.onButtonDown(...args)),
    onFocus: _cache[5] || (_cache[5] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onBlur: _cache[6] || (_cache[6] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onKeydown: [
      _cache[7] || (_cache[7] = vue$F.withKeys((...args) => _ctx.onLeftKeyDown && _ctx.onLeftKeyDown(...args), ["left"])),
      _cache[8] || (_cache[8] = vue$F.withKeys((...args) => _ctx.onRightKeyDown && _ctx.onRightKeyDown(...args), ["right"])),
      _cache[9] || (_cache[9] = vue$F.withKeys(vue$F.withModifiers((...args) => _ctx.onLeftKeyDown && _ctx.onLeftKeyDown(...args), ["prevent"]), ["down"])),
      _cache[10] || (_cache[10] = vue$F.withKeys(vue$F.withModifiers((...args) => _ctx.onRightKeyDown && _ctx.onRightKeyDown(...args), ["prevent"]), ["up"]))
    ]
  }, [
    vue$F.createVNode(_component_el_tooltip, {
      ref: "tooltip",
      modelValue: _ctx.tooltipVisible,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.tooltipVisible = $event),
      placement: "top",
      "stop-popper-mouse-event": false,
      "popper-class": _ctx.tooltipClass,
      disabled: !_ctx.showTooltip,
      manual: ""
    }, {
      content: vue$F.withCtx(() => [
        vue$F.createElementVNode("span", null, vue$F.toDisplayString(_ctx.formatValue), 1)
      ]),
      default: vue$F.withCtx(() => [
        vue$F.createElementVNode("div", {
          class: vue$F.normalizeClass(["el-slider__button", { hover: _ctx.hovering, dragging: _ctx.dragging }])
        }, null, 2)
      ]),
      _: 1
    }, 8, ["modelValue", "popper-class", "disabled"])
  ], 38);
}
button_vue_vue_type_template_id_9cd3e794_lang.render = render$n;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var button_vue_vue_type_script_lang$12 = button_vue_vue_type_script_lang;
  var button_vue_vue_type_template_id_9cd3e794_lang$1 = button_vue_vue_type_template_id_9cd3e794_lang;
  button_vue_vue_type_script_lang$12["default"].render = button_vue_vue_type_template_id_9cd3e794_lang$1.render;
  button_vue_vue_type_script_lang$12["default"].__file = "packages/components/slider/src/button.vue";
  exports["default"] = button_vue_vue_type_script_lang$12["default"];
})(button$1);
var marker = {};
var marker_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElMarker",
    props: {
      mark: {
        type: [String, Object],
        default: () => void 0
      }
    },
    setup(props2) {
      const label = vue2.computed(() => {
        return typeof props2.mark === "string" ? props2.mark : props2.mark.label;
      });
      return {
        label
      };
    },
    render() {
      var _a;
      return vue2.h("div", {
        class: "el-slider__marks-text",
        style: (_a = this.mark) == null ? void 0 : _a.style
      }, this.label);
    }
  });
  exports["default"] = script2;
})(marker_vue_vue_type_script_lang);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var marker_vue_vue_type_script_lang$1 = marker_vue_vue_type_script_lang;
  marker_vue_vue_type_script_lang$1["default"].__file = "packages/components/slider/src/marker.vue";
  exports["default"] = marker_vue_vue_type_script_lang$1["default"];
})(marker);
var useMarks$1 = {};
Object.defineProperty(useMarks$1, "__esModule", { value: true });
var vue$E = require$$0$1;
const useMarks = (props2) => {
  return vue$E.computed(() => {
    if (!props2.marks) {
      return [];
    }
    const marksKeys = Object.keys(props2.marks);
    return marksKeys.map(parseFloat).sort((a2, b2) => a2 - b2).filter((point) => point <= props2.max && point >= props2.min).map((point) => ({
      point,
      position: (point - props2.min) * 100 / (props2.max - props2.min),
      mark: props2.marks[point]
    }));
  });
};
useMarks$1.useMarks = useMarks;
var useSlide$1 = {};
Object.defineProperty(useSlide$1, "__esModule", { value: true });
var vue$D = require$$0$1;
var constants$4 = constants$f;
var form = form$7;
const useSlide = (props2, initData, emit) => {
  const elForm = vue$D.inject(form.elFormKey, {});
  const elFormItem = vue$D.inject(form.elFormItemKey, {});
  const slider2 = vue$D.shallowRef(null);
  const firstButton = vue$D.ref(null);
  const secondButton = vue$D.ref(null);
  const buttonRefs = {
    firstButton,
    secondButton
  };
  const sliderDisabled = vue$D.computed(() => {
    return props2.disabled || elForm.disabled || false;
  });
  const minValue = vue$D.computed(() => {
    return Math.min(initData.firstValue, initData.secondValue);
  });
  const maxValue = vue$D.computed(() => {
    return Math.max(initData.firstValue, initData.secondValue);
  });
  const barSize = vue$D.computed(() => {
    return props2.range ? `${100 * (maxValue.value - minValue.value) / (props2.max - props2.min)}%` : `${100 * (initData.firstValue - props2.min) / (props2.max - props2.min)}%`;
  });
  const barStart = vue$D.computed(() => {
    return props2.range ? `${100 * (minValue.value - props2.min) / (props2.max - props2.min)}%` : "0%";
  });
  const runwayStyle = vue$D.computed(() => {
    return props2.vertical ? { height: props2.height } : {};
  });
  const barStyle = vue$D.computed(() => {
    return props2.vertical ? {
      height: barSize.value,
      bottom: barStart.value
    } : {
      width: barSize.value,
      left: barStart.value
    };
  });
  const resetSize = () => {
    if (slider2.value) {
      initData.sliderSize = slider2.value[`client${props2.vertical ? "Height" : "Width"}`];
    }
  };
  const setPosition = (percent) => {
    const targetValue = props2.min + percent * (props2.max - props2.min) / 100;
    if (!props2.range) {
      firstButton.value.setPosition(percent);
      return;
    }
    let buttonRefName;
    if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
      buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
    } else {
      buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
    }
    buttonRefs[buttonRefName].value.setPosition(percent);
  };
  const setFirstValue = (firstValue) => {
    initData.firstValue = firstValue;
    _emit(props2.range ? [minValue.value, maxValue.value] : firstValue);
  };
  const setSecondValue = (secondValue) => {
    initData.secondValue = secondValue;
    if (props2.range) {
      _emit([minValue.value, maxValue.value]);
    }
  };
  const _emit = (val) => {
    emit(constants$4.UPDATE_MODEL_EVENT, val);
    emit(constants$4.INPUT_EVENT, val);
  };
  const emitChange = async () => {
    await vue$D.nextTick();
    emit(constants$4.CHANGE_EVENT, props2.range ? [minValue.value, maxValue.value] : props2.modelValue);
  };
  const onSliderClick = (event) => {
    if (sliderDisabled.value || initData.dragging)
      return;
    resetSize();
    if (props2.vertical) {
      const sliderOffsetBottom = slider2.value.getBoundingClientRect().bottom;
      setPosition((sliderOffsetBottom - event.clientY) / initData.sliderSize * 100);
    } else {
      const sliderOffsetLeft = slider2.value.getBoundingClientRect().left;
      setPosition((event.clientX - sliderOffsetLeft) / initData.sliderSize * 100);
    }
    emitChange();
  };
  return {
    elFormItem,
    slider: slider2,
    firstButton,
    secondButton,
    sliderDisabled,
    minValue,
    maxValue,
    runwayStyle,
    barStyle,
    resetSize,
    setPosition,
    emitChange,
    onSliderClick,
    setFirstValue,
    setSecondValue
  };
};
useSlide$1.useSlide = useSlide;
var useStops$1 = {};
Object.defineProperty(useStops$1, "__esModule", { value: true });
var vue$C = require$$0$1;
var error = error$5;
const useStops = (props2, initData, minValue, maxValue) => {
  const stops = vue$C.computed(() => {
    if (!props2.showStops || props2.min > props2.max)
      return [];
    if (props2.step === 0) {
      error.debugWarn("Slider", "step should not be 0.");
      return [];
    }
    const stopCount = (props2.max - props2.min) / props2.step;
    const stepWidth = 100 * props2.step / (props2.max - props2.min);
    const result3 = Array.from({ length: stopCount - 1 }).map((_2, index2) => (index2 + 1) * stepWidth);
    if (props2.range) {
      return result3.filter((step) => {
        return step < 100 * (minValue.value - props2.min) / (props2.max - props2.min) || step > 100 * (maxValue.value - props2.min) / (props2.max - props2.min);
      });
    } else {
      return result3.filter((step) => step > 100 * (initData.firstValue - props2.min) / (props2.max - props2.min));
    }
  });
  const getStopStyle = (position2) => {
    return props2.vertical ? { bottom: `${position2}%` } : { left: `${position2}%` };
  };
  return {
    stops,
    getStopStyle
  };
};
useStops$1.useStops = useStops;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = inputNumber$2;
  var constants2 = constants$f;
  var dom2 = dom$8;
  var error2 = error$5;
  var useMarks2 = useMarks$1;
  var useSlide2 = useSlide$1;
  var useStops2 = useStops$1;
  var button_vue_vue_type_script_lang$12 = button_vue_vue_type_script_lang;
  var marker_vue_vue_type_script_lang$1 = marker_vue_vue_type_script_lang;
  var script2 = vue2.defineComponent({
    name: "ElSlider",
    components: {
      ElInputNumber: index2.ElInputNumber,
      SliderButton: button_vue_vue_type_script_lang$12["default"],
      SliderMarker: marker_vue_vue_type_script_lang$1["default"]
    },
    props: {
      modelValue: {
        type: [Number, Array],
        default: 0
      },
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      step: {
        type: Number,
        default: 1
      },
      showInput: {
        type: Boolean,
        default: false
      },
      showInputControls: {
        type: Boolean,
        default: true
      },
      inputSize: {
        type: String,
        default: "small"
      },
      showStops: {
        type: Boolean,
        default: false
      },
      showTooltip: {
        type: Boolean,
        default: true
      },
      formatTooltip: {
        type: Function,
        default: void 0
      },
      disabled: {
        type: Boolean,
        default: false
      },
      range: {
        type: Boolean,
        default: false
      },
      vertical: {
        type: Boolean,
        default: false
      },
      height: {
        type: String,
        default: ""
      },
      debounce: {
        type: Number,
        default: 300
      },
      label: {
        type: String,
        default: void 0
      },
      tooltipClass: {
        type: String,
        default: void 0
      },
      marks: Object
    },
    emits: [constants2.UPDATE_MODEL_EVENT, constants2.CHANGE_EVENT, constants2.INPUT_EVENT],
    setup(props2, { emit }) {
      const initData = vue2.reactive({
        firstValue: 0,
        secondValue: 0,
        oldValue: 0,
        dragging: false,
        sliderSize: 1
      });
      const {
        elFormItem,
        slider: slider2,
        firstButton,
        secondButton,
        sliderDisabled,
        minValue,
        maxValue,
        runwayStyle,
        barStyle,
        resetSize,
        emitChange,
        onSliderClick,
        setFirstValue,
        setSecondValue
      } = useSlide2.useSlide(props2, initData, emit);
      const { stops, getStopStyle } = useStops2.useStops(props2, initData, minValue, maxValue);
      const markList = useMarks2.useMarks(props2);
      useWatch(props2, initData, minValue, maxValue, emit, elFormItem);
      const precision = vue2.computed(() => {
        const precisions = [props2.min, props2.max, props2.step].map((item2) => {
          const decimal = `${item2}`.split(".")[1];
          return decimal ? decimal.length : 0;
        });
        return Math.max.apply(null, precisions);
      });
      const { sliderWrapper } = useLifecycle(props2, initData, resetSize);
      const { firstValue, secondValue, oldValue, dragging, sliderSize } = vue2.toRefs(initData);
      const updateDragging = (val) => {
        initData.dragging = val;
      };
      vue2.provide("SliderProvider", __spreadProps(__spreadValues({}, vue2.toRefs(props2)), {
        sliderSize,
        disabled: sliderDisabled,
        precision,
        emitChange,
        resetSize,
        updateDragging
      }));
      return {
        firstValue,
        secondValue,
        oldValue,
        dragging,
        sliderSize,
        slider: slider2,
        firstButton,
        secondButton,
        sliderDisabled,
        runwayStyle,
        barStyle,
        emitChange,
        onSliderClick,
        getStopStyle,
        setFirstValue,
        setSecondValue,
        stops,
        markList,
        sliderWrapper
      };
    }
  });
  const useWatch = (props2, initData, minValue, maxValue, emit, elFormItem) => {
    const _emit = (val) => {
      emit(constants2.UPDATE_MODEL_EVENT, val);
      emit(constants2.INPUT_EVENT, val);
    };
    const valueChanged = () => {
      if (props2.range) {
        return ![minValue.value, maxValue.value].every((item2, index3) => item2 === initData.oldValue[index3]);
      } else {
        return props2.modelValue !== initData.oldValue;
      }
    };
    const setValues = () => {
      var _a, _b;
      if (props2.min > props2.max) {
        error2.throwError("Slider", "min should not be greater than max.");
        return;
      }
      const val = props2.modelValue;
      if (props2.range && Array.isArray(val)) {
        if (val[1] < props2.min) {
          _emit([props2.min, props2.min]);
        } else if (val[0] > props2.max) {
          _emit([props2.max, props2.max]);
        } else if (val[0] < props2.min) {
          _emit([props2.min, val[1]]);
        } else if (val[1] > props2.max) {
          _emit([val[0], props2.max]);
        } else {
          initData.firstValue = val[0];
          initData.secondValue = val[1];
          if (valueChanged()) {
            (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change");
            initData.oldValue = val.slice();
          }
        }
      } else if (!props2.range && typeof val === "number" && !isNaN(val)) {
        if (val < props2.min) {
          _emit(props2.min);
        } else if (val > props2.max) {
          _emit(props2.max);
        } else {
          initData.firstValue = val;
          if (valueChanged()) {
            (_b = elFormItem.validate) == null ? void 0 : _b.call(elFormItem, "change");
            initData.oldValue = val;
          }
        }
      }
    };
    setValues();
    vue2.watch(() => initData.dragging, (val) => {
      if (!val) {
        setValues();
      }
    });
    vue2.watch(() => props2.modelValue, (val, oldVal) => {
      if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item2, index3) => item2 === oldVal[index3])) {
        return;
      }
      setValues();
    });
    vue2.watch(() => [props2.min, props2.max], () => {
      setValues();
    });
  };
  const useLifecycle = (props2, initData, resetSize) => {
    const sliderWrapper = vue2.ref(null);
    vue2.onMounted(async () => {
      let valuetext;
      if (props2.range) {
        if (Array.isArray(props2.modelValue)) {
          initData.firstValue = Math.max(props2.min, props2.modelValue[0]);
          initData.secondValue = Math.min(props2.max, props2.modelValue[1]);
        } else {
          initData.firstValue = props2.min;
          initData.secondValue = props2.max;
        }
        initData.oldValue = [initData.firstValue, initData.secondValue];
        valuetext = `${initData.firstValue}-${initData.secondValue}`;
      } else {
        if (typeof props2.modelValue !== "number" || isNaN(props2.modelValue)) {
          initData.firstValue = props2.min;
        } else {
          initData.firstValue = Math.min(props2.max, Math.max(props2.min, props2.modelValue));
        }
        initData.oldValue = initData.firstValue;
        valuetext = initData.firstValue;
      }
      sliderWrapper.value.setAttribute("aria-valuetext", valuetext);
      sliderWrapper.value.setAttribute("aria-label", props2.label ? props2.label : `slider between ${props2.min} and ${props2.max}`);
      dom2.on(window, "resize", resetSize);
      await vue2.nextTick();
      resetSize();
    });
    vue2.onBeforeUnmount(() => {
      dom2.off(window, "resize", resetSize);
    });
    return {
      sliderWrapper
    };
  };
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$5);
var index_vue_vue_type_template_id_24c42d04_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_24c42d04_lang, "__esModule", { value: true });
var vue$B = require$$0$1;
const _hoisted_1$h = ["aria-valuemin", "aria-valuemax", "aria-orientation", "aria-disabled"];
const _hoisted_2$e = { key: 1 };
const _hoisted_3$c = { class: "el-slider__marks" };
function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = vue$B.resolveComponent("el-input-number");
  const _component_slider_button = vue$B.resolveComponent("slider-button");
  const _component_slider_marker = vue$B.resolveComponent("slider-marker");
  return vue$B.openBlock(), vue$B.createElementBlock("div", {
    ref: "sliderWrapper",
    class: vue$B.normalizeClass(["el-slider", { "is-vertical": _ctx.vertical, "el-slider--with-input": _ctx.showInput }]),
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuemax": _ctx.max,
    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
    "aria-disabled": _ctx.sliderDisabled
  }, [
    _ctx.showInput && !_ctx.range ? (vue$B.openBlock(), vue$B.createBlock(_component_el_input_number, {
      key: 0,
      ref: "input",
      "model-value": _ctx.firstValue,
      class: "el-slider__input",
      step: _ctx.step,
      disabled: _ctx.sliderDisabled,
      controls: _ctx.showInputControls,
      min: _ctx.min,
      max: _ctx.max,
      debounce: _ctx.debounce,
      size: _ctx.inputSize,
      "onUpdate:modelValue": _ctx.setFirstValue,
      onChange: _ctx.emitChange
    }, null, 8, ["model-value", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : vue$B.createCommentVNode("v-if", true),
    vue$B.createElementVNode("div", {
      ref: "slider",
      class: vue$B.normalizeClass(["el-slider__runway", { "show-input": _ctx.showInput && !_ctx.range, disabled: _ctx.sliderDisabled }]),
      style: vue$B.normalizeStyle(_ctx.runwayStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onSliderClick && _ctx.onSliderClick(...args))
    }, [
      vue$B.createElementVNode("div", {
        class: "el-slider__bar",
        style: vue$B.normalizeStyle(_ctx.barStyle)
      }, null, 4),
      vue$B.createVNode(_component_slider_button, {
        ref: "firstButton",
        "model-value": _ctx.firstValue,
        vertical: _ctx.vertical,
        "tooltip-class": _ctx.tooltipClass,
        "onUpdate:modelValue": _ctx.setFirstValue
      }, null, 8, ["model-value", "vertical", "tooltip-class", "onUpdate:modelValue"]),
      _ctx.range ? (vue$B.openBlock(), vue$B.createBlock(_component_slider_button, {
        key: 0,
        ref: "secondButton",
        "model-value": _ctx.secondValue,
        vertical: _ctx.vertical,
        "tooltip-class": _ctx.tooltipClass,
        "onUpdate:modelValue": _ctx.setSecondValue
      }, null, 8, ["model-value", "vertical", "tooltip-class", "onUpdate:modelValue"])) : vue$B.createCommentVNode("v-if", true),
      _ctx.showStops ? (vue$B.openBlock(), vue$B.createElementBlock("div", _hoisted_2$e, [
        (vue$B.openBlock(true), vue$B.createElementBlock(vue$B.Fragment, null, vue$B.renderList(_ctx.stops, (item2, key2) => {
          return vue$B.openBlock(), vue$B.createElementBlock("div", {
            key: key2,
            class: "el-slider__stop",
            style: vue$B.normalizeStyle(_ctx.getStopStyle(item2))
          }, null, 4);
        }), 128))
      ])) : vue$B.createCommentVNode("v-if", true),
      _ctx.markList.length > 0 ? (vue$B.openBlock(), vue$B.createElementBlock(vue$B.Fragment, { key: 2 }, [
        vue$B.createElementVNode("div", null, [
          (vue$B.openBlock(true), vue$B.createElementBlock(vue$B.Fragment, null, vue$B.renderList(_ctx.markList, (item2, key2) => {
            return vue$B.openBlock(), vue$B.createElementBlock("div", {
              key: key2,
              style: vue$B.normalizeStyle(_ctx.getStopStyle(item2.position)),
              class: "el-slider__stop el-slider__marks-stop"
            }, null, 4);
          }), 128))
        ]),
        vue$B.createElementVNode("div", _hoisted_3$c, [
          (vue$B.openBlock(true), vue$B.createElementBlock(vue$B.Fragment, null, vue$B.renderList(_ctx.markList, (item2, key2) => {
            return vue$B.openBlock(), vue$B.createBlock(_component_slider_marker, {
              key: key2,
              mark: item2.mark,
              style: vue$B.normalizeStyle(_ctx.getStopStyle(item2.position))
            }, null, 8, ["mark", "style"]);
          }), 128))
        ])
      ], 64)) : vue$B.createCommentVNode("v-if", true)
    ], 6)
  ], 10, _hoisted_1$h);
}
index_vue_vue_type_template_id_24c42d04_lang.render = render$m;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$5;
  var index_vue_vue_type_template_id_24c42d04_lang$1 = index_vue_vue_type_template_id_24c42d04_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_24c42d04_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/slider/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$6);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$5;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  const _Slider = index_vue_vue_type_script_lang2["default"];
  const ElSlider = _Slider;
  exports.ElSlider = ElSlider;
  exports["default"] = _Slider;
})(slider);
var space$2 = {};
var space$1 = {};
var item$2 = {};
var item_vue_vue_type_script_lang$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var props2 = props$N;
  const spaceItem = props2.buildProps({
    prefixCls: {
      type: String,
      default: "el-space"
    }
  });
  var script2 = vue2.defineComponent({
    props: spaceItem,
    setup(props3) {
      const classes = vue2.computed(() => [`${props3.prefixCls}__item`]);
      return {
        classes
      };
    }
  });
  exports["default"] = script2;
})(item_vue_vue_type_script_lang$2);
var item_vue_vue_type_template_id_88dfb868_lang = {};
Object.defineProperty(item_vue_vue_type_template_id_88dfb868_lang, "__esModule", { value: true });
var vue$A = require$$0$1;
function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$A.openBlock(), vue$A.createElementBlock("div", {
    class: vue$A.normalizeClass(_ctx.classes)
  }, [
    vue$A.renderSlot(_ctx.$slots, "default")
  ], 2);
}
item_vue_vue_type_template_id_88dfb868_lang.render = render$l;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var item_vue_vue_type_script_lang2 = item_vue_vue_type_script_lang$2;
  var item_vue_vue_type_template_id_88dfb868_lang$1 = item_vue_vue_type_template_id_88dfb868_lang;
  item_vue_vue_type_script_lang2["default"].render = item_vue_vue_type_template_id_88dfb868_lang$1.render;
  item_vue_vue_type_script_lang2["default"].__file = "packages/components/space/src/item.vue";
  exports["default"] = item_vue_vue_type_script_lang2["default"];
})(item$2);
var useSpace$2 = {};
Object.defineProperty(useSpace$2, "__esModule", { value: true });
var vue$z = require$$0$1;
var util$5 = util$l;
const SIZE_MAP = {
  mini: 4,
  small: 8,
  medium: 12,
  large: 16
};
function useSpace$1(props2) {
  const classes = vue$z.computed(() => [
    "el-space",
    `el-space--${props2.direction}`,
    props2.class
  ]);
  const horizontalSize = vue$z.ref(0);
  const verticalSize = vue$z.ref(0);
  const containerStyle = vue$z.computed(() => {
    const wrapKls = props2.wrap || props2.fill ? { flexWrap: "wrap", marginBottom: `-${verticalSize.value}px` } : {};
    const alignment = {
      alignItems: props2.alignment
    };
    return [wrapKls, alignment, props2.style];
  });
  const itemStyle = vue$z.computed(() => {
    const itemBaseStyle = {
      paddingBottom: `${verticalSize.value}px`,
      marginRight: `${horizontalSize.value}px`
    };
    const fillStyle = props2.fill ? { flexGrow: 1, minWidth: `${props2.fillRatio}%` } : {};
    return [itemBaseStyle, fillStyle];
  });
  vue$z.watchEffect(() => {
    const { size: size2 = "small", wrap, direction: dir, fill } = props2;
    if (Array.isArray(size2)) {
      const [h2 = 0, v2 = 0] = size2;
      horizontalSize.value = h2;
      verticalSize.value = v2;
    } else {
      let val;
      if (util$5.isNumber(size2)) {
        val = size2;
      } else {
        val = SIZE_MAP[size2] || SIZE_MAP.small;
      }
      if ((wrap || fill) && dir === "horizontal") {
        horizontalSize.value = verticalSize.value = val;
      } else {
        if (dir === "horizontal") {
          horizontalSize.value = val;
          verticalSize.value = 0;
        } else {
          verticalSize.value = val;
          horizontalSize.value = 0;
        }
      }
    }
  });
  return {
    classes,
    containerStyle,
    itemStyle
  };
}
useSpace$2.useSpace = useSpace$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var vnode2 = vnode$1;
  var util2 = util$l;
  var props2 = props$N;
  var useSpace2 = useSpace$2;
  var item_vue_vue_type_script_lang2 = item_vue_vue_type_script_lang$2;
  const spaceProps = props2.buildProps({
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    class: {
      type: props2.definePropType([
        String,
        Object,
        Array
      ]),
      default: ""
    },
    style: {
      type: props2.definePropType([String, Array, Object]),
      default: ""
    },
    alignment: {
      type: props2.definePropType(String),
      default: "center"
    },
    prefixCls: {
      type: String
    },
    spacer: {
      type: props2.definePropType([Object, String, Number, Array]),
      default: null,
      validator: (val) => vue2.isVNode(val) || util2.isNumber(val) || shared2.isString(val)
    },
    wrap: {
      type: Boolean,
      default: false
    },
    fill: {
      type: Boolean,
      default: false
    },
    fillRatio: {
      type: Number,
      default: 100
    },
    size: {
      type: [String, Array, Number],
      values: props2.componentSize,
      validator: (val) => {
        return util2.isNumber(val) || shared2.isArray(val) && val.length === 2 && val.every((i) => util2.isNumber(i));
      }
    }
  });
  var Space = vue2.defineComponent({
    name: "ElSpace",
    props: spaceProps,
    setup(props3, { slots }) {
      const { classes, containerStyle, itemStyle } = useSpace2.useSpace(props3);
      return () => {
        var _a;
        const { spacer, prefixCls, direction: direction2 } = props3;
        const children = vue2.renderSlot(slots, "default", { key: 0 }, () => []);
        if (((_a = children.children) != null ? _a : []).length === 0)
          return null;
        if (shared2.isArray(children.children)) {
          let extractedChildren = [];
          children.children.forEach((child, loopKey) => {
            if (vnode2.isFragment(child)) {
              if (shared2.isArray(child.children)) {
                child.children.forEach((nested, key2) => {
                  extractedChildren.push(vue2.createVNode(item_vue_vue_type_script_lang2["default"], {
                    style: itemStyle.value,
                    prefixCls,
                    key: `nested-${key2}`
                  }, {
                    default: () => [nested]
                  }, vnode2.PatchFlags.PROPS | vnode2.PatchFlags.STYLE, ["style", "prefixCls"]));
                });
              }
            } else if (vnode2.isValidElementNode(child)) {
              extractedChildren.push(vue2.createVNode(item_vue_vue_type_script_lang2["default"], {
                style: itemStyle.value,
                prefixCls,
                key: `LoopKey${loopKey}`
              }, {
                default: () => [child]
              }, vnode2.PatchFlags.PROPS | vnode2.PatchFlags.STYLE, ["style", "prefixCls"]));
            }
          });
          if (spacer) {
            const len = extractedChildren.length - 1;
            extractedChildren = extractedChildren.reduce((acc, child, idx) => {
              const children2 = [...acc, child];
              if (idx !== len) {
                children2.push(vue2.createVNode("span", {
                  style: [
                    itemStyle.value,
                    direction2 === "vertical" ? "width: 100%" : null
                  ],
                  key: idx
                }, [
                  vue2.isVNode(spacer) ? spacer : vue2.createTextVNode(spacer, vnode2.PatchFlags.TEXT)
                ], vnode2.PatchFlags.STYLE));
              }
              return children2;
            }, []);
          }
          return vue2.createVNode("div", {
            class: classes.value,
            style: containerStyle.value
          }, extractedChildren, vnode2.PatchFlags.STYLE | vnode2.PatchFlags.CLASS);
        }
        return children.children;
      };
    }
  });
  exports["default"] = Space;
  exports.spaceProps = spaceProps;
})(space$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var space2 = space$1;
  var useSpace2 = useSpace$2;
  const ElSpace = withInstall2.withInstall(space2["default"]);
  exports.spaceProps = space2.spaceProps;
  exports.useSpace = useSpace2.useSpace;
  exports.ElSpace = ElSpace;
  exports["default"] = ElSpace;
})(space$2);
var steps = {};
var src$5 = {};
var index_vue_vue_type_script_lang$4 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var constants2 = constants$f;
  var script2 = vue2.defineComponent({
    name: "ElSteps",
    props: {
      space: {
        type: [Number, String],
        default: ""
      },
      active: {
        type: Number,
        default: 0
      },
      direction: {
        type: String,
        default: "horizontal",
        validator: (val) => ["horizontal", "vertical"].includes(val)
      },
      alignCenter: {
        type: Boolean,
        default: false
      },
      simple: {
        type: Boolean,
        default: false
      },
      finishStatus: {
        type: String,
        default: "finish",
        validator: (val) => ["wait", "process", "finish", "error", "success"].includes(val)
      },
      processStatus: {
        type: String,
        default: "process",
        validator: (val) => ["wait", "process", "finish", "error", "success"].includes(val)
      }
    },
    emits: [constants2.CHANGE_EVENT],
    setup(props2, { emit }) {
      const steps2 = vue2.ref([]);
      vue2.watch(steps2, () => {
        steps2.value.forEach((instance, index2) => {
          instance.setIndex(index2);
        });
      });
      vue2.provide("ElSteps", { props: props2, steps: steps2 });
      vue2.watch(() => props2.active, (newVal, oldVal) => {
        emit(constants2.CHANGE_EVENT, newVal, oldVal);
      });
      return {
        steps: steps2
      };
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$4);
var index_vue_vue_type_template_id_882d196c_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_882d196c_lang, "__esModule", { value: true });
var vue$y = require$$0$1;
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$y.openBlock(), vue$y.createElementBlock("div", {
    class: vue$y.normalizeClass([
      "el-steps",
      _ctx.simple ? "el-steps--simple" : `el-steps--${_ctx.direction}`
    ])
  }, [
    vue$y.renderSlot(_ctx.$slots, "default")
  ], 2);
}
index_vue_vue_type_template_id_882d196c_lang.render = render$k;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$4;
  var index_vue_vue_type_template_id_882d196c_lang$1 = index_vue_vue_type_template_id_882d196c_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_882d196c_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/steps/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$5);
var item$1 = {};
var item_vue_vue_type_script_lang$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var script2 = vue2.defineComponent({
    name: "ElStep",
    components: {
      ElIcon: index2.ElIcon,
      Close: iconsVue2.Close,
      Check: iconsVue2.Check
    },
    props: {
      title: {
        type: String,
        default: ""
      },
      icon: {
        type: [String, Object],
        default: ""
      },
      description: {
        type: String,
        default: ""
      },
      status: {
        type: String,
        default: "",
        validator: (val) => ["", "wait", "process", "finish", "error", "success"].includes(val)
      }
    },
    setup(props2) {
      const index3 = vue2.ref(-1);
      const lineStyle = vue2.ref({});
      const internalStatus = vue2.ref("");
      const parent = vue2.inject("ElSteps");
      const currentInstance2 = vue2.getCurrentInstance();
      vue2.onMounted(() => {
        vue2.watch([
          () => parent.props.active,
          () => parent.props.processStatus,
          () => parent.props.finishStatus
        ], ([active]) => {
          updateStatus(active);
        }, { immediate: true });
      });
      vue2.onBeforeUnmount(() => {
        parent.steps.value = parent.steps.value.filter((instance) => instance.uid !== currentInstance2.uid);
      });
      const currentStatus = vue2.computed(() => {
        return props2.status || internalStatus.value;
      });
      const prevStatus = vue2.computed(() => {
        const prevStep = parent.steps.value[index3.value - 1];
        return prevStep ? prevStep.currentStatus : "wait";
      });
      const isCenter = vue2.computed(() => {
        return parent.props.alignCenter;
      });
      const isVertical = vue2.computed(() => {
        return parent.props.direction === "vertical";
      });
      const isSimple = vue2.computed(() => {
        return parent.props.simple;
      });
      const stepsCount = vue2.computed(() => {
        return parent.steps.value.length;
      });
      const isLast = vue2.computed(() => {
        var _a;
        return ((_a = parent.steps.value[stepsCount.value - 1]) == null ? void 0 : _a.uid) === currentInstance2.uid;
      });
      const space2 = vue2.computed(() => {
        return isSimple.value ? "" : parent.props.space;
      });
      const style = vue2.computed(() => {
        const style2 = {
          flexBasis: typeof space2.value === "number" ? `${space2.value}px` : space2.value ? space2.value : `${100 / (stepsCount.value - (isCenter.value ? 0 : 1))}%`
        };
        if (isVertical.value)
          return style2;
        if (isLast.value) {
          style2.maxWidth = `${100 / stepsCount.value}%`;
        }
        return style2;
      });
      const setIndex = (val) => {
        index3.value = val;
      };
      const calcProgress = (status) => {
        let step = 100;
        const style2 = {};
        style2.transitionDelay = `${150 * index3.value}ms`;
        if (status === parent.props.processStatus) {
          step = 0;
        } else if (status === "wait") {
          step = 0;
          style2.transitionDelay = `${-150 * index3.value}ms`;
        }
        style2.borderWidth = step && !isSimple.value ? "1px" : 0;
        style2[parent.props.direction === "vertical" ? "height" : "width"] = `${step}%`;
        lineStyle.value = style2;
      };
      const updateStatus = (activeIndex) => {
        if (activeIndex > index3.value) {
          internalStatus.value = parent.props.finishStatus;
        } else if (activeIndex === index3.value && prevStatus.value !== "error") {
          internalStatus.value = parent.props.processStatus;
        } else {
          internalStatus.value = "wait";
        }
        const prevChild = parent.steps.value[stepsCount.value - 1];
        if (prevChild)
          prevChild.calcProgress(internalStatus.value);
      };
      const stepItemState = vue2.reactive({
        uid: vue2.computed(() => currentInstance2.uid),
        currentStatus,
        setIndex,
        calcProgress
      });
      parent.steps.value = [...parent.steps.value, stepItemState];
      return {
        index: index3,
        lineStyle,
        currentStatus,
        isCenter,
        isVertical,
        isSimple,
        isLast,
        space: space2,
        style,
        parent,
        setIndex,
        calcProgress,
        updateStatus
      };
    }
  });
  exports["default"] = script2;
})(item_vue_vue_type_script_lang$1);
var item_vue_vue_type_template_id_6ec47f4b_lang = {};
Object.defineProperty(item_vue_vue_type_template_id_6ec47f4b_lang, "__esModule", { value: true });
var vue$x = require$$0$1;
const _hoisted_1$g = { class: "el-step__line" };
const _hoisted_2$d = {
  key: 1,
  class: "el-step__icon-inner"
};
const _hoisted_3$b = { class: "el-step__main" };
const _hoisted_4$8 = {
  key: 0,
  class: "el-step__arrow"
};
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$x.resolveComponent("el-icon");
  const _component_check = vue$x.resolveComponent("check");
  const _component_close = vue$x.resolveComponent("close");
  return vue$x.openBlock(), vue$x.createElementBlock("div", {
    style: vue$x.normalizeStyle(_ctx.style),
    class: vue$x.normalizeClass([
      "el-step",
      _ctx.isSimple ? "is-simple" : `is-${_ctx.parent.props.direction}`,
      _ctx.isLast && !_ctx.space && !_ctx.isCenter && "is-flex",
      _ctx.isCenter && !_ctx.isVertical && !_ctx.isSimple && "is-center"
    ])
  }, [
    vue$x.createCommentVNode(" icon & line "),
    vue$x.createElementVNode("div", {
      class: vue$x.normalizeClass(["el-step__head", `is-${_ctx.currentStatus}`])
    }, [
      vue$x.createElementVNode("div", _hoisted_1$g, [
        vue$x.createElementVNode("i", {
          class: "el-step__line-inner",
          style: vue$x.normalizeStyle(_ctx.lineStyle)
        }, null, 4)
      ]),
      vue$x.createElementVNode("div", {
        class: vue$x.normalizeClass(["el-step__icon", `is-${_ctx.icon ? "icon" : "text"}`])
      }, [
        _ctx.currentStatus !== "success" && _ctx.currentStatus !== "error" ? vue$x.renderSlot(_ctx.$slots, "icon", { key: 0 }, () => [
          _ctx.icon ? (vue$x.openBlock(), vue$x.createBlock(_component_el_icon, {
            key: 0,
            class: "el-step__icon-inner"
          }, {
            default: vue$x.withCtx(() => [
              (vue$x.openBlock(), vue$x.createBlock(vue$x.resolveDynamicComponent(_ctx.icon)))
            ]),
            _: 1
          })) : vue$x.createCommentVNode("v-if", true),
          !_ctx.icon && !_ctx.isSimple ? (vue$x.openBlock(), vue$x.createElementBlock("div", _hoisted_2$d, vue$x.toDisplayString(_ctx.index + 1), 1)) : vue$x.createCommentVNode("v-if", true)
        ]) : (vue$x.openBlock(), vue$x.createBlock(_component_el_icon, {
          key: 1,
          class: "el-step__icon-inner is-status"
        }, {
          default: vue$x.withCtx(() => [
            _ctx.currentStatus === "success" ? (vue$x.openBlock(), vue$x.createBlock(_component_check, { key: 0 })) : (vue$x.openBlock(), vue$x.createBlock(_component_close, { key: 1 }))
          ]),
          _: 1
        }))
      ], 2)
    ], 2),
    vue$x.createCommentVNode(" title & description "),
    vue$x.createElementVNode("div", _hoisted_3$b, [
      vue$x.createElementVNode("div", {
        class: vue$x.normalizeClass(["el-step__title", `is-${_ctx.currentStatus}`])
      }, [
        vue$x.renderSlot(_ctx.$slots, "title", {}, () => [
          vue$x.createTextVNode(vue$x.toDisplayString(_ctx.title), 1)
        ])
      ], 2),
      _ctx.isSimple ? (vue$x.openBlock(), vue$x.createElementBlock("div", _hoisted_4$8)) : (vue$x.openBlock(), vue$x.createElementBlock("div", {
        key: 1,
        class: vue$x.normalizeClass(["el-step__description", `is-${_ctx.currentStatus}`])
      }, [
        vue$x.renderSlot(_ctx.$slots, "description", {}, () => [
          vue$x.createTextVNode(vue$x.toDisplayString(_ctx.description), 1)
        ])
      ], 2))
    ])
  ], 6);
}
item_vue_vue_type_template_id_6ec47f4b_lang.render = render$j;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var item_vue_vue_type_script_lang2 = item_vue_vue_type_script_lang$1;
  var item_vue_vue_type_template_id_6ec47f4b_lang$1 = item_vue_vue_type_template_id_6ec47f4b_lang;
  item_vue_vue_type_script_lang2["default"].render = item_vue_vue_type_template_id_6ec47f4b_lang$1.render;
  item_vue_vue_type_script_lang2["default"].__file = "packages/components/steps/src/item.vue";
  exports["default"] = item_vue_vue_type_script_lang2["default"];
})(item$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$4;
  var item_vue_vue_type_script_lang2 = item_vue_vue_type_script_lang$1;
  const ElSteps = withInstall2.withInstall(index_vue_vue_type_script_lang2["default"], {
    Step: item_vue_vue_type_script_lang2["default"]
  });
  const ElStep = withInstall2.withNoopInstall(item_vue_vue_type_script_lang2["default"]);
  exports.ElStep = ElStep;
  exports.ElSteps = ElSteps;
  exports["default"] = ElSteps;
})(steps);
var _switch$2 = {};
var switch2 = {};
var switch_vue_vue_type_script_lang = {};
var _switch$1 = {};
Object.defineProperty(_switch$1, "__esModule", { value: true });
var props$7 = props$N;
var constants$3 = constants$f;
var util$4 = util$l;
var shared$3 = require$$1$1;
const switchProps = props$7.buildProps({
  modelValue: {
    type: [Boolean, String, Number],
    default: false
  },
  value: {
    type: [Boolean, String, Number],
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  width: {
    type: Number,
    default: 40
  },
  inlinePrompt: {
    type: Boolean,
    default: false
  },
  activeIcon: {
    type: props$7.definePropType([String, Object]),
    default: ""
  },
  inactiveIcon: {
    type: props$7.definePropType([String, Object]),
    default: ""
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: true
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: false
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  id: String,
  loading: {
    type: Boolean,
    default: false
  },
  beforeChange: {
    type: props$7.definePropType(Function)
  }
});
const switchEmits = {
  [constants$3.UPDATE_MODEL_EVENT]: (val) => util$4.isBool(val) || shared$3.isString(val) || util$4.isNumber(val),
  [constants$3.CHANGE_EVENT]: (val) => util$4.isBool(val) || shared$3.isString(val) || util$4.isNumber(val),
  [constants$3.INPUT_EVENT]: (val) => util$4.isBool(val) || shared$3.isString(val) || util$4.isNumber(val)
};
_switch$1.switchEmits = switchEmits;
_switch$1.switchProps = switchProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var util2 = util$l;
  var error2 = error$5;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var constants2 = constants$f;
  var _switch2 = _switch$1;
  var index$110 = useFormItem$1;
  var index$22 = useCommonProps;
  const COMPONENT_NAME = "ElSwitch";
  var script2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    components: { ElIcon: index2.ElIcon, Loading: iconsVue2.Loading },
    props: _switch2.switchProps,
    emits: _switch2.switchEmits,
    setup(props2, { emit }) {
      const { formItem: formItem2 } = index$110.useFormItem();
      const switchDisabled = index$22.useDisabled(vue2.computed(() => props2.loading));
      const isModelValue = vue2.ref(props2.modelValue !== false);
      const input3 = vue2.ref();
      const core2 = vue2.ref();
      vue2.watch(() => props2.modelValue, () => {
        isModelValue.value = true;
      });
      vue2.watch(() => props2.value, () => {
        isModelValue.value = false;
      });
      const actualValue = vue2.computed(() => {
        return isModelValue.value ? props2.modelValue : props2.value;
      });
      const checked2 = vue2.computed(() => actualValue.value === props2.activeValue);
      if (![props2.activeValue, props2.inactiveValue].includes(actualValue.value)) {
        emit(constants2.UPDATE_MODEL_EVENT, props2.inactiveValue);
        emit(constants2.CHANGE_EVENT, props2.inactiveValue);
        emit(constants2.INPUT_EVENT, props2.inactiveValue);
      }
      vue2.watch(checked2, () => {
        var _a;
        input3.value.checked = checked2.value;
        if (props2.activeColor || props2.inactiveColor) {
          setBackgroundColor();
        }
        if (props2.validateEvent) {
          (_a = formItem2 == null ? void 0 : formItem2.validate) == null ? void 0 : _a.call(formItem2, "change");
        }
      });
      const handleChange = () => {
        const val = checked2.value ? props2.inactiveValue : props2.activeValue;
        emit(constants2.UPDATE_MODEL_EVENT, val);
        emit(constants2.CHANGE_EVENT, val);
        emit(constants2.INPUT_EVENT, val);
        vue2.nextTick(() => {
          input3.value.checked = checked2.value;
        });
      };
      const switchValue = () => {
        if (switchDisabled.value)
          return;
        const { beforeChange } = props2;
        if (!beforeChange) {
          handleChange();
          return;
        }
        const shouldChange = beforeChange();
        const isExpectType = [shared2.isPromise(shouldChange), util2.isBool(shouldChange)].some((i) => i);
        if (!isExpectType) {
          error2.throwError(COMPONENT_NAME, "beforeChange must return type `Promise<boolean>` or `boolean`");
        }
        if (shared2.isPromise(shouldChange)) {
          shouldChange.then((result3) => {
            if (result3) {
              handleChange();
            }
          }).catch((e) => {
            error2.debugWarn(COMPONENT_NAME, `some error occurred: ${e}`);
          });
        } else if (shouldChange) {
          handleChange();
        }
      };
      const setBackgroundColor = () => {
        const newColor = checked2.value ? props2.activeColor : props2.inactiveColor;
        const coreEl = core2.value;
        if (props2.borderColor)
          coreEl.style.borderColor = props2.borderColor;
        else if (!props2.borderColor)
          coreEl.style.borderColor = newColor;
        coreEl.style.backgroundColor = newColor;
        coreEl.children[0].style.color = newColor;
      };
      const focus = () => {
        var _a, _b;
        (_b = (_a = input3.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      };
      vue2.onMounted(() => {
        if (props2.activeColor || props2.inactiveColor || props2.borderColor) {
          setBackgroundColor();
        }
        input3.value.checked = checked2.value;
      });
      return {
        input: input3,
        core: core2,
        switchDisabled,
        checked: checked2,
        handleChange,
        switchValue,
        focus
      };
    }
  });
  exports["default"] = script2;
})(switch_vue_vue_type_script_lang);
var switch_vue_vue_type_template_id_538fbc85_lang = {};
Object.defineProperty(switch_vue_vue_type_template_id_538fbc85_lang, "__esModule", { value: true });
var vue$w = require$$0$1;
const _hoisted_1$f = ["aria-checked", "aria-disabled"];
const _hoisted_2$c = ["id", "name", "true-value", "false-value", "disabled"];
const _hoisted_3$a = ["aria-hidden"];
const _hoisted_4$7 = {
  key: 0,
  class: "el-switch__inner"
};
const _hoisted_5$6 = ["aria-hidden"];
const _hoisted_6$5 = ["aria-hidden"];
const _hoisted_7$3 = { class: "el-switch__action" };
const _hoisted_8$3 = ["aria-hidden"];
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$w.resolveComponent("el-icon");
  const _component_loading = vue$w.resolveComponent("loading");
  return vue$w.openBlock(), vue$w.createElementBlock("div", {
    class: vue$w.normalizeClass(["el-switch", { "is-disabled": _ctx.switchDisabled, "is-checked": _ctx.checked }]),
    role: "switch",
    "aria-checked": _ctx.checked,
    "aria-disabled": _ctx.switchDisabled,
    onClick: _cache[2] || (_cache[2] = vue$w.withModifiers((...args) => _ctx.switchValue && _ctx.switchValue(...args), ["prevent"]))
  }, [
    vue$w.createElementVNode("input", {
      id: _ctx.id,
      ref: "input",
      class: "el-switch__input",
      type: "checkbox",
      name: _ctx.name,
      "true-value": _ctx.activeValue,
      "false-value": _ctx.inactiveValue,
      disabled: _ctx.switchDisabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onKeydown: _cache[1] || (_cache[1] = vue$w.withKeys((...args) => _ctx.switchValue && _ctx.switchValue(...args), ["enter"]))
    }, null, 40, _hoisted_2$c),
    !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (vue$w.openBlock(), vue$w.createElementBlock("span", {
      key: 0,
      class: vue$w.normalizeClass([
        "el-switch__label",
        "el-switch__label--left",
        !_ctx.checked ? "is-active" : ""
      ])
    }, [
      _ctx.inactiveIcon ? (vue$w.openBlock(), vue$w.createBlock(_component_el_icon, { key: 0 }, {
        default: vue$w.withCtx(() => [
          (vue$w.openBlock(), vue$w.createBlock(vue$w.resolveDynamicComponent(_ctx.inactiveIcon)))
        ]),
        _: 1
      })) : vue$w.createCommentVNode("v-if", true),
      !_ctx.inactiveIcon && _ctx.inactiveText ? (vue$w.openBlock(), vue$w.createElementBlock("span", {
        key: 1,
        "aria-hidden": _ctx.checked
      }, vue$w.toDisplayString(_ctx.inactiveText), 9, _hoisted_3$a)) : vue$w.createCommentVNode("v-if", true)
    ], 2)) : vue$w.createCommentVNode("v-if", true),
    vue$w.createElementVNode("span", {
      ref: "core",
      class: "el-switch__core",
      style: vue$w.normalizeStyle({ width: (_ctx.width || 40) + "px" })
    }, [
      _ctx.inlinePrompt ? (vue$w.openBlock(), vue$w.createElementBlock("div", _hoisted_4$7, [
        _ctx.activeIcon || _ctx.inactiveIcon ? (vue$w.openBlock(), vue$w.createElementBlock(vue$w.Fragment, { key: 0 }, [
          _ctx.activeIcon ? (vue$w.openBlock(), vue$w.createBlock(_component_el_icon, {
            key: 0,
            class: vue$w.normalizeClass(["is-icon", _ctx.checked ? "is-show" : "is-hide"])
          }, {
            default: vue$w.withCtx(() => [
              (vue$w.openBlock(), vue$w.createBlock(vue$w.resolveDynamicComponent(_ctx.activeIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : vue$w.createCommentVNode("v-if", true),
          _ctx.inactiveIcon ? (vue$w.openBlock(), vue$w.createBlock(_component_el_icon, {
            key: 1,
            class: vue$w.normalizeClass(["is-icon", !_ctx.checked ? "is-show" : "is-hide"])
          }, {
            default: vue$w.withCtx(() => [
              (vue$w.openBlock(), vue$w.createBlock(vue$w.resolveDynamicComponent(_ctx.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : vue$w.createCommentVNode("v-if", true)
        ], 64)) : _ctx.activeText || _ctx.inactiveIcon ? (vue$w.openBlock(), vue$w.createElementBlock(vue$w.Fragment, { key: 1 }, [
          _ctx.activeText ? (vue$w.openBlock(), vue$w.createElementBlock("span", {
            key: 0,
            class: vue$w.normalizeClass(["is-text", _ctx.checked ? "is-show" : "is-hide"]),
            "aria-hidden": !_ctx.checked
          }, vue$w.toDisplayString(_ctx.activeText.substr(0, 1)), 11, _hoisted_5$6)) : vue$w.createCommentVNode("v-if", true),
          _ctx.inactiveText ? (vue$w.openBlock(), vue$w.createElementBlock("span", {
            key: 1,
            class: vue$w.normalizeClass(["is-text", !_ctx.checked ? "is-show" : "is-hide"]),
            "aria-hidden": _ctx.checked
          }, vue$w.toDisplayString(_ctx.inactiveText.substr(0, 1)), 11, _hoisted_6$5)) : vue$w.createCommentVNode("v-if", true)
        ], 64)) : vue$w.createCommentVNode("v-if", true)
      ])) : vue$w.createCommentVNode("v-if", true),
      vue$w.createElementVNode("div", _hoisted_7$3, [
        _ctx.loading ? (vue$w.openBlock(), vue$w.createBlock(_component_el_icon, {
          key: 0,
          class: "is-loading"
        }, {
          default: vue$w.withCtx(() => [
            vue$w.createVNode(_component_loading)
          ]),
          _: 1
        })) : vue$w.createCommentVNode("v-if", true)
      ])
    ], 4),
    !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (vue$w.openBlock(), vue$w.createElementBlock("span", {
      key: 1,
      class: vue$w.normalizeClass([
        "el-switch__label",
        "el-switch__label--right",
        _ctx.checked ? "is-active" : ""
      ])
    }, [
      _ctx.activeIcon ? (vue$w.openBlock(), vue$w.createBlock(_component_el_icon, { key: 0 }, {
        default: vue$w.withCtx(() => [
          (vue$w.openBlock(), vue$w.createBlock(vue$w.resolveDynamicComponent(_ctx.activeIcon)))
        ]),
        _: 1
      })) : vue$w.createCommentVNode("v-if", true),
      !_ctx.activeIcon && _ctx.activeText ? (vue$w.openBlock(), vue$w.createElementBlock("span", {
        key: 1,
        "aria-hidden": !_ctx.checked
      }, vue$w.toDisplayString(_ctx.activeText), 9, _hoisted_8$3)) : vue$w.createCommentVNode("v-if", true)
    ], 2)) : vue$w.createCommentVNode("v-if", true)
  ], 10, _hoisted_1$f);
}
switch_vue_vue_type_template_id_538fbc85_lang.render = render$i;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var switch_vue_vue_type_script_lang$1 = switch_vue_vue_type_script_lang;
  var switch_vue_vue_type_template_id_538fbc85_lang$1 = switch_vue_vue_type_template_id_538fbc85_lang;
  switch_vue_vue_type_script_lang$1["default"].render = switch_vue_vue_type_template_id_538fbc85_lang$1.render;
  switch_vue_vue_type_script_lang$1["default"].__file = "packages/components/switch/src/switch.vue";
  exports["default"] = switch_vue_vue_type_script_lang$1["default"];
})(switch2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var _switch2 = _switch$1;
  var switch_vue_vue_type_script_lang$1 = switch_vue_vue_type_script_lang;
  const ElSwitch = withInstall2.withInstall(switch_vue_vue_type_script_lang$1["default"]);
  exports.switchEmits = _switch2.switchEmits;
  exports.switchProps = _switch2.switchProps;
  exports.ElSwitch = ElSwitch;
  exports["default"] = ElSwitch;
})(_switch$2);
var table$1 = {};
var table = {};
var table_vue_vue_type_script_lang = {};
var helper = {};
var store = {};
var watcher = {};
var util$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var shared2 = require$$1$1;
  var core2 = require$$1;
  var popupManager2 = popupManager$3;
  var util2 = util$l;
  var dom2 = dom$8;
  const getCell = function(event) {
    let cell = event.target;
    while (cell && cell.tagName.toUpperCase() !== "HTML") {
      if (cell.tagName.toUpperCase() === "TD") {
        return cell;
      }
      cell = cell.parentNode;
    }
    return null;
  };
  const isObject2 = function(obj) {
    return obj !== null && typeof obj === "object";
  };
  const orderBy = function(array4, sortKey, reverse, sortMethod, sortBy) {
    if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
      return array4;
    }
    if (typeof reverse === "string") {
      reverse = reverse === "descending" ? -1 : 1;
    } else {
      reverse = reverse && reverse < 0 ? -1 : 1;
    }
    const getKey = sortMethod ? null : function(value, index2) {
      if (sortBy) {
        if (!Array.isArray(sortBy)) {
          sortBy = [sortBy];
        }
        return sortBy.map(function(by) {
          if (typeof by === "string") {
            return util2.getValueByPath(value, by);
          } else {
            return by(value, index2, array4);
          }
        });
      }
      if (sortKey !== "$key") {
        if (isObject2(value) && "$value" in value)
          value = value.$value;
      }
      return [isObject2(value) ? util2.getValueByPath(value, sortKey) : value];
    };
    const compare = function(a2, b2) {
      if (sortMethod) {
        return sortMethod(a2.value, b2.value);
      }
      for (let i = 0, len = a2.key.length; i < len; i++) {
        if (a2.key[i] < b2.key[i]) {
          return -1;
        }
        if (a2.key[i] > b2.key[i]) {
          return 1;
        }
      }
      return 0;
    };
    return array4.map(function(value, index2) {
      return {
        value,
        index: index2,
        key: getKey ? getKey(value, index2) : null
      };
    }).sort(function(a2, b2) {
      let order2 = compare(a2, b2);
      if (!order2) {
        order2 = a2.index - b2.index;
      }
      return order2 * +reverse;
    }).map((item2) => item2.value);
  };
  const getColumnById = function(table2, columnId) {
    let column = null;
    table2.columns.forEach(function(item2) {
      if (item2.id === columnId) {
        column = item2;
      }
    });
    return column;
  };
  const getColumnByKey = function(table2, columnKey) {
    let column = null;
    for (let i = 0; i < table2.columns.length; i++) {
      const item2 = table2.columns[i];
      if (item2.columnKey === columnKey) {
        column = item2;
        break;
      }
    }
    return column;
  };
  const getColumnByCell = function(table2, cell) {
    const matches2 = (cell.className || "").match(/el-table_[^\s]+/gm);
    if (matches2) {
      return getColumnById(table2, matches2[0]);
    }
    return null;
  };
  const getRowIdentity = (row2, rowKey) => {
    if (!row2)
      throw new Error("Row is required when get row identity");
    if (typeof rowKey === "string") {
      if (rowKey.indexOf(".") < 0) {
        return `${row2[rowKey]}`;
      }
      const key2 = rowKey.split(".");
      let current2 = row2;
      for (let i = 0; i < key2.length; i++) {
        current2 = current2[key2[i]];
      }
      return `${current2}`;
    } else if (typeof rowKey === "function") {
      return rowKey.call(null, row2);
    }
  };
  const getKeysMap = function(array4, rowKey) {
    const arrayMap2 = {};
    (array4 || []).forEach((row2, index2) => {
      arrayMap2[getRowIdentity(row2, rowKey)] = { row: row2, index: index2 };
    });
    return arrayMap2;
  };
  function mergeOptions2(defaults2, config2) {
    const options = {};
    let key2;
    for (key2 in defaults2) {
      options[key2] = defaults2[key2];
    }
    for (key2 in config2) {
      if (shared2.hasOwn(config2, key2)) {
        const value = config2[key2];
        if (typeof value !== "undefined") {
          options[key2] = value;
        }
      }
    }
    return options;
  }
  function parseWidth(width) {
    if (width !== void 0) {
      width = parseInt(width, 10);
      if (isNaN(width)) {
        width = null;
      }
    }
    return +width;
  }
  function parseMinWidth(minWidth) {
    if (typeof minWidth !== "undefined") {
      minWidth = parseWidth(minWidth);
      if (isNaN(minWidth)) {
        minWidth = 80;
      }
    }
    return minWidth;
  }
  function parseHeight(height) {
    if (typeof height === "number") {
      return height;
    }
    if (typeof height === "string") {
      if (/^\d+(?:px)?$/.test(height)) {
        return parseInt(height, 10);
      } else {
        return height;
      }
    }
    return null;
  }
  function compose(...funcs) {
    if (funcs.length === 0) {
      return (arg) => arg;
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
  }
  function toggleRowStatus(statusArr, row2, newVal) {
    let changed = false;
    const index2 = statusArr.indexOf(row2);
    const included = index2 !== -1;
    const addRow = () => {
      statusArr.push(row2);
      changed = true;
    };
    const removeRow = () => {
      statusArr.splice(index2, 1);
      changed = true;
    };
    if (typeof newVal === "boolean") {
      if (newVal && !included) {
        addRow();
      } else if (!newVal && included) {
        removeRow();
      }
    } else {
      if (included) {
        removeRow();
      } else {
        addRow();
      }
    }
    return changed;
  }
  function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
    const isNil = (array4) => !(Array.isArray(array4) && array4.length);
    function _walker(parent, children, level) {
      cb(parent, children, level);
      children.forEach((item2) => {
        if (item2[lazyKey]) {
          cb(item2, null, level + 1);
          return;
        }
        const children2 = item2[childrenKey];
        if (!isNil(children2)) {
          _walker(item2, children2, level + 1);
        }
      });
    }
    root2.forEach((item2) => {
      if (item2[lazyKey]) {
        cb(item2, null, 0);
        return;
      }
      const children = item2[childrenKey];
      if (!isNil(children)) {
        _walker(item2, children, 0);
      }
    });
  }
  exports.removePopper = void 0;
  function createTablePopper(trigger2, popperContent, popperOptions2, tooltipEffect) {
    function renderContent() {
      const isLight = tooltipEffect === "light";
      const content2 = document.createElement("div");
      content2.className = `el-popper ${isLight ? "is-light" : "is-dark"}`;
      content2.innerHTML = popperContent;
      content2.style.zIndex = String(popupManager2["default"].nextZIndex());
      document.body.appendChild(content2);
      return content2;
    }
    function renderArrow2() {
      const arrow22 = document.createElement("div");
      arrow22.className = "el-popper__arrow";
      return arrow22;
    }
    function showPopper() {
      popperInstance && popperInstance.update();
    }
    exports.removePopper = function removePopper2() {
      try {
        popperInstance && popperInstance.destroy();
        content && document.body.removeChild(content);
        dom2.off(trigger2, "mouseenter", showPopper);
        dom2.off(trigger2, "mouseleave", removePopper2);
      } catch (e) {
      }
    };
    let popperInstance = null;
    const content = renderContent();
    const arrow2 = renderArrow2();
    content.appendChild(arrow2);
    popperInstance = core2.createPopper(trigger2, content, __spreadValues({
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 8]
          }
        },
        {
          name: "arrow",
          options: {
            element: arrow2,
            padding: 10
          }
        }
      ]
    }, popperOptions2));
    dom2.on(trigger2, "mouseenter", showPopper);
    dom2.on(trigger2, "mouseleave", exports.removePopper);
    return popperInstance;
  }
  exports.compose = compose;
  exports.createTablePopper = createTablePopper;
  exports.getCell = getCell;
  exports.getColumnByCell = getColumnByCell;
  exports.getColumnById = getColumnById;
  exports.getColumnByKey = getColumnByKey;
  exports.getKeysMap = getKeysMap;
  exports.getRowIdentity = getRowIdentity;
  exports.mergeOptions = mergeOptions2;
  exports.orderBy = orderBy;
  exports.parseHeight = parseHeight;
  exports.parseMinWidth = parseMinWidth;
  exports.parseWidth = parseWidth;
  exports.toggleRowStatus = toggleRowStatus;
  exports.walkTreeNode = walkTreeNode;
})(util$3);
var expand = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$3;
  function useExpand(watcherData) {
    const instance = vue2.getCurrentInstance();
    const defaultExpandAll = vue2.ref(false);
    const expandRows = vue2.ref([]);
    const updateExpandRows = () => {
      const data2 = watcherData.data.value || [];
      const rowKey = watcherData.rowKey.value;
      if (defaultExpandAll.value) {
        expandRows.value = data2.slice();
      } else if (rowKey) {
        const expandRowsMap = util2.getKeysMap(expandRows.value, rowKey);
        expandRows.value = data2.reduce((prev2, row2) => {
          const rowId = util2.getRowIdentity(row2, rowKey);
          const rowInfo = expandRowsMap[rowId];
          if (rowInfo) {
            prev2.push(row2);
          }
          return prev2;
        }, []);
      } else {
        expandRows.value = [];
      }
    };
    const toggleRowExpansion = (row2, expanded) => {
      const changed = util2.toggleRowStatus(expandRows.value, row2, expanded);
      if (changed) {
        instance.emit("expand-change", row2, expandRows.value.slice());
        instance.store.scheduleLayout();
      }
    };
    const setExpandRowKeys = (rowKeys) => {
      instance.store.assertRowKey();
      const data2 = watcherData.data.value || [];
      const rowKey = watcherData.rowKey.value;
      const keysMap = util2.getKeysMap(data2, rowKey);
      expandRows.value = rowKeys.reduce((prev2, cur) => {
        const info = keysMap[cur];
        if (info) {
          prev2.push(info.row);
        }
        return prev2;
      }, []);
    };
    const isRowExpanded = (row2) => {
      const rowKey = watcherData.rowKey.value;
      if (rowKey) {
        const expandMap = util2.getKeysMap(expandRows.value, rowKey);
        return !!expandMap[util2.getRowIdentity(row2, rowKey)];
      }
      return expandRows.value.indexOf(row2) !== -1;
    };
    return {
      updateExpandRows,
      toggleRowExpansion,
      setExpandRowKeys,
      isRowExpanded,
      states: {
        expandRows,
        defaultExpandAll
      }
    };
  }
  exports["default"] = useExpand;
})(expand);
var current = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$3;
  function useCurrent(watcherData) {
    const instance = vue2.getCurrentInstance();
    const _currentRowKey = vue2.ref(null);
    const currentRow = vue2.ref(null);
    const setCurrentRowKey = (key2) => {
      instance.store.assertRowKey();
      _currentRowKey.value = key2;
      setCurrentRowByKey(key2);
    };
    const restoreCurrentRowKey = () => {
      _currentRowKey.value = null;
    };
    const setCurrentRowByKey = (key2) => {
      const { data: data2, rowKey } = watcherData;
      let _currentRow = null;
      if (rowKey.value) {
        _currentRow = (vue2.unref(data2) || []).find((item2) => util2.getRowIdentity(item2, rowKey.value) === key2);
      }
      currentRow.value = _currentRow;
    };
    const updateCurrentRow = (_currentRow) => {
      const oldCurrentRow = currentRow.value;
      if (_currentRow && _currentRow !== oldCurrentRow) {
        currentRow.value = _currentRow;
        instance.emit("current-change", currentRow.value, oldCurrentRow);
        return;
      }
      if (!_currentRow && oldCurrentRow) {
        currentRow.value = null;
        instance.emit("current-change", null, oldCurrentRow);
      }
    };
    const updateCurrentRowData = () => {
      const rowKey = watcherData.rowKey.value;
      const data2 = watcherData.data.value || [];
      const oldCurrentRow = currentRow.value;
      if (data2.indexOf(oldCurrentRow) === -1 && oldCurrentRow) {
        if (rowKey) {
          const currentRowKey = util2.getRowIdentity(oldCurrentRow, rowKey);
          setCurrentRowByKey(currentRowKey);
        } else {
          currentRow.value = null;
        }
        if (currentRow.value === null) {
          instance.emit("current-change", null, oldCurrentRow);
        }
      } else if (_currentRowKey.value) {
        setCurrentRowByKey(_currentRowKey.value);
        restoreCurrentRowKey();
      }
    };
    return {
      setCurrentRowKey,
      restoreCurrentRowKey,
      setCurrentRowByKey,
      updateCurrentRow,
      updateCurrentRowData,
      states: {
        _currentRowKey,
        currentRow
      }
    };
  }
  exports["default"] = useCurrent;
})(current);
var tree$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$3;
  function useTree2(watcherData) {
    const expandRowKeys = vue2.ref([]);
    const treeData = vue2.ref({});
    const indent = vue2.ref(16);
    const lazy = vue2.ref(false);
    const lazyTreeNodeMap = vue2.ref({});
    const lazyColumnIdentifier = vue2.ref("hasChildren");
    const childrenColumnName = vue2.ref("children");
    const instance = vue2.getCurrentInstance();
    const normalizedData = vue2.computed(() => {
      if (!watcherData.rowKey.value)
        return {};
      const data2 = watcherData.data.value || [];
      return normalize(data2);
    });
    const normalizedLazyNode = vue2.computed(() => {
      const rowKey = watcherData.rowKey.value;
      const keys2 = Object.keys(lazyTreeNodeMap.value);
      const res = {};
      if (!keys2.length)
        return res;
      keys2.forEach((key2) => {
        if (lazyTreeNodeMap.value[key2].length) {
          const item2 = { children: [] };
          lazyTreeNodeMap.value[key2].forEach((row2) => {
            const currentRowKey = util2.getRowIdentity(row2, rowKey);
            item2.children.push(currentRowKey);
            if (row2[lazyColumnIdentifier.value] && !res[currentRowKey]) {
              res[currentRowKey] = { children: [] };
            }
          });
          res[key2] = item2;
        }
      });
      return res;
    });
    const normalize = (data2) => {
      const rowKey = watcherData.rowKey.value;
      const res = {};
      util2.walkTreeNode(data2, (parent, children, level) => {
        const parentId = util2.getRowIdentity(parent, rowKey);
        if (Array.isArray(children)) {
          res[parentId] = {
            children: children.map((row2) => util2.getRowIdentity(row2, rowKey)),
            level
          };
        } else if (lazy.value) {
          res[parentId] = {
            children: [],
            lazy: true,
            level
          };
        }
      }, childrenColumnName.value, lazyColumnIdentifier.value);
      return res;
    };
    const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a) => (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value)()) => {
      var _a2;
      const nested = normalizedData.value;
      const normalizedLazyNode_ = normalizedLazyNode.value;
      const keys2 = Object.keys(nested);
      const newTreeData = {};
      if (keys2.length) {
        const oldTreeData = vue2.unref(treeData);
        const rootLazyRowKeys = [];
        const getExpanded = (oldValue, key2) => {
          if (ifChangeExpandRowKeys) {
            if (expandRowKeys.value) {
              return ifExpandAll || expandRowKeys.value.includes(key2);
            } else {
              return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
            }
          } else {
            const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key2);
            return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
          }
        };
        keys2.forEach((key2) => {
          const oldValue = oldTreeData[key2];
          const newValue = __spreadValues({}, nested[key2]);
          newValue.expanded = getExpanded(oldValue, key2);
          if (newValue.lazy) {
            const { loaded = false, loading: loading2 = false } = oldValue || {};
            newValue.loaded = !!loaded;
            newValue.loading = !!loading2;
            rootLazyRowKeys.push(key2);
          }
          newTreeData[key2] = newValue;
        });
        const lazyKeys = Object.keys(normalizedLazyNode_);
        if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
          lazyKeys.forEach((key2) => {
            const oldValue = oldTreeData[key2];
            const lazyNodeChildren = normalizedLazyNode_[key2].children;
            if (rootLazyRowKeys.indexOf(key2) !== -1) {
              if (newTreeData[key2].children.length !== 0) {
                throw new Error("[ElTable]children must be an empty array.");
              }
              newTreeData[key2].children = lazyNodeChildren;
            } else {
              const { loaded = false, loading: loading2 = false } = oldValue || {};
              newTreeData[key2] = {
                lazy: true,
                loaded: !!loaded,
                loading: !!loading2,
                expanded: getExpanded(oldValue, key2),
                children: lazyNodeChildren,
                level: ""
              };
            }
          });
        }
      }
      treeData.value = newTreeData;
      (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
    };
    vue2.watch(() => expandRowKeys.value, () => {
      updateTreeData(true);
    });
    vue2.watch(() => normalizedData.value, () => {
      updateTreeData();
    });
    vue2.watch(() => normalizedLazyNode.value, () => {
      updateTreeData();
    });
    const updateTreeExpandKeys = (value) => {
      expandRowKeys.value = value;
      updateTreeData();
    };
    const toggleTreeExpansion = (row2, expanded) => {
      instance.store.assertRowKey();
      const rowKey = watcherData.rowKey.value;
      const id = util2.getRowIdentity(row2, rowKey);
      const data2 = id && treeData.value[id];
      if (id && data2 && "expanded" in data2) {
        const oldExpanded = data2.expanded;
        expanded = typeof expanded === "undefined" ? !data2.expanded : expanded;
        treeData.value[id].expanded = expanded;
        if (oldExpanded !== expanded) {
          instance.emit("expand-change", row2, expanded);
        }
        instance.store.updateTableScrollY();
      }
    };
    const loadOrToggle = (row2) => {
      instance.store.assertRowKey();
      const rowKey = watcherData.rowKey.value;
      const id = util2.getRowIdentity(row2, rowKey);
      const data2 = treeData.value[id];
      if (lazy.value && data2 && "loaded" in data2 && !data2.loaded) {
        loadData(row2, id, data2);
      } else {
        toggleTreeExpansion(row2, void 0);
      }
    };
    const loadData = (row2, key2, treeNode2) => {
      const { load } = instance.props;
      if (load && !treeData.value[key2].loaded) {
        treeData.value[key2].loading = true;
        load(row2, treeNode2, (data2) => {
          if (!Array.isArray(data2)) {
            throw new Error("[ElTable] data must be an array");
          }
          treeData.value[key2].loading = false;
          treeData.value[key2].loaded = true;
          treeData.value[key2].expanded = true;
          if (data2.length) {
            lazyTreeNodeMap.value[key2] = data2;
          }
          instance.emit("expand-change", row2, true);
        });
      }
    };
    return {
      loadData,
      loadOrToggle,
      toggleTreeExpansion,
      updateTreeExpandKeys,
      updateTreeData,
      normalize,
      states: {
        expandRowKeys,
        treeData,
        indent,
        lazy,
        lazyTreeNodeMap,
        lazyColumnIdentifier,
        childrenColumnName
      }
    };
  }
  exports["default"] = useTree2;
})(tree$3);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var util2 = util$3;
  var expand$12 = expand;
  var current$1 = current;
  var tree2 = tree$3;
  const sortData = (data2, states) => {
    const sortingColumn = states.sortingColumn;
    if (!sortingColumn || typeof sortingColumn.sortable === "string") {
      return data2;
    }
    return util2.orderBy(data2, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
  };
  const doFlattenColumns = (columns) => {
    const result3 = [];
    columns.forEach((column) => {
      if (column.children) {
        result3.push.apply(result3, doFlattenColumns(column.children));
      } else {
        result3.push(column);
      }
    });
    return result3;
  };
  function useWatcher() {
    var _a;
    const instance = vue2.getCurrentInstance();
    const { size: tableSize } = vue2.toRefs((_a = instance.proxy) == null ? void 0 : _a.$props);
    const rowKey = vue2.ref(null);
    const data2 = vue2.ref([]);
    const _data = vue2.ref([]);
    const isComplex = vue2.ref(false);
    const _columns = vue2.ref([]);
    const originColumns = vue2.ref([]);
    const columns = vue2.ref([]);
    const fixedColumns = vue2.ref([]);
    const rightFixedColumns = vue2.ref([]);
    const leafColumns = vue2.ref([]);
    const fixedLeafColumns = vue2.ref([]);
    const rightFixedLeafColumns = vue2.ref([]);
    const leafColumnsLength = vue2.ref(0);
    const fixedLeafColumnsLength = vue2.ref(0);
    const rightFixedLeafColumnsLength = vue2.ref(0);
    const isAllSelected = vue2.ref(false);
    const selection = vue2.ref([]);
    const reserveSelection = vue2.ref(false);
    const selectOnIndeterminate = vue2.ref(false);
    const selectable = vue2.ref(null);
    const filters = vue2.ref({});
    const filteredData = vue2.ref(null);
    const sortingColumn = vue2.ref(null);
    const sortProp = vue2.ref(null);
    const sortOrder = vue2.ref(null);
    const hoverRow = vue2.ref(null);
    vue2.watch(data2, () => instance.state && scheduleLayout(false), {
      deep: true
    });
    const assertRowKey = () => {
      if (!rowKey.value)
        throw new Error("[ElTable] prop row-key is required");
    };
    const updateColumns = () => {
      fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
      rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
      if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
        _columns.value[0].fixed = true;
        fixedColumns.value.unshift(_columns.value[0]);
      }
      const notFixedColumns = _columns.value.filter((column) => !column.fixed);
      originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
      const leafColumns2 = doFlattenColumns(notFixedColumns);
      const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
      const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
      leafColumnsLength.value = leafColumns2.length;
      fixedLeafColumnsLength.value = fixedLeafColumns2.length;
      rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
      columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
      isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
    };
    const scheduleLayout = (needUpdateColumns, immediate = false) => {
      if (needUpdateColumns) {
        updateColumns();
      }
      if (immediate) {
        instance.state.doLayout();
      } else {
        instance.state.debouncedUpdateLayout();
      }
    };
    const isSelected = (row2) => {
      return selection.value.indexOf(row2) > -1;
    };
    const clearSelection = () => {
      isAllSelected.value = false;
      const oldSelection = selection.value;
      if (oldSelection.length) {
        selection.value = [];
        instance.emit("selection-change", []);
      }
    };
    const cleanSelection = () => {
      let deleted;
      if (rowKey.value) {
        deleted = [];
        const selectedMap = util2.getKeysMap(selection.value, rowKey.value);
        const dataMap = util2.getKeysMap(data2.value, rowKey.value);
        for (const key2 in selectedMap) {
          if (shared2.hasOwn(selectedMap, key2) && !dataMap[key2]) {
            deleted.push(selectedMap[key2].row);
          }
        }
      } else {
        deleted = selection.value.filter((item2) => data2.value.indexOf(item2) === -1);
      }
      if (deleted.length) {
        const newSelection = selection.value.filter((item2) => deleted.indexOf(item2) === -1);
        selection.value = newSelection;
        instance.emit("selection-change", newSelection.slice());
      } else {
        if (selection.value.length) {
          selection.value = [];
          instance.emit("selection-change", []);
        }
      }
    };
    const toggleRowSelection = (row2, selected = void 0, emitChange = true) => {
      const changed = util2.toggleRowStatus(selection.value, row2, selected);
      if (changed) {
        const newSelection = (selection.value || []).slice();
        if (emitChange) {
          instance.emit("select", newSelection, row2);
        }
        instance.emit("selection-change", newSelection);
      }
    };
    const _toggleAllSelection = () => {
      var _a2, _b;
      const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
      isAllSelected.value = value;
      let selectionChanged = false;
      let childrenCount = 0;
      const rowKey2 = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.rowKey.value;
      data2.value.forEach((row2, index2) => {
        const rowIndex = index2 + childrenCount;
        if (selectable.value) {
          if (selectable.value.call(null, row2, rowIndex) && util2.toggleRowStatus(selection.value, row2, value)) {
            selectionChanged = true;
          }
        } else {
          if (util2.toggleRowStatus(selection.value, row2, value)) {
            selectionChanged = true;
          }
        }
        childrenCount += getChildrenCount(util2.getRowIdentity(row2, rowKey2));
      });
      if (selectionChanged) {
        instance.emit("selection-change", selection.value ? selection.value.slice() : []);
      }
      instance.emit("select-all", selection.value);
    };
    const updateSelectionByRowKey = () => {
      const selectedMap = util2.getKeysMap(selection.value, rowKey.value);
      data2.value.forEach((row2) => {
        const rowId = util2.getRowIdentity(row2, rowKey.value);
        const rowInfo = selectedMap[rowId];
        if (rowInfo) {
          selection.value[rowInfo.index] = row2;
        }
      });
    };
    const updateAllSelected = () => {
      var _a2, _b, _c;
      if (((_a2 = data2.value) == null ? void 0 : _a2.length) === 0) {
        isAllSelected.value = false;
        return;
      }
      let selectedMap;
      if (rowKey.value) {
        selectedMap = util2.getKeysMap(selection.value, rowKey.value);
      }
      const isSelected2 = function(row2) {
        if (selectedMap) {
          return !!selectedMap[util2.getRowIdentity(row2, rowKey.value)];
        } else {
          return selection.value.indexOf(row2) !== -1;
        }
      };
      let isAllSelected_ = true;
      let selectedCount = 0;
      let childrenCount = 0;
      for (let i = 0, j = (data2.value || []).length; i < j; i++) {
        const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
        const rowIndex = i + childrenCount;
        const item2 = data2.value[i];
        const isRowSelectable = selectable.value && selectable.value.call(null, item2, rowIndex);
        if (!isSelected2(item2)) {
          if (!selectable.value || isRowSelectable) {
            isAllSelected_ = false;
            break;
          }
        } else {
          selectedCount++;
        }
        childrenCount += getChildrenCount(util2.getRowIdentity(item2, keyProp));
      }
      if (selectedCount === 0)
        isAllSelected_ = false;
      isAllSelected.value = isAllSelected_;
    };
    const getChildrenCount = (rowKey2) => {
      var _a2;
      if (!instance || !instance.store)
        return 0;
      const { treeData } = instance.store.states;
      let count = 0;
      const children = (_a2 = treeData.value[rowKey2]) == null ? void 0 : _a2.children;
      if (children) {
        count += children.length;
        children.forEach((childKey) => {
          count += getChildrenCount(childKey);
        });
      }
      return count;
    };
    const updateFilters = (columns2, values) => {
      if (!Array.isArray(columns2)) {
        columns2 = [columns2];
      }
      const filters_ = {};
      columns2.forEach((col2) => {
        filters.value[col2.id] = values;
        filters_[col2.columnKey || col2.id] = values;
      });
      return filters_;
    };
    const updateSort = (column, prop, order2) => {
      if (sortingColumn.value && sortingColumn.value !== column) {
        sortingColumn.value.order = null;
      }
      sortingColumn.value = column;
      sortProp.value = prop;
      sortOrder.value = order2;
    };
    const execFilter = () => {
      let sourceData = vue2.unref(_data);
      Object.keys(filters.value).forEach((columnId) => {
        const values = filters.value[columnId];
        if (!values || values.length === 0)
          return;
        const column = util2.getColumnById({
          columns: columns.value
        }, columnId);
        if (column && column.filterMethod) {
          sourceData = sourceData.filter((row2) => {
            return values.some((value) => column.filterMethod.call(null, value, row2, column));
          });
        }
      });
      filteredData.value = sourceData;
    };
    const execSort = () => {
      data2.value = sortData(filteredData.value, {
        sortingColumn: sortingColumn.value,
        sortProp: sortProp.value,
        sortOrder: sortOrder.value
      });
    };
    const execQuery = (ignore = void 0) => {
      if (!(ignore && ignore.filter)) {
        execFilter();
      }
      execSort();
    };
    const clearFilter = (columnKeys) => {
      const { tableHeader: tableHeader2, fixedTableHeader, rightFixedTableHeader } = instance.refs;
      let panels = {};
      if (tableHeader2)
        panels = Object.assign(panels, tableHeader2.filterPanels);
      if (fixedTableHeader)
        panels = Object.assign(panels, fixedTableHeader.filterPanels);
      if (rightFixedTableHeader)
        panels = Object.assign(panels, rightFixedTableHeader.filterPanels);
      const keys2 = Object.keys(panels);
      if (!keys2.length)
        return;
      if (typeof columnKeys === "string") {
        columnKeys = [columnKeys];
      }
      if (Array.isArray(columnKeys)) {
        const columns_ = columnKeys.map((key2) => util2.getColumnByKey({
          columns: columns.value
        }, key2));
        keys2.forEach((key2) => {
          const column = columns_.find((col2) => col2.id === key2);
          if (column) {
            column.filteredValue = [];
          }
        });
        instance.store.commit("filterChange", {
          column: columns_,
          values: [],
          silent: true,
          multi: true
        });
      } else {
        keys2.forEach((key2) => {
          const column = columns.value.find((col2) => col2.id === key2);
          if (column) {
            column.filteredValue = [];
          }
        });
        filters.value = {};
        instance.store.commit("filterChange", {
          column: {},
          values: [],
          silent: true
        });
      }
    };
    const clearSort = () => {
      if (!sortingColumn.value)
        return;
      updateSort(null, null, null);
      instance.store.commit("changeSortCondition", {
        silent: true
      });
    };
    const {
      setExpandRowKeys,
      toggleRowExpansion,
      updateExpandRows,
      states: expandStates,
      isRowExpanded
    } = expand$12["default"]({
      data: data2,
      rowKey
    });
    const {
      updateTreeExpandKeys,
      toggleTreeExpansion,
      updateTreeData,
      loadOrToggle,
      states: treeStates
    } = tree2["default"]({
      data: data2,
      rowKey
    });
    const {
      updateCurrentRowData,
      updateCurrentRow,
      setCurrentRowKey,
      states: currentData
    } = current$1["default"]({
      data: data2,
      rowKey
    });
    const setExpandRowKeysAdapter = (val) => {
      setExpandRowKeys(val);
      updateTreeExpandKeys(val);
    };
    const toggleRowExpansionAdapter = (row2, expanded) => {
      const hasExpandColumn = columns.value.some(({ type: type4 }) => type4 === "expand");
      if (hasExpandColumn) {
        toggleRowExpansion(row2, expanded);
      } else {
        toggleTreeExpansion(row2, expanded);
      }
    };
    return {
      assertRowKey,
      updateColumns,
      scheduleLayout,
      isSelected,
      clearSelection,
      cleanSelection,
      toggleRowSelection,
      _toggleAllSelection,
      toggleAllSelection: null,
      updateSelectionByRowKey,
      updateAllSelected,
      updateFilters,
      updateCurrentRow,
      updateSort,
      execFilter,
      execSort,
      execQuery,
      clearFilter,
      clearSort,
      toggleRowExpansion,
      setExpandRowKeysAdapter,
      setCurrentRowKey,
      toggleRowExpansionAdapter,
      isRowExpanded,
      updateExpandRows,
      updateCurrentRowData,
      loadOrToggle,
      updateTreeData,
      states: __spreadValues(__spreadValues(__spreadValues({
        tableSize,
        rowKey,
        data: data2,
        _data,
        isComplex,
        _columns,
        originColumns,
        columns,
        fixedColumns,
        rightFixedColumns,
        leafColumns,
        fixedLeafColumns,
        rightFixedLeafColumns,
        leafColumnsLength,
        fixedLeafColumnsLength,
        rightFixedLeafColumnsLength,
        isAllSelected,
        selection,
        reserveSelection,
        selectOnIndeterminate,
        selectable,
        filters,
        filteredData,
        sortingColumn,
        sortProp,
        sortOrder,
        hoverRow
      }, expandStates), treeStates), currentData)
    };
  }
  exports["default"] = useWatcher;
})(watcher);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var watcher$1 = watcher;
  function replaceColumn(array4, column) {
    return array4.map((item2) => {
      var _a;
      if (item2.id === column.id) {
        return column;
      } else if ((_a = item2.children) == null ? void 0 : _a.length) {
        item2.children = replaceColumn(item2.children, column);
      }
      return item2;
    });
  }
  function sortColumn(array4) {
    array4.forEach((item2) => {
      var _a, _b;
      item2.no = (_a = item2.getColumnIndex) == null ? void 0 : _a.call(item2);
      if ((_b = item2.children) == null ? void 0 : _b.length) {
        sortColumn(item2.children);
      }
    });
    array4.sort((cur, pre) => cur.no - pre.no);
  }
  function useStore2() {
    const instance = vue2.getCurrentInstance();
    const watcher$1$1 = watcher$1["default"]();
    const mutations = {
      setData(states, data2) {
        const dataInstanceChanged = vue2.unref(states.data) !== data2;
        states.data.value = data2;
        states._data.value = data2;
        instance.store.execQuery();
        instance.store.updateCurrentRowData();
        instance.store.updateExpandRows();
        instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
        if (vue2.unref(states.reserveSelection)) {
          instance.store.assertRowKey();
          instance.store.updateSelectionByRowKey();
        } else {
          if (dataInstanceChanged) {
            instance.store.clearSelection();
          } else {
            instance.store.cleanSelection();
          }
        }
        instance.store.updateAllSelected();
        if (instance.$ready) {
          instance.store.scheduleLayout();
        }
      },
      insertColumn(states, column, parent) {
        const array4 = vue2.unref(states._columns);
        let newColumns = [];
        if (!parent) {
          array4.push(column);
          newColumns = array4;
        } else {
          if (parent && !parent.children) {
            parent.children = [];
          }
          parent.children.push(column);
          newColumns = replaceColumn(array4, parent);
        }
        sortColumn(newColumns);
        states._columns.value = newColumns;
        if (column.type === "selection") {
          states.selectable.value = column.selectable;
          states.reserveSelection.value = column.reserveSelection;
        }
        if (instance.$ready) {
          instance.store.updateColumns();
          instance.store.scheduleLayout();
        }
      },
      removeColumn(states, column, parent) {
        const array4 = vue2.unref(states._columns) || [];
        if (parent) {
          parent.children.splice(parent.children.findIndex((item2) => item2.id === column.id), 1);
          if (parent.children.length === 0) {
            delete parent.children;
          }
          states._columns.value = replaceColumn(array4, parent);
        } else {
          const index2 = array4.indexOf(column);
          if (index2 > -1) {
            array4.splice(index2, 1);
            states._columns.value = array4;
          }
        }
        if (instance.$ready) {
          instance.store.updateColumns();
          instance.store.scheduleLayout();
        }
      },
      sort(states, options) {
        const { prop, order: order2, init } = options;
        if (prop) {
          const column = vue2.unref(states.columns).find((column2) => column2.property === prop);
          if (column) {
            column.order = order2;
            instance.store.updateSort(column, prop, order2);
            instance.store.commit("changeSortCondition", { init });
          }
        }
      },
      changeSortCondition(states, options) {
        const { sortingColumn: column, sortProp: prop, sortOrder: order2 } = states;
        if (vue2.unref(order2) === null) {
          states.sortingColumn.value = null;
          states.sortProp.value = null;
        }
        const ingore = { filter: true };
        instance.store.execQuery(ingore);
        if (!options || !(options.silent || options.init)) {
          instance.emit("sort-change", {
            column: vue2.unref(column),
            prop: vue2.unref(prop),
            order: vue2.unref(order2)
          });
        }
        instance.store.updateTableScrollY();
      },
      filterChange(_states, options) {
        const { column, values, silent } = options;
        const newFilters = instance.store.updateFilters(column, values);
        instance.store.execQuery();
        if (!silent) {
          instance.emit("filter-change", newFilters);
        }
        instance.store.updateTableScrollY();
      },
      toggleAllSelection() {
        instance.store.toggleAllSelection();
      },
      rowSelectedChanged(_states, row2) {
        instance.store.toggleRowSelection(row2);
        instance.store.updateAllSelected();
      },
      setHoverRow(states, row2) {
        states.hoverRow.value = row2;
      },
      setCurrentRow(_states, row2) {
        instance.store.updateCurrentRow(row2);
      }
    };
    const commit2 = function(name, ...args) {
      const mutations2 = instance.store.mutations;
      if (mutations2[name]) {
        mutations2[name].apply(instance, [instance.store.states].concat(args));
      } else {
        throw new Error(`Action not found: ${name}`);
      }
    };
    const updateTableScrollY = function() {
      vue2.nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
    };
    return __spreadProps(__spreadValues({}, watcher$1$1), {
      mutations,
      commit: commit2,
      updateTableScrollY
    });
  }
  exports["default"] = useStore2;
})(store);
Object.defineProperty(helper, "__esModule", { value: true });
var vue$v = require$$0$1;
var debounce = debounce_1;
var index$19 = store;
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
var debounce__default = /* @__PURE__ */ _interopDefaultLegacy(debounce);
const InitialStateMap = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function createStore$1(table2, props2) {
  if (!table2) {
    throw new Error("Table is required.");
  }
  const store2 = index$19["default"]();
  store2.toggleAllSelection = debounce__default["default"](store2._toggleAllSelection, 10);
  Object.keys(InitialStateMap).forEach((key2) => {
    handleValue(getArrKeysValue(props2, key2), key2, store2);
  });
  proxyTableProps(store2, props2);
  return store2;
}
function proxyTableProps(store2, props2) {
  Object.keys(InitialStateMap).forEach((key2) => {
    vue$v.watch(() => getArrKeysValue(props2, key2), (value) => {
      handleValue(value, key2, store2);
    });
  });
}
function handleValue(value, propsKey, store2) {
  let newVal = value;
  let storeKey2 = InitialStateMap[propsKey];
  if (typeof InitialStateMap[propsKey] === "object") {
    storeKey2 = storeKey2.key;
    newVal = newVal || InitialStateMap[propsKey].default;
  }
  store2.states[storeKey2].value = newVal;
}
function getArrKeysValue(props2, keys2) {
  if (keys2.includes(".")) {
    const keyList = keys2.split(".");
    let value = props2;
    keyList.forEach((key2) => {
      value = value[key2];
    });
    return value;
  } else {
    return props2[keys2];
  }
}
helper.createStore = createStore$1;
var tableLayout = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var scrollbarWidth2 = scrollbarWidth$1;
  var isServer2 = isServer$8;
  var util2 = util$3;
  class TableLayout {
    constructor(options) {
      this.observers = [];
      this.table = null;
      this.store = null;
      this.columns = [];
      this.fit = true;
      this.showHeader = true;
      this.height = vue2.ref(null);
      this.scrollX = vue2.ref(false);
      this.scrollY = vue2.ref(false);
      this.bodyWidth = vue2.ref(null);
      this.fixedWidth = vue2.ref(null);
      this.rightFixedWidth = vue2.ref(null);
      this.tableHeight = vue2.ref(null);
      this.headerHeight = vue2.ref(44);
      this.appendHeight = vue2.ref(0);
      this.footerHeight = vue2.ref(44);
      this.viewportHeight = vue2.ref(null);
      this.bodyHeight = vue2.ref(null);
      this.fixedBodyHeight = vue2.ref(null);
      this.gutterWidth = scrollbarWidth2["default"]();
      for (const name in options) {
        if (shared2.hasOwn(options, name)) {
          if (vue2.isRef(this[name])) {
            this[name].value = options[name];
          } else {
            this[name] = options[name];
          }
        }
      }
      if (!this.table) {
        throw new Error("Table is required for Table Layout");
      }
      if (!this.store) {
        throw new Error("Store is required for Table Layout");
      }
    }
    updateScrollY() {
      const height = this.height.value;
      if (height === null)
        return false;
      const bodyWrapper = this.table.refs.bodyWrapper;
      if (this.table.vnode.el && bodyWrapper) {
        let scrollY = true;
        const prevScrollY = this.scrollY.value;
        if (this.bodyHeight.value === null) {
          scrollY = false;
        } else {
          const body = bodyWrapper.querySelector(".el-table__body");
          scrollY = body.offsetHeight > this.bodyHeight.value;
        }
        this.scrollY.value = scrollY;
        return prevScrollY !== scrollY;
      }
      return false;
    }
    setHeight(value, prop = "height") {
      if (isServer2["default"])
        return;
      const el = this.table.vnode.el;
      value = util2.parseHeight(value);
      this.height.value = Number(value);
      if (!el && (value || value === 0))
        return vue2.nextTick(() => this.setHeight(value, prop));
      if (typeof value === "number") {
        el.style[prop] = `${value}px`;
        this.updateElsHeight();
      } else if (typeof value === "string") {
        el.style[prop] = value;
        this.updateElsHeight();
      }
    }
    setMaxHeight(value) {
      this.setHeight(value, "max-height");
    }
    getFlattenColumns() {
      const flattenColumns = [];
      const columns = this.table.store.states.columns.value;
      columns.forEach((column) => {
        if (column.isColumnGroup) {
          flattenColumns.push.apply(flattenColumns, column.columns);
        } else {
          flattenColumns.push(column);
        }
      });
      return flattenColumns;
    }
    updateElsHeight() {
      if (!this.table.$ready)
        return vue2.nextTick(() => this.updateElsHeight());
      const { headerWrapper, appendWrapper, footerWrapper } = this.table.refs;
      this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;
      if (this.showHeader && !headerWrapper)
        return;
      const headerTrElm = headerWrapper ? headerWrapper.querySelector(".el-table__header tr") : null;
      const noneHeader = this.headerDisplayNone(headerTrElm);
      const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapper.offsetHeight;
      if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {
        return vue2.nextTick(() => this.updateElsHeight());
      }
      const tableHeight = this.tableHeight.value = this.table.vnode.el.clientHeight;
      const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;
      if (this.height.value !== null) {
        this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
      }
      this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;
      this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;
      this.updateScrollY();
      this.notifyObservers("scrollable");
    }
    headerDisplayNone(elm) {
      if (!elm)
        return true;
      let headerChild = elm;
      while (headerChild.tagName !== "DIV") {
        if (getComputedStyle(headerChild).display === "none") {
          return true;
        }
        headerChild = headerChild.parentElement;
      }
      return false;
    }
    updateColumnsWidth() {
      if (isServer2["default"])
        return;
      const fit = this.fit;
      const bodyWidth = this.table.vnode.el.clientWidth;
      let bodyMinWidth = 0;
      const flattenColumns = this.getFlattenColumns();
      const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
      flattenColumns.forEach((column) => {
        if (typeof column.width === "number" && column.realWidth)
          column.realWidth = null;
      });
      if (flexColumns.length > 0 && fit) {
        flattenColumns.forEach((column) => {
          bodyMinWidth += Number(column.width || column.minWidth || 80);
        });
        const scrollYWidth = this.scrollY.value ? this.gutterWidth : 0;
        if (bodyMinWidth <= bodyWidth - scrollYWidth) {
          this.scrollX.value = false;
          const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;
          if (flexColumns.length === 1) {
            flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
          } else {
            const allColumnsWidth = flexColumns.reduce((prev2, column) => prev2 + Number(column.minWidth || 80), 0);
            const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
            let noneFirstWidth = 0;
            flexColumns.forEach((column, index2) => {
              if (index2 === 0)
                return;
              const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
              noneFirstWidth += flexWidth;
              column.realWidth = Number(column.minWidth || 80) + flexWidth;
            });
            flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
          }
        } else {
          this.scrollX.value = true;
          flexColumns.forEach(function(column) {
            column.realWidth = Number(column.minWidth);
          });
        }
        this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
        this.table.state.resizeState.value.width = this.bodyWidth.value;
      } else {
        flattenColumns.forEach((column) => {
          if (!column.width && !column.minWidth) {
            column.realWidth = 80;
          } else {
            column.realWidth = Number(column.width || column.minWidth);
          }
          bodyMinWidth += column.realWidth;
        });
        this.scrollX.value = bodyMinWidth > bodyWidth;
        this.bodyWidth.value = bodyMinWidth;
      }
      const fixedColumns = this.store.states.fixedColumns.value;
      if (fixedColumns.length > 0) {
        let fixedWidth = 0;
        fixedColumns.forEach(function(column) {
          fixedWidth += Number(column.realWidth || column.width);
        });
        this.fixedWidth.value = fixedWidth;
      }
      const rightFixedColumns = this.store.states.rightFixedColumns.value;
      if (rightFixedColumns.length > 0) {
        let rightFixedWidth = 0;
        rightFixedColumns.forEach(function(column) {
          rightFixedWidth += Number(column.realWidth || column.width);
        });
        this.rightFixedWidth.value = rightFixedWidth;
      }
      this.notifyObservers("columns");
    }
    addObserver(observer) {
      this.observers.push(observer);
    }
    removeObserver(observer) {
      const index2 = this.observers.indexOf(observer);
      if (index2 !== -1) {
        this.observers.splice(index2, 1);
      }
    }
    notifyObservers(event) {
      const observers = this.observers;
      observers.forEach((observer) => {
        var _a, _b;
        switch (event) {
          case "columns":
            (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);
            break;
          case "scrollable":
            (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
            break;
          default:
            throw new Error(`Table Layout don't have event ${event}.`);
        }
      });
    }
  }
  exports["default"] = TableLayout;
})(tableLayout);
var tableHeader = {};
var filterPanel = {};
var filterPanel_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = checkbox$1;
  var index$32 = icon$4;
  var iconsVue2 = require$$3;
  var index$22 = popper$3;
  var index$110 = scrollbar$3;
  var index$42 = clickOutside;
  var index$52 = useLocale$1;
  var defaults2 = defaults$d;
  const { CheckboxGroup: ElCheckboxGroup } = index2.ElCheckbox;
  var script2 = vue2.defineComponent({
    name: "ElTableFilterPanel",
    components: {
      ElCheckbox: index2.ElCheckbox,
      ElCheckboxGroup,
      ElScrollbar: index$110.ElScrollbar,
      ElPopper: index$22["default"],
      ElIcon: index$32.ElIcon,
      ArrowDown: iconsVue2.ArrowDown,
      ArrowUp: iconsVue2.ArrowUp
    },
    directives: { ClickOutside: index$42["default"] },
    props: {
      placement: {
        type: String,
        default: "bottom-start"
      },
      store: {
        type: Object
      },
      column: {
        type: Object
      },
      upDataColumn: {
        type: Function
      }
    },
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const { t } = index$52.useLocale();
      const parent = instance.parent;
      if (!parent.filterPanels.value[props2.column.id]) {
        parent.filterPanels.value[props2.column.id] = instance;
      }
      const tooltipVisible = vue2.ref(false);
      const tooltip2 = vue2.ref(null);
      const filters = vue2.computed(() => {
        return props2.column && props2.column.filters;
      });
      const filterValue = vue2.computed({
        get: () => (props2.column.filteredValue || [])[0],
        set: (value) => {
          if (filteredValue.value) {
            if (typeof value !== "undefined" && value !== null) {
              filteredValue.value.splice(0, 1, value);
            } else {
              filteredValue.value.splice(0, 1);
            }
          }
        }
      });
      const filteredValue = vue2.computed({
        get() {
          if (props2.column) {
            return props2.column.filteredValue || [];
          }
          return [];
        },
        set(value) {
          if (props2.column) {
            props2.upDataColumn("filteredValue", value);
          }
        }
      });
      const multiple = vue2.computed(() => {
        if (props2.column) {
          return props2.column.filterMultiple;
        }
        return true;
      });
      const isActive = (filter2) => {
        return filter2.value === filterValue.value;
      };
      const hidden = () => {
        tooltipVisible.value = false;
      };
      const showFilterPanel = (e) => {
        e.stopPropagation();
        tooltipVisible.value = !tooltipVisible.value;
      };
      const hideFilterPanel = () => {
        tooltipVisible.value = false;
      };
      const handleConfirm = () => {
        confirmFilter(filteredValue.value);
        hidden();
      };
      const handleReset = () => {
        filteredValue.value = [];
        confirmFilter(filteredValue.value);
        hidden();
      };
      const handleSelect = (_filterValue) => {
        filterValue.value = _filterValue;
        if (typeof _filterValue !== "undefined" && _filterValue !== null) {
          confirmFilter(filteredValue.value);
        } else {
          confirmFilter([]);
        }
        hidden();
      };
      const confirmFilter = (filteredValue2) => {
        props2.store.commit("filterChange", {
          column: props2.column,
          values: filteredValue2
        });
        props2.store.updateAllSelected();
      };
      vue2.watch(tooltipVisible, (value) => {
        if (props2.column) {
          props2.upDataColumn("filterOpened", value);
        }
      }, {
        immediate: true
      });
      const popperPaneRef = vue2.computed(() => {
        var _a;
        return (_a = tooltip2.value) == null ? void 0 : _a.popperRef;
      });
      return {
        tooltipVisible,
        multiple,
        filteredValue,
        filterValue,
        filters,
        handleConfirm,
        handleReset,
        handleSelect,
        isActive,
        t,
        showFilterPanel,
        hideFilterPanel,
        popperPaneRef,
        tooltip: tooltip2,
        Effect: defaults2.Effect
      };
    }
  });
  exports["default"] = script2;
})(filterPanel_vue_vue_type_script_lang);
var filterPanel_vue_vue_type_template_id_fde1c940_lang = {};
Object.defineProperty(filterPanel_vue_vue_type_template_id_fde1c940_lang, "__esModule", { value: true });
var vue$u = require$$0$1;
const _hoisted_1$e = { key: 0 };
const _hoisted_2$b = { class: "el-table-filter__content" };
const _hoisted_3$9 = { class: "el-table-filter__bottom" };
const _hoisted_4$6 = ["disabled"];
const _hoisted_5$5 = {
  key: 1,
  class: "el-table-filter__list"
};
const _hoisted_6$4 = ["label", "onClick"];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = vue$u.resolveComponent("el-checkbox");
  const _component_el_checkbox_group = vue$u.resolveComponent("el-checkbox-group");
  const _component_el_scrollbar = vue$u.resolveComponent("el-scrollbar");
  const _component_arrow_up = vue$u.resolveComponent("arrow-up");
  const _component_arrow_down = vue$u.resolveComponent("arrow-down");
  const _component_el_icon = vue$u.resolveComponent("el-icon");
  const _component_el_popper = vue$u.resolveComponent("el-popper");
  const _directive_click_outside = vue$u.resolveDirective("click-outside");
  return vue$u.openBlock(), vue$u.createBlock(_component_el_popper, {
    ref: "tooltip",
    visible: _ctx.tooltipVisible,
    "onUpdate:visible": _cache[5] || (_cache[5] = ($event) => _ctx.tooltipVisible = $event),
    offset: 0,
    placement: _ctx.placement,
    "show-arrow": false,
    "stop-popper-mouse-event": false,
    effect: _ctx.Effect.LIGHT,
    pure: "",
    "manual-mode": "",
    "popper-class": "el-table-filter",
    "append-to-body": ""
  }, {
    default: vue$u.withCtx(() => [
      _ctx.multiple ? (vue$u.openBlock(), vue$u.createElementBlock("div", _hoisted_1$e, [
        vue$u.createElementVNode("div", _hoisted_2$b, [
          vue$u.createVNode(_component_el_scrollbar, { "wrap-class": "el-table-filter__wrap" }, {
            default: vue$u.withCtx(() => [
              vue$u.createVNode(_component_el_checkbox_group, {
                modelValue: _ctx.filteredValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                class: "el-table-filter__checkbox-group"
              }, {
                default: vue$u.withCtx(() => [
                  (vue$u.openBlock(true), vue$u.createElementBlock(vue$u.Fragment, null, vue$u.renderList(_ctx.filters, (filter2) => {
                    return vue$u.openBlock(), vue$u.createBlock(_component_el_checkbox, {
                      key: filter2.value,
                      label: filter2.value
                    }, {
                      default: vue$u.withCtx(() => [
                        vue$u.createTextVNode(vue$u.toDisplayString(filter2.text), 1)
                      ]),
                      _: 2
                    }, 1032, ["label"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            _: 1
          })
        ]),
        vue$u.createElementVNode("div", _hoisted_3$9, [
          vue$u.createElementVNode("button", {
            class: vue$u.normalizeClass({ "is-disabled": _ctx.filteredValue.length === 0 }),
            disabled: _ctx.filteredValue.length === 0,
            type: "button",
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
          }, vue$u.toDisplayString(_ctx.t("el.table.confirmFilter")), 11, _hoisted_4$6),
          vue$u.createElementVNode("button", {
            type: "button",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
          }, vue$u.toDisplayString(_ctx.t("el.table.resetFilter")), 1)
        ])
      ])) : (vue$u.openBlock(), vue$u.createElementBlock("ul", _hoisted_5$5, [
        vue$u.createElementVNode("li", {
          class: vue$u.normalizeClass([{
            "is-active": _ctx.filterValue === void 0 || _ctx.filterValue === null
          }, "el-table-filter__list-item"]),
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
        }, vue$u.toDisplayString(_ctx.t("el.table.clearFilter")), 3),
        (vue$u.openBlock(true), vue$u.createElementBlock(vue$u.Fragment, null, vue$u.renderList(_ctx.filters, (filter2) => {
          return vue$u.openBlock(), vue$u.createElementBlock("li", {
            key: filter2.value,
            class: vue$u.normalizeClass([{ "is-active": _ctx.isActive(filter2) }, "el-table-filter__list-item"]),
            label: filter2.value,
            onClick: ($event) => _ctx.handleSelect(filter2.value)
          }, vue$u.toDisplayString(filter2.text), 11, _hoisted_6$4);
        }), 128))
      ]))
    ]),
    trigger: vue$u.withCtx(() => [
      vue$u.withDirectives(vue$u.createElementVNode("span", {
        class: "el-table__column-filter-trigger el-none-outline",
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
      }, [
        vue$u.createVNode(_component_el_icon, null, {
          default: vue$u.withCtx(() => [
            _ctx.column.filterOpened ? (vue$u.openBlock(), vue$u.createBlock(_component_arrow_up, { key: 0 })) : (vue$u.openBlock(), vue$u.createBlock(_component_arrow_down, { key: 1 }))
          ]),
          _: 1
        })
      ], 512), [
        [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "effect"]);
}
filterPanel_vue_vue_type_template_id_fde1c940_lang.render = render$h;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var filterPanel_vue_vue_type_script_lang$1 = filterPanel_vue_vue_type_script_lang;
  var filterPanel_vue_vue_type_template_id_fde1c940_lang$1 = filterPanel_vue_vue_type_template_id_fde1c940_lang;
  filterPanel_vue_vue_type_script_lang$1["default"].render = filterPanel_vue_vue_type_template_id_fde1c940_lang$1.render;
  filterPanel_vue_vue_type_script_lang$1["default"].__file = "packages/components/table/src/filter-panel.vue";
  exports["default"] = filterPanel_vue_vue_type_script_lang$1["default"];
})(filterPanel);
var layoutObserver = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  function useLayoutObserver(root2) {
    const instance = vue2.getCurrentInstance();
    vue2.onBeforeMount(() => {
      tableLayout2.value.addObserver(instance);
    });
    vue2.onMounted(() => {
      onColumnsChange(tableLayout2.value);
      onScrollableChange(tableLayout2.value);
    });
    vue2.onUpdated(() => {
      onColumnsChange(tableLayout2.value);
      onScrollableChange(tableLayout2.value);
    });
    vue2.onUnmounted(() => {
      tableLayout2.value.removeObserver(instance);
    });
    const tableLayout2 = vue2.computed(() => {
      const layout2 = root2.layout;
      if (!layout2) {
        throw new Error("Can not find table layout.");
      }
      return layout2;
    });
    const onColumnsChange = (layout2) => {
      var _a;
      const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col")) || [];
      if (!cols.length)
        return;
      const flattenColumns = layout2.getFlattenColumns();
      const columnsMap = {};
      flattenColumns.forEach((column) => {
        columnsMap[column.id] = column;
      });
      for (let i = 0, j = cols.length; i < j; i++) {
        const col2 = cols[i];
        const name = col2.getAttribute("name");
        const column = columnsMap[name];
        if (column) {
          col2.setAttribute("width", column.realWidth || column.width);
        }
      }
    };
    const onScrollableChange = (layout2) => {
      const cols = root2.vnode.el.querySelectorAll("colgroup > col[name=gutter]");
      for (let i = 0, j = cols.length; i < j; i++) {
        const col2 = cols[i];
        col2.setAttribute("width", layout2.scrollY.value ? layout2.gutterWidth : "0");
      }
      const ths = root2.vnode.el.querySelectorAll("th.gutter");
      for (let i = 0, j = ths.length; i < j; i++) {
        const th = ths[i];
        th.style.width = layout2.scrollY.value ? `${layout2.gutterWidth}px` : "0";
        th.style.display = layout2.scrollY.value ? "" : "none";
      }
    };
    return {
      tableLayout: tableLayout2.value,
      onColumnsChange,
      onScrollableChange
    };
  }
  exports["default"] = useLayoutObserver;
})(layoutObserver);
var hHelper = {};
Object.defineProperty(hHelper, "__esModule", { value: true });
var vue$t = require$$0$1;
function hGutter() {
  return vue$t.h("col", {
    name: "gutter"
  });
}
function hColgroup(columns, hasGutter = false) {
  return vue$t.h("colgroup", {}, [
    ...columns.map((column) => vue$t.h("col", {
      name: column.id,
      key: column.id
    })),
    hasGutter && hGutter()
  ]);
}
hHelper.hColgroup = hColgroup;
hHelper.hGutter = hGutter;
var eventHelper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var isServer2 = isServer$8;
  function useEvent2(props2, emit) {
    const instance = vue2.getCurrentInstance();
    const parent = instance.parent;
    const handleFilterClick = (event) => {
      event.stopPropagation();
      return;
    };
    const handleHeaderClick = (event, column) => {
      if (!column.filters && column.sortable) {
        handleSortClick(event, column, false);
      } else if (column.filterable && !column.sortable) {
        handleFilterClick(event);
      }
      parent.emit("header-click", column, event);
    };
    const handleHeaderContextMenu = (event, column) => {
      parent.emit("header-contextmenu", column, event);
    };
    const draggingColumn = vue2.ref(null);
    const dragging = vue2.ref(false);
    const dragState = vue2.ref({});
    const handleMouseDown = (event, column) => {
      if (isServer2["default"])
        return;
      if (column.children && column.children.length > 0)
        return;
      if (draggingColumn.value && props2.border) {
        dragging.value = true;
        const table2 = parent;
        emit("set-drag-visible", true);
        const tableEl = table2.vnode.el;
        const tableLeft = tableEl.getBoundingClientRect().left;
        const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
        const columnRect = columnEl.getBoundingClientRect();
        const minLeft = columnRect.left - tableLeft + 30;
        dom2.addClass(columnEl, "noclick");
        dragState.value = {
          startMouseLeft: event.clientX,
          startLeft: columnRect.right - tableLeft,
          startColumnLeft: columnRect.left - tableLeft,
          tableLeft
        };
        const resizeProxy = table2.refs.resizeProxy;
        resizeProxy.style.left = `${dragState.value.startLeft}px`;
        document.onselectstart = function() {
          return false;
        };
        document.ondragstart = function() {
          return false;
        };
        const handleMouseMove2 = (event2) => {
          const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
          const proxyLeft = dragState.value.startLeft + deltaLeft;
          resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
        };
        const handleMouseUp = () => {
          if (dragging.value) {
            const { startColumnLeft, startLeft } = dragState.value;
            const finalLeft = parseInt(resizeProxy.style.left, 10);
            const columnWidth = finalLeft - startColumnLeft;
            column.width = column.realWidth = columnWidth;
            table2.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
            requestAnimationFrame(() => {
              props2.store.scheduleLayout(false, true);
            });
            document.body.style.cursor = "";
            dragging.value = false;
            draggingColumn.value = null;
            dragState.value = {};
            emit("set-drag-visible", false);
          }
          document.removeEventListener("mousemove", handleMouseMove2);
          document.removeEventListener("mouseup", handleMouseUp);
          document.onselectstart = null;
          document.ondragstart = null;
          setTimeout(function() {
            dom2.removeClass(columnEl, "noclick");
          }, 0);
        };
        document.addEventListener("mousemove", handleMouseMove2);
        document.addEventListener("mouseup", handleMouseUp);
      }
    };
    const handleMouseMove = (event, column) => {
      if (column.children && column.children.length > 0)
        return;
      let target2 = event.target;
      while (target2 && target2.tagName !== "TH") {
        target2 = target2.parentNode;
      }
      if (!column || !column.resizable)
        return;
      if (!dragging.value && props2.border) {
        const rect = target2.getBoundingClientRect();
        const bodyStyle = document.body.style;
        if (rect.width > 12 && rect.right - event.pageX < 8) {
          bodyStyle.cursor = "col-resize";
          if (dom2.hasClass(target2, "is-sortable")) {
            target2.style.cursor = "col-resize";
          }
          draggingColumn.value = column;
        } else if (!dragging.value) {
          bodyStyle.cursor = "";
          if (dom2.hasClass(target2, "is-sortable")) {
            target2.style.cursor = "pointer";
          }
          draggingColumn.value = null;
        }
      }
    };
    const handleMouseOut = () => {
      if (isServer2["default"])
        return;
      document.body.style.cursor = "";
    };
    const toggleOrder = ({ order: order2, sortOrders }) => {
      if (order2 === "")
        return sortOrders[0];
      const index2 = sortOrders.indexOf(order2 || null);
      return sortOrders[index2 > sortOrders.length - 2 ? 0 : index2 + 1];
    };
    const handleSortClick = (event, column, givenOrder) => {
      event.stopPropagation();
      const order2 = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
      let target2 = event.target;
      while (target2 && target2.tagName !== "TH") {
        target2 = target2.parentNode;
      }
      if (target2 && target2.tagName === "TH") {
        if (dom2.hasClass(target2, "noclick")) {
          dom2.removeClass(target2, "noclick");
          return;
        }
      }
      if (!column.sortable)
        return;
      const states = props2.store.states;
      let sortProp = states.sortProp.value;
      let sortOrder;
      const sortingColumn = states.sortingColumn.value;
      if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
        if (sortingColumn) {
          sortingColumn.order = null;
        }
        states.sortingColumn.value = column;
        sortProp = column.property;
      }
      if (!order2) {
        sortOrder = column.order = null;
      } else {
        sortOrder = column.order = order2;
      }
      states.sortProp.value = sortProp;
      states.sortOrder.value = sortOrder;
      parent.store.commit("changeSortCondition");
    };
    return {
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick
    };
  }
  exports["default"] = useEvent2;
})(eventHelper);
var style_helper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  function useStyle(props2) {
    const instance = vue2.getCurrentInstance();
    const parent = instance.parent;
    const storeData = parent.store.states;
    const isCellHidden = (index2, columns) => {
      let start2 = 0;
      for (let i = 0; i < index2; i++) {
        start2 += columns[i].colSpan;
      }
      const after = start2 + columns[index2].colSpan - 1;
      if (props2.fixed === "left") {
        return after >= storeData.fixedLeafColumnsLength.value;
      } else if (props2.fixed === "right") {
        return start2 < storeData.columns.value.length - storeData.rightFixedLeafColumnsLength.value;
      } else {
        return after < storeData.fixedLeafColumnsLength.value || start2 >= storeData.columns.value.length - storeData.rightFixedLeafColumnsLength.value;
      }
    };
    const getHeaderRowStyle = (rowIndex) => {
      const headerRowStyle = parent.props.headerRowStyle;
      if (typeof headerRowStyle === "function") {
        return headerRowStyle.call(null, { rowIndex });
      }
      return headerRowStyle;
    };
    const getHeaderRowClass = (rowIndex) => {
      const classes = [];
      const headerRowClassName = parent.props.headerRowClassName;
      if (typeof headerRowClassName === "string") {
        classes.push(headerRowClassName);
      } else if (typeof headerRowClassName === "function") {
        classes.push(headerRowClassName.call(null, { rowIndex }));
      }
      return classes.join(" ");
    };
    const getHeaderCellStyle = (rowIndex, columnIndex, row2, column) => {
      const headerCellStyle = parent.props.headerCellStyle;
      if (typeof headerCellStyle === "function") {
        return headerCellStyle.call(null, {
          rowIndex,
          columnIndex,
          row: row2,
          column
        });
      }
      return headerCellStyle;
    };
    const getHeaderCellClass = (rowIndex, columnIndex, row2, column) => {
      const classes = [
        column.id,
        column.order,
        column.headerAlign,
        column.className,
        column.labelClassName
      ];
      if (rowIndex === 0 && isCellHidden(columnIndex, row2)) {
        classes.push("is-hidden");
      }
      if (!column.children) {
        classes.push("is-leaf");
      }
      if (column.sortable) {
        classes.push("is-sortable");
      }
      const headerCellClassName = parent.props.headerCellClassName;
      if (typeof headerCellClassName === "string") {
        classes.push(headerCellClassName);
      } else if (typeof headerCellClassName === "function") {
        classes.push(headerCellClassName.call(null, {
          rowIndex,
          columnIndex,
          row: row2,
          column
        }));
      }
      classes.push("el-table__cell");
      return classes.join(" ");
    };
    return {
      getHeaderRowStyle,
      getHeaderRowClass,
      getHeaderCellStyle,
      getHeaderCellClass
    };
  }
  exports["default"] = useStyle;
})(style_helper);
var utilsHelper$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  const getAllColumns = (columns) => {
    const result3 = [];
    columns.forEach((column) => {
      if (column.children) {
        result3.push(column);
        result3.push.apply(result3, getAllColumns(column.children));
      } else {
        result3.push(column);
      }
    });
    return result3;
  };
  const convertToRows = (originColumns) => {
    let maxLevel = 1;
    const traverse2 = (column, parent) => {
      if (parent) {
        column.level = parent.level + 1;
        if (maxLevel < column.level) {
          maxLevel = column.level;
        }
      }
      if (column.children) {
        let colSpan = 0;
        column.children.forEach((subColumn) => {
          traverse2(subColumn, column);
          colSpan += subColumn.colSpan;
        });
        column.colSpan = colSpan;
      } else {
        column.colSpan = 1;
      }
    };
    originColumns.forEach((column) => {
      column.level = 1;
      traverse2(column, void 0);
    });
    const rows = [];
    for (let i = 0; i < maxLevel; i++) {
      rows.push([]);
    }
    const allColumns = getAllColumns(originColumns);
    allColumns.forEach((column) => {
      if (!column.children) {
        column.rowSpan = maxLevel - column.level + 1;
      } else {
        column.rowSpan = 1;
      }
      rows[column.level - 1].push(column);
    });
    return rows;
  };
  function useUtils(props2) {
    const instance = vue2.getCurrentInstance();
    const parent = instance.parent;
    const columnRows = vue2.computed(() => {
      return convertToRows(props2.store.states.originColumns.value);
    });
    const isGroup = vue2.computed(() => {
      const result3 = columnRows.value.length > 1;
      if (result3)
        parent.state.isGroup.value = true;
      return result3;
    });
    const toggleAllSelection = (event) => {
      event.stopPropagation();
      parent.store.commit("toggleAllSelection");
    };
    return {
      isGroup,
      toggleAllSelection,
      columnRows
    };
  }
  exports["default"] = useUtils;
})(utilsHelper$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = checkbox$1;
  var layoutObserver$1 = layoutObserver;
  var hHelper$1 = hHelper;
  var eventHelper$1 = eventHelper;
  var style_helper$1 = style_helper;
  var utilsHelper2 = utilsHelper$1;
  var filterPanel_vue_vue_type_script_lang$1 = filterPanel_vue_vue_type_script_lang;
  var TableHeader = vue2.defineComponent({
    name: "ElTableHeader",
    components: {
      ElCheckbox: index2.ElCheckbox
    },
    props: {
      fixed: {
        type: String,
        default: ""
      },
      store: {
        required: true,
        type: Object
      },
      border: Boolean,
      defaultSort: {
        type: Object,
        default: () => {
          return {
            prop: "",
            order: ""
          };
        }
      }
    },
    setup(props2, { emit }) {
      const instance = vue2.getCurrentInstance();
      const parent = instance.parent;
      const storeData = parent.store.states;
      const filterPanels = vue2.ref({});
      const { tableLayout: tableLayout2, onColumnsChange, onScrollableChange } = layoutObserver$1["default"](parent);
      const hasGutter = vue2.computed(() => {
        return !props2.fixed && tableLayout2.gutterWidth;
      });
      vue2.onMounted(() => {
        vue2.nextTick(() => {
          const { prop, order: order2 } = props2.defaultSort;
          const init = true;
          parent.store.commit("sort", { prop, order: order2, init });
        });
      });
      const {
        handleHeaderClick,
        handleHeaderContextMenu,
        handleMouseDown,
        handleMouseMove,
        handleMouseOut,
        handleSortClick,
        handleFilterClick
      } = eventHelper$1["default"](props2, emit);
      const {
        getHeaderRowStyle,
        getHeaderRowClass,
        getHeaderCellStyle,
        getHeaderCellClass
      } = style_helper$1["default"](props2);
      const { isGroup, toggleAllSelection, columnRows } = utilsHelper2["default"](props2);
      instance.state = {
        onColumnsChange,
        onScrollableChange
      };
      instance.filterPanels = filterPanels;
      return {
        columns: storeData.columns,
        filterPanels,
        hasGutter,
        onColumnsChange,
        onScrollableChange,
        columnRows,
        getHeaderRowClass,
        getHeaderRowStyle,
        getHeaderCellClass,
        getHeaderCellStyle,
        handleHeaderClick,
        handleHeaderContextMenu,
        handleMouseDown,
        handleMouseMove,
        handleMouseOut,
        handleSortClick,
        handleFilterClick,
        isGroup,
        toggleAllSelection
      };
    },
    render() {
      return vue2.h("table", {
        border: "0",
        cellpadding: "0",
        cellspacing: "0",
        class: "el-table__header"
      }, [
        hHelper$1.hColgroup(this.columns, this.hasGutter),
        vue2.h("thead", {
          class: { "is-group": this.isGroup, "has-gutter": this.hasGutter }
        }, this.columnRows.map((subColumns, rowIndex) => vue2.h("tr", {
          class: this.getHeaderRowClass(rowIndex),
          key: rowIndex,
          style: this.getHeaderRowStyle(rowIndex)
        }, subColumns.map((column, cellIndex) => vue2.h("th", {
          class: this.getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
          colspan: column.colSpan,
          key: `${column.id}-thead`,
          rowSpan: column.rowSpan,
          style: this.getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
          onClick: ($event) => this.handleHeaderClick($event, column),
          onContextmenu: ($event) => this.handleHeaderContextMenu($event, column),
          onMousedown: ($event) => this.handleMouseDown($event, column),
          onMousemove: ($event) => this.handleMouseMove($event, column),
          onMouseout: this.handleMouseOut
        }, [
          vue2.h("div", {
            class: [
              "cell",
              column.filteredValue && column.filteredValue.length > 0 ? "highlight" : "",
              column.labelClassName
            ]
          }, [
            column.renderHeader ? column.renderHeader({
              column,
              $index: cellIndex,
              store: this.store,
              _self: this.$parent
            }) : column.label,
            column.sortable && vue2.h("span", {
              onClick: ($event) => this.handleSortClick($event, column),
              class: "caret-wrapper"
            }, [
              vue2.h("i", {
                onClick: ($event) => this.handleSortClick($event, column, "ascending"),
                class: "sort-caret ascending"
              }),
              vue2.h("i", {
                onClick: ($event) => this.handleSortClick($event, column, "descending"),
                class: "sort-caret descending"
              })
            ]),
            column.filterable && vue2.h(filterPanel_vue_vue_type_script_lang$1["default"], {
              store: this.$parent.store,
              placement: column.filterPlacement || "bottom-start",
              column,
              upDataColumn: (key2, value) => {
                column[key2] = value;
              }
            })
          ])
        ])))))
      ]);
    }
  });
  exports["default"] = TableHeader;
})(tableHeader);
var tableBody = {};
var renderHelper$1 = {};
var eventsHelper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var debounce2 = debounce_1;
  var dom2 = dom$8;
  var util2 = util$3;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var debounce__default2 = /* @__PURE__ */ _interopDefaultLegacy2(debounce2);
  function useEvents(props2) {
    const instance = vue2.getCurrentInstance();
    const parent = instance.parent;
    const tooltipContent = vue2.ref("");
    const tooltipTrigger = vue2.ref(vue2.h("div"));
    const handleEvent = (event, row2, name) => {
      const table2 = parent;
      const cell = util2.getCell(event);
      let column;
      if (cell) {
        column = util2.getColumnByCell({
          columns: props2.store.states.columns.value
        }, cell);
        if (column) {
          table2.emit(`cell-${name}`, row2, column, cell, event);
        }
      }
      table2.emit(`row-${name}`, row2, column, event);
    };
    const handleDoubleClick = (event, row2) => {
      handleEvent(event, row2, "dblclick");
    };
    const handleClick = (event, row2) => {
      props2.store.commit("setCurrentRow", row2);
      handleEvent(event, row2, "click");
    };
    const handleContextMenu = (event, row2) => {
      handleEvent(event, row2, "contextmenu");
    };
    const handleMouseEnter = debounce__default2["default"](function(index2) {
      props2.store.commit("setHoverRow", index2);
    }, 30);
    const handleMouseLeave = debounce__default2["default"](function() {
      props2.store.commit("setHoverRow", null);
    }, 30);
    const handleCellMouseEnter = (event, row2) => {
      const table2 = parent;
      const cell = util2.getCell(event);
      if (cell) {
        const column = util2.getColumnByCell({
          columns: props2.store.states.columns.value
        }, cell);
        const hoverState = table2.hoverState = { cell, column, row: row2 };
        table2.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
      }
      const cellChild = event.target.querySelector(".cell");
      if (!(dom2.hasClass(cellChild, "el-tooltip") && cellChild.childNodes.length)) {
        return;
      }
      const range3 = document.createRange();
      range3.setStart(cellChild, 0);
      range3.setEnd(cellChild, cellChild.childNodes.length);
      const rangeWidth = range3.getBoundingClientRect().width;
      const padding = (parseInt(dom2.getStyle(cellChild, "paddingLeft"), 10) || 0) + (parseInt(dom2.getStyle(cellChild, "paddingRight"), 10) || 0);
      if (rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) {
        util2.createTablePopper(cell, cell.innerText || cell.textContent, {
          placement: "top",
          strategy: "fixed"
        }, row2.tooltipEffect);
      }
    };
    const handleCellMouseLeave = (event) => {
      const cell = util2.getCell(event);
      if (!cell)
        return;
      const oldHoverState = parent.hoverState;
      parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
    };
    return {
      handleDoubleClick,
      handleClick,
      handleContextMenu,
      handleMouseEnter,
      handleMouseLeave,
      handleCellMouseEnter,
      handleCellMouseLeave,
      tooltipContent,
      tooltipTrigger
    };
  }
  exports["default"] = useEvents;
})(eventsHelper);
var stylesHelper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  function useStyles(props2) {
    const instance = vue2.getCurrentInstance();
    const parent = instance.parent;
    const isColumnHidden = (index2) => {
      if (props2.fixed === "left") {
        return index2 >= props2.store.states.fixedLeafColumnsLength.value;
      } else if (props2.fixed === "right") {
        return index2 < props2.store.states.columns.value.length - props2.store.states.rightFixedLeafColumnsLength.value;
      } else {
        return index2 < props2.store.states.fixedLeafColumnsLength.value || index2 >= props2.store.states.columns.value.length - props2.store.states.rightFixedLeafColumnsLength.value;
      }
    };
    const getRowStyle = (row2, rowIndex) => {
      const rowStyle = parent.props.rowStyle;
      if (typeof rowStyle === "function") {
        return rowStyle.call(null, {
          row: row2,
          rowIndex
        });
      }
      return rowStyle || null;
    };
    const getRowClass = (row2, rowIndex) => {
      const classes = ["el-table__row"];
      if (parent.props.highlightCurrentRow && row2 === props2.store.states.currentRow.value) {
        classes.push("current-row");
      }
      if (props2.stripe && rowIndex % 2 === 1) {
        classes.push("el-table__row--striped");
      }
      const rowClassName = parent.props.rowClassName;
      if (typeof rowClassName === "string") {
        classes.push(rowClassName);
      } else if (typeof rowClassName === "function") {
        classes.push(rowClassName.call(null, {
          row: row2,
          rowIndex
        }));
      }
      if (props2.store.states.expandRows.value.indexOf(row2) > -1) {
        classes.push("expanded");
      }
      return classes;
    };
    const getCellStyle = (rowIndex, columnIndex, row2, column) => {
      const cellStyle = parent.props.cellStyle;
      if (typeof cellStyle === "function") {
        return cellStyle.call(null, {
          rowIndex,
          columnIndex,
          row: row2,
          column
        });
      }
      return cellStyle;
    };
    const getCellClass = (rowIndex, columnIndex, row2, column) => {
      const classes = [column.id, column.align, column.className];
      if (isColumnHidden(columnIndex)) {
        classes.push("is-hidden");
      }
      const cellClassName = parent.props.cellClassName;
      if (typeof cellClassName === "string") {
        classes.push(cellClassName);
      } else if (typeof cellClassName === "function") {
        classes.push(cellClassName.call(null, {
          rowIndex,
          columnIndex,
          row: row2,
          column
        }));
      }
      classes.push("el-table__cell");
      return classes.join(" ");
    };
    const getSpan = (row2, column, rowIndex, columnIndex) => {
      let rowspan = 1;
      let colspan = 1;
      const fn3 = parent.props.spanMethod;
      if (typeof fn3 === "function") {
        const result3 = fn3({
          row: row2,
          column,
          rowIndex,
          columnIndex
        });
        if (Array.isArray(result3)) {
          rowspan = result3[0];
          colspan = result3[1];
        } else if (typeof result3 === "object") {
          rowspan = result3.rowspan;
          colspan = result3.colspan;
        }
      }
      return { rowspan, colspan };
    };
    const getColspanRealWidth = (columns, colspan, index2) => {
      if (colspan < 1) {
        return columns[index2].realWidth;
      }
      const widthArr = columns.map(({ realWidth, width }) => realWidth || width).slice(index2, index2 + colspan);
      return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
    };
    return {
      getRowStyle,
      getRowClass,
      getCellStyle,
      getCellClass,
      getSpan,
      getColspanRealWidth,
      isColumnHidden
    };
  }
  exports["default"] = useStyles;
})(stylesHelper);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var util2 = util$3;
  var eventsHelper$1 = eventsHelper;
  var stylesHelper$1 = stylesHelper;
  function useRender(props2) {
    const instance = vue2.getCurrentInstance();
    const parent = instance.parent;
    const {
      handleDoubleClick,
      handleClick,
      handleContextMenu,
      handleMouseEnter,
      handleMouseLeave,
      handleCellMouseEnter,
      handleCellMouseLeave,
      tooltipContent,
      tooltipTrigger
    } = eventsHelper$1["default"](props2);
    const {
      getRowStyle,
      getRowClass,
      getCellStyle,
      getCellClass,
      getSpan,
      getColspanRealWidth
    } = stylesHelper$1["default"](props2);
    const firstDefaultColumnIndex = vue2.computed(() => {
      return props2.store.states.columns.value.findIndex(({ type: type4 }) => type4 === "default");
    });
    const getKeyOfRow = (row2, index2) => {
      const rowKey = parent.props.rowKey;
      if (rowKey) {
        return util2.getRowIdentity(row2, rowKey);
      }
      return index2;
    };
    const rowRender = (row2, $index, treeRowData) => {
      const { tooltipEffect, store: store2 } = props2;
      const { indent, columns } = store2.states;
      const rowClasses = getRowClass(row2, $index);
      let display = true;
      if (treeRowData) {
        rowClasses.push(`el-table__row--level-${treeRowData.level}`);
        display = treeRowData.display;
      }
      const displayStyle = display ? null : {
        display: "none"
      };
      return vue2.h("tr", {
        style: [displayStyle, getRowStyle(row2, $index)],
        class: rowClasses,
        key: getKeyOfRow(row2, $index),
        onDblclick: ($event) => handleDoubleClick($event, row2),
        onClick: ($event) => handleClick($event, row2),
        onContextmenu: ($event) => handleContextMenu($event, row2),
        onMouseenter: () => handleMouseEnter($index),
        onMouseleave: handleMouseLeave
      }, columns.value.map((column, cellIndex) => {
        const { rowspan, colspan } = getSpan(row2, column, $index, cellIndex);
        if (!rowspan || !colspan) {
          return null;
        }
        const columnData = __spreadValues({}, column);
        columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
        const data2 = {
          store: props2.store,
          _self: props2.context || parent,
          column: columnData,
          row: row2,
          $index
        };
        if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
          data2.treeNode = {
            indent: treeRowData.level * indent.value,
            level: treeRowData.level
          };
          if (typeof treeRowData.expanded === "boolean") {
            data2.treeNode.expanded = treeRowData.expanded;
            if ("loading" in treeRowData) {
              data2.treeNode.loading = treeRowData.loading;
            }
            if ("noLazyChildren" in treeRowData) {
              data2.treeNode.noLazyChildren = treeRowData.noLazyChildren;
            }
          }
        }
        const baseKey = `${$index},${cellIndex}`;
        const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
        const tdChildren = cellChildren(cellIndex, column, data2);
        return vue2.h("td", {
          style: getCellStyle($index, cellIndex, row2, column),
          class: getCellClass($index, cellIndex, row2, column),
          key: `${patchKey}${baseKey}`,
          rowspan,
          colspan,
          onMouseenter: ($event) => handleCellMouseEnter($event, __spreadProps(__spreadValues({}, row2), { tooltipEffect })),
          onMouseleave: handleCellMouseLeave
        }, [tdChildren]);
      }));
    };
    const cellChildren = (cellIndex, column, data2) => {
      return column.renderCell(data2);
    };
    const wrappedRowRender = (row2, $index) => {
      const store2 = props2.store;
      const { isRowExpanded, assertRowKey } = store2;
      const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store2.states;
      const hasExpandColumn = store2.states.columns.value.some(({ type: type4 }) => type4 === "expand");
      if (hasExpandColumn && isRowExpanded(row2)) {
        const renderExpanded = parent.renderExpanded;
        const tr = rowRender(row2, $index, void 0);
        if (!renderExpanded) {
          console.error("[Element Error]renderExpanded is required.");
          return tr;
        }
        return [
          [
            tr,
            vue2.h("tr", {
              key: `expanded-row__${tr.key}`
            }, [
              vue2.h("td", {
                colspan: store2.states.columns.value.length,
                class: "el-table__cell el-table__expanded-cell"
              }, [renderExpanded({ row: row2, $index, store: store2 })])
            ])
          ]
        ];
      } else if (Object.keys(treeData.value).length) {
        assertRowKey();
        const key2 = util2.getRowIdentity(row2, rowKey.value);
        let cur = treeData.value[key2];
        let treeRowData = null;
        if (cur) {
          treeRowData = {
            expanded: cur.expanded,
            level: cur.level,
            display: true
          };
          if (typeof cur.lazy === "boolean") {
            if (typeof cur.loaded === "boolean" && cur.loaded) {
              treeRowData.noLazyChildren = !(cur.children && cur.children.length);
            }
            treeRowData.loading = cur.loading;
          }
        }
        const tmp = [rowRender(row2, $index, treeRowData)];
        if (cur) {
          let i = 0;
          const traverse2 = (children, parent2) => {
            if (!(children && children.length && parent2))
              return;
            children.forEach((node3) => {
              const innerTreeRowData = {
                display: parent2.display && parent2.expanded,
                level: parent2.level + 1,
                expanded: false,
                noLazyChildren: false,
                loading: false
              };
              const childKey = util2.getRowIdentity(node3, rowKey.value);
              if (childKey === void 0 || childKey === null) {
                throw new Error("For nested data item, row-key is required.");
              }
              cur = __spreadValues({}, treeData.value[childKey]);
              if (cur) {
                innerTreeRowData.expanded = cur.expanded;
                cur.level = cur.level || innerTreeRowData.level;
                cur.display = !!(cur.expanded && innerTreeRowData.display);
                if (typeof cur.lazy === "boolean") {
                  if (typeof cur.loaded === "boolean" && cur.loaded) {
                    innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                  }
                  innerTreeRowData.loading = cur.loading;
                }
              }
              i++;
              tmp.push(rowRender(node3, $index + i, innerTreeRowData));
              if (cur) {
                const nodes2 = lazyTreeNodeMap.value[childKey] || node3[childrenColumnName.value];
                traverse2(nodes2, cur);
              }
            });
          };
          cur.display = true;
          const nodes = lazyTreeNodeMap.value[key2] || row2[childrenColumnName.value];
          traverse2(nodes, cur);
        }
        return tmp;
      } else {
        return rowRender(row2, $index, void 0);
      }
    };
    return {
      wrappedRowRender,
      tooltipContent,
      tooltipTrigger
    };
  }
  exports["default"] = useRender;
})(renderHelper$1);
var defaults$8 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const defaultProps2 = {
    store: {
      required: true,
      type: Object
    },
    stripe: Boolean,
    tooltipEffect: String,
    context: {
      default: () => ({}),
      type: Object
    },
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    fixed: {
      type: String,
      default: ""
    },
    highlight: Boolean
  };
  exports["default"] = defaultProps2;
})(defaults$8);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var dom2 = dom$8;
  var isServer2 = isServer$8;
  var hHelper$1 = hHelper;
  var layoutObserver$1 = layoutObserver;
  var util2 = util$3;
  var renderHelper2 = renderHelper$1;
  var defaults2 = defaults$8;
  var TableBody = vue2.defineComponent({
    name: "ElTableBody",
    props: defaults2["default"],
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const parent = instance.parent;
      const { wrappedRowRender, tooltipContent, tooltipTrigger } = renderHelper2["default"](props2);
      const { onColumnsChange, onScrollableChange } = layoutObserver$1["default"](parent);
      vue2.watch(props2.store.states.hoverRow, (newVal, oldVal) => {
        if (!props2.store.states.isComplex.value || isServer2["default"])
          return;
        let raf2 = window.requestAnimationFrame;
        if (!raf2) {
          raf2 = (fn3) => window.setTimeout(fn3, 16);
        }
        raf2(() => {
          const rows = instance.vnode.el.querySelectorAll(".el-table__row");
          const oldRow = rows[oldVal];
          const newRow = rows[newVal];
          if (oldRow) {
            dom2.removeClass(oldRow, "hover-row");
          }
          if (newRow) {
            dom2.addClass(newRow, "hover-row");
          }
        });
      });
      vue2.onUnmounted(() => {
        var _a;
        (_a = util2.removePopper) == null ? void 0 : _a();
      });
      vue2.onUpdated(() => {
        var _a;
        (_a = util2.removePopper) == null ? void 0 : _a();
      });
      return {
        onColumnsChange,
        onScrollableChange,
        wrappedRowRender,
        tooltipContent,
        tooltipTrigger
      };
    },
    render() {
      const data2 = this.store.states.data.value || [];
      return vue2.h("table", {
        class: "el-table__body",
        cellspacing: "0",
        cellpadding: "0",
        border: "0"
      }, [
        hHelper$1.hColgroup(this.store.states.columns.value),
        vue2.h("tbody", {}, [
          data2.reduce((acc, row2) => {
            return acc.concat(this.wrappedRowRender(row2, acc.length));
          }, [])
        ])
      ]);
    }
  });
  exports["default"] = TableBody;
})(tableBody);
var tableFooter = {};
var styleHelper$1 = {};
var mapStateHelper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  function useMapState() {
    const instance = vue2.getCurrentInstance();
    const table2 = instance.parent;
    const store2 = table2.store;
    const leftFixedLeafCount = vue2.computed(() => {
      return store2.states.fixedLeafColumnsLength.value;
    });
    const rightFixedLeafCount = vue2.computed(() => {
      return store2.states.rightFixedColumns.value.length;
    });
    const columnsCount = vue2.computed(() => {
      return store2.states.columns.value.length;
    });
    const leftFixedCount = vue2.computed(() => {
      return store2.states.fixedColumns.value.length;
    });
    const rightFixedCount = vue2.computed(() => {
      return store2.states.rightFixedColumns.value.length;
    });
    return {
      leftFixedLeafCount,
      rightFixedLeafCount,
      columnsCount,
      leftFixedCount,
      rightFixedCount,
      columns: store2.states.columns
    };
  }
  exports["default"] = useMapState;
})(mapStateHelper);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var mapStateHelper$1 = mapStateHelper;
  function useStyle(props2) {
    const instance = vue2.getCurrentInstance();
    const table2 = instance.parent;
    const store2 = table2.store;
    const {
      leftFixedLeafCount,
      rightFixedLeafCount,
      columnsCount,
      leftFixedCount,
      rightFixedCount,
      columns
    } = mapStateHelper$1["default"]();
    const hasGutter = vue2.computed(() => {
      return !props2.fixed && !table2.layout.gutterWidth;
    });
    const isCellHidden = (index2, columns2, column) => {
      if (props2.fixed || props2.fixed === "left") {
        return index2 >= leftFixedLeafCount.value;
      } else if (props2.fixed === "right") {
        let before = 0;
        for (let i = 0; i < index2; i++) {
          before += columns2[i].colSpan;
        }
        return before < columnsCount.value - rightFixedLeafCount.value;
      } else if (!props2.fixed && column.fixed) {
        return true;
      } else {
        return index2 < leftFixedCount.value || index2 >= columnsCount.value - rightFixedCount.value;
      }
    };
    const getRowClasses = (column, cellIndex) => {
      const classes = [column.id, column.align, column.labelClassName];
      if (column.className) {
        classes.push(column.className);
      }
      if (isCellHidden(cellIndex, store2.states.columns.value, column)) {
        classes.push("is-hidden");
      }
      if (!column.children) {
        classes.push("is-leaf");
      }
      return classes;
    };
    return {
      hasGutter,
      getRowClasses,
      columns
    };
  }
  exports["default"] = useStyle;
})(styleHelper$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var hHelper$1 = hHelper;
  var styleHelper2 = styleHelper$1;
  var TableFooter = vue2.defineComponent({
    name: "ElTableFooter",
    props: {
      fixed: {
        type: String,
        default: ""
      },
      store: {
        required: true,
        type: Object
      },
      summaryMethod: Function,
      sumText: String,
      border: Boolean,
      defaultSort: {
        type: Object,
        default: () => {
          return {
            prop: "",
            order: ""
          };
        }
      }
    },
    setup(props2) {
      const { hasGutter, getRowClasses, columns } = styleHelper2["default"](props2);
      return {
        getRowClasses,
        hasGutter,
        columns
      };
    },
    render() {
      let sums = [];
      if (this.summaryMethod) {
        sums = this.summaryMethod({
          columns: this.columns,
          data: this.store.states.data.value
        });
      } else {
        this.columns.forEach((column, index2) => {
          if (index2 === 0) {
            sums[index2] = this.sumText;
            return;
          }
          const values = this.store.states.data.value.map((item2) => Number(item2[column.property]));
          const precisions = [];
          let notNumber = true;
          values.forEach((value) => {
            if (!isNaN(value)) {
              notNumber = false;
              const decimal = `${value}`.split(".")[1];
              precisions.push(decimal ? decimal.length : 0);
            }
          });
          const precision = Math.max.apply(null, precisions);
          if (!notNumber) {
            sums[index2] = values.reduce((prev2, curr) => {
              const value = Number(curr);
              if (!isNaN(value)) {
                return parseFloat((prev2 + curr).toFixed(Math.min(precision, 20)));
              } else {
                return prev2;
              }
            }, 0);
          } else {
            sums[index2] = "";
          }
        });
      }
      return vue2.h("table", {
        class: "el-table__footer",
        cellspacing: "0",
        cellpadding: "0",
        border: "0"
      }, [
        hHelper$1.hColgroup(this.columns, this.hasGutter),
        vue2.h("tbody", {
          class: [{ "has-gutter": this.hasGutter }]
        }, [
          vue2.h("tr", {}, [
            ...this.columns.map((column, cellIndex) => vue2.h("td", {
              key: cellIndex,
              colspan: column.colSpan,
              rowspan: column.rowSpan,
              class: [
                ...this.getRowClasses(column, cellIndex),
                "el-table__cell"
              ]
            }, [
              vue2.h("div", {
                class: ["cell", column.labelClassName]
              }, [sums[cellIndex]])
            ])),
            this.hasGutter && hHelper$1.hGutter()
          ])
        ])
      ]);
    }
  });
  exports["default"] = TableFooter;
})(tableFooter);
var utilsHelper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function useUtils(store2) {
    const setCurrentRow = (row2) => {
      store2.commit("setCurrentRow", row2);
    };
    const toggleRowSelection = (row2, selected) => {
      store2.toggleRowSelection(row2, selected, false);
      store2.updateAllSelected();
    };
    const clearSelection = () => {
      store2.clearSelection();
    };
    const clearFilter = (columnKeys) => {
      store2.clearFilter(columnKeys);
    };
    const toggleAllSelection = () => {
      store2.commit("toggleAllSelection");
    };
    const toggleRowExpansion = (row2, expanded) => {
      store2.toggleRowExpansionAdapter(row2, expanded);
    };
    const clearSort = () => {
      store2.clearSort();
    };
    const sort2 = (prop, order2) => {
      store2.commit("sort", { prop, order: order2 });
    };
    return {
      setCurrentRow,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      sort: sort2
    };
  }
  exports["default"] = useUtils;
})(utilsHelper);
var styleHelper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var throttle2 = throttle_1;
  var resizeEvent$1 = resizeEvent;
  var dom2 = dom$8;
  var util2 = util$3;
  var index2 = useCommonProps;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var throttle__default = /* @__PURE__ */ _interopDefaultLegacy2(throttle2);
  function useStyle(props2, layout2, store2, table2) {
    const isHidden = vue2.ref(false);
    const renderExpanded = vue2.ref(null);
    const resizeProxyVisible = vue2.ref(false);
    const setDragVisible = (visible) => {
      resizeProxyVisible.value = visible;
    };
    const resizeState = vue2.ref({
      width: null,
      height: null
    });
    const isGroup = vue2.ref(false);
    vue2.watchEffect(() => {
      layout2.setHeight(props2.height);
    });
    vue2.watchEffect(() => {
      layout2.setMaxHeight(props2.maxHeight);
    });
    vue2.watch(() => [props2.currentRowKey, store2.states.rowKey], ([currentRowKey, rowKey]) => {
      if (!vue2.unref(rowKey))
        return;
      store2.setCurrentRowKey(`${currentRowKey}`);
    }, {
      immediate: true
    });
    vue2.watch(() => props2.data, (data2) => {
      table2.store.commit("setData", data2);
    }, {
      immediate: true,
      deep: true
    });
    vue2.watchEffect(() => {
      if (props2.expandRowKeys) {
        store2.setExpandRowKeysAdapter(props2.expandRowKeys);
      }
    });
    const handleMouseLeave = () => {
      table2.store.commit("setHoverRow", null);
      if (table2.hoverState)
        table2.hoverState = null;
    };
    const handleHeaderFooterMousewheel = (event, data2) => {
      const { pixelX, pixelY } = data2;
      if (Math.abs(pixelX) >= Math.abs(pixelY)) {
        table2.refs.bodyWrapper.scrollLeft += data2.pixelX / 5;
      }
    };
    const shouldUpdateHeight = vue2.computed(() => {
      return props2.height || props2.maxHeight || store2.states.fixedColumns.value.length > 0 || store2.states.rightFixedColumns.value.length > 0;
    });
    const doLayout = () => {
      if (shouldUpdateHeight.value) {
        layout2.updateElsHeight();
      }
      layout2.updateColumnsWidth();
      requestAnimationFrame(syncPostion);
    };
    vue2.onMounted(async () => {
      setScrollClass("is-scrolling-left");
      store2.updateColumns();
      await vue2.nextTick();
      bindEvents();
      requestAnimationFrame(doLayout);
      resizeState.value = {
        width: table2.vnode.el.offsetWidth,
        height: table2.vnode.el.offsetHeight
      };
      store2.states.columns.value.forEach((column) => {
        if (column.filteredValue && column.filteredValue.length) {
          table2.store.commit("filterChange", {
            column,
            values: column.filteredValue,
            silent: true
          });
        }
      });
      table2.$ready = true;
    });
    const setScrollClassByEl = (el, className) => {
      if (!el)
        return;
      const classList = Array.from(el.classList).filter((item2) => !item2.startsWith("is-scrolling-"));
      classList.push(layout2.scrollX.value ? className : "is-scrolling-none");
      el.className = classList.join(" ");
    };
    const setScrollClass = (className) => {
      const { bodyWrapper } = table2.refs;
      setScrollClassByEl(bodyWrapper, className);
    };
    const syncPostion = throttle__default["default"](function() {
      if (!table2.refs.bodyWrapper)
        return;
      const { scrollLeft, scrollTop, offsetWidth, scrollWidth } = table2.refs.bodyWrapper;
      const {
        headerWrapper,
        footerWrapper,
        fixedBodyWrapper,
        rightFixedBodyWrapper
      } = table2.refs;
      if (headerWrapper)
        headerWrapper.scrollLeft = scrollLeft;
      if (footerWrapper)
        footerWrapper.scrollLeft = scrollLeft;
      if (fixedBodyWrapper)
        fixedBodyWrapper.scrollTop = scrollTop;
      if (rightFixedBodyWrapper)
        rightFixedBodyWrapper.scrollTop = scrollTop;
      const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
      if (scrollLeft >= maxScrollLeftPosition) {
        setScrollClass("is-scrolling-right");
      } else if (scrollLeft === 0) {
        setScrollClass("is-scrolling-left");
      } else {
        setScrollClass("is-scrolling-middle");
      }
    }, 10);
    const bindEvents = () => {
      table2.refs.bodyWrapper.addEventListener("scroll", syncPostion, {
        passive: true
      });
      if (props2.fit) {
        resizeEvent$1.addResizeListener(table2.vnode.el, resizeListener);
      } else {
        dom2.on(window, "resize", doLayout);
      }
    };
    vue2.onUnmounted(() => {
      unbindEvents();
    });
    const unbindEvents = () => {
      var _a;
      (_a = table2.refs.bodyWrapper) == null ? void 0 : _a.removeEventListener("scroll", syncPostion, true);
      if (props2.fit) {
        resizeEvent$1.removeResizeListener(table2.vnode.el, resizeListener);
      } else {
        dom2.off(window, "resize", doLayout);
      }
    };
    const resizeListener = () => {
      if (!table2.$ready)
        return;
      let shouldUpdateLayout = false;
      const el = table2.vnode.el;
      const { width: oldWidth, height: oldHeight } = resizeState.value;
      const width = el.offsetWidth;
      if (oldWidth !== width) {
        shouldUpdateLayout = true;
      }
      const height = el.offsetHeight;
      if ((props2.height || shouldUpdateHeight.value) && oldHeight !== height) {
        shouldUpdateLayout = true;
      }
      if (shouldUpdateLayout) {
        resizeState.value = {
          width,
          height
        };
        doLayout();
      }
    };
    const tableSize = index2.useSize();
    const bodyWidth = vue2.computed(() => {
      const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout2;
      return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
    });
    const bodyHeight = vue2.computed(() => {
      const headerHeight = layout2.headerHeight.value || 0;
      const bodyHeight2 = layout2.bodyHeight.value;
      const footerHeight = layout2.footerHeight.value || 0;
      if (props2.height) {
        return {
          height: bodyHeight2 ? `${bodyHeight2}px` : ""
        };
      } else if (props2.maxHeight) {
        const maxHeight = util2.parseHeight(props2.maxHeight);
        if (typeof maxHeight === "number") {
          return {
            "max-height": `${maxHeight - footerHeight - (props2.showHeader ? headerHeight : 0)}px`
          };
        }
      }
      return {};
    });
    const emptyBlockStyle = vue2.computed(() => {
      if (props2.data && props2.data.length)
        return null;
      let height = "100%";
      if (layout2.appendHeight.value) {
        height = `calc(100% - ${layout2.appendHeight.value}px)`;
      }
      return {
        width: bodyWidth.value,
        height
      };
    });
    const handleFixedMousewheel = (event, data2) => {
      const bodyWrapper = table2.refs.bodyWrapper;
      if (Math.abs(data2.spinY) > 0) {
        const currentScrollTop = bodyWrapper.scrollTop;
        if (data2.pixelY < 0 && currentScrollTop !== 0) {
          event.preventDefault();
        }
        if (data2.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
          event.preventDefault();
        }
        bodyWrapper.scrollTop += Math.ceil(data2.pixelY / 5);
      } else {
        bodyWrapper.scrollLeft += Math.ceil(data2.pixelX / 5);
      }
    };
    const fixedHeight = vue2.computed(() => {
      if (props2.maxHeight) {
        if (props2.showSummary) {
          return {
            bottom: 0
          };
        }
        return {
          bottom: layout2.scrollX.value && props2.data.length ? `${layout2.gutterWidth}px` : ""
        };
      } else {
        if (props2.showSummary) {
          return {
            height: layout2.tableHeight.value ? `${layout2.tableHeight.value}px` : ""
          };
        }
        return {
          height: layout2.viewportHeight.value ? `${layout2.viewportHeight.value}px` : ""
        };
      }
    });
    const fixedBodyHeight = vue2.computed(() => {
      if (props2.height) {
        return {
          height: layout2.fixedBodyHeight.value ? `${layout2.fixedBodyHeight.value}px` : ""
        };
      } else if (props2.maxHeight) {
        let maxHeight = util2.parseHeight(props2.maxHeight);
        if (typeof maxHeight === "number") {
          maxHeight = layout2.scrollX.value ? maxHeight - layout2.gutterWidth : maxHeight;
          if (props2.showHeader) {
            maxHeight -= layout2.headerHeight.value;
          }
          maxHeight -= layout2.footerHeight.value;
          return {
            "max-height": `${maxHeight}px`
          };
        }
      }
      return {};
    });
    return {
      isHidden,
      renderExpanded,
      setDragVisible,
      isGroup,
      handleMouseLeave,
      handleHeaderFooterMousewheel,
      tableSize,
      bodyHeight,
      emptyBlockStyle,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      resizeProxyVisible,
      bodyWidth,
      resizeState,
      doLayout
    };
  }
  exports["default"] = useStyle;
})(styleHelper);
var defaults$7 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var defaultProps2 = {
    data: {
      type: Array,
      default: () => {
        return [];
      }
    },
    size: String,
    width: [String, Number],
    height: [String, Number],
    maxHeight: [String, Number],
    fit: {
      type: Boolean,
      default: true
    },
    stripe: Boolean,
    border: Boolean,
    rowKey: [String, Function],
    showHeader: {
      type: Boolean,
      default: true
    },
    showSummary: Boolean,
    sumText: String,
    summaryMethod: Function,
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    cellClassName: [String, Function],
    cellStyle: [Object, Function],
    headerRowClassName: [String, Function],
    headerRowStyle: [Object, Function],
    headerCellClassName: [String, Function],
    headerCellStyle: [Object, Function],
    highlightCurrentRow: Boolean,
    currentRowKey: [String, Number],
    emptyText: String,
    expandRowKeys: Array,
    defaultExpandAll: Boolean,
    defaultSort: Object,
    tooltipEffect: String,
    spanMethod: Function,
    selectOnIndeterminate: {
      type: Boolean,
      default: true
    },
    indent: {
      type: Number,
      default: 16
    },
    treeProps: {
      type: Object,
      default: () => {
        return {
          hasChildren: "hasChildren",
          children: "children"
        };
      }
    },
    lazy: Boolean,
    load: Function,
    style: {
      type: Object,
      default: () => ({})
    },
    className: {
      type: String,
      default: ""
    }
  };
  exports["default"] = defaultProps2;
})(defaults$7);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var debounce2 = debounce_1;
  var helper$1 = helper;
  var tableLayout$1 = tableLayout;
  var index$110 = tableHeader;
  var index$22 = tableBody;
  var index$32 = tableFooter;
  var utilsHelper$12 = utilsHelper;
  var styleHelper$12 = styleHelper;
  var defaults2 = defaults$7;
  var index2 = mousewheel;
  var index$42 = useLocale$1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var debounce__default2 = /* @__PURE__ */ _interopDefaultLegacy2(debounce2);
  let tableIdSeed = 1;
  var script2 = vue2.defineComponent({
    name: "ElTable",
    directives: {
      Mousewheel: index2["default"]
    },
    components: {
      TableHeader: index$110["default"],
      TableBody: index$22["default"],
      TableFooter: index$32["default"]
    },
    props: defaults2["default"],
    emits: [
      "select",
      "select-all",
      "selection-change",
      "cell-mouse-enter",
      "cell-mouse-leave",
      "cell-contextmenu",
      "cell-click",
      "cell-dblclick",
      "row-click",
      "row-contextmenu",
      "row-dblclick",
      "header-click",
      "header-contextmenu",
      "sort-change",
      "filter-change",
      "current-change",
      "header-dragend",
      "expand-change"
    ],
    setup(props2) {
      const { t } = index$42.useLocale();
      const table2 = vue2.getCurrentInstance();
      const store2 = helper$1.createStore(table2, props2);
      table2.store = store2;
      const layout2 = new tableLayout$1["default"]({
        store: table2.store,
        table: table2,
        fit: props2.fit,
        showHeader: props2.showHeader
      });
      table2.layout = layout2;
      const isEmpty = vue2.computed(() => (store2.states.data.value || []).length === 0);
      const {
        setCurrentRow,
        toggleRowSelection,
        clearSelection,
        clearFilter,
        toggleAllSelection,
        toggleRowExpansion,
        clearSort,
        sort: sort2
      } = utilsHelper$12["default"](store2);
      const {
        isHidden,
        renderExpanded,
        setDragVisible,
        isGroup,
        handleMouseLeave,
        handleHeaderFooterMousewheel,
        tableSize,
        bodyHeight,
        emptyBlockStyle,
        handleFixedMousewheel,
        fixedHeight,
        fixedBodyHeight,
        resizeProxyVisible,
        bodyWidth,
        resizeState,
        doLayout
      } = styleHelper$12["default"](props2, layout2, store2, table2);
      const debouncedUpdateLayout = debounce__default2["default"](doLayout, 50);
      const tableId = `el-table_${tableIdSeed++}`;
      table2.tableId = tableId;
      table2.state = {
        isGroup,
        resizeState,
        doLayout,
        debouncedUpdateLayout
      };
      return {
        layout: layout2,
        store: store2,
        handleHeaderFooterMousewheel,
        handleMouseLeave,
        tableId,
        tableSize,
        isHidden,
        isEmpty,
        renderExpanded,
        resizeProxyVisible,
        resizeState,
        isGroup,
        bodyWidth,
        bodyHeight,
        emptyBlockStyle,
        debouncedUpdateLayout,
        handleFixedMousewheel,
        fixedHeight,
        fixedBodyHeight,
        setCurrentRow,
        toggleRowSelection,
        clearSelection,
        clearFilter,
        toggleAllSelection,
        toggleRowExpansion,
        clearSort,
        doLayout,
        sort: sort2,
        t,
        setDragVisible,
        context: table2
      };
    }
  });
  exports["default"] = script2;
})(table_vue_vue_type_script_lang);
var table_vue_vue_type_template_id_4a1660ad_lang = {};
Object.defineProperty(table_vue_vue_type_template_id_4a1660ad_lang, "__esModule", { value: true });
var vue$s = require$$0$1;
const _hoisted_1$d = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
const _hoisted_2$a = {
  key: 0,
  ref: "headerWrapper",
  class: "el-table__header-wrapper"
};
const _hoisted_3$8 = { class: "el-table__empty-text" };
const _hoisted_4$5 = {
  key: 1,
  ref: "appendWrapper",
  class: "el-table__append-wrapper"
};
const _hoisted_5$4 = {
  key: 1,
  ref: "footerWrapper",
  class: "el-table__footer-wrapper"
};
const _hoisted_6$3 = {
  key: 0,
  ref: "fixedHeaderWrapper",
  class: "el-table__fixed-header-wrapper"
};
const _hoisted_7$2 = {
  key: 1,
  ref: "fixedFooterWrapper",
  class: "el-table__fixed-footer-wrapper"
};
const _hoisted_8$2 = {
  key: 0,
  ref: "rightFixedHeaderWrapper",
  class: "el-table__fixed-header-wrapper"
};
const _hoisted_9$1 = {
  key: 1,
  ref: "rightFixedFooterWrapper",
  class: "el-table__fixed-footer-wrapper"
};
const _hoisted_10$1 = {
  ref: "resizeProxy",
  class: "el-table__column-resize-proxy"
};
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_table_header = vue$s.resolveComponent("table-header");
  const _component_table_body = vue$s.resolveComponent("table-body");
  const _component_table_footer = vue$s.resolveComponent("table-footer");
  const _directive_mousewheel = vue$s.resolveDirective("mousewheel");
  return vue$s.openBlock(), vue$s.createElementBlock("div", {
    class: vue$s.normalizeClass([
      {
        "el-table--fit": _ctx.fit,
        "el-table--striped": _ctx.stripe,
        "el-table--border": _ctx.border || _ctx.isGroup,
        "el-table--hidden": _ctx.isHidden,
        "el-table--group": _ctx.isGroup,
        "el-table--fluid-height": _ctx.maxHeight,
        "el-table--scrollable-x": _ctx.layout.scrollX.value,
        "el-table--scrollable-y": _ctx.layout.scrollY.value,
        "el-table--enable-row-hover": !_ctx.store.states.isComplex.value,
        "el-table--enable-row-transition": (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100
      },
      _ctx.tableSize ? `el-table--${_ctx.tableSize}` : "",
      _ctx.className,
      "el-table"
    ]),
    style: vue$s.normalizeStyle(_ctx.style),
    onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.handleMouseLeave())
  }, [
    vue$s.createElementVNode("div", _hoisted_1$d, [
      vue$s.renderSlot(_ctx.$slots, "default")
    ], 512),
    _ctx.showHeader ? vue$s.withDirectives((vue$s.openBlock(), vue$s.createElementBlock("div", _hoisted_2$a, [
      vue$s.createVNode(_component_table_header, {
        ref: "tableHeader",
        border: _ctx.border,
        "default-sort": _ctx.defaultSort,
        store: _ctx.store,
        style: vue$s.normalizeStyle({
          width: _ctx.layout.bodyWidth.value ? _ctx.layout.bodyWidth.value + "px" : ""
        }),
        onSetDragVisible: _ctx.setDragVisible
      }, null, 8, ["border", "default-sort", "store", "style", "onSetDragVisible"])
    ], 512)), [
      [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
    ]) : vue$s.createCommentVNode("v-if", true),
    vue$s.createElementVNode("div", {
      ref: "bodyWrapper",
      style: vue$s.normalizeStyle([_ctx.bodyHeight]),
      class: "el-table__body-wrapper"
    }, [
      vue$s.createVNode(_component_table_body, {
        context: _ctx.context,
        highlight: _ctx.highlightCurrentRow,
        "row-class-name": _ctx.rowClassName,
        "tooltip-effect": _ctx.tooltipEffect,
        "row-style": _ctx.rowStyle,
        store: _ctx.store,
        stripe: _ctx.stripe,
        style: vue$s.normalizeStyle({
          width: _ctx.bodyWidth
        })
      }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
      _ctx.isEmpty ? (vue$s.openBlock(), vue$s.createElementBlock("div", {
        key: 0,
        ref: "emptyBlock",
        style: vue$s.normalizeStyle(_ctx.emptyBlockStyle),
        class: "el-table__empty-block"
      }, [
        vue$s.createElementVNode("span", _hoisted_3$8, [
          vue$s.renderSlot(_ctx.$slots, "empty", {}, () => [
            vue$s.createTextVNode(vue$s.toDisplayString(_ctx.emptyText || _ctx.t("el.table.emptyText")), 1)
          ])
        ])
      ], 4)) : vue$s.createCommentVNode("v-if", true),
      _ctx.$slots.append ? (vue$s.openBlock(), vue$s.createElementBlock("div", _hoisted_4$5, [
        vue$s.renderSlot(_ctx.$slots, "append")
      ], 512)) : vue$s.createCommentVNode("v-if", true)
    ], 4),
    _ctx.showSummary ? vue$s.withDirectives((vue$s.openBlock(), vue$s.createElementBlock("div", _hoisted_5$4, [
      vue$s.createVNode(_component_table_footer, {
        border: _ctx.border,
        "default-sort": _ctx.defaultSort,
        store: _ctx.store,
        style: vue$s.normalizeStyle({
          width: _ctx.layout.bodyWidth.value ? _ctx.layout.bodyWidth.value + "px" : ""
        }),
        "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
        "summary-method": _ctx.summaryMethod
      }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
    ], 512)), [
      [vue$s.vShow, !_ctx.isEmpty],
      [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
    ]) : vue$s.createCommentVNode("v-if", true),
    _ctx.store.states.fixedColumns.value.length > 0 ? vue$s.withDirectives((vue$s.openBlock(), vue$s.createElementBlock("div", {
      key: 2,
      ref: "fixedWrapper",
      style: vue$s.normalizeStyle([
        {
          width: _ctx.layout.fixedWidth.value ? _ctx.layout.fixedWidth.value + "px" : ""
        },
        _ctx.fixedHeight
      ]),
      class: "el-table__fixed"
    }, [
      _ctx.showHeader ? (vue$s.openBlock(), vue$s.createElementBlock("div", _hoisted_6$3, [
        vue$s.createVNode(_component_table_header, {
          ref: "fixedTableHeader",
          border: _ctx.border,
          store: _ctx.store,
          style: vue$s.normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "left",
          onSetDragVisible: _ctx.setDragVisible
        }, null, 8, ["border", "store", "style", "onSetDragVisible"])
      ], 512)) : vue$s.createCommentVNode("v-if", true),
      vue$s.createElementVNode("div", {
        ref: "fixedBodyWrapper",
        style: vue$s.normalizeStyle([
          {
            top: _ctx.layout.headerHeight.value + "px"
          },
          _ctx.fixedBodyHeight
        ]),
        class: "el-table__fixed-body-wrapper"
      }, [
        vue$s.createVNode(_component_table_body, {
          highlight: _ctx.highlightCurrentRow,
          "row-class-name": _ctx.rowClassName,
          "tooltip-effect": _ctx.tooltipEffect,
          "row-style": _ctx.rowStyle,
          store: _ctx.store,
          stripe: _ctx.stripe,
          style: vue$s.normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "left"
        }, null, 8, ["highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
        _ctx.$slots.append ? (vue$s.openBlock(), vue$s.createElementBlock("div", {
          key: 0,
          style: vue$s.normalizeStyle({ height: _ctx.layout.appendHeight.value + "px" }),
          class: "el-table__append-gutter"
        }, null, 4)) : vue$s.createCommentVNode("v-if", true)
      ], 4),
      _ctx.showSummary ? vue$s.withDirectives((vue$s.openBlock(), vue$s.createElementBlock("div", _hoisted_7$2, [
        vue$s.createVNode(_component_table_footer, {
          border: _ctx.border,
          store: _ctx.store,
          style: vue$s.normalizeStyle({
            width: _ctx.bodyWidth
          }),
          "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
          "summary-method": _ctx.summaryMethod,
          fixed: "left"
        }, null, 8, ["border", "store", "style", "sum-text", "summary-method"])
      ], 512)), [
        [vue$s.vShow, !_ctx.isEmpty]
      ]) : vue$s.createCommentVNode("v-if", true)
    ], 4)), [
      [_directive_mousewheel, _ctx.handleFixedMousewheel]
    ]) : vue$s.createCommentVNode("v-if", true),
    _ctx.store.states.rightFixedColumns.value.length > 0 ? vue$s.withDirectives((vue$s.openBlock(), vue$s.createElementBlock("div", {
      key: 3,
      ref: "rightFixedWrapper",
      style: vue$s.normalizeStyle([
        {
          width: _ctx.layout.rightFixedWidth.value ? _ctx.layout.rightFixedWidth.value + "px" : "",
          right: _ctx.layout.scrollY.value ? (_ctx.border ? _ctx.layout.gutterWidth : _ctx.layout.gutterWidth || 0) + "px" : ""
        },
        _ctx.fixedHeight
      ]),
      class: "el-table__fixed-right"
    }, [
      _ctx.showHeader ? (vue$s.openBlock(), vue$s.createElementBlock("div", _hoisted_8$2, [
        vue$s.createVNode(_component_table_header, {
          ref: "rightFixedTableHeader",
          border: _ctx.border,
          store: _ctx.store,
          style: vue$s.normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "right",
          onSetDragVisible: _ctx.setDragVisible
        }, null, 8, ["border", "store", "style", "onSetDragVisible"])
      ], 512)) : vue$s.createCommentVNode("v-if", true),
      vue$s.createElementVNode("div", {
        ref: "rightFixedBodyWrapper",
        style: vue$s.normalizeStyle([{ top: _ctx.layout.headerHeight.value + "px" }, _ctx.fixedBodyHeight]),
        class: "el-table__fixed-body-wrapper"
      }, [
        vue$s.createVNode(_component_table_body, {
          highlight: _ctx.highlightCurrentRow,
          "row-class-name": _ctx.rowClassName,
          "tooltip-effect": _ctx.tooltipEffect,
          "row-style": _ctx.rowStyle,
          store: _ctx.store,
          stripe: _ctx.stripe,
          style: vue$s.normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "right"
        }, null, 8, ["highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
        _ctx.$slots.append ? (vue$s.openBlock(), vue$s.createElementBlock("div", {
          key: 0,
          style: vue$s.normalizeStyle({ height: _ctx.layout.appendHeight.value + "px" }),
          class: "el-table__append-gutter"
        }, null, 4)) : vue$s.createCommentVNode("v-if", true)
      ], 4),
      _ctx.showSummary ? vue$s.withDirectives((vue$s.openBlock(), vue$s.createElementBlock("div", _hoisted_9$1, [
        vue$s.createVNode(_component_table_footer, {
          border: _ctx.border,
          store: _ctx.store,
          style: vue$s.normalizeStyle({
            width: _ctx.bodyWidth
          }),
          "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
          "summary-method": _ctx.summaryMethod,
          fixed: "right"
        }, null, 8, ["border", "store", "style", "sum-text", "summary-method"])
      ], 512)), [
        [vue$s.vShow, !_ctx.isEmpty]
      ]) : vue$s.createCommentVNode("v-if", true)
    ], 4)), [
      [_directive_mousewheel, _ctx.handleFixedMousewheel]
    ]) : vue$s.createCommentVNode("v-if", true),
    _ctx.store.states.rightFixedColumns.value.length > 0 ? (vue$s.openBlock(), vue$s.createElementBlock("div", {
      key: 4,
      ref: "rightFixedPatch",
      style: vue$s.normalizeStyle({
        width: _ctx.layout.scrollY.value ? _ctx.layout.gutterWidth + "px" : "0",
        height: _ctx.layout.headerHeight.value + "px"
      }),
      class: "el-table__fixed-right-patch"
    }, null, 4)) : vue$s.createCommentVNode("v-if", true),
    vue$s.withDirectives(vue$s.createElementVNode("div", _hoisted_10$1, null, 512), [
      [vue$s.vShow, _ctx.resizeProxyVisible]
    ])
  ], 38);
}
table_vue_vue_type_template_id_4a1660ad_lang.render = render$g;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var table_vue_vue_type_script_lang$1 = table_vue_vue_type_script_lang;
  var table_vue_vue_type_template_id_4a1660ad_lang$1 = table_vue_vue_type_template_id_4a1660ad_lang;
  table_vue_vue_type_script_lang$1["default"].render = table_vue_vue_type_template_id_4a1660ad_lang$1.render;
  table_vue_vue_type_script_lang$1["default"].__file = "packages/components/table/src/table.vue";
  exports["default"] = table_vue_vue_type_script_lang$1["default"];
})(table);
var tableColumn$1 = {};
var tableColumn = {};
var config$1 = {};
Object.defineProperty(config$1, "__esModule", { value: true });
var vue$r = require$$0$1;
var index$18 = checkbox$1;
var index$1$1 = icon$4;
var iconsVue = require$$3;
var util$2 = util$l;
const cellStarts = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: "",
    className: "el-table-column--selection"
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
};
const cellForced = {
  selection: {
    renderHeader({ store: store2 }) {
      function isDisabled() {
        return store2.states.data.value && store2.states.data.value.length === 0;
      }
      return vue$r.h(index$18.ElCheckbox, {
        disabled: isDisabled(),
        size: store2.states.tableSize.value,
        indeterminate: store2.states.selection.value.length > 0 && !store2.states.isAllSelected.value,
        "onUpdate:modelValue": store2.toggleAllSelection,
        modelValue: store2.states.isAllSelected.value
      });
    },
    renderCell({
      row: row2,
      column,
      store: store2,
      $index
    }) {
      return vue$r.h(index$18.ElCheckbox, {
        disabled: column.selectable ? !column.selectable.call(null, row2, $index) : false,
        size: store2.states.tableSize.value,
        onChange: () => {
          store2.commit("rowSelectedChanged", row2);
        },
        onClick: (event) => event.stopPropagation(),
        modelValue: store2.isSelected(row2)
      });
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader({ column }) {
      return column.label || "#";
    },
    renderCell({
      column,
      $index
    }) {
      let i = $index + 1;
      const index2 = column.index;
      if (typeof index2 === "number") {
        i = $index + index2;
      } else if (typeof index2 === "function") {
        i = index2($index);
      }
      return vue$r.h("div", {}, [i]);
    },
    sortable: false
  },
  expand: {
    renderHeader({ column }) {
      return column.label || "";
    },
    renderCell({ row: row2, store: store2 }) {
      const classes = ["el-table__expand-icon"];
      if (store2.states.expandRows.value.indexOf(row2) > -1) {
        classes.push("el-table__expand-icon--expanded");
      }
      const callback = function(e) {
        e.stopPropagation();
        store2.toggleRowExpansion(row2);
      };
      return vue$r.h("div", {
        class: classes,
        onClick: callback
      }, {
        default: () => {
          return [
            vue$r.h(index$1$1.ElIcon, null, {
              default: () => {
                return [vue$r.h(iconsVue.ArrowRight)];
              }
            })
          ];
        }
      });
    },
    sortable: false,
    resizable: false,
    className: "el-table__expand-column"
  }
};
function defaultRenderCell({
  row: row2,
  column,
  $index
}) {
  var _a;
  const property = column.property;
  const value = property && util$2.getPropByPath(row2, property, false).v;
  if (column && column.formatter) {
    return column.formatter(row2, column, value, $index);
  }
  return ((_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) || "";
}
function treeCellPrefix({
  row: row2,
  treeNode: treeNode2,
  store: store2
}) {
  if (!treeNode2)
    return null;
  const ele = [];
  const callback = function(e) {
    e.stopPropagation();
    store2.loadOrToggle(row2);
  };
  if (treeNode2.indent) {
    ele.push(vue$r.h("span", {
      class: "el-table__indent",
      style: { "padding-left": `${treeNode2.indent}px` }
    }));
  }
  if (typeof treeNode2.expanded === "boolean" && !treeNode2.noLazyChildren) {
    const expandClasses = [
      "el-table__expand-icon",
      treeNode2.expanded ? "el-table__expand-icon--expanded" : ""
    ];
    let icon3 = iconsVue.ArrowRight;
    if (treeNode2.loading) {
      icon3 = iconsVue.Loading;
    }
    ele.push(vue$r.h("div", {
      class: expandClasses,
      onClick: callback
    }, {
      default: () => {
        return [
          vue$r.h(index$1$1.ElIcon, { class: { "is-loading": treeNode2.loading } }, {
            default: () => [vue$r.h(icon3)]
          })
        ];
      }
    }));
  } else {
    ele.push(vue$r.h("span", {
      class: "el-table__placeholder"
    }));
  }
  return ele;
}
config$1.cellForced = cellForced;
config$1.cellStarts = cellStarts;
config$1.defaultRenderCell = defaultRenderCell;
config$1.treeCellPrefix = treeCellPrefix;
var watcherHelper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var util2 = util$3;
  function useWatcher(owner, props_) {
    const instance = vue2.getCurrentInstance();
    const registerComplexWatchers = () => {
      const props2 = ["fixed"];
      const aliases = {
        realWidth: "width",
        realMinWidth: "minWidth"
      };
      const allAliases = props2.reduce((prev2, cur) => {
        prev2[cur] = cur;
        return prev2;
      }, aliases);
      Object.keys(allAliases).forEach((key2) => {
        const columnKey = aliases[key2];
        if (shared2.hasOwn(props_, columnKey)) {
          vue2.watch(() => props_[columnKey], (newVal) => {
            let value = newVal;
            if (columnKey === "width" && key2 === "realWidth") {
              value = util2.parseWidth(newVal);
            }
            if (columnKey === "minWidth" && key2 === "realMinWidth") {
              value = util2.parseMinWidth(newVal);
            }
            instance.columnConfig.value[columnKey] = value;
            instance.columnConfig.value[key2] = value;
            const updateColumns = columnKey === "fixed";
            owner.value.store.scheduleLayout(updateColumns);
          });
        }
      });
    };
    const registerNormalWatchers = () => {
      const props2 = [
        "label",
        "filters",
        "filterMultiple",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "showOverflowTooltip"
      ];
      const aliases = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      };
      const allAliases = props2.reduce((prev2, cur) => {
        prev2[cur] = cur;
        return prev2;
      }, aliases);
      Object.keys(allAliases).forEach((key2) => {
        const columnKey = aliases[key2];
        if (shared2.hasOwn(props_, columnKey)) {
          vue2.watch(() => props_[columnKey], (newVal) => {
            instance.columnConfig.value[key2] = newVal;
          });
        }
      });
    };
    return {
      registerComplexWatchers,
      registerNormalWatchers
    };
  }
  exports["default"] = useWatcher;
})(watcherHelper);
var renderHelper = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var error2 = error$5;
  var config2 = config$1;
  var util2 = util$3;
  function useRender(props2, slots, owner) {
    const instance = vue2.getCurrentInstance();
    const columnId = vue2.ref("");
    const isSubColumn = vue2.ref(false);
    const realAlign = vue2.ref();
    const realHeaderAlign = vue2.ref();
    vue2.watchEffect(() => {
      realAlign.value = props2.align ? `is-${props2.align}` : null;
      realAlign.value;
    });
    vue2.watchEffect(() => {
      realHeaderAlign.value = props2.headerAlign ? `is-${props2.headerAlign}` : realAlign.value;
      realHeaderAlign.value;
    });
    const columnOrTableParent = vue2.computed(() => {
      let parent = instance.vnode.vParent || instance.parent;
      while (parent && !parent.tableId && !parent.columnId) {
        parent = parent.vnode.vParent || parent.parent;
      }
      return parent;
    });
    const realWidth = vue2.ref(util2.parseWidth(props2.width));
    const realMinWidth = vue2.ref(util2.parseMinWidth(props2.minWidth));
    const setColumnWidth = (column) => {
      if (realWidth.value)
        column.width = realWidth.value;
      if (realMinWidth.value) {
        column.minWidth = realMinWidth.value;
      }
      if (!column.minWidth) {
        column.minWidth = 80;
      }
      column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
      return column;
    };
    const setColumnForcedProps = (column) => {
      const type4 = column.type;
      const source2 = config2.cellForced[type4] || {};
      Object.keys(source2).forEach((prop) => {
        const value = source2[prop];
        if (value !== void 0) {
          column[prop] = prop === "className" ? `${column[prop]} ${value}` : value;
        }
      });
      return column;
    };
    const checkSubColumn = (children) => {
      if (children instanceof Array) {
        children.forEach((child) => check2(child));
      } else {
        check2(children);
      }
      function check2(item2) {
        var _a;
        if (((_a = item2 == null ? void 0 : item2.type) == null ? void 0 : _a.name) === "ElTableColumn") {
          item2.vParent = instance;
        }
      }
    };
    const setColumnRenders = (column) => {
      if (props2.renderHeader) {
        error2.debugWarn("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.");
      } else if (column.type !== "selection") {
        column.renderHeader = (scope) => {
          instance.columnConfig.value["label"];
          const renderHeader = slots.header;
          return renderHeader ? renderHeader(scope) : column.label;
        };
      }
      let originRenderCell = column.renderCell;
      if (column.type === "expand") {
        column.renderCell = (data2) => vue2.h("div", {
          class: "cell"
        }, [originRenderCell(data2)]);
        owner.value.renderExpanded = (data2) => {
          return slots.default ? slots.default(data2) : slots.default;
        };
      } else {
        originRenderCell = originRenderCell || config2.defaultRenderCell;
        column.renderCell = (data2) => {
          let children = null;
          if (slots.default) {
            children = slots.default(data2);
          } else {
            children = originRenderCell(data2);
          }
          const prefix = config2.treeCellPrefix(data2);
          const props22 = {
            class: "cell",
            style: {}
          };
          if (column.showOverflowTooltip) {
            props22.class += " el-tooltip";
            props22.style = {
              width: `${(data2.column.realWidth || Number(data2.column.width)) - 1}px`
            };
          }
          checkSubColumn(children);
          return vue2.h("div", props22, [prefix, children]);
        };
      }
      return column;
    };
    const getPropsData = (...propsKey) => {
      return propsKey.reduce((prev2, cur) => {
        if (Array.isArray(cur)) {
          cur.forEach((key2) => {
            prev2[key2] = props2[key2];
          });
        }
        return prev2;
      }, {});
    };
    const getColumnElIndex = (children, child) => {
      return [].indexOf.call(children, child);
    };
    return {
      columnId,
      realAlign,
      isSubColumn,
      realHeaderAlign,
      columnOrTableParent,
      setColumnWidth,
      setColumnForcedProps,
      setColumnRenders,
      getPropsData,
      getColumnElIndex
    };
  }
  exports["default"] = useRender;
})(renderHelper);
var defaults$6 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var defaultProps2 = {
    type: {
      type: String,
      default: "default"
    },
    label: String,
    className: String,
    labelClassName: String,
    property: String,
    prop: String,
    width: {
      type: [String, Number],
      default: ""
    },
    minWidth: {
      type: [String, Number],
      default: ""
    },
    renderHeader: Function,
    sortable: {
      type: [Boolean, String],
      default: false
    },
    sortMethod: Function,
    sortBy: [String, Function, Array],
    resizable: {
      type: Boolean,
      default: true
    },
    columnKey: String,
    align: String,
    headerAlign: String,
    showTooltipWhenOverflow: Boolean,
    showOverflowTooltip: Boolean,
    fixed: [Boolean, String],
    formatter: Function,
    selectable: Function,
    reserveSelection: Boolean,
    filterMethod: Function,
    filteredValue: Array,
    filters: Array,
    filterPlacement: String,
    filterMultiple: {
      type: Boolean,
      default: true
    },
    index: [Number, Function],
    sortOrders: {
      type: Array,
      default: () => {
        return ["ascending", "descending", null];
      },
      validator: (val) => {
        return val.every((order2) => ["ascending", "descending", null].indexOf(order2) > -1);
      }
    }
  };
  exports["default"] = defaultProps2;
})(defaults$6);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = checkbox$1;
  var config2 = config$1;
  var util2 = util$3;
  var watcherHelper$1 = watcherHelper;
  var renderHelper$12 = renderHelper;
  var defaults2 = defaults$6;
  let columnIdSeed = 1;
  var ElTableColumn = vue2.defineComponent({
    name: "ElTableColumn",
    components: {
      ElCheckbox: index2.ElCheckbox
    },
    props: defaults2["default"],
    setup(props2, { slots }) {
      const instance = vue2.getCurrentInstance();
      const columnConfig = vue2.ref({});
      const owner = vue2.computed(() => {
        let parent2 = instance.parent;
        while (parent2 && !parent2.tableId) {
          parent2 = parent2.parent;
        }
        return parent2;
      });
      const { registerNormalWatchers, registerComplexWatchers } = watcherHelper$1["default"](owner, props2);
      const {
        columnId,
        isSubColumn,
        realHeaderAlign,
        columnOrTableParent,
        setColumnWidth,
        setColumnForcedProps,
        setColumnRenders,
        getPropsData,
        getColumnElIndex,
        realAlign
      } = renderHelper$12["default"](props2, slots, owner);
      const parent = columnOrTableParent.value;
      columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
      vue2.onBeforeMount(() => {
        isSubColumn.value = owner.value !== parent;
        const type4 = props2.type || "default";
        const sortable = props2.sortable === "" ? true : props2.sortable;
        const defaults3 = __spreadProps(__spreadValues({}, config2.cellStarts[type4]), {
          id: columnId.value,
          type: type4,
          property: props2.prop || props2.property,
          align: realAlign,
          headerAlign: realHeaderAlign,
          showOverflowTooltip: props2.showOverflowTooltip || props2.showTooltipWhenOverflow,
          filterable: props2.filters || props2.filterMethod,
          filteredValue: [],
          filterPlacement: "",
          isColumnGroup: false,
          filterOpened: false,
          sortable,
          index: props2.index,
          rawColumnKey: instance.vnode.key
        });
        const basicProps = [
          "columnKey",
          "label",
          "className",
          "labelClassName",
          "type",
          "renderHeader",
          "formatter",
          "fixed",
          "resizable"
        ];
        const sortProps = ["sortMethod", "sortBy", "sortOrders"];
        const selectProps = ["selectable", "reserveSelection"];
        const filterProps = [
          "filterMethod",
          "filters",
          "filterMultiple",
          "filterOpened",
          "filteredValue",
          "filterPlacement"
        ];
        let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
        column = util2.mergeOptions(defaults3, column);
        const chains = util2.compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
        column = chains(column);
        columnConfig.value = column;
        registerNormalWatchers();
        registerComplexWatchers();
      });
      vue2.onMounted(() => {
        var _a;
        const parent2 = columnOrTableParent.value;
        const children = isSubColumn.value ? parent2.vnode.el.children : (_a = parent2.refs.hiddenColumns) == null ? void 0 : _a.children;
        const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
        columnConfig.value.getColumnIndex = getColumnIndex;
        const columnIndex = getColumnIndex();
        columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null);
      });
      vue2.onBeforeUnmount(() => {
        owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null);
      });
      instance.columnId = columnId.value;
      instance.columnConfig = columnConfig;
      return;
    },
    render() {
      var _a, _b, _c;
      let children = [];
      try {
        const renderDefault = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
          row: {},
          column: {},
          $index: -1
        });
        if (renderDefault instanceof Array) {
          for (const childNode of renderDefault) {
            if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
              children.push(childNode);
            } else if (childNode.type === vue2.Fragment && childNode.children instanceof Array) {
              children.push(...childNode.children);
            }
          }
        }
      } catch (e) {
        children = [];
      }
      return vue2.h("div", children);
    }
  });
  exports["default"] = ElTableColumn;
})(tableColumn);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index2 = tableColumn;
  exports["default"] = index2["default"];
})(tableColumn$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var table_vue_vue_type_script_lang$1 = table_vue_vue_type_script_lang;
  var index2 = tableColumn;
  const ElTable = withInstall2.withInstall(table_vue_vue_type_script_lang$1["default"], {
    TableColumn: index2["default"]
  });
  const ElTableColumn = withInstall2.withNoopInstall(index2["default"]);
  exports.ElTable = ElTable;
  exports.ElTableColumn = ElTableColumn;
  exports["default"] = ElTable;
})(table$1);
var tabs$2 = {};
var tabs$1 = {};
var tabNav$1 = {};
var tabBar2 = {};
var tabBar_vue_vue_type_script_lang = {};
var tabBar$2 = {};
Object.defineProperty(tabBar$2, "__esModule", { value: true });
var props$6 = props$N;
const tabBar$1 = props$6.buildProps({
  tabs: {
    type: props$6.definePropType(Array),
    default: () => props$6.mutable([])
  }
});
tabBar$2.tabBar = tabBar$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var core2 = core$7;
  var error2 = error$5;
  var tabBar3 = tabBar$2;
  var tabs2 = tabs$3;
  const COMPONENT_NAME = "ElTabBar";
  var script2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    props: tabBar3.tabBar,
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const rootTabs = vue2.inject(tabs2.tabsRootContextKey);
      if (!rootTabs)
        error2.throwError(COMPONENT_NAME, "must use with ElTabs");
      const bar$ = vue2.ref();
      const barStyle = vue2.ref();
      const getBarStyle = () => {
        let offset2 = 0;
        let tabSize = 0;
        const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
        const sizeDir = sizeName === "width" ? "x" : "y";
        props2.tabs.every((tab) => {
          var _a, _b, _c, _d;
          const $el = (_b = (_a = instance.parent) == null ? void 0 : _a.refs) == null ? void 0 : _b[`tab-${tab.paneName}`];
          if (!$el)
            return false;
          if (!tab.active) {
            return true;
          }
          tabSize = $el[`client${shared2.capitalize(sizeName)}`];
          const position2 = sizeDir === "x" ? "left" : "top";
          offset2 = $el.getBoundingClientRect()[position2] - ((_d = (_c = $el.parentElement) == null ? void 0 : _c.getBoundingClientRect()[position2]) != null ? _d : 0);
          const tabStyles = window.getComputedStyle($el);
          if (sizeName === "width") {
            if (props2.tabs.length > 1) {
              tabSize -= parseFloat(tabStyles.paddingLeft) + parseFloat(tabStyles.paddingRight);
            }
            offset2 += parseFloat(tabStyles.paddingLeft);
          }
          return false;
        });
        return {
          [sizeName]: `${tabSize}px`,
          transform: `translate${shared2.capitalize(sizeDir)}(${offset2}px)`
        };
      };
      const update3 = () => barStyle.value = getBarStyle();
      vue2.watch(() => props2.tabs, async () => {
        await vue2.nextTick();
        update3();
      }, { immediate: true });
      core2.useResizeObserver(bar$, () => update3());
      return {
        bar$,
        rootTabs,
        barStyle,
        update: update3
      };
    }
  });
  exports["default"] = script2;
})(tabBar_vue_vue_type_script_lang);
var tabBar_vue_vue_type_template_id_09e034e4_lang = {};
Object.defineProperty(tabBar_vue_vue_type_template_id_09e034e4_lang, "__esModule", { value: true });
var vue$q = require$$0$1;
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$q.openBlock(), vue$q.createElementBlock("div", {
    ref: "bar$",
    class: vue$q.normalizeClass(["el-tabs__active-bar", `is-${_ctx.rootTabs.props.tabPosition}`]),
    style: vue$q.normalizeStyle(_ctx.barStyle)
  }, null, 6);
}
tabBar_vue_vue_type_template_id_09e034e4_lang.render = render$f;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tabBar_vue_vue_type_script_lang$1 = tabBar_vue_vue_type_script_lang;
  var tabBar_vue_vue_type_template_id_09e034e4_lang$1 = tabBar_vue_vue_type_template_id_09e034e4_lang;
  tabBar_vue_vue_type_script_lang$1["default"].render = tabBar_vue_vue_type_template_id_09e034e4_lang$1.render;
  tabBar_vue_vue_type_script_lang$1["default"].__file = "packages/components/tabs/src/tab-bar.vue";
  exports["default"] = tabBar_vue_vue_type_script_lang$1["default"];
})(tabBar2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var core2 = core$7;
  var props2 = props$N;
  var aria2 = aria$5;
  var error2 = error$5;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var tabs2 = tabs$3;
  var tabBar_vue_vue_type_script_lang$1 = tabBar_vue_vue_type_script_lang;
  const tabNavProps = props2.buildProps({
    panes: {
      type: props2.definePropType(Array),
      default: () => props2.mutable([])
    },
    currentName: {
      type: String,
      default: ""
    },
    editable: Boolean,
    onTabClick: {
      type: props2.definePropType(Function),
      default: shared2.NOOP
    },
    onTabRemove: {
      type: props2.definePropType(Function),
      default: shared2.NOOP
    },
    type: {
      type: String,
      values: ["card", "border-card", ""],
      default: ""
    },
    stretch: Boolean
  });
  const COMPONENT_NAME = "ElTabNav";
  var TabNav = vue2.defineComponent({
    name: COMPONENT_NAME,
    props: tabNavProps,
    setup(props3, { expose }) {
      const visibility = core2.useDocumentVisibility();
      const focused = core2.useWindowFocus();
      const rootTabs = vue2.inject(tabs2.tabsRootContextKey);
      if (!rootTabs)
        error2.throwError(COMPONENT_NAME, `ElTabNav must be nested inside ElTabs`);
      const scrollable = vue2.ref(false);
      const navOffset = vue2.ref(0);
      const isFocus = vue2.ref(false);
      const focusable = vue2.ref(true);
      const navScroll$ = vue2.ref();
      const nav$ = vue2.ref();
      const el$ = vue2.ref();
      const sizeName = vue2.computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
      const navStyle = vue2.computed(() => {
        const dir = sizeName.value === "width" ? "X" : "Y";
        return {
          transform: `translate${dir}(-${navOffset.value}px)`
        };
      });
      const scrollPrev = () => {
        if (!navScroll$.value)
          return;
        const containerSize = navScroll$.value[`offset${shared2.capitalize(sizeName.value)}`];
        const currentOffset = navOffset.value;
        if (!currentOffset)
          return;
        const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
        navOffset.value = newOffset;
      };
      const scrollNext = () => {
        if (!navScroll$.value || !nav$.value)
          return;
        const navSize = nav$.value[`offset${shared2.capitalize(sizeName.value)}`];
        const containerSize = navScroll$.value[`offset${shared2.capitalize(sizeName.value)}`];
        const currentOffset = navOffset.value;
        if (navSize - currentOffset <= containerSize)
          return;
        const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
        navOffset.value = newOffset;
      };
      const scrollToActiveTab = () => {
        const nav = nav$.value;
        if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
          return;
        const activeTab = el$.value.querySelector(".is-active");
        if (!activeTab)
          return;
        const navScroll = navScroll$.value;
        const isHorizontal2 = ["top", "bottom"].includes(rootTabs.props.tabPosition);
        const activeTabBounding = activeTab.getBoundingClientRect();
        const navScrollBounding = navScroll.getBoundingClientRect();
        const maxOffset = isHorizontal2 ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
        const currentOffset = navOffset.value;
        let newOffset = currentOffset;
        if (isHorizontal2) {
          if (activeTabBounding.left < navScrollBounding.left) {
            newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
          }
          if (activeTabBounding.right > navScrollBounding.right) {
            newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
          }
        } else {
          if (activeTabBounding.top < navScrollBounding.top) {
            newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
          }
          if (activeTabBounding.bottom > navScrollBounding.bottom) {
            newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
          }
        }
        newOffset = Math.max(newOffset, 0);
        navOffset.value = Math.min(newOffset, maxOffset);
      };
      const update3 = () => {
        if (!nav$.value || !navScroll$.value)
          return;
        const navSize = nav$.value[`offset${shared2.capitalize(sizeName.value)}`];
        const containerSize = navScroll$.value[`offset${shared2.capitalize(sizeName.value)}`];
        const currentOffset = navOffset.value;
        if (containerSize < navSize) {
          const currentOffset2 = navOffset.value;
          scrollable.value = scrollable.value || {};
          scrollable.value.prev = currentOffset2;
          scrollable.value.next = currentOffset2 + containerSize < navSize;
          if (navSize - currentOffset2 < containerSize) {
            navOffset.value = navSize - containerSize;
          }
        } else {
          scrollable.value = false;
          if (currentOffset > 0) {
            navOffset.value = 0;
          }
        }
      };
      const changeTab = (e) => {
        const code2 = e.code;
        const { up, down, left: left2, right: right2 } = aria2.EVENT_CODE;
        if (![up, down, left2, right2].includes(code2))
          return;
        const tabList = Array.from(e.currentTarget.querySelectorAll("[role=tab]"));
        const currentIndex = tabList.indexOf(e.target);
        let nextIndex;
        if (code2 === left2 || code2 === up) {
          if (currentIndex === 0) {
            nextIndex = tabList.length - 1;
          } else {
            nextIndex = currentIndex - 1;
          }
        } else {
          if (currentIndex < tabList.length - 1) {
            nextIndex = currentIndex + 1;
          } else {
            nextIndex = 0;
          }
        }
        tabList[nextIndex].focus();
        tabList[nextIndex].click();
        setFocus();
      };
      const setFocus = () => {
        if (focusable.value)
          isFocus.value = true;
      };
      const removeFocus = () => isFocus.value = false;
      vue2.watch(visibility, (visibility2) => {
        if (visibility2 === "hidden") {
          focusable.value = false;
        } else if (visibility2 === "visible") {
          setTimeout(() => focusable.value = true, 50);
        }
      });
      vue2.watch(focused, (focused2) => {
        if (focused2) {
          setTimeout(() => focusable.value = true, 50);
        } else {
          focusable.value = false;
        }
      });
      core2.useResizeObserver(el$, update3);
      vue2.onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
      vue2.onUpdated(() => update3());
      expose({
        scrollToActiveTab,
        removeFocus
      });
      return () => {
        const scrollBtn = scrollable.value ? [
          vue2.h("span", {
            class: [
              "el-tabs__nav-prev",
              scrollable.value.prev ? "" : "is-disabled"
            ],
            onClick: scrollPrev
          }, [vue2.h(index2.ElIcon, {}, { default: () => vue2.h(iconsVue2.ArrowLeft) })]),
          vue2.h("span", {
            class: [
              "el-tabs__nav-next",
              scrollable.value.next ? "" : "is-disabled"
            ],
            onClick: scrollNext
          }, [vue2.h(index2.ElIcon, {}, { default: () => vue2.h(iconsVue2.ArrowRight) })])
        ] : null;
        const tabs3 = props3.panes.map((pane, index$110) => {
          var _a, _b;
          const tabName = pane.props.name || pane.index || `${index$110}`;
          const closable = pane.isClosable || props3.editable;
          pane.index = `${index$110}`;
          const btnClose = closable ? vue2.h(index2.ElIcon, {
            class: "is-icon-close",
            onClick: (ev) => props3.onTabRemove(pane, ev)
          }, { default: () => vue2.h(iconsVue2.Close) }) : null;
          const tabLabelContent = ((_b = (_a = pane.instance.slots).label) == null ? void 0 : _b.call(_a)) || pane.props.label;
          const tabindex = pane.active ? 0 : -1;
          return vue2.h("div", {
            class: {
              "el-tabs__item": true,
              [`is-${rootTabs.props.tabPosition}`]: true,
              "is-active": pane.active,
              "is-disabled": pane.props.disabled,
              "is-closable": closable,
              "is-focus": isFocus
            },
            id: `tab-${tabName}`,
            key: `tab-${tabName}`,
            "aria-controls": `pane-${tabName}`,
            role: "tab",
            "aria-selected": pane.active,
            ref: `tab-${tabName}`,
            tabindex,
            onFocus: () => setFocus(),
            onBlur: () => removeFocus(),
            onClick: (ev) => {
              removeFocus();
              props3.onTabClick(pane, tabName, ev);
            },
            onKeydown: (ev) => {
              if (closable && (ev.code === aria2.EVENT_CODE.delete || ev.code === aria2.EVENT_CODE.backspace)) {
                props3.onTabRemove(pane, ev);
              }
            }
          }, [tabLabelContent, btnClose]);
        });
        return vue2.h("div", {
          ref: el$,
          class: [
            "el-tabs__nav-wrap",
            scrollable.value ? "is-scrollable" : "",
            `is-${rootTabs.props.tabPosition}`
          ]
        }, [
          scrollBtn,
          vue2.h("div", {
            class: "el-tabs__nav-scroll",
            ref: navScroll$
          }, [
            vue2.h("div", {
              class: [
                "el-tabs__nav",
                `is-${rootTabs.props.tabPosition}`,
                props3.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "is-stretch" : ""
              ],
              ref: nav$,
              style: navStyle.value,
              role: "tablist",
              onKeydown: changeTab
            }, [
              !props3.type ? vue2.h(tabBar_vue_vue_type_script_lang$1["default"], {
                tabs: [...props3.panes]
              }) : null,
              tabs3
            ])
          ])
        ]);
      };
    }
  });
  exports["default"] = TabNav;
  exports.tabNavProps = tabNavProps;
})(tabNav$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var aria2 = aria$5;
  var index2 = icon$4;
  var iconsVue2 = require$$3;
  var props2 = props$N;
  var constants2 = constants$f;
  var tabNav2 = tabNav$1;
  var tabs2 = tabs$3;
  const tabsProps = props2.buildProps({
    type: {
      type: String,
      values: ["card", "border-card", ""],
      default: ""
    },
    activeName: {
      type: String,
      default: ""
    },
    closable: Boolean,
    addable: Boolean,
    modelValue: {
      type: String,
      default: ""
    },
    editable: Boolean,
    tabPosition: {
      type: String,
      values: ["top", "right", "bottom", "left"],
      default: "top"
    },
    beforeLeave: {
      type: props2.definePropType(Function),
      default: () => true
    },
    stretch: Boolean
  });
  const tabsEmits = {
    [constants2.UPDATE_MODEL_EVENT]: (tabName) => typeof tabName === "string",
    [constants2.INPUT_EVENT]: (tabName) => typeof tabName === "string",
    "tab-click": (pane, ev) => ev instanceof Event,
    edit: (paneName, action) => action === "remove" || action === "add",
    "tab-remove": (paneName) => typeof paneName === "string",
    "tab-add": () => true
  };
  const getPaneInstanceFromSlot = (vnode2, paneInstanceList = []) => {
    const children = vnode2.children || [];
    Array.from(children).forEach((node3) => {
      let type4 = node3.type;
      type4 = type4.name || type4;
      if (type4 === "ElTabPane" && node3.component) {
        paneInstanceList.push(node3.component);
      } else if (type4 === vue2.Fragment || type4 === "template") {
        getPaneInstanceFromSlot(node3, paneInstanceList);
      }
    });
    return paneInstanceList;
  };
  var Tabs = vue2.defineComponent({
    name: "ElTabs",
    props: tabsProps,
    emits: tabsEmits,
    setup(props3, { emit, slots, expose }) {
      const instance = vue2.getCurrentInstance();
      const nav$ = vue2.ref();
      const panes = vue2.ref([]);
      const currentName = vue2.ref(props3.modelValue || props3.activeName || "0");
      const paneStatesMap = {};
      const updatePaneInstances = (isForceUpdate = false) => {
        if (slots.default) {
          const children = instance.subTree.children;
          const content = Array.from(children).find(({ props: props22 }) => (props22 == null ? void 0 : props22.class) === "el-tabs__content");
          if (!content)
            return;
          const paneInstanceList = getPaneInstanceFromSlot(content).map((paneComponent) => paneStatesMap[paneComponent.uid]);
          const panesChanged = !(paneInstanceList.length === panes.value.length && paneInstanceList.every((pane, index3) => pane.uid === panes.value[index3].uid));
          if (isForceUpdate || panesChanged) {
            panes.value = paneInstanceList;
          }
        } else if (panes.value.length !== 0) {
          panes.value = [];
        }
      };
      const changeCurrentName = (value) => {
        currentName.value = value;
        emit(constants2.INPUT_EVENT, value);
        emit(constants2.UPDATE_MODEL_EVENT, value);
      };
      const setCurrentName = (value) => {
        var _a;
        if (currentName.value === value)
          return;
        const canLeave = (_a = props3.beforeLeave) == null ? void 0 : _a.call(props3, value, currentName.value);
        if (shared2.isPromise(canLeave)) {
          canLeave.then(() => {
            var _a2, _b;
            changeCurrentName(value);
            (_b = (_a2 = nav$.value) == null ? void 0 : _a2.removeFocus) == null ? void 0 : _b.call(_a2);
          }, shared2.NOOP);
        } else if (canLeave !== false) {
          changeCurrentName(value);
        }
      };
      const handleTabClick = (tab, tabName, event) => {
        if (tab.props.disabled)
          return;
        setCurrentName(tabName);
        emit("tab-click", tab, event);
      };
      const handleTabRemove = (pane, ev) => {
        if (pane.props.disabled)
          return;
        ev.stopPropagation();
        emit("edit", pane.props.name, "remove");
        emit("tab-remove", pane.props.name);
      };
      const handleTabAdd = () => {
        emit("edit", null, "add");
        emit("tab-add");
      };
      vue2.onUpdated(() => updatePaneInstances());
      vue2.onMounted(() => updatePaneInstances());
      vue2.watch(() => props3.activeName, (modelValue) => setCurrentName(modelValue));
      vue2.watch(() => props3.modelValue, (modelValue) => setCurrentName(modelValue));
      vue2.watch(currentName, async () => {
        var _a, _b;
        updatePaneInstances(true);
        await vue2.nextTick();
        await ((_a = nav$.value) == null ? void 0 : _a.$nextTick());
        (_b = nav$.value) == null ? void 0 : _b.scrollToActiveTab();
      });
      vue2.provide(tabs2.tabsRootContextKey, {
        props: props3,
        currentName,
        updatePaneState: (pane) => paneStatesMap[pane.uid] = pane
      });
      expose({
        currentName
      });
      return () => {
        const newButton = props3.editable || props3.addable ? vue2.h("span", {
          class: "el-tabs__new-tab",
          tabindex: "0",
          onClick: handleTabAdd,
          onKeydown: (ev) => {
            if (ev.code === aria2.EVENT_CODE.enter)
              handleTabAdd();
          }
        }, [vue2.h(index2.ElIcon, { class: "is-icon-plus" }, { default: () => vue2.h(iconsVue2.Plus) })]) : null;
        const header2 = vue2.h("div", { class: ["el-tabs__header", `is-${props3.tabPosition}`] }, [
          newButton,
          vue2.h(tabNav2["default"], {
            currentName: currentName.value,
            editable: props3.editable,
            type: props3.type,
            panes: panes.value,
            stretch: props3.stretch,
            ref: nav$,
            onTabClick: handleTabClick,
            onTabRemove: handleTabRemove
          })
        ]);
        const panels = vue2.h("div", { class: "el-tabs__content" }, [
          vue2.renderSlot(slots, "default")
        ]);
        return vue2.h("div", {
          class: {
            "el-tabs": true,
            "el-tabs--card": props3.type === "card",
            [`el-tabs--${props3.tabPosition}`]: true,
            "el-tabs--border-card": props3.type === "border-card"
          }
        }, props3.tabPosition !== "bottom" ? [header2, panels] : [panels, header2]);
      };
    }
  });
  exports["default"] = Tabs;
  exports.tabsEmits = tabsEmits;
  exports.tabsProps = tabsProps;
})(tabs$1);
var tabPane2 = {};
var tabPane_vue_vue_type_script_lang = {};
var tabPane$1 = {};
Object.defineProperty(tabPane$1, "__esModule", { value: true });
var props$5 = props$N;
const tabPaneProps = props$5.buildProps({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  closable: Boolean,
  disabled: Boolean,
  lazy: Boolean
});
tabPane$1.tabPaneProps = tabPaneProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var error2 = error$5;
  var tabPane3 = tabPane$1;
  var tabs2 = tabs$3;
  const COMPONENT_NAME = "ElTabPane";
  var script2 = vue2.defineComponent({
    name: COMPONENT_NAME,
    props: tabPane3.tabPaneProps,
    setup(props2) {
      const instance = vue2.getCurrentInstance();
      const tabsRoot = vue2.inject(tabs2.tabsRootContextKey);
      if (!tabsRoot)
        error2.throwError(COMPONENT_NAME, `must use with ElTabs`);
      const index2 = vue2.ref();
      const loaded = vue2.ref(false);
      const isClosable = vue2.computed(() => props2.closable || tabsRoot.props.closable);
      const active = core2.eagerComputed(() => tabsRoot.currentName.value === (props2.name || index2.value));
      const paneName = vue2.computed(() => props2.name || index2.value);
      const shouldBeRender = core2.eagerComputed(() => !props2.lazy || loaded.value || active.value);
      vue2.watch(active, (val) => {
        if (val)
          loaded.value = true;
      });
      tabsRoot.updatePaneState(vue2.reactive({
        uid: instance.uid,
        instance: vue2.markRaw(instance),
        props: props2,
        paneName,
        active,
        index: index2,
        isClosable
      }));
      return {
        active,
        paneName,
        shouldBeRender
      };
    }
  });
  exports["default"] = script2;
})(tabPane_vue_vue_type_script_lang);
var tabPane_vue_vue_type_template_id_46ec5d32_lang = {};
Object.defineProperty(tabPane_vue_vue_type_template_id_46ec5d32_lang, "__esModule", { value: true });
var vue$p = require$$0$1;
const _hoisted_1$c = ["id", "aria-hidden", "aria-labelledby"];
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.shouldBeRender ? vue$p.withDirectives((vue$p.openBlock(), vue$p.createElementBlock("div", {
    key: 0,
    id: `pane-${_ctx.paneName}`,
    class: "el-tab-pane",
    role: "tabpanel",
    "aria-hidden": !_ctx.active,
    "aria-labelledby": `tab-${_ctx.paneName}`
  }, [
    vue$p.renderSlot(_ctx.$slots, "default")
  ], 8, _hoisted_1$c)), [
    [vue$p.vShow, _ctx.active]
  ]) : vue$p.createCommentVNode("v-if", true);
}
tabPane_vue_vue_type_template_id_46ec5d32_lang.render = render$e;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tabPane_vue_vue_type_script_lang$1 = tabPane_vue_vue_type_script_lang;
  var tabPane_vue_vue_type_template_id_46ec5d32_lang$1 = tabPane_vue_vue_type_template_id_46ec5d32_lang;
  tabPane_vue_vue_type_script_lang$1["default"].render = tabPane_vue_vue_type_template_id_46ec5d32_lang$1.render;
  tabPane_vue_vue_type_script_lang$1["default"].__file = "packages/components/tabs/src/tab-pane.vue";
  exports["default"] = tabPane_vue_vue_type_script_lang$1["default"];
})(tabPane2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var tabs2 = tabs$1;
  var tabBar3 = tabBar$2;
  var tabNav2 = tabNav$1;
  var tabPane3 = tabPane$1;
  var tabPane_vue_vue_type_script_lang$1 = tabPane_vue_vue_type_script_lang;
  const ElTabs = withInstall2.withInstall(tabs2["default"], {
    TabPane: tabPane_vue_vue_type_script_lang$1["default"]
  });
  const ElTabPane = withInstall2.withNoopInstall(tabPane_vue_vue_type_script_lang$1["default"]);
  exports.tabsEmits = tabs2.tabsEmits;
  exports.tabsProps = tabs2.tabsProps;
  exports.tabBar = tabBar3.tabBar;
  exports.tabNavProps = tabNav2.tabNavProps;
  exports.tabPaneProps = tabPane3.tabPaneProps;
  exports.ElTabPane = ElTabPane;
  exports.ElTabs = ElTabs;
  exports["default"] = ElTabs;
})(tabs$2);
var timeSelect$1 = {};
var timeSelect = {};
var timeSelect_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = select$2;
  var index$110 = icon$4;
  var iconsVue2 = require$$3;
  const { Option: ElOption } = index2.ElSelect;
  const parseTime = (time) => {
    const values = (time || "").split(":");
    if (values.length >= 2) {
      const hours = parseInt(values[0], 10);
      const minutes = parseInt(values[1], 10);
      return {
        hours,
        minutes
      };
    }
    return null;
  };
  const compareTime = (time1, time2) => {
    const value1 = parseTime(time1);
    const value2 = parseTime(time2);
    const minutes1 = value1.minutes + value1.hours * 60;
    const minutes2 = value2.minutes + value2.hours * 60;
    if (minutes1 === minutes2) {
      return 0;
    }
    return minutes1 > minutes2 ? 1 : -1;
  };
  const formatTime = (time) => {
    return `${time.hours < 10 ? `0${time.hours}` : time.hours}:${time.minutes < 10 ? `0${time.minutes}` : time.minutes}`;
  };
  const nextTime = (time, step) => {
    const timeValue = parseTime(time);
    const stepValue = parseTime(step);
    const next2 = {
      hours: timeValue.hours,
      minutes: timeValue.minutes
    };
    next2.minutes += stepValue.minutes;
    next2.hours += stepValue.hours;
    next2.hours += Math.floor(next2.minutes / 60);
    next2.minutes = next2.minutes % 60;
    return formatTime(next2);
  };
  var script2 = vue2.defineComponent({
    name: "ElTimeSelect",
    components: { ElSelect: index2.ElSelect, ElOption, ElIcon: index$110.ElIcon },
    model: {
      prop: "value",
      event: "change"
    },
    props: {
      modelValue: String,
      disabled: {
        type: Boolean,
        default: false
      },
      editable: {
        type: Boolean,
        default: true
      },
      clearable: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        default: "",
        validator: (value) => !value || ["medium", "small", "mini"].indexOf(value) !== -1
      },
      placeholder: {
        type: String,
        default: ""
      },
      start: {
        type: String,
        default: "09:00"
      },
      end: {
        type: String,
        default: "18:00"
      },
      step: {
        type: String,
        default: "00:30"
      },
      minTime: {
        type: String,
        default: ""
      },
      maxTime: {
        type: String,
        default: ""
      },
      name: {
        type: String,
        default: ""
      },
      prefixIcon: {
        type: [String, Object],
        default: iconsVue2.Clock
      },
      clearIcon: {
        type: [String, Object],
        default: iconsVue2.CircleClose
      }
    },
    emits: ["change", "blur", "focus", "update:modelValue"],
    setup(props2) {
      const select2 = vue2.ref(null);
      const value = vue2.computed(() => props2.modelValue);
      const items = vue2.computed(() => {
        const result3 = [];
        if (props2.start && props2.end && props2.step) {
          let current2 = props2.start;
          while (compareTime(current2, props2.end) <= 0) {
            result3.push({
              value: current2,
              disabled: compareTime(current2, props2.minTime || "-1:-1") <= 0 || compareTime(current2, props2.maxTime || "100:100") >= 0
            });
            current2 = nextTime(current2, props2.step);
          }
        }
        return result3;
      });
      const blur = () => {
        var _a, _b;
        (_b = (_a = select2.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
      };
      const focus = () => {
        var _a, _b;
        (_b = (_a = select2.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      };
      return {
        select: select2,
        value,
        items,
        blur,
        focus
      };
    }
  });
  exports["default"] = script2;
})(timeSelect_vue_vue_type_script_lang);
var timeSelect_vue_vue_type_template_id_5beb6389_lang = {};
Object.defineProperty(timeSelect_vue_vue_type_template_id_5beb6389_lang, "__esModule", { value: true });
var vue$o = require$$0$1;
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = vue$o.resolveComponent("el-option");
  const _component_el_icon = vue$o.resolveComponent("el-icon");
  const _component_el_select = vue$o.resolveComponent("el-select");
  return vue$o.openBlock(), vue$o.createBlock(_component_el_select, {
    ref: "select",
    "model-value": _ctx.value,
    disabled: _ctx.disabled,
    clearable: _ctx.clearable,
    "clear-icon": _ctx.clearIcon,
    size: _ctx.size,
    placeholder: _ctx.placeholder,
    "default-first-option": "",
    filterable: _ctx.editable,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = (event) => _ctx.$emit("update:modelValue", event)),
    onChange: _cache[1] || (_cache[1] = (event) => _ctx.$emit("change", event)),
    onBlur: _cache[2] || (_cache[2] = (event) => _ctx.$emit("blur", event)),
    onFocus: _cache[3] || (_cache[3] = (event) => _ctx.$emit("focus", event))
  }, {
    prefix: vue$o.withCtx(() => [
      _ctx.prefixIcon ? (vue$o.openBlock(), vue$o.createBlock(_component_el_icon, {
        key: 0,
        class: "el-input__prefix-icon"
      }, {
        default: vue$o.withCtx(() => [
          (vue$o.openBlock(), vue$o.createBlock(vue$o.resolveDynamicComponent(_ctx.prefixIcon)))
        ]),
        _: 1
      })) : vue$o.createCommentVNode("v-if", true)
    ]),
    default: vue$o.withCtx(() => [
      (vue$o.openBlock(true), vue$o.createElementBlock(vue$o.Fragment, null, vue$o.renderList(_ctx.items, (item2) => {
        return vue$o.openBlock(), vue$o.createBlock(_component_el_option, {
          key: item2.value,
          label: item2.value,
          value: item2.value,
          disabled: item2.disabled
        }, null, 8, ["label", "value", "disabled"]);
      }), 128))
    ]),
    _: 1
  }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "placeholder", "filterable"]);
}
timeSelect_vue_vue_type_template_id_5beb6389_lang.render = render$d;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var timeSelect_vue_vue_type_script_lang$1 = timeSelect_vue_vue_type_script_lang;
  var timeSelect_vue_vue_type_template_id_5beb6389_lang$1 = timeSelect_vue_vue_type_template_id_5beb6389_lang;
  timeSelect_vue_vue_type_script_lang$1["default"].render = timeSelect_vue_vue_type_template_id_5beb6389_lang$1.render;
  timeSelect_vue_vue_type_script_lang$1["default"].__file = "packages/components/time-select/src/time-select.vue";
  exports["default"] = timeSelect_vue_vue_type_script_lang$1["default"];
})(timeSelect);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var timeSelect_vue_vue_type_script_lang$1 = timeSelect_vue_vue_type_script_lang;
  timeSelect_vue_vue_type_script_lang$1["default"].install = (app) => {
    app.component(timeSelect_vue_vue_type_script_lang$1["default"].name, timeSelect_vue_vue_type_script_lang$1["default"]);
  };
  const _TimeSelect = timeSelect_vue_vue_type_script_lang$1["default"];
  const ElTimeSelect = _TimeSelect;
  exports.ElTimeSelect = ElTimeSelect;
  exports["default"] = _TimeSelect;
})(timeSelect$1);
var timeline = {};
var src$4 = {};
var index_vue_vue_type_script_lang$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElTimeline",
    setup(_2, ctx) {
      vue2.provide("timeline", ctx);
      return () => {
        var _a, _b;
        return vue2.h("ul", {
          class: { "el-timeline": true }
        }, (_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a));
      };
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$3);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$3;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/timeline/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$4);
var item = {};
var item_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = icon$4;
  var script2 = vue2.defineComponent({
    name: "ElTimelineItem",
    components: {
      ElIcon: index2.ElIcon
    },
    props: {
      timestamp: {
        type: String,
        default: ""
      },
      hideTimestamp: {
        type: Boolean,
        default: false
      },
      center: {
        type: Boolean,
        default: false
      },
      placement: {
        type: String,
        default: "bottom"
      },
      type: {
        type: String,
        default: ""
      },
      color: {
        type: String,
        default: ""
      },
      size: {
        type: String,
        default: "normal"
      },
      icon: {
        type: [String, Object],
        default: ""
      },
      hollow: {
        type: Boolean,
        default: false
      }
    },
    setup() {
      vue2.inject("timeline");
    }
  });
  exports["default"] = script2;
})(item_vue_vue_type_script_lang);
var item_vue_vue_type_template_id_174d5b12_lang = {};
Object.defineProperty(item_vue_vue_type_template_id_174d5b12_lang, "__esModule", { value: true });
var vue$n = require$$0$1;
const _hoisted_1$b = /* @__PURE__ */ vue$n.createElementVNode("div", { class: "el-timeline-item__tail" }, null, -1);
const _hoisted_2$9 = {
  key: 1,
  class: "el-timeline-item__dot"
};
const _hoisted_3$7 = { class: "el-timeline-item__wrapper" };
const _hoisted_4$4 = {
  key: 0,
  class: "el-timeline-item__timestamp is-top"
};
const _hoisted_5$3 = { class: "el-timeline-item__content" };
const _hoisted_6$2 = {
  key: 1,
  class: "el-timeline-item__timestamp is-bottom"
};
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$n.resolveComponent("el-icon");
  return vue$n.openBlock(), vue$n.createElementBlock("li", {
    class: vue$n.normalizeClass(["el-timeline-item", { "el-timeline-item__center": _ctx.center }])
  }, [
    _hoisted_1$b,
    !_ctx.$slots.dot ? (vue$n.openBlock(), vue$n.createElementBlock("div", {
      key: 0,
      class: vue$n.normalizeClass(["el-timeline-item__node", [
        `el-timeline-item__node--${_ctx.size || ""}`,
        `el-timeline-item__node--${_ctx.type || ""}`,
        _ctx.hollow ? "is-hollow" : ""
      ]]),
      style: vue$n.normalizeStyle({
        backgroundColor: _ctx.color
      })
    }, [
      _ctx.icon ? (vue$n.openBlock(), vue$n.createBlock(_component_el_icon, {
        key: 0,
        class: "el-timeline-item__icon"
      }, {
        default: vue$n.withCtx(() => [
          (vue$n.openBlock(), vue$n.createBlock(vue$n.resolveDynamicComponent(_ctx.icon)))
        ]),
        _: 1
      })) : vue$n.createCommentVNode("v-if", true)
    ], 6)) : vue$n.createCommentVNode("v-if", true),
    _ctx.$slots.dot ? (vue$n.openBlock(), vue$n.createElementBlock("div", _hoisted_2$9, [
      vue$n.renderSlot(_ctx.$slots, "dot")
    ])) : vue$n.createCommentVNode("v-if", true),
    vue$n.createElementVNode("div", _hoisted_3$7, [
      !_ctx.hideTimestamp && _ctx.placement === "top" ? (vue$n.openBlock(), vue$n.createElementBlock("div", _hoisted_4$4, vue$n.toDisplayString(_ctx.timestamp), 1)) : vue$n.createCommentVNode("v-if", true),
      vue$n.createElementVNode("div", _hoisted_5$3, [
        vue$n.renderSlot(_ctx.$slots, "default")
      ]),
      !_ctx.hideTimestamp && _ctx.placement === "bottom" ? (vue$n.openBlock(), vue$n.createElementBlock("div", _hoisted_6$2, vue$n.toDisplayString(_ctx.timestamp), 1)) : vue$n.createCommentVNode("v-if", true)
    ])
  ], 2);
}
item_vue_vue_type_template_id_174d5b12_lang.render = render$c;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var item_vue_vue_type_script_lang$12 = item_vue_vue_type_script_lang;
  var item_vue_vue_type_template_id_174d5b12_lang$1 = item_vue_vue_type_template_id_174d5b12_lang;
  item_vue_vue_type_script_lang$12["default"].render = item_vue_vue_type_template_id_174d5b12_lang$1.render;
  item_vue_vue_type_script_lang$12["default"].__file = "packages/components/timeline/src/item.vue";
  exports["default"] = item_vue_vue_type_script_lang$12["default"];
})(item);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$3;
  var item_vue_vue_type_script_lang$12 = item_vue_vue_type_script_lang;
  const ElTimeline = withInstall2.withInstall(index_vue_vue_type_script_lang2["default"], {
    TimelineItem: item_vue_vue_type_script_lang$12["default"]
  });
  const ElTimelineItem = withInstall2.withNoopInstall(item_vue_vue_type_script_lang$12["default"]);
  exports.ElTimeline = ElTimeline;
  exports.ElTimelineItem = ElTimelineItem;
  exports["default"] = ElTimeline;
})(timeline);
var transfer$1 = {};
var src$3 = {};
var index_vue_vue_type_script_lang$2 = {};
var transferPanel = {};
var transferPanel_vue_vue_type_script_lang = {};
var useCheck$4 = {};
Object.defineProperty(useCheck$4, "__esModule", { value: true });
var vue$m = require$$0$1;
const CHECKED_CHANGE_EVENT = "checked-change";
const useCheckProps = {
  data: {
    type: Array,
    default() {
      return [];
    }
  },
  optionRender: Function,
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: Object,
  filterMethod: Function,
  defaultChecked: Array,
  props: Object
};
const useCheck$3 = (props2, panelState) => {
  const { emit } = vue$m.getCurrentInstance();
  const labelProp = vue$m.computed(() => props2.props.label || "label");
  const keyProp = vue$m.computed(() => props2.props.key || "key");
  const disabledProp = vue$m.computed(() => props2.props.disabled || "disabled");
  const filteredData = vue$m.computed(() => {
    return props2.data.filter((item2) => {
      if (typeof props2.filterMethod === "function") {
        return props2.filterMethod(panelState.query, item2);
      } else {
        const label = item2[labelProp.value] || item2[keyProp.value].toString();
        return label.toLowerCase().includes(panelState.query.toLowerCase());
      }
    });
  });
  const checkableData = vue$m.computed(() => {
    return filteredData.value.filter((item2) => !item2[disabledProp.value]);
  });
  const checkedSummary = vue$m.computed(() => {
    const checkedLength = panelState.checked.length;
    const dataLength = props2.data.length;
    const { noChecked, hasChecked } = props2.format;
    if (noChecked && hasChecked) {
      return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength.toString()).replace(/\${total}/g, dataLength.toString()) : noChecked.replace(/\${total}/g, dataLength.toString());
    } else {
      return `${checkedLength}/${dataLength}`;
    }
  });
  const isIndeterminate = vue$m.computed(() => {
    const checkedLength = panelState.checked.length;
    return checkedLength > 0 && checkedLength < checkableData.value.length;
  });
  const updateAllChecked = () => {
    const checkableDataKeys = checkableData.value.map((item2) => item2[keyProp.value]);
    panelState.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every((item2) => panelState.checked.includes(item2));
  };
  const handleAllCheckedChange = (value) => {
    panelState.checked = value ? checkableData.value.map((item2) => item2[keyProp.value]) : [];
  };
  vue$m.watch(() => panelState.checked, (val, oldVal) => {
    updateAllChecked();
    if (panelState.checkChangeByUser) {
      const movedKeys = val.concat(oldVal).filter((v2) => !val.includes(v2) || !oldVal.includes(v2));
      emit(CHECKED_CHANGE_EVENT, val, movedKeys);
    } else {
      emit(CHECKED_CHANGE_EVENT, val);
      panelState.checkChangeByUser = true;
    }
  });
  vue$m.watch(checkableData, () => {
    updateAllChecked();
  });
  vue$m.watch(() => props2.data, () => {
    const checked2 = [];
    const filteredDataKeys = filteredData.value.map((item2) => item2[keyProp.value]);
    panelState.checked.forEach((item2) => {
      if (filteredDataKeys.includes(item2)) {
        checked2.push(item2);
      }
    });
    panelState.checkChangeByUser = false;
    panelState.checked = checked2;
  });
  vue$m.watch(() => props2.defaultChecked, (val, oldVal) => {
    if (oldVal && val.length === oldVal.length && val.every((item2) => oldVal.includes(item2)))
      return;
    const checked2 = [];
    const checkableDataKeys = checkableData.value.map((item2) => item2[keyProp.value]);
    val.forEach((item2) => {
      if (checkableDataKeys.includes(item2)) {
        checked2.push(item2);
      }
    });
    panelState.checkChangeByUser = false;
    panelState.checked = checked2;
  }, {
    immediate: true
  });
  return {
    labelProp,
    keyProp,
    disabledProp,
    filteredData,
    checkableData,
    checkedSummary,
    isIndeterminate,
    updateAllChecked,
    handleAllCheckedChange
  };
};
useCheck$4.CHECKED_CHANGE_EVENT = CHECKED_CHANGE_EVENT;
useCheck$4.useCheck = useCheck$3;
useCheck$4.useCheckProps = useCheckProps;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = checkbox$1;
  var index$22 = icon$4;
  var index$110 = input$2;
  var iconsVue2 = require$$3;
  var useCheck2 = useCheck$4;
  var index$32 = useLocale$1;
  var script2 = vue2.defineComponent({
    name: "ElTransferPanel",
    components: {
      ElCheckboxGroup: index2.ElCheckboxGroup,
      ElCheckbox: index2.ElCheckbox,
      ElInput: index$110.ElInput,
      ElIcon: index$22.ElIcon,
      OptionContent: ({ option: option2 }) => option2
    },
    props: useCheck2.useCheckProps,
    emits: [useCheck2.CHECKED_CHANGE_EVENT],
    setup(props2, { slots }) {
      const { t } = index$32.useLocale();
      const panelState = vue2.reactive({
        checked: [],
        allChecked: false,
        query: "",
        inputHover: false,
        checkChangeByUser: true
      });
      const {
        labelProp,
        keyProp,
        disabledProp,
        filteredData,
        checkedSummary,
        isIndeterminate,
        handleAllCheckedChange
      } = useCheck2.useCheck(props2, panelState);
      const hasNoMatch = vue2.computed(() => {
        return panelState.query.length > 0 && filteredData.value.length === 0;
      });
      const inputIcon = vue2.computed(() => {
        return panelState.query.length > 0 && panelState.inputHover ? iconsVue2.CircleClose : iconsVue2.Search;
      });
      const hasFooter = vue2.computed(() => !!slots.default()[0].children.length);
      const clearQuery = () => {
        if (inputIcon.value === iconsVue2.CircleClose) {
          panelState.query = "";
        }
      };
      const { checked: checked2, allChecked, query, inputHover, checkChangeByUser } = vue2.toRefs(panelState);
      return {
        labelProp,
        keyProp,
        disabledProp,
        filteredData,
        checkedSummary,
        isIndeterminate,
        handleAllCheckedChange,
        checked: checked2,
        allChecked,
        query,
        inputHover,
        checkChangeByUser,
        hasNoMatch,
        inputIcon,
        hasFooter,
        clearQuery,
        t
      };
    }
  });
  exports["default"] = script2;
})(transferPanel_vue_vue_type_script_lang);
var transferPanel_vue_vue_type_template_id_1a7d1f9c_lang = {};
Object.defineProperty(transferPanel_vue_vue_type_template_id_1a7d1f9c_lang, "__esModule", { value: true });
var vue$l = require$$0$1;
const _hoisted_1$a = { class: "el-transfer-panel" };
const _hoisted_2$8 = { class: "el-transfer-panel__header" };
const _hoisted_3$6 = {
  key: 0,
  class: "el-transfer-panel__footer"
};
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = vue$l.resolveComponent("el-checkbox");
  const _component_el_icon = vue$l.resolveComponent("el-icon");
  const _component_el_input = vue$l.resolveComponent("el-input");
  const _component_option_content = vue$l.resolveComponent("option-content");
  const _component_el_checkbox_group = vue$l.resolveComponent("el-checkbox-group");
  return vue$l.openBlock(), vue$l.createElementBlock("div", _hoisted_1$a, [
    vue$l.createElementVNode("p", _hoisted_2$8, [
      vue$l.createVNode(_component_el_checkbox, {
        modelValue: _ctx.allChecked,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.allChecked = $event),
        indeterminate: _ctx.isIndeterminate,
        onChange: _ctx.handleAllCheckedChange
      }, {
        default: vue$l.withCtx(() => [
          vue$l.createTextVNode(vue$l.toDisplayString(_ctx.title) + " ", 1),
          vue$l.createElementVNode("span", null, vue$l.toDisplayString(_ctx.checkedSummary), 1)
        ]),
        _: 1
      }, 8, ["modelValue", "indeterminate", "onChange"])
    ]),
    vue$l.createElementVNode("div", {
      class: vue$l.normalizeClass(["el-transfer-panel__body", _ctx.hasFooter ? "is-with-footer" : ""])
    }, [
      _ctx.filterable ? (vue$l.openBlock(), vue$l.createBlock(_component_el_input, {
        key: 0,
        modelValue: _ctx.query,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.query = $event),
        class: "el-transfer-panel__filter",
        size: "small",
        placeholder: _ctx.placeholder,
        onMouseenter: _cache[2] || (_cache[2] = ($event) => _ctx.inputHover = true),
        onMouseleave: _cache[3] || (_cache[3] = ($event) => _ctx.inputHover = false)
      }, {
        prefix: vue$l.withCtx(() => [
          _ctx.inputIcon ? (vue$l.openBlock(), vue$l.createBlock(_component_el_icon, {
            key: 0,
            class: "el-input__icon",
            onClick: _ctx.clearQuery
          }, {
            default: vue$l.withCtx(() => [
              (vue$l.openBlock(), vue$l.createBlock(vue$l.resolveDynamicComponent(_ctx.inputIcon)))
            ]),
            _: 1
          }, 8, ["onClick"])) : vue$l.createCommentVNode("v-if", true)
        ]),
        _: 1
      }, 8, ["modelValue", "placeholder"])) : vue$l.createCommentVNode("v-if", true),
      vue$l.withDirectives(vue$l.createVNode(_component_el_checkbox_group, {
        modelValue: _ctx.checked,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.checked = $event),
        class: vue$l.normalizeClass([{ "is-filterable": _ctx.filterable }, "el-transfer-panel__list"])
      }, {
        default: vue$l.withCtx(() => [
          (vue$l.openBlock(true), vue$l.createElementBlock(vue$l.Fragment, null, vue$l.renderList(_ctx.filteredData, (item2) => {
            return vue$l.openBlock(), vue$l.createBlock(_component_el_checkbox, {
              key: item2[_ctx.keyProp],
              class: "el-transfer-panel__item",
              label: item2[_ctx.keyProp],
              disabled: item2[_ctx.disabledProp]
            }, {
              default: vue$l.withCtx(() => [
                vue$l.createVNode(_component_option_content, {
                  option: _ctx.optionRender(item2)
                }, null, 8, ["option"])
              ]),
              _: 2
            }, 1032, ["label", "disabled"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["modelValue", "class"]), [
        [vue$l.vShow, !_ctx.hasNoMatch && _ctx.data.length > 0]
      ]),
      vue$l.withDirectives(vue$l.createElementVNode("p", { class: "el-transfer-panel__empty" }, vue$l.toDisplayString(_ctx.hasNoMatch ? _ctx.t("el.transfer.noMatch") : _ctx.t("el.transfer.noData")), 513), [
        [vue$l.vShow, _ctx.hasNoMatch || _ctx.data.length === 0]
      ])
    ], 2),
    _ctx.hasFooter ? (vue$l.openBlock(), vue$l.createElementBlock("p", _hoisted_3$6, [
      vue$l.renderSlot(_ctx.$slots, "default")
    ])) : vue$l.createCommentVNode("v-if", true)
  ]);
}
transferPanel_vue_vue_type_template_id_1a7d1f9c_lang.render = render$b;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var transferPanel_vue_vue_type_script_lang$1 = transferPanel_vue_vue_type_script_lang;
  var transferPanel_vue_vue_type_template_id_1a7d1f9c_lang$1 = transferPanel_vue_vue_type_template_id_1a7d1f9c_lang;
  transferPanel_vue_vue_type_script_lang$1["default"].render = transferPanel_vue_vue_type_template_id_1a7d1f9c_lang$1.render;
  transferPanel_vue_vue_type_script_lang$1["default"].__file = "packages/components/transfer/src/transfer-panel.vue";
  exports["default"] = transferPanel_vue_vue_type_script_lang$1["default"];
})(transferPanel);
var useComputedData$1 = {};
Object.defineProperty(useComputedData$1, "__esModule", { value: true });
var vue$k = require$$0$1;
const useComputedData = (props2) => {
  const propsKey = vue$k.computed(() => props2.props.key);
  const dataObj = vue$k.computed(() => {
    return props2.data.reduce((o2, cur) => (o2[cur[propsKey.value]] = cur) && o2, {});
  });
  const sourceData = vue$k.computed(() => {
    return props2.data.filter((item2) => !props2.modelValue.includes(item2[propsKey.value]));
  });
  const targetData = vue$k.computed(() => {
    if (props2.targetOrder === "original") {
      return props2.data.filter((item2) => props2.modelValue.includes(item2[propsKey.value]));
    } else {
      return props2.modelValue.reduce((arr, cur) => {
        const val = dataObj.value[cur];
        if (val) {
          arr.push(val);
        }
        return arr;
      }, []);
    }
  });
  return {
    propsKey,
    sourceData,
    targetData
  };
};
useComputedData$1.useComputedData = useComputedData;
var useCheckedChange$1 = {};
Object.defineProperty(useCheckedChange$1, "__esModule", { value: true });
const LEFT_CHECK_CHANGE_EVENT = "left-check-change";
const RIGHT_CHECK_CHANGE_EVENT = "right-check-change";
const useCheckedChange = (checkedState, emit) => {
  const onSourceCheckedChange = (val, movedKeys) => {
    checkedState.leftChecked = val;
    if (movedKeys === void 0)
      return;
    emit(LEFT_CHECK_CHANGE_EVENT, val, movedKeys);
  };
  const onTargetCheckedChange = (val, movedKeys) => {
    checkedState.rightChecked = val;
    if (movedKeys === void 0)
      return;
    emit(RIGHT_CHECK_CHANGE_EVENT, val, movedKeys);
  };
  return {
    onSourceCheckedChange,
    onTargetCheckedChange
  };
};
useCheckedChange$1.LEFT_CHECK_CHANGE_EVENT = LEFT_CHECK_CHANGE_EVENT;
useCheckedChange$1.RIGHT_CHECK_CHANGE_EVENT = RIGHT_CHECK_CHANGE_EVENT;
useCheckedChange$1.useCheckedChange = useCheckedChange;
var useMove$1 = {};
Object.defineProperty(useMove$1, "__esModule", { value: true });
var constants$2 = constants$f;
const useMove = (props2, checkedState, propsKey, emit) => {
  const _emit = (value, type4, checked2) => {
    emit(constants$2.UPDATE_MODEL_EVENT, value);
    emit(constants$2.CHANGE_EVENT, value, type4, checked2);
  };
  const addToLeft = () => {
    const currentValue = props2.modelValue.slice();
    checkedState.rightChecked.forEach((item2) => {
      const index2 = currentValue.indexOf(item2);
      if (index2 > -1) {
        currentValue.splice(index2, 1);
      }
    });
    _emit(currentValue, "left", checkedState.rightChecked);
  };
  const addToRight = () => {
    let currentValue = props2.modelValue.slice();
    const itemsToBeMoved = props2.data.filter((item2) => {
      const itemKey = item2[propsKey.value];
      return checkedState.leftChecked.includes(itemKey) && !props2.modelValue.includes(itemKey);
    }).map((item2) => item2[propsKey.value]);
    currentValue = props2.targetOrder === "unshift" ? itemsToBeMoved.concat(currentValue) : currentValue.concat(itemsToBeMoved);
    if (props2.targetOrder === "original") {
      currentValue = props2.data.filter((item2) => currentValue.includes(item2[propsKey.value])).map((item2) => item2[propsKey.value]);
    }
    _emit(currentValue, "right", checkedState.leftChecked);
  };
  return {
    addToLeft,
    addToRight
  };
};
useMove$1.useMove = useMove;
var transfer = {};
Object.defineProperty(transfer, "__esModule", { value: true });
var constants$1 = constants$f;
transfer.CHANGE_EVENT = constants$1.CHANGE_EVENT;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index2 = button$5;
  var index$110 = icon$4;
  var constants2 = constants$f;
  var iconsVue2 = require$$3;
  var useComputedData2 = useComputedData$1;
  var useCheckedChange2 = useCheckedChange$1;
  var useMove2 = useMove$1;
  var transferPanel_vue_vue_type_script_lang$1 = transferPanel_vue_vue_type_script_lang;
  var index$22 = useLocale$1;
  var form2 = form$7;
  var script2 = vue2.defineComponent({
    name: "ElTransfer",
    components: {
      TransferPanel: transferPanel_vue_vue_type_script_lang$1["default"],
      ElButton: index2.ElButton,
      ElIcon: index$110.ElIcon,
      ArrowLeft: iconsVue2.ArrowLeft,
      ArrowRight: iconsVue2.ArrowRight
    },
    props: {
      data: {
        type: Array,
        default: () => []
      },
      titles: {
        type: Array,
        default: () => []
      },
      buttonTexts: {
        type: Array,
        default: () => []
      },
      filterPlaceholder: {
        type: String,
        default: ""
      },
      filterMethod: Function,
      leftDefaultChecked: {
        type: Array,
        default: () => []
      },
      rightDefaultChecked: {
        type: Array,
        default: () => []
      },
      renderContent: Function,
      modelValue: {
        type: Array,
        default: () => []
      },
      format: {
        type: Object,
        default: () => ({})
      },
      filterable: {
        type: Boolean,
        default: false
      },
      props: {
        type: Object,
        default: () => ({
          label: "label",
          key: "key",
          disabled: "disabled"
        })
      },
      targetOrder: {
        type: String,
        default: "original",
        validator: (val) => {
          return ["original", "push", "unshift"].includes(val);
        }
      }
    },
    emits: [
      constants2.UPDATE_MODEL_EVENT,
      constants2.CHANGE_EVENT,
      useCheckedChange2.LEFT_CHECK_CHANGE_EVENT,
      useCheckedChange2.RIGHT_CHECK_CHANGE_EVENT
    ],
    setup(props2, { emit, slots }) {
      const { t } = index$22.useLocale();
      const elFormItem = vue2.inject(form2.elFormItemKey, {});
      const checkedState = vue2.reactive({
        leftChecked: [],
        rightChecked: []
      });
      const { propsKey, sourceData, targetData } = useComputedData2.useComputedData(props2);
      const { onSourceCheckedChange, onTargetCheckedChange } = useCheckedChange2.useCheckedChange(checkedState, emit);
      const { addToLeft, addToRight } = useMove2.useMove(props2, checkedState, propsKey, emit);
      const leftPanel = vue2.ref(null);
      const rightPanel = vue2.ref(null);
      const clearQuery = (which) => {
        if (which === "left") {
          leftPanel.value.query = "";
        } else if (which === "right") {
          rightPanel.value.query = "";
        }
      };
      const hasButtonTexts = vue2.computed(() => props2.buttonTexts.length === 2);
      const leftPanelTitle = vue2.computed(() => props2.titles[0] || t("el.transfer.titles.0"));
      const rightPanelTitle = vue2.computed(() => props2.titles[1] || t("el.transfer.titles.1"));
      const panelFilterPlaceholder = vue2.computed(() => props2.filterPlaceholder || t("el.transfer.filterPlaceholder"));
      vue2.watch(() => props2.modelValue, () => {
        var _a;
        (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change");
      });
      const optionRender = vue2.computed(() => (option2) => {
        if (props2.renderContent)
          return props2.renderContent(vue2.h, option2);
        if (slots.default)
          return slots.default({ option: option2 });
        return vue2.h("span", option2[props2.props.label] || option2[props2.props.key]);
      });
      return __spreadProps(__spreadValues({
        sourceData,
        targetData,
        onSourceCheckedChange,
        onTargetCheckedChange,
        addToLeft,
        addToRight
      }, vue2.toRefs(checkedState)), {
        hasButtonTexts,
        leftPanelTitle,
        rightPanelTitle,
        panelFilterPlaceholder,
        clearQuery,
        optionRender
      });
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$2);
var index_vue_vue_type_template_id_6c8b9070_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_6c8b9070_lang, "__esModule", { value: true });
var vue$j = require$$0$1;
const _hoisted_1$9 = { class: "el-transfer" };
const _hoisted_2$7 = { class: "el-transfer__buttons" };
const _hoisted_3$5 = { key: 0 };
const _hoisted_4$3 = { key: 0 };
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_transfer_panel = vue$j.resolveComponent("transfer-panel");
  const _component_arrow_left = vue$j.resolveComponent("arrow-left");
  const _component_el_icon = vue$j.resolveComponent("el-icon");
  const _component_el_button = vue$j.resolveComponent("el-button");
  const _component_arrow_right = vue$j.resolveComponent("arrow-right");
  return vue$j.openBlock(), vue$j.createElementBlock("div", _hoisted_1$9, [
    vue$j.createVNode(_component_transfer_panel, {
      ref: "leftPanel",
      data: _ctx.sourceData,
      "option-render": _ctx.optionRender,
      placeholder: _ctx.panelFilterPlaceholder,
      title: _ctx.leftPanelTitle,
      filterable: _ctx.filterable,
      format: _ctx.format,
      "filter-method": _ctx.filterMethod,
      "default-checked": _ctx.leftDefaultChecked,
      props: _ctx.props,
      onCheckedChange: _ctx.onSourceCheckedChange
    }, {
      default: vue$j.withCtx(() => [
        vue$j.renderSlot(_ctx.$slots, "left-footer")
      ]),
      _: 3
    }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
    vue$j.createElementVNode("div", _hoisted_2$7, [
      vue$j.createVNode(_component_el_button, {
        type: "primary",
        class: vue$j.normalizeClass(["el-transfer__button", _ctx.hasButtonTexts ? "is-with-texts" : ""]),
        disabled: _ctx.rightChecked.length === 0,
        onClick: _ctx.addToLeft
      }, {
        default: vue$j.withCtx(() => [
          vue$j.createVNode(_component_el_icon, null, {
            default: vue$j.withCtx(() => [
              vue$j.createVNode(_component_arrow_left)
            ]),
            _: 1
          }),
          _ctx.buttonTexts[0] !== void 0 ? (vue$j.openBlock(), vue$j.createElementBlock("span", _hoisted_3$5, vue$j.toDisplayString(_ctx.buttonTexts[0]), 1)) : vue$j.createCommentVNode("v-if", true)
        ]),
        _: 1
      }, 8, ["class", "disabled", "onClick"]),
      vue$j.createVNode(_component_el_button, {
        type: "primary",
        class: vue$j.normalizeClass(["el-transfer__button", _ctx.hasButtonTexts ? "is-with-texts" : ""]),
        disabled: _ctx.leftChecked.length === 0,
        onClick: _ctx.addToRight
      }, {
        default: vue$j.withCtx(() => [
          _ctx.buttonTexts[1] !== void 0 ? (vue$j.openBlock(), vue$j.createElementBlock("span", _hoisted_4$3, vue$j.toDisplayString(_ctx.buttonTexts[1]), 1)) : vue$j.createCommentVNode("v-if", true),
          vue$j.createVNode(_component_el_icon, null, {
            default: vue$j.withCtx(() => [
              vue$j.createVNode(_component_arrow_right)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["class", "disabled", "onClick"])
    ]),
    vue$j.createVNode(_component_transfer_panel, {
      ref: "rightPanel",
      data: _ctx.targetData,
      "option-render": _ctx.optionRender,
      placeholder: _ctx.panelFilterPlaceholder,
      filterable: _ctx.filterable,
      format: _ctx.format,
      "filter-method": _ctx.filterMethod,
      title: _ctx.rightPanelTitle,
      "default-checked": _ctx.rightDefaultChecked,
      props: _ctx.props,
      onCheckedChange: _ctx.onTargetCheckedChange
    }, {
      default: vue$j.withCtx(() => [
        vue$j.renderSlot(_ctx.$slots, "right-footer")
      ]),
      _: 3
    }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
  ]);
}
index_vue_vue_type_template_id_6c8b9070_lang.render = render$a;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$2;
  var index_vue_vue_type_template_id_6c8b9070_lang$1 = index_vue_vue_type_template_id_6c8b9070_lang;
  index_vue_vue_type_script_lang2["default"].render = index_vue_vue_type_template_id_6c8b9070_lang$1.render;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/transfer/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$3);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$2;
  var constants2 = constants$f;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  const _Transfer = index_vue_vue_type_script_lang2["default"];
  const ElTransfer = _Transfer;
  exports.CHANGE_EVENT = constants2.CHANGE_EVENT;
  exports.ElTransfer = ElTransfer;
  exports["default"] = _Transfer;
})(transfer$1);
var tree$2 = {};
var tree$1 = {};
var tree_vue_vue_type_script_lang$1 = {};
var treeStore = {};
var node = {};
var util$1 = {};
Object.defineProperty(util$1, "__esModule", { value: true });
const NODE_KEY = "$treeNodeId";
const markNodeData = function(node3, data2) {
  if (!data2 || data2[NODE_KEY])
    return;
  Object.defineProperty(data2, NODE_KEY, {
    value: node3.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};
const getNodeKey = function(key2, data2) {
  if (!key2)
    return data2[NODE_KEY];
  return data2[key2];
};
util$1.NODE_KEY = NODE_KEY;
util$1.getNodeKey = getNodeKey;
util$1.markNodeData = markNodeData;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var util2 = util$1;
  const getChildState = (node3) => {
    let all2 = true;
    let none = true;
    let allWithoutDisable = true;
    for (let i = 0, j = node3.length; i < j; i++) {
      const n = node3[i];
      if (n.checked !== true || n.indeterminate) {
        all2 = false;
        if (!n.disabled) {
          allWithoutDisable = false;
        }
      }
      if (n.checked !== false || n.indeterminate) {
        none = false;
      }
    }
    return { all: all2, none, allWithoutDisable, half: !all2 && !none };
  };
  const reInitChecked = function(node3) {
    if (node3.childNodes.length === 0)
      return;
    const { all: all2, none, half } = getChildState(node3.childNodes);
    if (all2) {
      node3.checked = true;
      node3.indeterminate = false;
    } else if (half) {
      node3.checked = false;
      node3.indeterminate = true;
    } else if (none) {
      node3.checked = false;
      node3.indeterminate = false;
    }
    const parent = node3.parent;
    if (!parent || parent.level === 0)
      return;
    if (!node3.store.checkStrictly) {
      reInitChecked(parent);
    }
  };
  const getPropertyFromData = function(node3, prop) {
    const props2 = node3.store.props;
    const data2 = node3.data || {};
    const config2 = props2[prop];
    if (typeof config2 === "function") {
      return config2(data2, node3);
    } else if (typeof config2 === "string") {
      return data2[config2];
    } else if (typeof config2 === "undefined") {
      const dataProp = data2[prop];
      return dataProp === void 0 ? "" : dataProp;
    }
  };
  let nodeIdSeed = 0;
  class Node2 {
    constructor(options) {
      this.id = nodeIdSeed++;
      this.text = null;
      this.checked = false;
      this.indeterminate = false;
      this.data = null;
      this.expanded = false;
      this.parent = null;
      this.visible = true;
      this.isCurrent = false;
      this.canFocus = false;
      for (const name in options) {
        if (shared2.hasOwn(options, name)) {
          this[name] = options[name];
        }
      }
      this.level = 0;
      this.loaded = false;
      this.childNodes = [];
      this.loading = false;
      if (this.parent) {
        this.level = this.parent.level + 1;
      }
    }
    initialize() {
      const store2 = this.store;
      if (!store2) {
        throw new Error("[Node]store is required!");
      }
      store2.registerNode(this);
      const props2 = store2.props;
      if (props2 && typeof props2.isLeaf !== "undefined") {
        const isLeaf = getPropertyFromData(this, "isLeaf");
        if (typeof isLeaf === "boolean") {
          this.isLeafByUser = isLeaf;
        }
      }
      if (store2.lazy !== true && this.data) {
        this.setData(this.data);
        if (store2.defaultExpandAll) {
          this.expanded = true;
          this.canFocus = true;
        }
      } else if (this.level > 0 && store2.lazy && store2.defaultExpandAll) {
        this.expand();
      }
      if (!Array.isArray(this.data)) {
        util2.markNodeData(this, this.data);
      }
      if (!this.data)
        return;
      const defaultExpandedKeys = store2.defaultExpandedKeys;
      const key2 = store2.key;
      if (key2 && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
        this.expand(null, store2.autoExpandParent);
      }
      if (key2 && store2.currentNodeKey !== void 0 && this.key === store2.currentNodeKey) {
        store2.currentNode = this;
        store2.currentNode.isCurrent = true;
      }
      if (store2.lazy) {
        store2._initDefaultCheckedNode(this);
      }
      this.updateLeafState();
      if (this.parent && (this.level === 1 || this.parent.expanded === true))
        this.canFocus = true;
    }
    setData(data2) {
      if (!Array.isArray(data2)) {
        util2.markNodeData(this, data2);
      }
      this.data = data2;
      this.childNodes = [];
      let children;
      if (this.level === 0 && this.data instanceof Array) {
        children = this.data;
      } else {
        children = getPropertyFromData(this, "children") || [];
      }
      for (let i = 0, j = children.length; i < j; i++) {
        this.insertChild({ data: children[i] });
      }
    }
    get label() {
      return getPropertyFromData(this, "label");
    }
    get key() {
      const nodeKey = this.store.key;
      if (this.data)
        return this.data[nodeKey];
      return null;
    }
    get disabled() {
      return getPropertyFromData(this, "disabled");
    }
    get nextSibling() {
      const parent = this.parent;
      if (parent) {
        const index2 = parent.childNodes.indexOf(this);
        if (index2 > -1) {
          return parent.childNodes[index2 + 1];
        }
      }
      return null;
    }
    get previousSibling() {
      const parent = this.parent;
      if (parent) {
        const index2 = parent.childNodes.indexOf(this);
        if (index2 > -1) {
          return index2 > 0 ? parent.childNodes[index2 - 1] : null;
        }
      }
      return null;
    }
    contains(target2, deep = true) {
      return (this.childNodes || []).some((child) => child === target2 || deep && child.contains(target2));
    }
    remove() {
      const parent = this.parent;
      if (parent) {
        parent.removeChild(this);
      }
    }
    insertChild(child, index2, batch) {
      if (!child)
        throw new Error("InsertChild error: child is required.");
      if (!(child instanceof Node2)) {
        if (!batch) {
          const children = this.getChildren(true);
          if (children.indexOf(child.data) === -1) {
            if (typeof index2 === "undefined" || index2 < 0) {
              children.push(child.data);
            } else {
              children.splice(index2, 0, child.data);
            }
          }
        }
        Object.assign(child, {
          parent: this,
          store: this.store
        });
        child = vue2.reactive(new Node2(child));
        if (child instanceof Node2) {
          child.initialize();
        }
      }
      child.level = this.level + 1;
      if (typeof index2 === "undefined" || index2 < 0) {
        this.childNodes.push(child);
      } else {
        this.childNodes.splice(index2, 0, child);
      }
      this.updateLeafState();
    }
    insertBefore(child, ref2) {
      let index2;
      if (ref2) {
        index2 = this.childNodes.indexOf(ref2);
      }
      this.insertChild(child, index2);
    }
    insertAfter(child, ref2) {
      let index2;
      if (ref2) {
        index2 = this.childNodes.indexOf(ref2);
        if (index2 !== -1)
          index2 += 1;
      }
      this.insertChild(child, index2);
    }
    removeChild(child) {
      const children = this.getChildren() || [];
      const dataIndex = children.indexOf(child.data);
      if (dataIndex > -1) {
        children.splice(dataIndex, 1);
      }
      const index2 = this.childNodes.indexOf(child);
      if (index2 > -1) {
        this.store && this.store.deregisterNode(child);
        child.parent = null;
        this.childNodes.splice(index2, 1);
      }
      this.updateLeafState();
    }
    removeChildByData(data2) {
      let targetNode = null;
      for (let i = 0; i < this.childNodes.length; i++) {
        if (this.childNodes[i].data === data2) {
          targetNode = this.childNodes[i];
          break;
        }
      }
      if (targetNode) {
        this.removeChild(targetNode);
      }
    }
    expand(callback, expandParent) {
      const done = () => {
        if (expandParent) {
          let parent = this.parent;
          while (parent.level > 0) {
            parent.expanded = true;
            parent = parent.parent;
          }
        }
        this.expanded = true;
        if (callback)
          callback();
        this.childNodes.forEach((item2) => {
          item2.canFocus = true;
        });
      };
      if (this.shouldLoadData()) {
        this.loadData((data2) => {
          if (Array.isArray(data2)) {
            if (this.checked) {
              this.setChecked(true, true);
            } else if (!this.store.checkStrictly) {
              reInitChecked(this);
            }
            done();
          }
        });
      } else {
        done();
      }
    }
    doCreateChildren(array4, defaultProps2 = {}) {
      array4.forEach((item2) => {
        this.insertChild(Object.assign({ data: item2 }, defaultProps2), void 0, true);
      });
    }
    collapse() {
      this.expanded = false;
      this.childNodes.forEach((item2) => {
        item2.canFocus = false;
      });
    }
    shouldLoadData() {
      return this.store.lazy === true && this.store.load && !this.loaded;
    }
    updateLeafState() {
      if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== "undefined") {
        this.isLeaf = this.isLeafByUser;
        return;
      }
      const childNodes = this.childNodes;
      if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
        this.isLeaf = !childNodes || childNodes.length === 0;
        return;
      }
      this.isLeaf = false;
    }
    setChecked(value, deep, recursion, passValue) {
      this.indeterminate = value === "half";
      this.checked = value === true;
      if (this.store.checkStrictly)
        return;
      if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
        const { all: all2, allWithoutDisable } = getChildState(this.childNodes);
        if (!this.isLeaf && !all2 && allWithoutDisable) {
          this.checked = false;
          value = false;
        }
        const handleDescendants = () => {
          if (deep) {
            const childNodes = this.childNodes;
            for (let i = 0, j = childNodes.length; i < j; i++) {
              const child = childNodes[i];
              passValue = passValue || value !== false;
              const isCheck = child.disabled ? child.checked : passValue;
              child.setChecked(isCheck, deep, true, passValue);
            }
            const { half, all: all22 } = getChildState(childNodes);
            if (!all22) {
              this.checked = all22;
              this.indeterminate = half;
            }
          }
        };
        if (this.shouldLoadData()) {
          this.loadData(() => {
            handleDescendants();
            reInitChecked(this);
          }, {
            checked: value !== false
          });
          return;
        } else {
          handleDescendants();
        }
      }
      const parent = this.parent;
      if (!parent || parent.level === 0)
        return;
      if (!recursion) {
        reInitChecked(parent);
      }
    }
    getChildren(forceInit = false) {
      if (this.level === 0)
        return this.data;
      const data2 = this.data;
      if (!data2)
        return null;
      const props2 = this.store.props;
      let children = "children";
      if (props2) {
        children = props2.children || "children";
      }
      if (data2[children] === void 0) {
        data2[children] = null;
      }
      if (forceInit && !data2[children]) {
        data2[children] = [];
      }
      return data2[children];
    }
    updateChildren() {
      const newData = this.getChildren() || [];
      const oldData = this.childNodes.map((node3) => node3.data);
      const newDataMap = {};
      const newNodes = [];
      newData.forEach((item2, index2) => {
        const key2 = item2[util2.NODE_KEY];
        const isNodeExists = !!key2 && oldData.findIndex((data2) => data2[util2.NODE_KEY] === key2) >= 0;
        if (isNodeExists) {
          newDataMap[key2] = { index: index2, data: item2 };
        } else {
          newNodes.push({ index: index2, data: item2 });
        }
      });
      if (!this.store.lazy) {
        oldData.forEach((item2) => {
          if (!newDataMap[item2[util2.NODE_KEY]])
            this.removeChildByData(item2);
        });
      }
      newNodes.forEach(({ index: index2, data: data2 }) => {
        this.insertChild({ data: data2 }, index2);
      });
      this.updateLeafState();
    }
    loadData(callback, defaultProps2 = {}) {
      if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps2).length)) {
        this.loading = true;
        const resolve2 = (children) => {
          this.loaded = true;
          this.loading = false;
          this.childNodes = [];
          this.doCreateChildren(children, defaultProps2);
          this.updateLeafState();
          if (callback) {
            callback.call(this, children);
          }
        };
        this.store.load(this, resolve2);
      } else {
        if (callback) {
          callback.call(this);
        }
      }
    }
  }
  exports["default"] = Node2;
  exports.getChildState = getChildState;
})(node);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var shared2 = require$$1$1;
  var node$12 = node;
  var util2 = util$1;
  class TreeStore {
    constructor(options) {
      this.currentNode = null;
      this.currentNodeKey = null;
      for (const option2 in options) {
        if (shared2.hasOwn(options, option2)) {
          this[option2] = options[option2];
        }
      }
      this.nodesMap = {};
    }
    initialize() {
      this.root = new node$12["default"]({
        data: this.data,
        store: this
      });
      this.root.initialize();
      if (this.lazy && this.load) {
        const loadFn = this.load;
        loadFn(this.root, (data2) => {
          this.root.doCreateChildren(data2);
          this._initDefaultCheckedNodes();
        });
      } else {
        this._initDefaultCheckedNodes();
      }
    }
    filter(value) {
      const filterNodeMethod = this.filterNodeMethod;
      const lazy = this.lazy;
      const traverse2 = function(node3) {
        const childNodes = node3.root ? node3.root.childNodes : node3.childNodes;
        childNodes.forEach((child) => {
          child.visible = filterNodeMethod.call(child, value, child.data, child);
          traverse2(child);
        });
        if (!node3.visible && childNodes.length) {
          let allHidden = true;
          allHidden = !childNodes.some((child) => child.visible);
          if (node3.root) {
            node3.root.visible = allHidden === false;
          } else {
            node3.visible = allHidden === false;
          }
        }
        if (!value)
          return;
        if (node3.visible && !node3.isLeaf && !lazy)
          node3.expand();
      };
      traverse2(this);
    }
    setData(newVal) {
      const instanceChanged = newVal !== this.root.data;
      if (instanceChanged) {
        this.root.setData(newVal);
        this._initDefaultCheckedNodes();
      } else {
        this.root.updateChildren();
      }
    }
    getNode(data2) {
      if (data2 instanceof node$12["default"])
        return data2;
      const key2 = typeof data2 !== "object" ? data2 : util2.getNodeKey(this.key, data2);
      return this.nodesMap[key2] || null;
    }
    insertBefore(data2, refData) {
      const refNode = this.getNode(refData);
      refNode.parent.insertBefore({ data: data2 }, refNode);
    }
    insertAfter(data2, refData) {
      const refNode = this.getNode(refData);
      refNode.parent.insertAfter({ data: data2 }, refNode);
    }
    remove(data2) {
      const node3 = this.getNode(data2);
      if (node3 && node3.parent) {
        if (node3 === this.currentNode) {
          this.currentNode = null;
        }
        node3.parent.removeChild(node3);
      }
    }
    append(data2, parentData) {
      const parentNode = parentData ? this.getNode(parentData) : this.root;
      if (parentNode) {
        parentNode.insertChild({ data: data2 });
      }
    }
    _initDefaultCheckedNodes() {
      const defaultCheckedKeys = this.defaultCheckedKeys || [];
      const nodesMap = this.nodesMap;
      defaultCheckedKeys.forEach((checkedKey) => {
        const node3 = nodesMap[checkedKey];
        if (node3) {
          node3.setChecked(true, !this.checkStrictly);
        }
      });
    }
    _initDefaultCheckedNode(node3) {
      const defaultCheckedKeys = this.defaultCheckedKeys || [];
      if (defaultCheckedKeys.indexOf(node3.key) !== -1) {
        node3.setChecked(true, !this.checkStrictly);
      }
    }
    setDefaultCheckedKey(newVal) {
      if (newVal !== this.defaultCheckedKeys) {
        this.defaultCheckedKeys = newVal;
        this._initDefaultCheckedNodes();
      }
    }
    registerNode(node3) {
      const key2 = this.key;
      if (!node3 || !node3.data)
        return;
      if (!key2) {
        this.nodesMap[node3.id] = node3;
      } else {
        const nodeKey = node3.key;
        if (nodeKey !== void 0)
          this.nodesMap[node3.key] = node3;
      }
    }
    deregisterNode(node3) {
      const key2 = this.key;
      if (!key2 || !node3 || !node3.data)
        return;
      node3.childNodes.forEach((child) => {
        this.deregisterNode(child);
      });
      delete this.nodesMap[node3.key];
    }
    getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
      const checkedNodes = [];
      const traverse2 = function(node3) {
        const childNodes = node3.root ? node3.root.childNodes : node3.childNodes;
        childNodes.forEach((child) => {
          if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
            checkedNodes.push(child.data);
          }
          traverse2(child);
        });
      };
      traverse2(this);
      return checkedNodes;
    }
    getCheckedKeys(leafOnly = false) {
      return this.getCheckedNodes(leafOnly).map((data2) => (data2 || {})[this.key]);
    }
    getHalfCheckedNodes() {
      const nodes = [];
      const traverse2 = function(node3) {
        const childNodes = node3.root ? node3.root.childNodes : node3.childNodes;
        childNodes.forEach((child) => {
          if (child.indeterminate) {
            nodes.push(child.data);
          }
          traverse2(child);
        });
      };
      traverse2(this);
      return nodes;
    }
    getHalfCheckedKeys() {
      return this.getHalfCheckedNodes().map((data2) => (data2 || {})[this.key]);
    }
    _getAllNodes() {
      const allNodes = [];
      const nodesMap = this.nodesMap;
      for (const nodeKey in nodesMap) {
        if (shared2.hasOwn(nodesMap, nodeKey)) {
          allNodes.push(nodesMap[nodeKey]);
        }
      }
      return allNodes;
    }
    updateChildren(key2, data2) {
      const node3 = this.nodesMap[key2];
      if (!node3)
        return;
      const childNodes = node3.childNodes;
      for (let i = childNodes.length - 1; i >= 0; i--) {
        const child = childNodes[i];
        this.remove(child.data);
      }
      for (let i = 0, j = data2.length; i < j; i++) {
        const child = data2[i];
        this.append(child, node3.data);
      }
    }
    _setCheckedKeys(key2, leafOnly = false, checkedKeys) {
      const allNodes = this._getAllNodes().sort((a2, b2) => b2.level - a2.level);
      const cache2 = Object.create(null);
      const keys2 = Object.keys(checkedKeys);
      allNodes.forEach((node3) => node3.setChecked(false, false));
      for (let i = 0, j = allNodes.length; i < j; i++) {
        const node3 = allNodes[i];
        const nodeKey = node3.data[key2].toString();
        const checked2 = keys2.indexOf(nodeKey) > -1;
        if (!checked2) {
          if (node3.checked && !cache2[nodeKey]) {
            node3.setChecked(false, false);
          }
          continue;
        }
        let parent = node3.parent;
        while (parent && parent.level > 0) {
          cache2[parent.data[key2]] = true;
          parent = parent.parent;
        }
        if (node3.isLeaf || this.checkStrictly) {
          node3.setChecked(true, false);
          continue;
        }
        node3.setChecked(true, true);
        if (leafOnly) {
          node3.setChecked(false, false);
          const traverse2 = function(node22) {
            const childNodes = node22.childNodes;
            childNodes.forEach((child) => {
              if (!child.isLeaf) {
                child.setChecked(false, false);
              }
              traverse2(child);
            });
          };
          traverse2(node3);
        }
      }
    }
    setCheckedNodes(array4, leafOnly = false) {
      const key2 = this.key;
      const checkedKeys = {};
      array4.forEach((item2) => {
        checkedKeys[(item2 || {})[key2]] = true;
      });
      this._setCheckedKeys(key2, leafOnly, checkedKeys);
    }
    setCheckedKeys(keys2, leafOnly = false) {
      this.defaultCheckedKeys = keys2;
      const key2 = this.key;
      const checkedKeys = {};
      keys2.forEach((key22) => {
        checkedKeys[key22] = true;
      });
      this._setCheckedKeys(key2, leafOnly, checkedKeys);
    }
    setDefaultExpandedKeys(keys2) {
      keys2 = keys2 || [];
      this.defaultExpandedKeys = keys2;
      keys2.forEach((key2) => {
        const node3 = this.getNode(key2);
        if (node3)
          node3.expand(null, this.autoExpandParent);
      });
    }
    setChecked(data2, checked2, deep) {
      const node3 = this.getNode(data2);
      if (node3) {
        node3.setChecked(!!checked2, deep);
      }
    }
    getCurrentNode() {
      return this.currentNode;
    }
    setCurrentNode(currentNode) {
      const prevCurrentNode = this.currentNode;
      if (prevCurrentNode) {
        prevCurrentNode.isCurrent = false;
      }
      this.currentNode = currentNode;
      this.currentNode.isCurrent = true;
    }
    setUserCurrentNode(node3, shouldAutoExpandParent = true) {
      const key2 = node3[this.key];
      const currNode = this.nodesMap[key2];
      this.setCurrentNode(currNode);
      if (shouldAutoExpandParent && this.currentNode.level > 1) {
        this.currentNode.parent.expand(null, true);
      }
    }
    setCurrentNodeKey(key2, shouldAutoExpandParent = true) {
      if (key2 === null || key2 === void 0) {
        this.currentNode && (this.currentNode.isCurrent = false);
        this.currentNode = null;
        return;
      }
      const node3 = this.getNode(key2);
      if (node3) {
        this.setCurrentNode(node3);
        if (shouldAutoExpandParent && this.currentNode.level > 1) {
          this.currentNode.parent.expand(null, true);
        }
      }
    }
  }
  exports["default"] = TreeStore;
})(treeStore);
var treeNode$1 = {};
var treeNode_vue_vue_type_script_lang$1 = {};
var treeNodeContent$1 = {};
var treeNodeContent_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElTreeNodeContent",
    props: {
      node: {
        type: Object,
        required: true
      },
      renderContent: Function
    },
    setup(props2) {
      const nodeInstance = vue2.inject("NodeInstance");
      const tree2 = vue2.inject("RootTree");
      return () => {
        const node3 = props2.node;
        const { data: data2, store: store2 } = node3;
        return props2.renderContent ? props2.renderContent(vue2.h, { _self: nodeInstance, node: node3, data: data2, store: store2 }) : tree2.ctx.slots.default ? tree2.ctx.slots.default({ node: node3, data: data2 }) : vue2.h("span", { class: "el-tree-node__label" }, [node3.label]);
      };
    }
  });
  exports["default"] = script2;
})(treeNodeContent_vue_vue_type_script_lang);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var treeNodeContent_vue_vue_type_script_lang$1 = treeNodeContent_vue_vue_type_script_lang;
  treeNodeContent_vue_vue_type_script_lang$1["default"].__file = "packages/components/tree/src/tree-node-content.vue";
  exports["default"] = treeNodeContent_vue_vue_type_script_lang$1["default"];
})(treeNodeContent$1);
var useNodeExpandEventBroadcast$1 = {};
Object.defineProperty(useNodeExpandEventBroadcast$1, "__esModule", { value: true });
var vue$i = require$$0$1;
function useNodeExpandEventBroadcast(props2) {
  const parentNodeMap = vue$i.inject("TreeNodeMap", null);
  const currentNodeMap = {
    treeNodeExpand: (node3) => {
      if (props2.node !== node3) {
        props2.node.collapse();
      }
    },
    children: []
  };
  if (parentNodeMap) {
    parentNodeMap.children.push(currentNodeMap);
  }
  vue$i.provide("TreeNodeMap", currentNodeMap);
  return {
    broadcastExpanded: (node3) => {
      if (!props2.accordion)
        return;
      for (const childNode of currentNodeMap.children) {
        childNode.treeNodeExpand(node3);
      }
    }
  };
}
useNodeExpandEventBroadcast$1.useNodeExpandEventBroadcast = useNodeExpandEventBroadcast;
var useDragNode = {};
Object.defineProperty(useDragNode, "__esModule", { value: true });
var vue$h = require$$0$1;
var dom$3 = dom$8;
const dragEventsKey = Symbol("dragEvents");
function useDragNodeHandler({ props: props2, ctx, el$, dropIndicator$, store: store2 }) {
  const dragState = vue$h.ref({
    showDropIndicator: false,
    draggingNode: null,
    dropNode: null,
    allowDrop: true,
    dropType: null
  });
  const treeNodeDragStart = ({ event, treeNode: treeNode2 }) => {
    if (typeof props2.allowDrag === "function" && !props2.allowDrag(treeNode2.node)) {
      event.preventDefault();
      return false;
    }
    event.dataTransfer.effectAllowed = "move";
    try {
      event.dataTransfer.setData("text/plain", "");
    } catch (e) {
    }
    dragState.value.draggingNode = treeNode2;
    ctx.emit("node-drag-start", treeNode2.node, event);
  };
  const treeNodeDragOver = ({ event, treeNode: treeNode2 }) => {
    const dropNode = treeNode2;
    const oldDropNode = dragState.value.dropNode;
    if (oldDropNode && oldDropNode !== dropNode) {
      dom$3.removeClass(oldDropNode.$el, "is-drop-inner");
    }
    const draggingNode = dragState.value.draggingNode;
    if (!draggingNode || !dropNode)
      return;
    let dropPrev = true;
    let dropInner = true;
    let dropNext = true;
    let userAllowDropInner = true;
    if (typeof props2.allowDrop === "function") {
      dropPrev = props2.allowDrop(draggingNode.node, dropNode.node, "prev");
      userAllowDropInner = dropInner = props2.allowDrop(draggingNode.node, dropNode.node, "inner");
      dropNext = props2.allowDrop(draggingNode.node, dropNode.node, "next");
    }
    event.dataTransfer.dropEffect = dropInner ? "move" : "none";
    if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
      if (oldDropNode) {
        ctx.emit("node-drag-leave", draggingNode.node, oldDropNode.node, event);
      }
      ctx.emit("node-drag-enter", draggingNode.node, dropNode.node, event);
    }
    if (dropPrev || dropInner || dropNext) {
      dragState.value.dropNode = dropNode;
    }
    if (dropNode.node.nextSibling === draggingNode.node) {
      dropNext = false;
    }
    if (dropNode.node.previousSibling === draggingNode.node) {
      dropPrev = false;
    }
    if (dropNode.node.contains(draggingNode.node, false)) {
      dropInner = false;
    }
    if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
      dropPrev = false;
      dropInner = false;
      dropNext = false;
    }
    const targetPosition = dropNode.$el.getBoundingClientRect();
    const treePosition = el$.value.getBoundingClientRect();
    let dropType;
    const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
    const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
    let indicatorTop = -9999;
    const distance = event.clientY - targetPosition.top;
    if (distance < targetPosition.height * prevPercent) {
      dropType = "before";
    } else if (distance > targetPosition.height * nextPercent) {
      dropType = "after";
    } else if (dropInner) {
      dropType = "inner";
    } else {
      dropType = "none";
    }
    const iconPosition = dropNode.$el.querySelector(".el-tree-node__expand-icon").getBoundingClientRect();
    const dropIndicator = dropIndicator$.value;
    if (dropType === "before") {
      indicatorTop = iconPosition.top - treePosition.top;
    } else if (dropType === "after") {
      indicatorTop = iconPosition.bottom - treePosition.top;
    }
    dropIndicator.style.top = `${indicatorTop}px`;
    dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;
    if (dropType === "inner") {
      dom$3.addClass(dropNode.$el, "is-drop-inner");
    } else {
      dom$3.removeClass(dropNode.$el, "is-drop-inner");
    }
    dragState.value.showDropIndicator = dropType === "before" || dropType === "after";
    dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;
    dragState.value.dropType = dropType;
    ctx.emit("node-drag-over", draggingNode.node, dropNode.node, event);
  };
  const treeNodeDragEnd = (event) => {
    const { draggingNode, dropType, dropNode } = dragState.value;
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    if (draggingNode && dropNode) {
      const draggingNodeCopy = { data: draggingNode.node.data };
      if (dropType !== "none") {
        draggingNode.node.remove();
      }
      if (dropType === "before") {
        dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
      } else if (dropType === "after") {
        dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
      } else if (dropType === "inner") {
        dropNode.node.insertChild(draggingNodeCopy);
      }
      if (dropType !== "none") {
        store2.value.registerNode(draggingNodeCopy);
      }
      dom$3.removeClass(dropNode.$el, "is-drop-inner");
      ctx.emit("node-drag-end", draggingNode.node, dropNode.node, dropType, event);
      if (dropType !== "none") {
        ctx.emit("node-drop", draggingNode.node, dropNode.node, dropType, event);
      }
    }
    if (draggingNode && !dropNode) {
      ctx.emit("node-drag-end", draggingNode.node, null, dropType, event);
    }
    dragState.value.showDropIndicator = false;
    dragState.value.draggingNode = null;
    dragState.value.dropNode = null;
    dragState.value.allowDrop = true;
  };
  vue$h.provide(dragEventsKey, {
    treeNodeDragStart,
    treeNodeDragOver,
    treeNodeDragEnd
  });
  return {
    dragState
  };
}
useDragNode.dragEventsKey = dragEventsKey;
useDragNode.useDragNodeHandler = useDragNodeHandler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var index2 = collapseTransition$1;
  var index$110 = checkbox$1;
  var index$22 = icon$4;
  var iconsVue2 = require$$3;
  var error2 = error$5;
  var util2 = util$1;
  var useNodeExpandEventBroadcast2 = useNodeExpandEventBroadcast$1;
  var useDragNode$1 = useDragNode;
  var node$12 = node;
  var treeNodeContent_vue_vue_type_script_lang$1 = treeNodeContent_vue_vue_type_script_lang;
  var script2 = vue2.defineComponent({
    name: "ElTreeNode",
    components: {
      ElCollapseTransition: index2["default"],
      ElCheckbox: index$110.ElCheckbox,
      NodeContent: treeNodeContent_vue_vue_type_script_lang$1["default"],
      ElIcon: index$22.ElIcon,
      Loading: iconsVue2.Loading
    },
    props: {
      node: {
        type: node$12["default"],
        default: () => ({})
      },
      props: {
        type: Object,
        default: () => ({})
      },
      accordion: Boolean,
      renderContent: Function,
      renderAfterExpand: Boolean,
      showCheckbox: {
        type: Boolean,
        default: false
      }
    },
    emits: ["node-expand"],
    setup(props2, ctx) {
      const { broadcastExpanded } = useNodeExpandEventBroadcast2.useNodeExpandEventBroadcast(props2);
      const tree2 = vue2.inject("RootTree");
      const expanded = vue2.ref(false);
      const childNodeRendered = vue2.ref(false);
      const oldChecked = vue2.ref(null);
      const oldIndeterminate = vue2.ref(null);
      const node$ = vue2.ref(null);
      const dragEvents = vue2.inject(useDragNode$1.dragEventsKey);
      const instance = vue2.getCurrentInstance();
      vue2.provide("NodeInstance", instance);
      if (!tree2) {
        error2.debugWarn("Tree", "Can not find node's tree.");
      }
      if (props2.node.expanded) {
        expanded.value = true;
        childNodeRendered.value = true;
      }
      const childrenKey = tree2.props["children"] || "children";
      vue2.watch(() => {
        const children = props2.node.data[childrenKey];
        return children && [...children];
      }, () => {
        props2.node.updateChildren();
      });
      vue2.watch(() => props2.node.indeterminate, (val) => {
        handleSelectChange(props2.node.checked, val);
      });
      vue2.watch(() => props2.node.checked, (val) => {
        handleSelectChange(val, props2.node.indeterminate);
      });
      vue2.watch(() => props2.node.expanded, (val) => {
        vue2.nextTick(() => expanded.value = val);
        if (val) {
          childNodeRendered.value = true;
        }
      });
      const getNodeKey2 = (node3) => {
        return util2.getNodeKey(tree2.props.nodeKey, node3.data);
      };
      const getNodeClass = (node3) => {
        const nodeClassFunc = props2.props.class;
        if (!nodeClassFunc) {
          return {};
        }
        let className;
        if (shared2.isFunction(nodeClassFunc)) {
          const { data: data2 } = node3;
          className = nodeClassFunc(data2, node3);
        } else {
          className = nodeClassFunc;
        }
        if (shared2.isString(className)) {
          return { [className]: true };
        } else {
          return className;
        }
      };
      const handleSelectChange = (checked2, indeterminate) => {
        if (oldChecked.value !== checked2 || oldIndeterminate.value !== indeterminate) {
          tree2.ctx.emit("check-change", props2.node.data, checked2, indeterminate);
        }
        oldChecked.value = checked2;
        oldIndeterminate.value = indeterminate;
      };
      const handleClick = () => {
        const store2 = tree2.store.value;
        store2.setCurrentNode(props2.node);
        tree2.ctx.emit("current-change", store2.currentNode ? store2.currentNode.data : null, store2.currentNode);
        tree2.currentNode.value = props2.node;
        if (tree2.props.expandOnClickNode) {
          handleExpandIconClick();
        }
        if (tree2.props.checkOnClickNode && !props2.node.disabled) {
          handleCheckChange(null, {
            target: { checked: !props2.node.checked }
          });
        }
        tree2.ctx.emit("node-click", props2.node.data, props2.node, instance);
      };
      const handleContextMenu = (event) => {
        if (tree2.instance.vnode.props["onNodeContextmenu"]) {
          event.stopPropagation();
          event.preventDefault();
        }
        tree2.ctx.emit("node-contextmenu", event, props2.node.data, props2.node, instance);
      };
      const handleExpandIconClick = () => {
        if (props2.node.isLeaf)
          return;
        if (expanded.value) {
          tree2.ctx.emit("node-collapse", props2.node.data, props2.node, instance);
          props2.node.collapse();
        } else {
          props2.node.expand();
          ctx.emit("node-expand", props2.node.data, props2.node, instance);
        }
      };
      const handleCheckChange = (value, ev) => {
        props2.node.setChecked(ev.target.checked, !tree2.props.checkStrictly);
        vue2.nextTick(() => {
          const store2 = tree2.store.value;
          tree2.ctx.emit("check", props2.node.data, {
            checkedNodes: store2.getCheckedNodes(),
            checkedKeys: store2.getCheckedKeys(),
            halfCheckedNodes: store2.getHalfCheckedNodes(),
            halfCheckedKeys: store2.getHalfCheckedKeys()
          });
        });
      };
      const handleChildNodeExpand = (nodeData, node3, instance2) => {
        broadcastExpanded(node3);
        tree2.ctx.emit("node-expand", nodeData, node3, instance2);
      };
      const handleDragStart = (event) => {
        if (!tree2.props.draggable)
          return;
        dragEvents.treeNodeDragStart({ event, treeNode: props2 });
      };
      const handleDragOver = (event) => {
        if (!tree2.props.draggable)
          return;
        dragEvents.treeNodeDragOver({
          event,
          treeNode: { $el: node$.value, node: props2.node }
        });
        event.preventDefault();
      };
      const handleDrop = (event) => {
        event.preventDefault();
      };
      const handleDragEnd = (event) => {
        if (!tree2.props.draggable)
          return;
        dragEvents.treeNodeDragEnd(event);
      };
      return {
        node$,
        tree: tree2,
        expanded,
        childNodeRendered,
        oldChecked,
        oldIndeterminate,
        getNodeKey: getNodeKey2,
        getNodeClass,
        handleSelectChange,
        handleClick,
        handleContextMenu,
        handleExpandIconClick,
        handleCheckChange,
        handleChildNodeExpand,
        handleDragStart,
        handleDragOver,
        handleDrop,
        handleDragEnd,
        CaretRight: iconsVue2.CaretRight
      };
    }
  });
  exports["default"] = script2;
})(treeNode_vue_vue_type_script_lang$1);
var treeNode_vue_vue_type_template_id_62959aba_lang = {};
Object.defineProperty(treeNode_vue_vue_type_template_id_62959aba_lang, "__esModule", { value: true });
var vue$g = require$$0$1;
const _hoisted_1$8 = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"];
const _hoisted_2$6 = ["aria-expanded"];
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$g.resolveComponent("el-icon");
  const _component_el_checkbox = vue$g.resolveComponent("el-checkbox");
  const _component_loading = vue$g.resolveComponent("loading");
  const _component_node_content = vue$g.resolveComponent("node-content");
  const _component_el_tree_node = vue$g.resolveComponent("el-tree-node");
  const _component_el_collapse_transition = vue$g.resolveComponent("el-collapse-transition");
  return vue$g.withDirectives((vue$g.openBlock(), vue$g.createElementBlock("div", {
    ref: "node$",
    class: vue$g.normalizeClass(["el-tree-node", __spreadValues({
      "is-expanded": _ctx.expanded,
      "is-current": _ctx.node.isCurrent,
      "is-hidden": !_ctx.node.visible,
      "is-focusable": !_ctx.node.disabled,
      "is-checked": !_ctx.node.disabled && _ctx.node.checked
    }, _ctx.getNodeClass(_ctx.node))]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": _ctx.expanded,
    "aria-disabled": _ctx.node.disabled,
    "aria-checked": _ctx.node.checked,
    draggable: _ctx.tree.props.draggable,
    "data-key": _ctx.getNodeKey(_ctx.node),
    onClick: _cache[1] || (_cache[1] = vue$g.withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
    onContextmenu: _cache[2] || (_cache[2] = (...args) => _ctx.handleContextMenu && _ctx.handleContextMenu(...args)),
    onDragstart: _cache[3] || (_cache[3] = vue$g.withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
    onDragover: _cache[4] || (_cache[4] = vue$g.withModifiers((...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args), ["stop"])),
    onDragend: _cache[5] || (_cache[5] = vue$g.withModifiers((...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args), ["stop"])),
    onDrop: _cache[6] || (_cache[6] = vue$g.withModifiers((...args) => _ctx.handleDrop && _ctx.handleDrop(...args), ["stop"]))
  }, [
    vue$g.createElementVNode("div", {
      class: "el-tree-node__content",
      style: vue$g.normalizeStyle({ paddingLeft: (_ctx.node.level - 1) * _ctx.tree.props.indent + "px" })
    }, [
      _ctx.tree.props.icon || _ctx.CaretRight ? (vue$g.openBlock(), vue$g.createBlock(_component_el_icon, {
        key: 0,
        class: vue$g.normalizeClass([
          {
            "is-leaf": _ctx.node.isLeaf,
            expanded: !_ctx.node.isLeaf && _ctx.expanded
          },
          "el-tree-node__expand-icon"
        ]),
        onClick: vue$g.withModifiers(_ctx.handleExpandIconClick, ["stop"])
      }, {
        default: vue$g.withCtx(() => [
          (vue$g.openBlock(), vue$g.createBlock(vue$g.resolveDynamicComponent(_ctx.tree.props.icon || _ctx.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : vue$g.createCommentVNode("v-if", true),
      _ctx.showCheckbox ? (vue$g.openBlock(), vue$g.createBlock(_component_el_checkbox, {
        key: 1,
        "model-value": _ctx.node.checked,
        indeterminate: _ctx.node.indeterminate,
        disabled: !!_ctx.node.disabled,
        onClick: _cache[0] || (_cache[0] = vue$g.withModifiers(() => {
        }, ["stop"])),
        onChange: _ctx.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : vue$g.createCommentVNode("v-if", true),
      _ctx.node.loading ? (vue$g.openBlock(), vue$g.createBlock(_component_el_icon, {
        key: 2,
        class: "el-tree-node__loading-icon is-loading"
      }, {
        default: vue$g.withCtx(() => [
          vue$g.createVNode(_component_loading)
        ]),
        _: 1
      })) : vue$g.createCommentVNode("v-if", true),
      vue$g.createVNode(_component_node_content, {
        node: _ctx.node,
        "render-content": _ctx.renderContent
      }, null, 8, ["node", "render-content"])
    ], 4),
    vue$g.createVNode(_component_el_collapse_transition, null, {
      default: vue$g.withCtx(() => [
        !_ctx.renderAfterExpand || _ctx.childNodeRendered ? vue$g.withDirectives((vue$g.openBlock(), vue$g.createElementBlock("div", {
          key: 0,
          class: "el-tree-node__children",
          role: "group",
          "aria-expanded": _ctx.expanded
        }, [
          (vue$g.openBlock(true), vue$g.createElementBlock(vue$g.Fragment, null, vue$g.renderList(_ctx.node.childNodes, (child) => {
            return vue$g.openBlock(), vue$g.createBlock(_component_el_tree_node, {
              key: _ctx.getNodeKey(child),
              "render-content": _ctx.renderContent,
              "render-after-expand": _ctx.renderAfterExpand,
              "show-checkbox": _ctx.showCheckbox,
              node: child,
              props: _ctx.props,
              onNodeExpand: _ctx.handleChildNodeExpand
            }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "props", "onNodeExpand"]);
          }), 128))
        ], 8, _hoisted_2$6)), [
          [vue$g.vShow, _ctx.expanded]
        ]) : vue$g.createCommentVNode("v-if", true)
      ]),
      _: 1
    })
  ], 42, _hoisted_1$8)), [
    [vue$g.vShow, _ctx.node.visible]
  ]);
}
treeNode_vue_vue_type_template_id_62959aba_lang.render = render$9;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var treeNode_vue_vue_type_script_lang2 = treeNode_vue_vue_type_script_lang$1;
  var treeNode_vue_vue_type_template_id_62959aba_lang$1 = treeNode_vue_vue_type_template_id_62959aba_lang;
  treeNode_vue_vue_type_script_lang2["default"].render = treeNode_vue_vue_type_template_id_62959aba_lang$1.render;
  treeNode_vue_vue_type_script_lang2["default"].__file = "packages/components/tree/src/tree-node.vue";
  exports["default"] = treeNode_vue_vue_type_script_lang2["default"];
})(treeNode$1);
var useKeydown$1 = {};
Object.defineProperty(useKeydown$1, "__esModule", { value: true });
var vue$f = require$$0$1;
var aria = aria$5;
var dom$2 = dom$8;
function useKeydown({ el$ }, store2) {
  const treeItems = vue$f.shallowRef([]);
  const checkboxItems = vue$f.shallowRef([]);
  vue$f.onMounted(() => {
    initTabIndex();
    dom$2.on(el$.value, "keydown", handleKeydown);
  });
  vue$f.onBeforeUnmount(() => {
    dom$2.off(el$.value, "keydown", handleKeydown);
  });
  vue$f.onUpdated(() => {
    treeItems.value = Array.from(el$.value.querySelectorAll("[role=treeitem]"));
    checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
  });
  vue$f.watch(checkboxItems, (val) => {
    val.forEach((checkbox2) => {
      checkbox2.setAttribute("tabindex", "-1");
    });
  });
  const handleKeydown = (ev) => {
    const currentItem = ev.target;
    if (currentItem.className.indexOf("el-tree-node") === -1)
      return;
    const code2 = ev.code;
    treeItems.value = Array.from(el$.value.querySelectorAll(".is-focusable[role=treeitem]"));
    const currentIndex = treeItems.value.indexOf(currentItem);
    let nextIndex;
    if ([aria.EVENT_CODE.up, aria.EVENT_CODE.down].indexOf(code2) > -1) {
      ev.preventDefault();
      if (code2 === aria.EVENT_CODE.up) {
        nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.value.length - 1;
        const startIndex = nextIndex;
        while (true) {
          if (store2.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
            break;
          nextIndex--;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex < 0) {
            nextIndex = treeItems.value.length - 1;
          }
        }
      } else {
        nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.value.length - 1 ? currentIndex + 1 : 0;
        const startIndex = nextIndex;
        while (true) {
          if (store2.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
            break;
          nextIndex++;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex >= treeItems.value.length) {
            nextIndex = 0;
          }
        }
      }
      nextIndex !== -1 && treeItems.value[nextIndex].focus();
    }
    if ([aria.EVENT_CODE.left, aria.EVENT_CODE.right].indexOf(code2) > -1) {
      ev.preventDefault();
      currentItem.click();
    }
    const hasInput = currentItem.querySelector('[type="checkbox"]');
    if ([aria.EVENT_CODE.enter, aria.EVENT_CODE.space].indexOf(code2) > -1 && hasInput) {
      ev.preventDefault();
      hasInput.click();
    }
  };
  const initTabIndex = () => {
    var _a;
    treeItems.value = Array.from(el$.value.querySelectorAll(".is-focusable[role=treeitem]"));
    checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
    const checkedItem = el$.value.querySelectorAll(".is-checked[role=treeitem]");
    if (checkedItem.length) {
      checkedItem[0].setAttribute("tabindex", "0");
      return;
    }
    (_a = treeItems.value[0]) == null ? void 0 : _a.setAttribute("tabindex", "0");
  };
}
useKeydown$1.useKeydown = useKeydown;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var treeStore$1 = treeStore;
  var util2 = util$1;
  var useNodeExpandEventBroadcast2 = useNodeExpandEventBroadcast$1;
  var useDragNode$1 = useDragNode;
  var useKeydown2 = useKeydown$1;
  var treeNode_vue_vue_type_script_lang2 = treeNode_vue_vue_type_script_lang$1;
  var index2 = useLocale$1;
  var script2 = vue2.defineComponent({
    name: "ElTree",
    components: { ElTreeNode: treeNode_vue_vue_type_script_lang2["default"] },
    props: {
      data: {
        type: Array,
        default: () => []
      },
      emptyText: {
        type: String
      },
      renderAfterExpand: {
        type: Boolean,
        default: true
      },
      nodeKey: String,
      checkStrictly: Boolean,
      defaultExpandAll: Boolean,
      expandOnClickNode: {
        type: Boolean,
        default: true
      },
      checkOnClickNode: Boolean,
      checkDescendants: {
        type: Boolean,
        default: false
      },
      autoExpandParent: {
        type: Boolean,
        default: true
      },
      defaultCheckedKeys: Array,
      defaultExpandedKeys: Array,
      currentNodeKey: [String, Number],
      renderContent: Function,
      showCheckbox: {
        type: Boolean,
        default: false
      },
      draggable: {
        type: Boolean,
        default: false
      },
      allowDrag: Function,
      allowDrop: Function,
      props: {
        type: Object,
        default: () => ({
          children: "children",
          label: "label",
          disabled: "disabled"
        })
      },
      lazy: {
        type: Boolean,
        default: false
      },
      highlightCurrent: Boolean,
      load: Function,
      filterNodeMethod: Function,
      accordion: Boolean,
      indent: {
        type: Number,
        default: 18
      },
      icon: [String, Object]
    },
    emits: [
      "check-change",
      "current-change",
      "node-click",
      "node-contextmenu",
      "node-collapse",
      "node-expand",
      "check",
      "node-drag-start",
      "node-drag-end",
      "node-drop",
      "node-drag-leave",
      "node-drag-enter",
      "node-drag-over"
    ],
    setup(props2, ctx) {
      const { t } = index2.useLocale();
      const store2 = vue2.ref(new treeStore$1["default"]({
        key: props2.nodeKey,
        data: props2.data,
        lazy: props2.lazy,
        props: props2.props,
        load: props2.load,
        currentNodeKey: props2.currentNodeKey,
        checkStrictly: props2.checkStrictly,
        checkDescendants: props2.checkDescendants,
        defaultCheckedKeys: props2.defaultCheckedKeys,
        defaultExpandedKeys: props2.defaultExpandedKeys,
        autoExpandParent: props2.autoExpandParent,
        defaultExpandAll: props2.defaultExpandAll,
        filterNodeMethod: props2.filterNodeMethod
      }));
      store2.value.initialize();
      const root2 = vue2.ref(store2.value.root);
      const currentNode = vue2.ref(null);
      const el$ = vue2.ref(null);
      const dropIndicator$ = vue2.ref(null);
      const { broadcastExpanded } = useNodeExpandEventBroadcast2.useNodeExpandEventBroadcast(props2);
      const { dragState } = useDragNode$1.useDragNodeHandler({
        props: props2,
        ctx,
        el$,
        dropIndicator$,
        store: store2
      });
      useKeydown2.useKeydown({ el$ }, store2);
      const isEmpty = vue2.computed(() => {
        const { childNodes } = root2.value;
        return !childNodes || childNodes.length === 0 || childNodes.every(({ visible }) => !visible);
      });
      vue2.watch(() => props2.defaultCheckedKeys, (newVal) => {
        store2.value.setDefaultCheckedKey(newVal);
      });
      vue2.watch(() => props2.defaultExpandedKeys, (newVal) => {
        store2.value.defaultExpandedKeys = newVal;
        store2.value.setDefaultExpandedKeys(newVal);
      });
      vue2.watch(() => props2.data, (newVal) => {
        store2.value.setData(newVal);
      }, { deep: true });
      vue2.watch(() => props2.checkStrictly, (newVal) => {
        store2.value.checkStrictly = newVal;
      });
      const filter2 = (value) => {
        if (!props2.filterNodeMethod)
          throw new Error("[Tree] filterNodeMethod is required when filter");
        store2.value.filter(value);
      };
      const getNodeKey2 = (node3) => {
        return util2.getNodeKey(props2.nodeKey, node3.data);
      };
      const getNodePath = (data2) => {
        if (!props2.nodeKey)
          throw new Error("[Tree] nodeKey is required in getNodePath");
        const node3 = store2.value.getNode(data2);
        if (!node3)
          return [];
        const path = [node3.data];
        let parent = node3.parent;
        while (parent && parent !== root2.value) {
          path.push(parent.data);
          parent = parent.parent;
        }
        return path.reverse();
      };
      const getCheckedNodes = (leafOnly, includeHalfChecked) => {
        return store2.value.getCheckedNodes(leafOnly, includeHalfChecked);
      };
      const getCheckedKeys = (leafOnly) => {
        return store2.value.getCheckedKeys(leafOnly);
      };
      const getCurrentNode = () => {
        const currentNode2 = store2.value.getCurrentNode();
        return currentNode2 ? currentNode2.data : null;
      };
      const getCurrentKey = () => {
        if (!props2.nodeKey)
          throw new Error("[Tree] nodeKey is required in getCurrentKey");
        const currentNode2 = getCurrentNode();
        return currentNode2 ? currentNode2[props2.nodeKey] : null;
      };
      const setCheckedNodes = (nodes, leafOnly) => {
        if (!props2.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCheckedNodes");
        store2.value.setCheckedNodes(nodes, leafOnly);
      };
      const setCheckedKeys = (keys2, leafOnly) => {
        if (!props2.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCheckedKeys");
        store2.value.setCheckedKeys(keys2, leafOnly);
      };
      const setChecked2 = (data2, checked2, deep) => {
        store2.value.setChecked(data2, checked2, deep);
      };
      const getHalfCheckedNodes = () => {
        return store2.value.getHalfCheckedNodes();
      };
      const getHalfCheckedKeys = () => {
        return store2.value.getHalfCheckedKeys();
      };
      const setCurrentNode = (node3, shouldAutoExpandParent = true) => {
        if (!props2.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCurrentNode");
        store2.value.setUserCurrentNode(node3, shouldAutoExpandParent);
      };
      const setCurrentKey = (key2, shouldAutoExpandParent = true) => {
        if (!props2.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCurrentKey");
        store2.value.setCurrentNodeKey(key2, shouldAutoExpandParent);
      };
      const getNode = (data2) => {
        return store2.value.getNode(data2);
      };
      const remove2 = (data2) => {
        store2.value.remove(data2);
      };
      const append = (data2, parentNode) => {
        store2.value.append(data2, parentNode);
      };
      const insertBefore = (data2, refNode) => {
        store2.value.insertBefore(data2, refNode);
      };
      const insertAfter = (data2, refNode) => {
        store2.value.insertAfter(data2, refNode);
      };
      const handleNodeExpand = (nodeData, node3, instance) => {
        broadcastExpanded(node3);
        ctx.emit("node-expand", nodeData, node3, instance);
      };
      const updateKeyChildren = (key2, data2) => {
        if (!props2.nodeKey)
          throw new Error("[Tree] nodeKey is required in updateKeyChild");
        store2.value.updateChildren(key2, data2);
      };
      vue2.provide("RootTree", {
        ctx,
        props: props2,
        store: store2,
        root: root2,
        currentNode,
        instance: vue2.getCurrentInstance()
      });
      return {
        store: store2,
        root: root2,
        currentNode,
        dragState,
        el$,
        dropIndicator$,
        isEmpty,
        filter: filter2,
        getNodeKey: getNodeKey2,
        getNodePath,
        getCheckedNodes,
        getCheckedKeys,
        getCurrentNode,
        getCurrentKey,
        setCheckedNodes,
        setCheckedKeys,
        setChecked: setChecked2,
        getHalfCheckedNodes,
        getHalfCheckedKeys,
        setCurrentNode,
        setCurrentKey,
        t,
        getNode,
        remove: remove2,
        append,
        insertBefore,
        insertAfter,
        handleNodeExpand,
        updateKeyChildren
      };
    }
  });
  exports["default"] = script2;
})(tree_vue_vue_type_script_lang$1);
var tree_vue_vue_type_template_id_7539bec5_lang = {};
Object.defineProperty(tree_vue_vue_type_template_id_7539bec5_lang, "__esModule", { value: true });
var vue$e = require$$0$1;
const _hoisted_1$7 = {
  key: 0,
  class: "el-tree__empty-block"
};
const _hoisted_2$5 = { class: "el-tree__empty-text" };
const _hoisted_3$4 = {
  ref: "dropIndicator$",
  class: "el-tree__drop-indicator"
};
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_el_tree_node = vue$e.resolveComponent("el-tree-node");
  return vue$e.openBlock(), vue$e.createElementBlock("div", {
    ref: "el$",
    class: vue$e.normalizeClass(["el-tree", {
      "el-tree--highlight-current": _ctx.highlightCurrent,
      "is-dragging": !!_ctx.dragState.draggingNode,
      "is-drop-not-allow": !_ctx.dragState.allowDrop,
      "is-drop-inner": _ctx.dragState.dropType === "inner"
    }]),
    role: "tree"
  }, [
    (vue$e.openBlock(true), vue$e.createElementBlock(vue$e.Fragment, null, vue$e.renderList(_ctx.root.childNodes, (child) => {
      return vue$e.openBlock(), vue$e.createBlock(_component_el_tree_node, {
        key: _ctx.getNodeKey(child),
        node: child,
        props: _ctx.props,
        accordion: _ctx.accordion,
        "render-after-expand": _ctx.renderAfterExpand,
        "show-checkbox": _ctx.showCheckbox,
        "render-content": _ctx.renderContent,
        onNodeExpand: _ctx.handleNodeExpand
      }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]);
    }), 128)),
    _ctx.isEmpty ? (vue$e.openBlock(), vue$e.createElementBlock("div", _hoisted_1$7, [
      vue$e.createElementVNode("span", _hoisted_2$5, vue$e.toDisplayString((_a = _ctx.emptyText) != null ? _a : _ctx.t("el.tree.emptyText")), 1)
    ])) : vue$e.createCommentVNode("v-if", true),
    vue$e.withDirectives(vue$e.createElementVNode("div", _hoisted_3$4, null, 512), [
      [vue$e.vShow, _ctx.dragState.showDropIndicator]
    ])
  ], 2);
}
tree_vue_vue_type_template_id_7539bec5_lang.render = render$8;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tree_vue_vue_type_script_lang2 = tree_vue_vue_type_script_lang$1;
  var tree_vue_vue_type_template_id_7539bec5_lang$1 = tree_vue_vue_type_template_id_7539bec5_lang;
  tree_vue_vue_type_script_lang2["default"].render = tree_vue_vue_type_template_id_7539bec5_lang$1.render;
  tree_vue_vue_type_script_lang2["default"].__file = "packages/components/tree/src/tree.vue";
  exports["default"] = tree_vue_vue_type_script_lang2["default"];
})(tree$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tree_vue_vue_type_script_lang2 = tree_vue_vue_type_script_lang$1;
  tree_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(tree_vue_vue_type_script_lang2["default"].name, tree_vue_vue_type_script_lang2["default"]);
  };
  const _Tree = tree_vue_vue_type_script_lang2["default"];
  const ElTree = _Tree;
  exports.ElTree = ElTree;
  exports["default"] = _Tree;
})(tree$2);
var treeV2 = {};
var tree = {};
var tree_vue_vue_type_script_lang = {};
var useTree$1 = {};
var virtualTree$2 = {};
Object.defineProperty(virtualTree$2, "__esModule", { value: true });
var props$4 = props$N;
const ROOT_TREE_INJECTION_KEY = Symbol();
const EMPTY_NODE = {
  key: -1,
  level: -1,
  data: {}
};
var TreeOptionsEnum = /* @__PURE__ */ ((TreeOptionsEnum2) => {
  TreeOptionsEnum2["KEY"] = "id";
  TreeOptionsEnum2["LABEL"] = "label";
  TreeOptionsEnum2["CHILDREN"] = "children";
  TreeOptionsEnum2["DISABLED"] = "disabled";
  return TreeOptionsEnum2;
})(TreeOptionsEnum || {});
var SetOperationEnum = /* @__PURE__ */ ((SetOperationEnum2) => {
  SetOperationEnum2["ADD"] = "add";
  SetOperationEnum2["DELETE"] = "delete";
  return SetOperationEnum2;
})(SetOperationEnum || {});
const treeProps = props$4.buildProps({
  data: {
    type: props$4.definePropType(Array),
    default: () => props$4.mutable([])
  },
  emptyText: {
    type: String
  },
  height: {
    type: Number,
    default: 200
  },
  props: {
    type: props$4.definePropType(Object),
    default: () => props$4.mutable({
      children: "children",
      label: "label",
      disabled: "disabled",
      value: "id"
    })
  },
  highlightCurrent: {
    type: Boolean,
    default: false
  },
  showCheckbox: {
    type: Boolean,
    default: false
  },
  defaultCheckedKeys: {
    type: props$4.definePropType(Array),
    default: () => props$4.mutable([])
  },
  checkStrictly: {
    type: Boolean,
    default: false
  },
  defaultExpandedKeys: {
    type: props$4.definePropType(Array),
    default: () => props$4.mutable([])
  },
  indent: {
    type: Number,
    default: 16
  },
  icon: {
    type: String
  },
  expandOnClickNode: {
    type: Boolean,
    default: true
  },
  checkOnClickNode: {
    type: Boolean,
    default: false
  },
  currentNodeKey: {
    type: props$4.definePropType([String, Number])
  },
  accordion: {
    type: Boolean,
    default: false
  },
  filterMethod: {
    type: props$4.definePropType(Function)
  },
  perfMode: {
    type: Boolean,
    default: true
  }
});
const treeNodeProps = props$4.buildProps({
  node: {
    type: props$4.definePropType(Object),
    default: () => props$4.mutable(EMPTY_NODE)
  },
  expanded: {
    type: Boolean,
    default: false
  },
  checked: {
    type: Boolean,
    default: false
  },
  indeterminate: {
    type: Boolean,
    default: false
  },
  showCheckbox: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  current: {
    type: Boolean,
    default: false
  },
  hiddenExpandIcon: {
    type: Boolean,
    default: false
  }
});
const treeNodeContentProps = props$4.buildProps({
  node: {
    type: props$4.definePropType(Object),
    required: true
  }
});
const NODE_CLICK = "node-click";
const NODE_EXPAND = "node-expand";
const NODE_COLLAPSE = "node-collapse";
const CURRENT_CHANGE = "current-change";
const NODE_CHECK = "check";
const NODE_CHECK_CHANGE = "check-change";
const NODE_CONTEXTMENU = "node-contextmenu";
const treeEmits = {
  [NODE_CLICK]: (data2, node3) => data2 && node3,
  [NODE_EXPAND]: (data2, node3) => data2 && node3,
  [NODE_COLLAPSE]: (data2, node3) => data2 && node3,
  [CURRENT_CHANGE]: (data2, node3) => data2 && node3,
  [NODE_CHECK]: (data2, checkedInfo) => data2 && checkedInfo,
  [NODE_CHECK_CHANGE]: (data2, checked2) => data2 && typeof checked2 === "boolean",
  [NODE_CONTEXTMENU]: (event, data2, node3) => event && data2 && node3
};
const treeNodeEmits = {
  click: (node3) => !!node3,
  toggle: (node3) => !!node3,
  check: (node3, checked2) => node3 && typeof checked2 === "boolean"
};
virtualTree$2.CURRENT_CHANGE = CURRENT_CHANGE;
virtualTree$2.NODE_CHECK = NODE_CHECK;
virtualTree$2.NODE_CHECK_CHANGE = NODE_CHECK_CHANGE;
virtualTree$2.NODE_CLICK = NODE_CLICK;
virtualTree$2.NODE_COLLAPSE = NODE_COLLAPSE;
virtualTree$2.NODE_CONTEXTMENU = NODE_CONTEXTMENU;
virtualTree$2.NODE_EXPAND = NODE_EXPAND;
virtualTree$2.ROOT_TREE_INJECTION_KEY = ROOT_TREE_INJECTION_KEY;
virtualTree$2.SetOperationEnum = SetOperationEnum;
virtualTree$2.TreeOptionsEnum = TreeOptionsEnum;
virtualTree$2.treeEmits = treeEmits;
virtualTree$2.treeNodeContentProps = treeNodeContentProps;
virtualTree$2.treeNodeEmits = treeNodeEmits;
virtualTree$2.treeNodeProps = treeNodeProps;
virtualTree$2.treeProps = treeProps;
var useCheck$2 = {};
Object.defineProperty(useCheck$2, "__esModule", { value: true });
var vue$d = require$$0$1;
var virtualTree$1 = virtualTree$2;
function useCheck$1(props2, tree2) {
  const checkedKeys = vue$d.ref(/* @__PURE__ */ new Set());
  const indeterminateKeys = vue$d.ref(/* @__PURE__ */ new Set());
  const { emit } = vue$d.getCurrentInstance();
  vue$d.watch(() => tree2.value, () => {
    return vue$d.nextTick(() => {
      _setCheckedKeys(props2.defaultCheckedKeys);
    });
  }, {
    immediate: true
  });
  const updateCheckedKeys = () => {
    if (!tree2.value || !props2.showCheckbox || props2.checkStrictly) {
      return;
    }
    const { levelTreeNodeMap, maxLevel } = tree2.value;
    const checkedKeySet = checkedKeys.value;
    const indeterminateKeySet = /* @__PURE__ */ new Set();
    for (let level = maxLevel - 1; level >= 1; --level) {
      const nodes = levelTreeNodeMap.get(level);
      if (!nodes)
        continue;
      nodes.forEach((node3) => {
        const children = node3.children;
        if (children) {
          let allChecked = true;
          let hasChecked = false;
          for (let i = 0; i < children.length; ++i) {
            const childNode = children[i];
            const key2 = childNode.key;
            if (checkedKeySet.has(key2)) {
              hasChecked = true;
            } else if (indeterminateKeySet.has(key2)) {
              allChecked = false;
              hasChecked = true;
              break;
            } else {
              allChecked = false;
            }
          }
          if (allChecked) {
            checkedKeySet.add(node3.key);
          } else if (hasChecked) {
            indeterminateKeySet.add(node3.key);
            checkedKeySet.delete(node3.key);
          } else {
            checkedKeySet.delete(node3.key);
            indeterminateKeySet.delete(node3.key);
          }
        }
      });
    }
    indeterminateKeys.value = indeterminateKeySet;
  };
  const isChecked = (node3) => checkedKeys.value.has(node3.key);
  const isIndeterminate = (node3) => indeterminateKeys.value.has(node3.key);
  const toggleCheckbox = (node3, isChecked2, nodeClick = true) => {
    const checkedKeySet = checkedKeys.value;
    const toggle = (node22, checked2) => {
      checkedKeySet[checked2 ? virtualTree$1.SetOperationEnum.ADD : virtualTree$1.SetOperationEnum.DELETE](node22.key);
      const children = node22.children;
      if (!props2.checkStrictly && children) {
        children.forEach((childNode) => {
          if (!childNode.disabled) {
            toggle(childNode, checked2);
          }
        });
      }
    };
    toggle(node3, isChecked2);
    updateCheckedKeys();
    if (nodeClick) {
      afterNodeCheck(node3, isChecked2);
    }
  };
  const afterNodeCheck = (node3, checked2) => {
    const { checkedNodes, checkedKeys: checkedKeys2 } = getChecked();
    const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked();
    emit(virtualTree$1.NODE_CHECK, node3.data, {
      checkedKeys: checkedKeys2,
      checkedNodes,
      halfCheckedKeys,
      halfCheckedNodes
    });
    emit(virtualTree$1.NODE_CHECK_CHANGE, node3.data, checked2);
  };
  function getCheckedKeys(leafOnly = false) {
    return getChecked(leafOnly).checkedKeys;
  }
  function getCheckedNodes(leafOnly = false) {
    return getChecked(leafOnly).checkedNodes;
  }
  function getHalfCheckedKeys() {
    return getHalfChecked().halfCheckedKeys;
  }
  function getHalfCheckedNodes() {
    return getHalfChecked().halfCheckedNodes;
  }
  function getChecked(leafOnly = false) {
    const checkedNodes = [];
    const keys2 = [];
    if ((tree2 == null ? void 0 : tree2.value) && props2.showCheckbox) {
      const { treeNodeMap } = tree2.value;
      checkedKeys.value.forEach((key2) => {
        const node3 = treeNodeMap.get(key2);
        if (node3 && (!leafOnly || leafOnly && node3.isLeaf)) {
          keys2.push(key2);
          checkedNodes.push(node3.data);
        }
      });
    }
    return {
      checkedKeys: keys2,
      checkedNodes
    };
  }
  function getHalfChecked() {
    const halfCheckedNodes = [];
    const halfCheckedKeys = [];
    if ((tree2 == null ? void 0 : tree2.value) && props2.showCheckbox) {
      const { treeNodeMap } = tree2.value;
      indeterminateKeys.value.forEach((key2) => {
        const node3 = treeNodeMap.get(key2);
        if (node3) {
          halfCheckedKeys.push(key2);
          halfCheckedNodes.push(node3.data);
        }
      });
    }
    return {
      halfCheckedNodes,
      halfCheckedKeys
    };
  }
  function setCheckedKeys(keys2) {
    checkedKeys.value.clear();
    _setCheckedKeys(keys2);
  }
  function setChecked2(key2, isChecked2) {
    if ((tree2 == null ? void 0 : tree2.value) && props2.showCheckbox) {
      const node3 = tree2.value.treeNodeMap.get(key2);
      if (node3) {
        toggleCheckbox(node3, isChecked2, false);
      }
    }
  }
  function _setCheckedKeys(keys2) {
    if (tree2 == null ? void 0 : tree2.value) {
      const { treeNodeMap } = tree2.value;
      if (props2.showCheckbox && treeNodeMap && keys2) {
        for (let i = 0; i < keys2.length; ++i) {
          const key2 = keys2[i];
          const node3 = treeNodeMap.get(key2);
          if (node3 && !isChecked(node3)) {
            toggleCheckbox(node3, true, false);
          }
        }
      }
    }
  }
  return {
    updateCheckedKeys,
    toggleCheckbox,
    isChecked,
    isIndeterminate,
    getCheckedKeys,
    getCheckedNodes,
    getHalfCheckedKeys,
    getHalfCheckedNodes,
    setChecked: setChecked2,
    setCheckedKeys
  };
}
useCheck$2.useCheck = useCheck$1;
var useFilter$2 = {};
Object.defineProperty(useFilter$2, "__esModule", { value: true });
var vue$c = require$$0$1;
var shared$2 = require$$1$1;
function useFilter$1(props2, tree2) {
  const hiddenNodeKeySet = vue$c.ref(/* @__PURE__ */ new Set([]));
  const hiddenExpandIconKeySet = vue$c.ref(/* @__PURE__ */ new Set([]));
  const filterable = vue$c.computed(() => {
    return shared$2.isFunction(props2.filterMethod);
  });
  function doFilter(query) {
    var _a;
    if (!filterable.value) {
      return;
    }
    const expandKeySet = /* @__PURE__ */ new Set();
    const hiddenExpandIconKeys = hiddenExpandIconKeySet.value;
    const hiddenKeys = hiddenNodeKeySet.value;
    const family = [];
    const nodes = ((_a = tree2.value) == null ? void 0 : _a.treeNodes) || [];
    const filter2 = props2.filterMethod;
    hiddenKeys.clear();
    function traverse2(nodes2) {
      nodes2.forEach((node3) => {
        family.push(node3);
        if (filter2 == null ? void 0 : filter2(query, node3.data)) {
          family.forEach((member) => {
            expandKeySet.add(member.key);
          });
        } else if (node3.isLeaf) {
          hiddenKeys.add(node3.key);
        }
        const children = node3.children;
        if (children) {
          traverse2(children);
        }
        if (!node3.isLeaf) {
          if (!expandKeySet.has(node3.key)) {
            hiddenKeys.add(node3.key);
          } else if (children) {
            let allHidden = true;
            for (let i = 0; i < children.length; ++i) {
              const childNode = children[i];
              if (!hiddenKeys.has(childNode.key)) {
                allHidden = false;
                break;
              }
            }
            if (allHidden) {
              hiddenExpandIconKeys.add(node3.key);
            } else {
              hiddenExpandIconKeys.delete(node3.key);
            }
          }
        }
        family.pop();
      });
    }
    traverse2(nodes);
    return expandKeySet;
  }
  function isForceHiddenExpandIcon(node3) {
    return hiddenExpandIconKeySet.value.has(node3.key);
  }
  return {
    hiddenExpandIconKeySet,
    hiddenNodeKeySet,
    doFilter,
    isForceHiddenExpandIcon
  };
}
useFilter$2.useFilter = useFilter$1;
Object.defineProperty(useTree$1, "__esModule", { value: true });
var vue$b = require$$0$1;
var virtualTree = virtualTree$2;
var useCheck = useCheck$2;
var useFilter = useFilter$2;
function useTree(props2, emit) {
  const expandedKeySet = vue$b.ref(new Set(props2.defaultExpandedKeys));
  const currentKey = vue$b.ref();
  const tree2 = vue$b.shallowRef();
  vue$b.watch(() => props2.currentNodeKey, (key2) => {
    currentKey.value = key2;
  }, {
    immediate: true
  });
  vue$b.watch(() => props2.data, (data2) => {
    setData(data2);
  }, {
    immediate: true
  });
  const {
    isIndeterminate,
    isChecked,
    toggleCheckbox,
    getCheckedKeys,
    getCheckedNodes,
    getHalfCheckedKeys,
    getHalfCheckedNodes,
    setChecked: setChecked2,
    setCheckedKeys
  } = useCheck.useCheck(props2, tree2);
  const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter.useFilter(props2, tree2);
  const valueKey = vue$b.computed(() => {
    var _a;
    return ((_a = props2.props) == null ? void 0 : _a.value) || virtualTree.TreeOptionsEnum.KEY;
  });
  const childrenKey = vue$b.computed(() => {
    var _a;
    return ((_a = props2.props) == null ? void 0 : _a.children) || virtualTree.TreeOptionsEnum.CHILDREN;
  });
  const disabledKey = vue$b.computed(() => {
    var _a;
    return ((_a = props2.props) == null ? void 0 : _a.disabled) || virtualTree.TreeOptionsEnum.DISABLED;
  });
  const labelKey = vue$b.computed(() => {
    var _a;
    return ((_a = props2.props) == null ? void 0 : _a.label) || virtualTree.TreeOptionsEnum.LABEL;
  });
  const flattenTree = vue$b.computed(() => {
    const expandedKeys = expandedKeySet.value;
    const hiddenKeys = hiddenNodeKeySet.value;
    const flattenNodes = [];
    const nodes = tree2.value && tree2.value.treeNodes || [];
    function traverse2() {
      const stack2 = [];
      for (let i = nodes.length - 1; i >= 0; --i) {
        stack2.push(nodes[i]);
      }
      while (stack2.length) {
        const node3 = stack2.pop();
        if (!node3)
          continue;
        if (!hiddenKeys.has(node3.key)) {
          flattenNodes.push(node3);
        }
        if (expandedKeys.has(node3.key)) {
          const children = node3.children;
          if (children) {
            const length = children.length;
            for (let i = length - 1; i >= 0; --i) {
              stack2.push(children[i]);
            }
          }
        }
      }
    }
    traverse2();
    return flattenNodes;
  });
  const isNotEmpty = vue$b.computed(() => {
    return flattenTree.value.length > 0;
  });
  function createTree(data2) {
    const treeNodeMap = /* @__PURE__ */ new Map();
    const levelTreeNodeMap = /* @__PURE__ */ new Map();
    let maxLevel = 1;
    function traverse2(nodes, level = 1, parent = void 0) {
      var _a;
      const siblings = [];
      for (let index2 = 0; index2 < nodes.length; ++index2) {
        const rawNode = nodes[index2];
        const value = getKey(rawNode);
        const node3 = {
          level,
          key: value,
          data: rawNode
        };
        node3.label = getLabel(rawNode);
        node3.parent = parent;
        const children = getChildren2(rawNode);
        node3.disabled = getDisabled(rawNode);
        node3.isLeaf = !children || children.length === 0;
        if (children && children.length) {
          node3.children = traverse2(children, level + 1, node3);
        }
        siblings.push(node3);
        treeNodeMap.set(value, node3);
        if (!levelTreeNodeMap.has(level)) {
          levelTreeNodeMap.set(level, []);
        }
        (_a = levelTreeNodeMap.get(level)) == null ? void 0 : _a.push(node3);
      }
      if (level > maxLevel) {
        maxLevel = level;
      }
      return siblings;
    }
    const treeNodes = traverse2(data2);
    return {
      treeNodeMap,
      levelTreeNodeMap,
      maxLevel,
      treeNodes
    };
  }
  function filter2(query) {
    const keys2 = doFilter(query);
    if (keys2) {
      expandedKeySet.value = keys2;
    }
  }
  function getChildren2(node3) {
    return node3[childrenKey.value];
  }
  function getKey(node3) {
    if (!node3) {
      return "";
    }
    return node3[valueKey.value];
  }
  function getDisabled(node3) {
    return node3[disabledKey.value];
  }
  function getLabel(node3) {
    return node3[labelKey.value];
  }
  function toggleExpand(node3) {
    const expandedKeys = expandedKeySet.value;
    if (expandedKeys.has(node3.key)) {
      collapse2(node3);
    } else {
      expand2(node3);
    }
  }
  function handleNodeClick(node3) {
    emit(virtualTree.NODE_CLICK, node3.data, node3);
    handleCurrentChange(node3);
    if (props2.expandOnClickNode) {
      toggleExpand(node3);
    }
    if (props2.showCheckbox && props2.checkOnClickNode && !node3.disabled) {
      toggleCheckbox(node3, !isChecked(node3), true);
    }
  }
  function handleCurrentChange(node3) {
    if (!isCurrent(node3)) {
      currentKey.value = node3.key;
      emit(virtualTree.CURRENT_CHANGE, node3.data, node3);
    }
  }
  function handleNodeCheck(node3, checked2) {
    toggleCheckbox(node3, checked2);
  }
  function expand2(node3) {
    const keySet = expandedKeySet.value;
    if ((tree2 == null ? void 0 : tree2.value) && props2.accordion) {
      const { treeNodeMap } = tree2.value;
      keySet.forEach((key2) => {
        const node22 = treeNodeMap.get(key2);
        if (node22 && node22.level === node22.level) {
          keySet.delete(key2);
        }
      });
    }
    keySet.add(node3.key);
    emit(virtualTree.NODE_EXPAND, node3.data, node3);
  }
  function collapse2(node3) {
    expandedKeySet.value.delete(node3.key);
    emit(virtualTree.NODE_COLLAPSE, node3.data, node3);
  }
  function isExpanded(node3) {
    return expandedKeySet.value.has(node3.key);
  }
  function isDisabled(node3) {
    return !!node3.disabled;
  }
  function isCurrent(node3) {
    const current2 = currentKey.value;
    return !!current2 && current2 === node3.key;
  }
  function getCurrentNode() {
    var _a, _b;
    if (!currentKey.value)
      return void 0;
    return (_b = (_a = tree2 == null ? void 0 : tree2.value) == null ? void 0 : _a.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;
  }
  function getCurrentKey() {
    return currentKey.value;
  }
  function setCurrentKey(key2) {
    currentKey.value = key2;
  }
  function setData(data2) {
    vue$b.nextTick(() => tree2.value = createTree(data2));
  }
  return {
    tree: tree2,
    flattenTree,
    isNotEmpty,
    getKey,
    getChildren: getChildren2,
    toggleExpand,
    toggleCheckbox,
    isExpanded,
    isChecked,
    isIndeterminate,
    isDisabled,
    isCurrent,
    isForceHiddenExpandIcon,
    handleNodeClick,
    handleNodeCheck,
    getCurrentNode,
    getCurrentKey,
    setCurrentKey,
    getCheckedKeys,
    getCheckedNodes,
    getHalfCheckedKeys,
    getHalfCheckedNodes,
    setChecked: setChecked2,
    setCheckedKeys,
    filter: filter2,
    setData
  };
}
useTree$1.useTree = useTree;
var treeNode = {};
var treeNode_vue_vue_type_script_lang = {};
var treeNodeContent = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var virtualTree2 = virtualTree$2;
  var ElNodeContent = vue2.defineComponent({
    name: "ElTreeNodeContent",
    props: virtualTree2.treeNodeContentProps,
    setup(props2) {
      const tree2 = vue2.inject(virtualTree2.ROOT_TREE_INJECTION_KEY);
      return () => {
        const node3 = props2.node;
        const { data: data2 } = node3;
        return (tree2 == null ? void 0 : tree2.ctx.slots.default) ? tree2.ctx.slots.default({ node: node3, data: data2 }) : vue2.h("span", { class: "el-tree-node__label" }, [node3 == null ? void 0 : node3.label]);
      };
    }
  });
  exports["default"] = ElNodeContent;
})(treeNodeContent);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var iconsVue2 = require$$3;
  var index2 = icon$4;
  var index$110 = checkbox$1;
  var treeNodeContent$12 = treeNodeContent;
  var virtualTree2 = virtualTree$2;
  const DEFAULT_ICON = "caret-right";
  var script2 = vue2.defineComponent({
    name: "ElTreeNode",
    components: {
      ElIcon: index2.ElIcon,
      CaretRight: iconsVue2.CaretRight,
      ElCheckbox: index$110.ElCheckbox,
      ElNodeContent: treeNodeContent$12["default"]
    },
    props: virtualTree2.treeNodeProps,
    emits: virtualTree2.treeNodeEmits,
    setup(props2, { emit }) {
      const tree2 = vue2.inject(virtualTree2.ROOT_TREE_INJECTION_KEY);
      const indent = vue2.computed(() => {
        var _a;
        return (_a = tree2 == null ? void 0 : tree2.props.indent) != null ? _a : 16;
      });
      const icon3 = vue2.computed(() => {
        var _a;
        return (_a = tree2 == null ? void 0 : tree2.props.icon) != null ? _a : DEFAULT_ICON;
      });
      const handleClick = () => {
        emit("click", props2.node);
      };
      const handleExpandIconClick = () => {
        emit("toggle", props2.node);
      };
      const handleCheckChange = (value) => {
        emit("check", props2.node, value);
      };
      const handleContextMenu = (event) => {
        var _a, _b, _c, _d;
        if ((_c = (_b = (_a = tree2 == null ? void 0 : tree2.instance) == null ? void 0 : _a.vnode) == null ? void 0 : _b.props) == null ? void 0 : _c["onNodeContextmenu"]) {
          event.stopPropagation();
          event.preventDefault();
        }
        tree2 == null ? void 0 : tree2.ctx.emit(virtualTree2.NODE_CONTEXTMENU, event, (_d = props2.node) == null ? void 0 : _d.data, props2.node);
      };
      return {
        indent,
        icon: icon3,
        handleClick,
        handleExpandIconClick,
        handleCheckChange,
        handleContextMenu
      };
    }
  });
  exports["default"] = script2;
})(treeNode_vue_vue_type_script_lang);
var treeNode_vue_vue_type_template_id_71d8f826_lang = {};
Object.defineProperty(treeNode_vue_vue_type_template_id_71d8f826_lang, "__esModule", { value: true });
var vue$a = require$$0$1;
const _hoisted_1$6 = ["aria-expanded", "aria-disabled", "aria-checked", "data-key"];
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  const _component_el_icon = vue$a.resolveComponent("el-icon");
  const _component_el_checkbox = vue$a.resolveComponent("el-checkbox");
  const _component_el_node_content = vue$a.resolveComponent("el-node-content");
  return vue$a.openBlock(), vue$a.createElementBlock("div", {
    ref: "node$",
    class: vue$a.normalizeClass(["el-tree-node", {
      "is-expanded": _ctx.expanded,
      "is-current": _ctx.current,
      "is-focusable": !_ctx.disabled,
      "is-checked": !_ctx.disabled && _ctx.checked
    }]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": _ctx.expanded,
    "aria-disabled": _ctx.disabled,
    "aria-checked": _ctx.checked,
    "data-key": (_a = _ctx.node) == null ? void 0 : _a.key,
    onClick: _cache[1] || (_cache[1] = vue$a.withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
    onContextmenu: _cache[2] || (_cache[2] = (...args) => _ctx.handleContextMenu && _ctx.handleContextMenu(...args))
  }, [
    vue$a.createElementVNode("div", {
      class: "el-tree-node__content",
      style: vue$a.normalizeStyle({ paddingLeft: `${(_ctx.node.level - 1) * _ctx.indent}px` })
    }, [
      _ctx.icon ? (vue$a.openBlock(), vue$a.createBlock(_component_el_icon, {
        key: 0,
        class: vue$a.normalizeClass([
          {
            "is-leaf": (_b = _ctx.node) == null ? void 0 : _b.isLeaf,
            "is-hidden": _ctx.hiddenExpandIcon,
            expanded: !((_c = _ctx.node) == null ? void 0 : _c.isLeaf) && _ctx.expanded
          },
          "el-tree-node__expand-icon"
        ]),
        onClick: vue$a.withModifiers(_ctx.handleExpandIconClick, ["stop"])
      }, {
        default: vue$a.withCtx(() => [
          (vue$a.openBlock(), vue$a.createBlock(vue$a.resolveDynamicComponent(_ctx.icon)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : vue$a.createCommentVNode("v-if", true),
      _ctx.showCheckbox ? (vue$a.openBlock(), vue$a.createBlock(_component_el_checkbox, {
        key: 1,
        "model-value": _ctx.checked,
        indeterminate: _ctx.indeterminate,
        disabled: _ctx.disabled,
        onChange: _ctx.handleCheckChange,
        onClick: _cache[0] || (_cache[0] = vue$a.withModifiers(() => {
        }, ["stop"]))
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : vue$a.createCommentVNode("v-if", true),
      vue$a.createVNode(_component_el_node_content, { node: _ctx.node }, null, 8, ["node"])
    ], 4)
  ], 42, _hoisted_1$6);
}
treeNode_vue_vue_type_template_id_71d8f826_lang.render = render$7;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var treeNode_vue_vue_type_script_lang$12 = treeNode_vue_vue_type_script_lang;
  var treeNode_vue_vue_type_template_id_71d8f826_lang$1 = treeNode_vue_vue_type_template_id_71d8f826_lang;
  treeNode_vue_vue_type_script_lang$12["default"].render = treeNode_vue_vue_type_template_id_71d8f826_lang$1.render;
  treeNode_vue_vue_type_script_lang$12["default"].__file = "packages/components/tree-v2/src/tree-node.vue";
  exports["default"] = treeNode_vue_vue_type_script_lang$12["default"];
})(treeNode);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var useTree2 = useTree$1;
  var virtualTree2 = virtualTree$2;
  var treeNode_vue_vue_type_script_lang$12 = treeNode_vue_vue_type_script_lang;
  var fixedSizeList2 = fixedSizeList$2;
  var index2 = useLocale$1;
  var script2 = vue2.defineComponent({
    name: "ElTreeV2",
    components: {
      ElTreeNode: treeNode_vue_vue_type_script_lang$12["default"],
      FixedSizeList: fixedSizeList2["default"]
    },
    props: virtualTree2.treeProps,
    emits: virtualTree2.treeEmits,
    setup(props2, ctx) {
      vue2.provide(virtualTree2.ROOT_TREE_INJECTION_KEY, {
        ctx,
        props: props2,
        instance: vue2.getCurrentInstance()
      });
      const { t } = index2.useLocale();
      const {
        flattenTree,
        isNotEmpty,
        toggleExpand,
        isExpanded,
        isIndeterminate,
        isChecked,
        isDisabled,
        isCurrent,
        isForceHiddenExpandIcon,
        toggleCheckbox,
        handleNodeClick,
        handleNodeCheck,
        getCurrentNode,
        getCurrentKey,
        setCurrentKey,
        getCheckedKeys,
        getCheckedNodes,
        getHalfCheckedKeys,
        getHalfCheckedNodes,
        setChecked: setChecked2,
        setCheckedKeys,
        filter: filter2,
        setData
      } = useTree2.useTree(props2, ctx.emit);
      ctx.expose({
        getCurrentNode,
        getCurrentKey,
        setCurrentKey,
        getCheckedKeys,
        getCheckedNodes,
        getHalfCheckedKeys,
        getHalfCheckedNodes,
        setChecked: setChecked2,
        setCheckedKeys,
        filter: filter2,
        setData
      });
      return {
        t,
        flattenTree,
        itemSize: 26,
        isNotEmpty,
        toggleExpand,
        toggleCheckbox,
        isExpanded,
        isIndeterminate,
        isChecked,
        isDisabled,
        isCurrent,
        isForceHiddenExpandIcon,
        handleNodeClick,
        handleNodeCheck
      };
    }
  });
  exports["default"] = script2;
})(tree_vue_vue_type_script_lang);
var tree_vue_vue_type_template_id_5b45a1b2_lang = {};
Object.defineProperty(tree_vue_vue_type_template_id_5b45a1b2_lang, "__esModule", { value: true });
var vue$9 = require$$0$1;
const _hoisted_1$5 = {
  key: 1,
  class: "el-tree__empty-block"
};
const _hoisted_2$4 = { class: "el-tree__empty-text" };
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_el_tree_node = vue$9.resolveComponent("el-tree-node");
  const _component_fixed_size_list = vue$9.resolveComponent("fixed-size-list");
  return vue$9.openBlock(), vue$9.createElementBlock("div", {
    class: vue$9.normalizeClass(["el-tree", {
      "el-tree--highlight-current": _ctx.highlightCurrent
    }]),
    role: "tree"
  }, [
    _ctx.isNotEmpty ? (vue$9.openBlock(), vue$9.createBlock(_component_fixed_size_list, {
      key: 0,
      "class-name": "el-tree-virtual-list",
      data: _ctx.flattenTree,
      total: _ctx.flattenTree.length,
      height: _ctx.height,
      "item-size": _ctx.itemSize,
      "perf-mode": _ctx.perfMode
    }, {
      default: vue$9.withCtx(({ data: data2, index: index2, style }) => [
        vue$9.createVNode(_component_el_tree_node, {
          key: data2[index2].key,
          style: vue$9.normalizeStyle(style),
          node: data2[index2],
          expanded: _ctx.isExpanded(data2[index2]),
          "show-checkbox": _ctx.showCheckbox,
          checked: _ctx.isChecked(data2[index2]),
          indeterminate: _ctx.isIndeterminate(data2[index2]),
          disabled: _ctx.isDisabled(data2[index2]),
          current: _ctx.isCurrent(data2[index2]),
          "hidden-expand-icon": _ctx.isForceHiddenExpandIcon(data2[index2]),
          onClick: _ctx.handleNodeClick,
          onToggle: _ctx.toggleExpand,
          onCheck: _ctx.handleNodeCheck
        }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"])
      ]),
      _: 1
    }, 8, ["data", "total", "height", "item-size", "perf-mode"])) : (vue$9.openBlock(), vue$9.createElementBlock("div", _hoisted_1$5, [
      vue$9.createElementVNode("span", _hoisted_2$4, vue$9.toDisplayString((_a = _ctx.emptyText) != null ? _a : _ctx.t("el.tree.emptyText")), 1)
    ]))
  ], 2);
}
tree_vue_vue_type_template_id_5b45a1b2_lang.render = render$6;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tree_vue_vue_type_script_lang$12 = tree_vue_vue_type_script_lang;
  var tree_vue_vue_type_template_id_5b45a1b2_lang$1 = tree_vue_vue_type_template_id_5b45a1b2_lang;
  tree_vue_vue_type_script_lang$12["default"].render = tree_vue_vue_type_template_id_5b45a1b2_lang$1.render;
  tree_vue_vue_type_script_lang$12["default"].__file = "packages/components/tree-v2/src/tree.vue";
  exports["default"] = tree_vue_vue_type_script_lang$12["default"];
})(tree);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var tree_vue_vue_type_script_lang$12 = tree_vue_vue_type_script_lang;
  const ElTreeV2 = withInstall2.withInstall(tree_vue_vue_type_script_lang$12["default"]);
  exports.ElTreeV2 = ElTreeV2;
  exports["default"] = ElTreeV2;
})(treeV2);
var upload$1 = {};
var src$2 = {};
var index_vue_vue_type_script_lang$1 = {};
var ajax = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var shared2 = require$$1$1;
  function getError(action, option2, xhr2) {
    let msg;
    if (xhr2.response) {
      msg = `${xhr2.response.error || xhr2.response}`;
    } else if (xhr2.responseText) {
      msg = `${xhr2.responseText}`;
    } else {
      msg = `fail to ${option2.method} ${action} ${xhr2.status}`;
    }
    const err = new Error(msg);
    err.status = xhr2.status;
    err.method = option2.method;
    err.url = action;
    return err;
  }
  function getBody(xhr2) {
    const text = xhr2.responseText || xhr2.response;
    if (!text) {
      return text;
    }
    try {
      return JSON.parse(text);
    } catch (e) {
      return text;
    }
  }
  function upload2(option2) {
    if (typeof XMLHttpRequest === "undefined") {
      return;
    }
    const xhr2 = new XMLHttpRequest();
    const action = option2.action;
    if (xhr2.upload) {
      xhr2.upload.onprogress = function progress3(e) {
        if (e.total > 0) {
          e.percent = e.loaded / e.total * 100;
        }
        option2.onProgress(e);
      };
    }
    const formData = new FormData();
    if (option2.data) {
      Object.keys(option2.data).forEach((key2) => {
        formData.append(key2, option2.data[key2]);
      });
    }
    formData.append(option2.filename, option2.file, option2.file.name);
    xhr2.onerror = function error2() {
      option2.onError(getError(action, option2, xhr2));
    };
    xhr2.onload = function onload() {
      if (xhr2.status < 200 || xhr2.status >= 300) {
        return option2.onError(getError(action, option2, xhr2));
      }
      option2.onSuccess(getBody(xhr2));
    };
    xhr2.open(option2.method, action, true);
    if (option2.withCredentials && "withCredentials" in xhr2) {
      xhr2.withCredentials = true;
    }
    const headers = option2.headers || {};
    for (const item2 in headers) {
      if (shared2.hasOwn(headers, item2) && headers[item2] !== null) {
        xhr2.setRequestHeader(item2, headers[item2]);
      }
    }
    if (headers instanceof Headers) {
      headers.forEach((value, key2) => {
        xhr2.setRequestHeader(key2, value);
      });
    }
    xhr2.send(formData);
    return xhr2;
  }
  exports["default"] = upload2;
})(ajax);
var uploadList = {};
var uploadList_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var index$110 = icon$4;
  var iconsVue2 = require$$3;
  var index2 = progress$2;
  var index$22 = useLocale$1;
  var script2 = vue2.defineComponent({
    name: "ElUploadList",
    components: {
      ElProgress: index2.ElProgress,
      ElIcon: index$110.ElIcon,
      Document: iconsVue2.Document,
      Delete: iconsVue2.Delete,
      Close: iconsVue2.Close,
      ZoomIn: iconsVue2.ZoomIn,
      Check: iconsVue2.Check,
      CircleCheck: iconsVue2.CircleCheck
    },
    props: {
      files: {
        type: Array,
        default: () => []
      },
      disabled: {
        type: Boolean,
        default: false
      },
      handlePreview: {
        type: Function,
        default: () => shared2.NOOP
      },
      listType: {
        type: String,
        default: "text"
      }
    },
    emits: ["remove"],
    setup(props2, { emit }) {
      const { t } = index$22.useLocale();
      const handleClick = (file) => {
        props2.handlePreview(file);
      };
      const onFileClicked = (e) => {
        e.target.focus();
      };
      const handleRemove = (e, file) => {
        emit("remove", file);
      };
      return {
        focusing: vue2.ref(false),
        handleClick,
        handleRemove,
        onFileClicked,
        t
      };
    }
  });
  exports["default"] = script2;
})(uploadList_vue_vue_type_script_lang);
var uploadList_vue_vue_type_template_id_192277b6_lang = {};
Object.defineProperty(uploadList_vue_vue_type_template_id_192277b6_lang, "__esModule", { value: true });
var vue$8 = require$$0$1;
const _hoisted_1$4 = ["onKeydown"];
const _hoisted_2$3 = ["src"];
const _hoisted_3$3 = ["onClick"];
const _hoisted_4$2 = { class: "el-upload-list__item-status-label" };
const _hoisted_5$2 = {
  key: 2,
  class: "el-icon--close-tip"
};
const _hoisted_6$1 = {
  key: 4,
  class: "el-upload-list__item-actions"
};
const _hoisted_7$1 = ["onClick"];
const _hoisted_8$1 = ["onClick"];
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_document = vue$8.resolveComponent("document");
  const _component_el_icon = vue$8.resolveComponent("el-icon");
  const _component_circle_check = vue$8.resolveComponent("circle-check");
  const _component_check = vue$8.resolveComponent("check");
  const _component_close = vue$8.resolveComponent("close");
  const _component_el_progress = vue$8.resolveComponent("el-progress");
  const _component_zoom_in = vue$8.resolveComponent("zoom-in");
  const _component_delete = vue$8.resolveComponent("delete");
  return vue$8.openBlock(), vue$8.createBlock(vue$8.TransitionGroup, {
    tag: "ul",
    class: vue$8.normalizeClass([
      "el-upload-list",
      "el-upload-list--" + _ctx.listType,
      { "is-disabled": _ctx.disabled }
    ]),
    name: "el-list"
  }, {
    default: vue$8.withCtx(() => [
      (vue$8.openBlock(true), vue$8.createElementBlock(vue$8.Fragment, null, vue$8.renderList(_ctx.files, (file) => {
        return vue$8.openBlock(), vue$8.createElementBlock("li", {
          key: file.uid || file,
          class: vue$8.normalizeClass([
            "el-upload-list__item",
            "is-" + file.status,
            _ctx.focusing ? "focusing" : ""
          ]),
          tabindex: "0",
          onKeydown: vue$8.withKeys(($event) => !_ctx.disabled && _ctx.handleRemove($event, file), ["delete"]),
          onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.focusing = true),
          onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.focusing = false),
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onFileClicked && _ctx.onFileClicked(...args))
        }, [
          vue$8.renderSlot(_ctx.$slots, "default", { file }, () => [
            file.status !== "uploading" && ["picture-card", "picture"].includes(_ctx.listType) ? (vue$8.openBlock(), vue$8.createElementBlock("img", {
              key: 0,
              class: "el-upload-list__item-thumbnail",
              src: file.url,
              alt: ""
            }, null, 8, _hoisted_2$3)) : vue$8.createCommentVNode("v-if", true),
            vue$8.createElementVNode("a", {
              class: "el-upload-list__item-name",
              onClick: ($event) => _ctx.handleClick(file)
            }, [
              vue$8.createVNode(_component_el_icon, { class: "el-icon--document" }, {
                default: vue$8.withCtx(() => [
                  vue$8.createVNode(_component_document)
                ]),
                _: 1
              }),
              vue$8.createTextVNode(" " + vue$8.toDisplayString(file.name), 1)
            ], 8, _hoisted_3$3),
            vue$8.createElementVNode("label", _hoisted_4$2, [
              _ctx.listType === "text" ? (vue$8.openBlock(), vue$8.createBlock(_component_el_icon, {
                key: 0,
                class: "el-icon--upload-success el-icon--circle-check"
              }, {
                default: vue$8.withCtx(() => [
                  vue$8.createVNode(_component_circle_check)
                ]),
                _: 1
              })) : ["picture-card", "picture"].includes(_ctx.listType) ? (vue$8.openBlock(), vue$8.createBlock(_component_el_icon, {
                key: 1,
                class: "el-icon--upload-success el-icon--check"
              }, {
                default: vue$8.withCtx(() => [
                  vue$8.createVNode(_component_check)
                ]),
                _: 1
              })) : vue$8.createCommentVNode("v-if", true)
            ]),
            !_ctx.disabled ? (vue$8.openBlock(), vue$8.createBlock(_component_el_icon, {
              key: 1,
              class: "el-icon--close",
              onClick: ($event) => _ctx.handleRemove($event, file)
            }, {
              default: vue$8.withCtx(() => [
                vue$8.createVNode(_component_close)
              ]),
              _: 2
            }, 1032, ["onClick"])) : vue$8.createCommentVNode("v-if", true),
            vue$8.createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            vue$8.createCommentVNode(" This is a bug which needs to be fixed "),
            vue$8.createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
            !_ctx.disabled ? (vue$8.openBlock(), vue$8.createElementBlock("i", _hoisted_5$2, vue$8.toDisplayString(_ctx.t("el.upload.deleteTip")), 1)) : vue$8.createCommentVNode("v-if", true),
            file.status === "uploading" ? (vue$8.openBlock(), vue$8.createBlock(_component_el_progress, {
              key: 3,
              type: _ctx.listType === "picture-card" ? "circle" : "line",
              "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
              percentage: +file.percentage
            }, null, 8, ["type", "stroke-width", "percentage"])) : vue$8.createCommentVNode("v-if", true),
            _ctx.listType === "picture-card" ? (vue$8.openBlock(), vue$8.createElementBlock("span", _hoisted_6$1, [
              vue$8.createElementVNode("span", {
                class: "el-upload-list__item-preview",
                onClick: ($event) => _ctx.handlePreview(file)
              }, [
                vue$8.createVNode(_component_el_icon, { class: "el-icon--zoom-in" }, {
                  default: vue$8.withCtx(() => [
                    vue$8.createVNode(_component_zoom_in)
                  ]),
                  _: 1
                })
              ], 8, _hoisted_7$1),
              !_ctx.disabled ? (vue$8.openBlock(), vue$8.createElementBlock("span", {
                key: 0,
                class: "el-upload-list__item-delete",
                onClick: ($event) => _ctx.handleRemove($event, file)
              }, [
                vue$8.createVNode(_component_el_icon, { class: "el-icon--delete" }, {
                  default: vue$8.withCtx(() => [
                    vue$8.createVNode(_component_delete)
                  ]),
                  _: 1
                })
              ], 8, _hoisted_8$1)) : vue$8.createCommentVNode("v-if", true)
            ])) : vue$8.createCommentVNode("v-if", true)
          ])
        ], 42, _hoisted_1$4);
      }), 128))
    ]),
    _: 3
  }, 8, ["class"]);
}
uploadList_vue_vue_type_template_id_192277b6_lang.render = render$5;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uploadList_vue_vue_type_script_lang$1 = uploadList_vue_vue_type_script_lang;
  var uploadList_vue_vue_type_template_id_192277b6_lang$1 = uploadList_vue_vue_type_template_id_192277b6_lang;
  uploadList_vue_vue_type_script_lang$1["default"].render = uploadList_vue_vue_type_template_id_192277b6_lang$1.render;
  uploadList_vue_vue_type_script_lang$1["default"].__file = "packages/components/upload/src/upload-list.vue";
  exports["default"] = uploadList_vue_vue_type_script_lang$1["default"];
})(uploadList);
var upload = {};
var upload_vue_vue_type_script_lang = {};
var uploadDragger = {};
var uploadDragger_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var script2 = vue2.defineComponent({
    name: "ElUploadDrag",
    props: {
      disabled: {
        type: Boolean,
        default: false
      }
    },
    emits: ["file"],
    setup(props2, { emit }) {
      const uploader = vue2.inject("uploader", {});
      const dragover = vue2.ref(false);
      function onDrop(e) {
        var _a;
        if (props2.disabled || !uploader)
          return;
        const accept = ((_a = uploader.props) == null ? void 0 : _a.accept) || uploader.accept;
        dragover.value = false;
        if (!accept) {
          emit("file", e.dataTransfer.files);
          return;
        }
        emit("file", Array.from(e.dataTransfer.files).filter((file) => {
          const { type: type4, name } = file;
          const extension = name.indexOf(".") > -1 ? `.${name.split(".").pop()}` : "";
          const baseType = type4.replace(/\/.*$/, "");
          return accept.split(",").map((type22) => type22.trim()).filter((type22) => type22).some((acceptedType) => {
            if (acceptedType.startsWith(".")) {
              return extension === acceptedType;
            }
            if (/\/\*$/.test(acceptedType)) {
              return baseType === acceptedType.replace(/\/\*$/, "");
            }
            if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
              return type4 === acceptedType;
            }
            return false;
          });
        }));
      }
      function onDragover() {
        if (!props2.disabled)
          dragover.value = true;
      }
      return {
        dragover,
        onDrop,
        onDragover
      };
    }
  });
  exports["default"] = script2;
})(uploadDragger_vue_vue_type_script_lang);
var uploadDragger_vue_vue_type_template_id_4f8ef690_lang = {};
Object.defineProperty(uploadDragger_vue_vue_type_template_id_4f8ef690_lang, "__esModule", { value: true });
var vue$7 = require$$0$1;
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return vue$7.openBlock(), vue$7.createElementBlock("div", {
    class: vue$7.normalizeClass({
      "el-upload-dragger": true,
      "is-dragover": _ctx.dragover
    }),
    onDrop: _cache[0] || (_cache[0] = vue$7.withModifiers((...args) => _ctx.onDrop && _ctx.onDrop(...args), ["prevent"])),
    onDragover: _cache[1] || (_cache[1] = vue$7.withModifiers((...args) => _ctx.onDragover && _ctx.onDragover(...args), ["prevent"])),
    onDragleave: _cache[2] || (_cache[2] = vue$7.withModifiers(($event) => _ctx.dragover = false, ["prevent"]))
  }, [
    vue$7.renderSlot(_ctx.$slots, "default")
  ], 34);
}
uploadDragger_vue_vue_type_template_id_4f8ef690_lang.render = render$4;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uploadDragger_vue_vue_type_script_lang$1 = uploadDragger_vue_vue_type_script_lang;
  var uploadDragger_vue_vue_type_template_id_4f8ef690_lang$1 = uploadDragger_vue_vue_type_template_id_4f8ef690_lang;
  uploadDragger_vue_vue_type_script_lang$1["default"].render = uploadDragger_vue_vue_type_template_id_4f8ef690_lang$1.render;
  uploadDragger_vue_vue_type_script_lang$1["default"].__file = "packages/components/upload/src/upload-dragger.vue";
  exports["default"] = uploadDragger_vue_vue_type_script_lang$1["default"];
})(uploadDragger);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var ajax$1 = ajax;
  var uploadDragger_vue_vue_type_script_lang$1 = uploadDragger_vue_vue_type_script_lang;
  var script2 = vue2.defineComponent({
    components: {
      UploadDragger: uploadDragger_vue_vue_type_script_lang$1["default"]
    },
    props: {
      type: {
        type: String,
        default: ""
      },
      action: {
        type: String,
        required: true
      },
      name: {
        type: String,
        default: "file"
      },
      data: {
        type: Object,
        default: () => null
      },
      headers: {
        type: Object,
        default: () => null
      },
      method: {
        type: String,
        default: "post"
      },
      withCredentials: {
        type: Boolean,
        default: false
      },
      multiple: {
        type: Boolean,
        default: null
      },
      accept: {
        type: String,
        default: ""
      },
      onStart: {
        type: Function,
        default: shared2.NOOP
      },
      onProgress: {
        type: Function,
        default: shared2.NOOP
      },
      onSuccess: {
        type: Function,
        default: shared2.NOOP
      },
      onError: {
        type: Function,
        default: shared2.NOOP
      },
      beforeUpload: {
        type: Function,
        default: shared2.NOOP
      },
      drag: {
        type: Boolean,
        default: false
      },
      onPreview: {
        type: Function,
        default: shared2.NOOP
      },
      onRemove: {
        type: Function,
        default: shared2.NOOP
      },
      fileList: {
        type: Array,
        default: () => []
      },
      autoUpload: {
        type: Boolean,
        default: true
      },
      listType: {
        type: String,
        default: "text"
      },
      httpRequest: {
        type: Function,
        default: () => ajax$1["default"]
      },
      disabled: Boolean,
      limit: {
        type: Number,
        default: null
      },
      onExceed: {
        type: Function,
        default: shared2.NOOP
      }
    },
    setup(props2) {
      const reqs = vue2.ref({});
      const mouseover = vue2.ref(false);
      const inputRef = vue2.ref(null);
      function uploadFiles(files2) {
        if (props2.limit && props2.fileList.length + files2.length > props2.limit) {
          props2.onExceed(files2, props2.fileList);
          return;
        }
        let postFiles = Array.from(files2);
        if (!props2.multiple) {
          postFiles = postFiles.slice(0, 1);
        }
        if (postFiles.length === 0) {
          return;
        }
        postFiles.forEach((rawFile) => {
          props2.onStart(rawFile);
          if (props2.autoUpload)
            upload2(rawFile);
        });
      }
      function upload2(rawFile) {
        inputRef.value.value = null;
        if (!props2.beforeUpload) {
          return post(rawFile);
        }
        const before = props2.beforeUpload(rawFile);
        if (before instanceof Promise) {
          before.then((processedFile) => {
            const fileType = Object.prototype.toString.call(processedFile);
            if (fileType === "[object File]" || fileType === "[object Blob]") {
              if (fileType === "[object Blob]") {
                processedFile = new File([processedFile], rawFile.name, {
                  type: rawFile.type
                });
              }
              for (const p2 in rawFile) {
                if (shared2.hasOwn(rawFile, p2)) {
                  processedFile[p2] = rawFile[p2];
                }
              }
              post(processedFile);
            } else {
              post(rawFile);
            }
          }).catch(() => {
            props2.onRemove(null, rawFile);
          });
        } else if (before !== false) {
          post(rawFile);
        } else {
          props2.onRemove(null, rawFile);
        }
      }
      function abort(file) {
        const _reqs = reqs.value;
        if (file) {
          let uid2 = file;
          if (file.uid)
            uid2 = file.uid;
          if (_reqs[uid2]) {
            _reqs[uid2].abort();
          }
        } else {
          Object.keys(_reqs).forEach((uid2) => {
            if (_reqs[uid2])
              _reqs[uid2].abort();
            delete _reqs[uid2];
          });
        }
      }
      function post(rawFile) {
        const { uid: uid2 } = rawFile;
        const options = {
          headers: props2.headers,
          withCredentials: props2.withCredentials,
          file: rawFile,
          data: props2.data,
          method: props2.method,
          filename: props2.name,
          action: props2.action,
          onProgress: (e) => {
            props2.onProgress(e, rawFile);
          },
          onSuccess: (res) => {
            props2.onSuccess(res, rawFile);
            delete reqs.value[uid2];
          },
          onError: (err) => {
            props2.onError(err, rawFile);
            delete reqs.value[uid2];
          }
        };
        const req = props2.httpRequest(options);
        reqs.value[uid2] = req;
        if (req instanceof Promise) {
          req.then(options.onSuccess, options.onError);
        }
      }
      function handleChange(e) {
        const files2 = e.target.files;
        if (!files2)
          return;
        uploadFiles(files2);
      }
      function handleClick() {
        if (!props2.disabled) {
          inputRef.value.value = null;
          inputRef.value.click();
        }
      }
      function handleKeydown() {
        handleClick();
      }
      return {
        reqs,
        mouseover,
        inputRef,
        abort,
        post,
        handleChange,
        handleClick,
        handleKeydown,
        upload: upload2,
        uploadFiles
      };
    }
  });
  exports["default"] = script2;
})(upload_vue_vue_type_script_lang);
var upload_vue_vue_type_template_id_efd50b36_lang = {};
Object.defineProperty(upload_vue_vue_type_template_id_efd50b36_lang, "__esModule", { value: true });
var vue$6 = require$$0$1;
const _hoisted_1$3 = ["name", "multiple", "accept"];
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_upload_dragger = vue$6.resolveComponent("upload-dragger");
  return vue$6.openBlock(), vue$6.createElementBlock("div", {
    class: vue$6.normalizeClass(["el-upload", `el-upload--${_ctx.listType}`]),
    tabindex: "0",
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onKeydown: _cache[2] || (_cache[2] = vue$6.withKeys(vue$6.withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"]), ["enter", "space"]))
  }, [
    _ctx.drag ? (vue$6.openBlock(), vue$6.createBlock(_component_upload_dragger, {
      key: 0,
      disabled: _ctx.disabled,
      onFile: _ctx.uploadFiles
    }, {
      default: vue$6.withCtx(() => [
        vue$6.renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["disabled", "onFile"])) : vue$6.renderSlot(_ctx.$slots, "default", { key: 1 }),
    vue$6.createElementVNode("input", {
      ref: "inputRef",
      class: "el-upload__input",
      type: "file",
      name: _ctx.name,
      multiple: _ctx.multiple,
      accept: _ctx.accept,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 40, _hoisted_1$3)
  ], 34);
}
upload_vue_vue_type_template_id_efd50b36_lang.render = render$3;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var upload_vue_vue_type_script_lang$1 = upload_vue_vue_type_script_lang;
  var upload_vue_vue_type_template_id_efd50b36_lang$1 = upload_vue_vue_type_template_id_efd50b36_lang;
  upload_vue_vue_type_script_lang$1["default"].render = upload_vue_vue_type_template_id_efd50b36_lang$1.render;
  upload_vue_vue_type_script_lang$1["default"].__file = "packages/components/upload/src/upload.vue";
  exports["default"] = upload_vue_vue_type_script_lang$1["default"];
})(upload);
var useHandlers = {};
function arrayEach$1(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (iteratee(array4[index2], index2, array4) === false) {
      break;
    }
  }
  return array4;
}
var _arrayEach = arrayEach$1;
var defineProperty = _defineProperty;
function baseAssignValue$2(object4, key2, value) {
  if (key2 == "__proto__" && defineProperty) {
    defineProperty(object4, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object4[key2] = value;
  }
}
var _baseAssignValue = baseAssignValue$2;
var baseAssignValue$1 = _baseAssignValue, eq = eq_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function assignValue$2(object4, key2, value) {
  var objValue = object4[key2];
  if (!(hasOwnProperty$3.call(object4, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object4)) {
    baseAssignValue$1(object4, key2, value);
  }
}
var _assignValue = assignValue$2;
var assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(source2, props2, object4, customizer) {
  var isNew = !object4;
  object4 || (object4 = {});
  var index2 = -1, length = props2.length;
  while (++index2 < length) {
    var key2 = props2[index2];
    var newValue = customizer ? customizer(object4[key2], source2[key2], key2, object4, source2) : void 0;
    if (newValue === void 0) {
      newValue = source2[key2];
    }
    if (isNew) {
      baseAssignValue(object4, key2, newValue);
    } else {
      assignValue$1(object4, key2, newValue);
    }
  }
  return object4;
}
var _copyObject = copyObject$4;
var copyObject$3 = _copyObject, keys$1 = keys_1;
function baseAssign$1(object4, source2) {
  return object4 && copyObject$3(source2, keys$1(source2), object4);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object4) {
  var result3 = [];
  if (object4 != null) {
    for (var key2 in Object(object4)) {
      result3.push(key2);
    }
  }
  return result3;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$5 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function baseKeysIn$1(object4) {
  if (!isObject$5(object4)) {
    return nativeKeysIn(object4);
  }
  var isProto = isPrototype$1(object4), result3 = [];
  for (var key2 in object4) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$2.call(object4, key2)))) {
      result3.push(key2);
    }
  }
  return result3;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$3(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
}
var keysIn_1 = keysIn$3;
var copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object4, source2) {
  return object4 && copyObject$2(source2, keysIn$2(source2), object4);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var length = buffer2.length, result3 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
    buffer2.copy(result3);
    return result3;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
function copyArray$1(source2, array4) {
  var index2 = -1, length = source2.length;
  array4 || (array4 = Array(length));
  while (++index2 < length) {
    array4[index2] = source2[index2];
  }
  return array4;
}
var _copyArray = copyArray$1;
var copyObject$1 = _copyObject, getSymbols$1 = _getSymbols;
function copySymbols$1(source2, object4) {
  return copyObject$1(source2, getSymbols$1(source2), object4);
}
var _copySymbols = copySymbols$1;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var arrayPush = _arrayPush, getPrototype$1 = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object4) {
  var result3 = [];
  while (object4) {
    arrayPush(result3, getSymbols(object4));
    object4 = getPrototype$1(object4);
  }
  return result3;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source2, object4) {
  return copyObject(source2, getSymbolsIn$1(source2), object4);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(object4) {
  return baseGetAllKeys(object4, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray$1(array4) {
  var length = array4.length, result3 = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty$1.call(array4, "index")) {
    result3.index = array4.index;
    result3.input = array4.input;
  }
  return result3;
}
var _initCloneArray = initCloneArray$1;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result3 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result3).set(new Uint8Array$1(arrayBuffer));
  return result3;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp4) {
  var result3 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
  result3.lastIndex = regexp4.lastIndex;
  return result3;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$1 = _Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object4, tag3, isDeep) {
  var Ctor = object4.constructor;
  switch (tag3) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object4);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object4);
    case dataViewTag$1:
      return cloneDataView(object4, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object4, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object4);
    case regexpTag$1:
      return cloneRegExp(object4);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object4);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$4 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object4() {
  }
  return function(proto) {
    if (!isObject$4(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object4.prototype = proto;
    var result3 = new object4();
    object4.prototype = void 0;
    return result3;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object4) {
  return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag, isObjectLike = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$2 = isArray_1, isBuffer$1 = isBuffer$4.exports, isMap = isMap_1, isObject$3 = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$1(value, bitmask, customizer, key2, object4, stack2) {
  var result3, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result3 = object4 ? customizer(value, key2, object4, stack2) : customizer(value);
  }
  if (result3 !== void 0) {
    return result3;
  }
  if (!isObject$3(value)) {
    return value;
  }
  var isArr = isArray$2(value);
  if (isArr) {
    result3 = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result3);
    }
  } else {
    var tag3 = getTag(value), isFunc = tag3 == funcTag || tag3 == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag3 == objectTag || tag3 == argsTag || isFunc && !object4) {
      result3 = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result3, value)) : copySymbols(value, baseAssign(result3, value));
      }
    } else {
      if (!cloneableTags[tag3]) {
        return object4 ? value : {};
      }
      result3 = initCloneByTag(value, tag3, isDeep);
    }
  }
  stack2 || (stack2 = new Stack());
  var stacked = stack2.get(value);
  if (stacked) {
    return stacked;
  }
  stack2.set(value, result3);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result3.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack2));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key3) {
      result3.set(key3, baseClone$1(subValue, bitmask, customizer, key3, value, stack2));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props2 = isArr ? void 0 : keysFunc(value);
  arrayEach(props2 || value, function(subValue, key3) {
    if (props2) {
      key3 = subValue;
      subValue = value[key3];
    }
    assignValue(result3, key3, baseClone$1(subValue, bitmask, customizer, key3, value, stack2));
  });
  return result3;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var cloneDeep2 = cloneDeep_1;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var cloneDeep__default = /* @__PURE__ */ _interopDefaultLegacy2(cloneDeep2);
  function getFile(rawFile, uploadFiles) {
    return uploadFiles.find((file) => file.uid === rawFile.uid);
  }
  function genUid(seed) {
    return Date.now() + seed;
  }
  var useHandlers2 = (props2) => {
    const uploadFiles = vue2.ref([]);
    const uploadRef = vue2.ref(null);
    let tempIndex = 1;
    function abort(file) {
      uploadRef.value.abort(file);
    }
    function clearFiles(status = ["success", "fail"]) {
      uploadFiles.value = uploadFiles.value.filter((row2) => {
        return status.indexOf(row2.status) === -1;
      });
    }
    function handleError2(err, rawFile) {
      const file = getFile(rawFile, uploadFiles.value);
      file.status = "fail";
      uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
      props2.onError(err, file, uploadFiles.value);
      props2.onChange(file, uploadFiles.value);
    }
    function handleProgress(ev, rawFile) {
      const file = getFile(rawFile, uploadFiles.value);
      props2.onProgress(ev, file, uploadFiles.value);
      file.status = "uploading";
      file.percentage = ev.percent || 0;
    }
    function handleSuccess(res, rawFile) {
      const file = getFile(rawFile, uploadFiles.value);
      if (file) {
        file.status = "success";
        file.response = res;
        props2.onSuccess(res, file, uploadFiles.value);
        props2.onChange(file, uploadFiles.value);
      }
    }
    function handleStart(rawFile) {
      const uid2 = genUid(tempIndex++);
      rawFile.uid = uid2;
      const file = {
        name: rawFile.name,
        percentage: 0,
        status: "ready",
        size: rawFile.size,
        raw: rawFile,
        uid: uid2
      };
      if (props2.listType === "picture-card" || props2.listType === "picture") {
        try {
          file.url = URL.createObjectURL(rawFile);
        } catch (err) {
          console.error("[Element Error][Upload]", err);
          props2.onError(err, file, uploadFiles.value);
        }
      }
      uploadFiles.value.push(file);
      props2.onChange(file, uploadFiles.value);
    }
    function handleRemove(file, raw) {
      if (raw) {
        file = getFile(raw, uploadFiles.value);
      }
      const revokeObjectURL = () => {
        if (file.url && file.url.indexOf("blob:") === 0) {
          URL.revokeObjectURL(file.url);
        }
      };
      const doRemove = () => {
        abort(file);
        const fileList = uploadFiles.value;
        fileList.splice(fileList.indexOf(file), 1);
        props2.onRemove(file, fileList);
        revokeObjectURL();
      };
      if (!props2.beforeRemove) {
        doRemove();
      } else if (typeof props2.beforeRemove === "function") {
        const before = props2.beforeRemove(file, uploadFiles.value);
        if (before instanceof Promise) {
          before.then(() => {
            doRemove();
          }).catch(shared2.NOOP);
        } else if (before !== false) {
          doRemove();
        }
      }
    }
    function submit() {
      uploadFiles.value.filter((file) => file.status === "ready").forEach((file) => {
        uploadRef.value.upload(file.raw);
      });
    }
    vue2.watch(() => props2.listType, (val) => {
      if (val === "picture-card" || val === "picture") {
        uploadFiles.value = uploadFiles.value.map((file) => {
          if (!file.url && file.raw) {
            try {
              file.url = URL.createObjectURL(file.raw);
            } catch (err) {
              props2.onError(err, file, uploadFiles.value);
            }
          }
          return file;
        });
      }
    });
    vue2.watch(() => props2.fileList, (fileList) => {
      uploadFiles.value = fileList.map((file) => {
        const cloneFile = cloneDeep__default["default"](file);
        return __spreadProps(__spreadValues({}, cloneFile), {
          uid: file.uid || genUid(tempIndex++),
          status: file.status || "success"
        });
      });
    }, {
      immediate: true,
      deep: true
    });
    return {
      abort,
      clearFiles,
      handleError: handleError2,
      handleProgress,
      handleStart,
      handleSuccess,
      handleRemove,
      submit,
      uploadFiles,
      uploadRef
    };
  };
  exports["default"] = useHandlers2;
})(useHandlers);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var ajax$1 = ajax;
  var useHandlers$1 = useHandlers;
  var upload_vue_vue_type_script_lang$1 = upload_vue_vue_type_script_lang;
  var uploadList_vue_vue_type_script_lang$1 = uploadList_vue_vue_type_script_lang;
  var form2 = form$7;
  var script2 = vue2.defineComponent({
    name: "ElUpload",
    components: {
      Upload: upload_vue_vue_type_script_lang$1["default"],
      UploadList: uploadList_vue_vue_type_script_lang$1["default"]
    },
    props: {
      action: {
        type: String,
        required: true
      },
      headers: {
        type: Object,
        default: () => ({})
      },
      method: {
        type: String,
        default: "post"
      },
      data: {
        type: Object,
        default: () => ({})
      },
      multiple: {
        type: Boolean,
        default: false
      },
      name: {
        type: String,
        default: "file"
      },
      drag: {
        type: Boolean,
        default: false
      },
      withCredentials: Boolean,
      showFileList: {
        type: Boolean,
        default: true
      },
      accept: {
        type: String,
        default: ""
      },
      type: {
        type: String,
        default: "select"
      },
      beforeUpload: {
        type: Function,
        default: shared2.NOOP
      },
      beforeRemove: {
        type: Function,
        default: shared2.NOOP
      },
      onRemove: {
        type: Function,
        default: shared2.NOOP
      },
      onChange: {
        type: Function,
        default: shared2.NOOP
      },
      onPreview: {
        type: Function,
        default: shared2.NOOP
      },
      onSuccess: {
        type: Function,
        default: shared2.NOOP
      },
      onProgress: {
        type: Function,
        default: shared2.NOOP
      },
      onError: {
        type: Function,
        default: shared2.NOOP
      },
      fileList: {
        type: Array,
        default: () => {
          return [];
        }
      },
      autoUpload: {
        type: Boolean,
        default: true
      },
      listType: {
        type: String,
        default: "text"
      },
      httpRequest: {
        type: Function,
        default: ajax$1["default"]
      },
      disabled: Boolean,
      limit: {
        type: Number,
        default: null
      },
      onExceed: {
        type: Function,
        default: () => shared2.NOOP
      }
    },
    setup(props2) {
      const elForm = vue2.inject(form2.elFormKey, {});
      const uploadDisabled = vue2.computed(() => {
        return props2.disabled || elForm.disabled;
      });
      const {
        abort,
        clearFiles,
        handleError: handleError2,
        handleProgress,
        handleStart,
        handleSuccess,
        handleRemove,
        submit,
        uploadRef,
        uploadFiles
      } = useHandlers$1["default"](props2);
      vue2.provide("uploader", vue2.getCurrentInstance());
      vue2.onBeforeUnmount(() => {
        uploadFiles.value.forEach((file) => {
          if (file.url && file.url.indexOf("blob:") === 0) {
            URL.revokeObjectURL(file.url);
          }
        });
      });
      return {
        abort,
        dragOver: vue2.ref(false),
        draging: vue2.ref(false),
        handleError: handleError2,
        handleProgress,
        handleRemove,
        handleStart,
        handleSuccess,
        uploadDisabled,
        uploadFiles,
        uploadRef,
        submit,
        clearFiles
      };
    },
    render() {
      var _a, _b;
      let uploadList2;
      if (this.showFileList) {
        uploadList2 = vue2.h(uploadList_vue_vue_type_script_lang$1["default"], {
          disabled: this.uploadDisabled,
          listType: this.listType,
          files: this.uploadFiles,
          onRemove: this.handleRemove,
          handlePreview: this.onPreview
        }, this.$slots.file ? {
          default: (props2) => {
            return this.$slots.file({
              file: props2.file
            });
          }
        } : null);
      } else {
        uploadList2 = null;
      }
      const uploadData = {
        type: this.type,
        drag: this.drag,
        action: this.action,
        multiple: this.multiple,
        "before-upload": this.beforeUpload,
        "with-credentials": this.withCredentials,
        headers: this.headers,
        method: this.method,
        name: this.name,
        data: this.data,
        accept: this.accept,
        fileList: this.uploadFiles,
        autoUpload: this.autoUpload,
        listType: this.listType,
        disabled: this.uploadDisabled,
        limit: this.limit,
        "on-exceed": this.onExceed,
        "on-start": this.handleStart,
        "on-progress": this.handleProgress,
        "on-success": this.handleSuccess,
        "on-error": this.handleError,
        "on-preview": this.onPreview,
        "on-remove": this.handleRemove,
        "http-request": this.httpRequest,
        ref: "uploadRef"
      };
      const trigger2 = this.$slots.trigger || this.$slots.default;
      const uploadComponent = vue2.h(upload_vue_vue_type_script_lang$1["default"], uploadData, {
        default: () => trigger2 == null ? void 0 : trigger2()
      });
      return vue2.h("div", [
        this.listType === "picture-card" ? uploadList2 : null,
        this.$slots.trigger ? [uploadComponent, this.$slots.default()] : uploadComponent,
        (_b = (_a = this.$slots).tip) == null ? void 0 : _b.call(_a),
        this.listType !== "picture-card" ? uploadList2 : null
      ]);
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$1;
  index_vue_vue_type_script_lang2["default"].__file = "packages/components/upload/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang2["default"];
})(src$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang2 = index_vue_vue_type_script_lang$1;
  index_vue_vue_type_script_lang2["default"].install = (app) => {
    app.component(index_vue_vue_type_script_lang2["default"].name, index_vue_vue_type_script_lang2["default"]);
  };
  const _Upload = index_vue_vue_type_script_lang2["default"];
  const ElUpload = _Upload;
  exports.ElUpload = ElUpload;
  exports["default"] = _Upload;
})(upload$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index2 = affix$2;
  var index$110 = alert$2;
  var index$22 = autocomplete;
  var index$32 = avatar$2;
  var index$42 = backtop$2;
  var index$52 = badge$2;
  var index$62 = breadcrumb$2;
  var index$72 = button$5;
  var index$82 = calendar$2;
  var index$92 = card$2;
  var index$a2 = carousel;
  var index$b2 = cascader;
  var index$c2 = cascaderPanel;
  var index$d2 = checkTag;
  var index$e2 = checkbox$1;
  var index$f2 = col$2;
  var index$g2 = collapse$1;
  var index$h2 = collapseTransition$1;
  var index$i2 = colorPicker;
  var index$j2 = configProvider$3;
  var index$k2 = container$1;
  var index$l2 = datePicker$1;
  var index$m2 = descriptions;
  var index$n2 = dialog$3;
  var index$o2 = divider$2;
  var index$p2 = drawer$2;
  var index$q2 = dropdown;
  var index$r2 = empty$2;
  var index$s2 = form$3;
  var index$t2 = icon$4;
  var index$u2 = image$2;
  var index$v2 = imageViewer$2;
  var index$w2 = input$2;
  var index$x2 = inputNumber$2;
  var index$y2 = link$2;
  var index$z2 = menu$2;
  var index$A2 = pageHeader$2;
  var index$B2 = pagination$3;
  var index$C2 = popconfirm$2;
  var index$D2 = popover;
  var index$E2 = popper$3;
  var index$F2 = progress$2;
  var index$G2 = radio$5;
  var index$H2 = rate$2;
  var index$I2 = result$2;
  var index$J2 = row$2;
  var index$K2 = scrollbar$3;
  var index$L2 = select$2;
  var index$M2 = selectV2;
  var index$N2 = skeleton$2;
  var index$O2 = slider;
  var index$P2 = space$2;
  var index$Q2 = steps;
  var index$R2 = _switch$2;
  var index$S2 = table$1;
  var index$T2 = tabs$2;
  var index$U2 = tag$2;
  var index$V2 = timePicker$1;
  var index$W2 = timeSelect$1;
  var index$X2 = timeline;
  var index$Y2 = tooltip;
  var index$Z2 = transfer$1;
  var index$_2 = tree$2;
  var index$$2 = treeV2;
  var index$102 = upload$1;
  var Components = [
    index2.ElAffix,
    index$110.ElAlert,
    index$22.ElAutocomplete,
    index$32.ElAvatar,
    index$42.ElBacktop,
    index$52.ElBadge,
    index$62.ElBreadcrumb,
    index$62.ElBreadcrumbItem,
    index$72.ElButton,
    index$72.ElButtonGroup,
    index$82.ElCalendar,
    index$92.ElCard,
    index$a2.ElCarousel,
    index$a2.ElCarouselItem,
    index$b2.ElCascader,
    index$c2.ElCascaderPanel,
    index$d2.ElCheckTag,
    index$e2.ElCheckbox,
    index$e2.ElCheckboxButton,
    index$e2.ElCheckboxGroup,
    index$f2.ElCol,
    index$g2.ElCollapse,
    index$g2.ElCollapseItem,
    index$h2.ElCollapseTransition,
    index$i2.ElColorPicker,
    index$j2.ElConfigProvider,
    index$k2.ElContainer,
    index$k2.ElAside,
    index$k2.ElFooter,
    index$k2.ElHeader,
    index$k2.ElMain,
    index$l2.ElDatePicker,
    index$m2.ElDescriptions,
    index$m2.ElDescriptionsItem,
    index$n2.ElDialog,
    index$o2.ElDivider,
    index$p2.ElDrawer,
    index$q2.ElDropdown,
    index$q2.ElDropdownItem,
    index$q2.ElDropdownMenu,
    index$r2.ElEmpty,
    index$s2.ElForm,
    index$s2.ElFormItem,
    index$t2.ElIcon,
    index$u2.ElImage,
    index$v2.ElImageViewer,
    index$w2.ElInput,
    index$x2.ElInputNumber,
    index$y2.ElLink,
    index$z2.ElMenu,
    index$z2.ElMenuItem,
    index$z2.ElMenuItemGroup,
    index$A2.ElPageHeader,
    index$B2.ElPagination,
    index$C2.ElPopconfirm,
    index$D2.ElPopover,
    index$E2.ElPopper,
    index$F2.ElProgress,
    index$G2.ElRadio,
    index$G2.ElRadioButton,
    index$G2.ElRadioGroup,
    index$H2.ElRate,
    index$I2.ElResult,
    index$J2.ElRow,
    index$K2.ElScrollbar,
    index$L2.ElSelect,
    index$L2.ElOption,
    index$L2.ElOptionGroup,
    index$M2.ElSelectV2,
    index$N2.ElSkeleton,
    index$N2.ElSkeletonItem,
    index$O2.ElSlider,
    index$P2.ElSpace,
    index$Q2.ElSteps,
    index$Q2.ElStep,
    index$R2.ElSwitch,
    index$S2.ElTable,
    index$S2.ElTableColumn,
    index$T2.ElTabs,
    index$T2.ElTabPane,
    index$U2.ElTag,
    index$V2.ElTimePicker,
    index$W2.ElTimeSelect,
    index$X2.ElTimeline,
    index$X2.ElTimelineItem,
    index$Y2.ElTooltip,
    index$Z2.ElTransfer,
    index$_2.ElTree,
    index$$2.ElTreeV2,
    index$102.ElUpload
  ];
  exports["default"] = Components;
})(component);
var plugin = {};
var infiniteScroll = {};
var src$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var throttle2 = throttle_1;
  var dom2 = dom$8;
  var error2 = error$5;
  function _interopDefaultLegacy2(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var throttle__default = /* @__PURE__ */ _interopDefaultLegacy2(throttle2);
  const SCOPE2 = "ElInfiniteScroll";
  const CHECK_INTERVAL = 50;
  const DEFAULT_DELAY = 200;
  const DEFAULT_DISTANCE = 0;
  const attributes = {
    delay: {
      type: Number,
      default: DEFAULT_DELAY
    },
    distance: {
      type: Number,
      default: DEFAULT_DISTANCE
    },
    disabled: {
      type: Boolean,
      default: false
    },
    immediate: {
      type: Boolean,
      default: true
    }
  };
  const getScrollOptions = (el, instance) => {
    return Object.entries(attributes).reduce((acm, [name, option2]) => {
      var _a, _b;
      const { type: type4, default: defaultValue } = option2;
      const attrVal = el.getAttribute(`infinite-scroll-${name}`);
      let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;
      value = value === "false" ? false : value;
      value = type4(value);
      acm[name] = Number.isNaN(value) ? defaultValue : value;
      return acm;
    }, {});
  };
  const destroyObserver = (el) => {
    const { observer } = el[SCOPE2];
    if (observer) {
      observer.disconnect();
      delete el[SCOPE2].observer;
    }
  };
  const handleScroll = (el, cb) => {
    const { container: container2, containerEl, instance, observer, lastScrollTop } = el[SCOPE2];
    const { disabled, distance } = getScrollOptions(el, instance);
    const { clientHeight, scrollHeight, scrollTop } = containerEl;
    const delta = scrollTop - lastScrollTop;
    el[SCOPE2].lastScrollTop = scrollTop;
    if (observer || disabled || delta < 0)
      return;
    let shouldTrigger = false;
    if (container2 === el) {
      shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;
    } else {
      const { clientTop, scrollHeight: height } = el;
      const offsetTop = dom2.getOffsetTopDistance(el, containerEl);
      shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;
    }
    if (shouldTrigger) {
      cb.call(instance);
    }
  };
  function checkFull(el, cb) {
    const { containerEl, instance } = el[SCOPE2];
    const { disabled } = getScrollOptions(el, instance);
    if (disabled)
      return;
    if (containerEl.scrollHeight <= containerEl.clientHeight) {
      cb.call(instance);
    } else {
      destroyObserver(el);
    }
  }
  const InfiniteScroll = {
    async mounted(el, binding) {
      const { instance, value: cb } = binding;
      if (!shared2.isFunction(cb)) {
        error2.throwError(SCOPE2, "'v-infinite-scroll' binding value must be a function");
      }
      await vue2.nextTick();
      const { delay, immediate } = getScrollOptions(el, instance);
      const container2 = dom2.getScrollContainer(el, true);
      const containerEl = container2 === window ? document.documentElement : container2;
      const onScroll = throttle__default["default"](handleScroll.bind(null, el, cb), delay);
      if (!container2)
        return;
      el[SCOPE2] = {
        instance,
        container: container2,
        containerEl,
        delay,
        cb,
        onScroll,
        lastScrollTop: containerEl.scrollTop
      };
      if (immediate) {
        const observer = new MutationObserver(throttle__default["default"](checkFull.bind(null, el, cb), CHECK_INTERVAL));
        el[SCOPE2].observer = observer;
        observer.observe(el, { childList: true, subtree: true });
        checkFull(el, cb);
      }
      container2.addEventListener("scroll", onScroll);
    },
    unmounted(el) {
      const { container: container2, onScroll } = el[SCOPE2];
      container2 == null ? void 0 : container2.removeEventListener("scroll", onScroll);
      destroyObserver(el);
    }
  };
  exports.CHECK_INTERVAL = CHECK_INTERVAL;
  exports.DEFAULT_DELAY = DEFAULT_DELAY;
  exports.DEFAULT_DISTANCE = DEFAULT_DISTANCE;
  exports.SCOPE = SCOPE2;
  exports["default"] = InfiniteScroll;
})(src$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index2 = src$1;
  const _InfiniteScroll = index2["default"];
  _InfiniteScroll.install = (app) => {
    app.directive("InfiniteScroll", _InfiniteScroll);
  };
  const ElInfiniteScroll = _InfiniteScroll;
  exports.ElInfiniteScroll = ElInfiniteScroll;
  exports["default"] = _InfiniteScroll;
})(infiniteScroll);
var loading$2 = {};
var service$1 = {};
var loading$1 = {};
Object.defineProperty(loading$1, "__esModule", { value: true });
var vue$5 = require$$0$1;
var dom$1 = dom$8;
function createLoadingComponent(options) {
  let afterLeaveTimer;
  const afterLeaveFlag = vue$5.ref(false);
  const data2 = vue$5.reactive(__spreadProps(__spreadValues({}, options), {
    originalPosition: "",
    originalOverflow: "",
    visible: false
  }));
  function setText(text) {
    data2.text = text;
  }
  function destroySelf() {
    var _a, _b;
    const target2 = data2.parent;
    if (!target2.vLoadingAddClassList) {
      let loadingNumber = target2.getAttribute("loading-number");
      loadingNumber = Number.parseInt(loadingNumber) - 1;
      if (!loadingNumber) {
        dom$1.removeClass(target2, "el-loading-parent--relative");
        target2.removeAttribute("loading-number");
      } else {
        target2.setAttribute("loading-number", loadingNumber.toString());
      }
      dom$1.removeClass(target2, "el-loading-parent--hidden");
    }
    (_b = (_a = vm.$el) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
  }
  function close2() {
    var _a;
    if (options.beforeClose && !options.beforeClose())
      return;
    const target2 = data2.parent;
    target2.vLoadingAddClassList = void 0;
    afterLeaveFlag.value = true;
    clearTimeout(afterLeaveTimer);
    afterLeaveTimer = window.setTimeout(() => {
      if (afterLeaveFlag.value) {
        afterLeaveFlag.value = false;
        destroySelf();
      }
    }, 400);
    data2.visible = false;
    (_a = options.closed) == null ? void 0 : _a.call(options);
  }
  function handleAfterLeave() {
    if (!afterLeaveFlag.value)
      return;
    afterLeaveFlag.value = false;
    destroySelf();
  }
  const elLoadingComponent = {
    name: "ElLoading",
    setup() {
      return () => {
        const svg = data2.spinner || data2.svg;
        const spinner = vue$5.h("svg", __spreadValues({
          class: "circular",
          viewBox: data2.svgViewBox ? data2.svgViewBox : "25 25 50 50"
        }, svg ? { innerHTML: svg } : {}), [
          vue$5.h("circle", {
            class: "path",
            cx: "50",
            cy: "50",
            r: "20",
            fill: "none"
          })
        ]);
        const spinnerText = data2.text ? vue$5.h("p", { class: "el-loading-text" }, [data2.text]) : void 0;
        return vue$5.h(vue$5.Transition, {
          name: "el-loading-fade",
          onAfterLeave: handleAfterLeave
        }, {
          default: vue$5.withCtx(() => [
            vue$5.withDirectives(vue$5.createVNode("div", {
              style: {
                backgroundColor: data2.background || ""
              },
              class: [
                "el-loading-mask",
                data2.customClass,
                data2.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              vue$5.h("div", {
                class: "el-loading-spinner"
              }, [spinner, spinnerText])
            ]), [[vue$5.vShow, data2.visible]])
          ])
        });
      };
    }
  };
  const vm = vue$5.createApp(elLoadingComponent).mount(document.createElement("div"));
  return __spreadProps(__spreadValues({}, vue$5.toRefs(data2)), {
    setText,
    close: close2,
    handleAfterLeave,
    vm,
    get $el() {
      return vm.$el;
    }
  });
}
loading$1.createLoadingComponent = createLoadingComponent;
Object.defineProperty(service$1, "__esModule", { value: true });
var vue$4 = require$$0$1;
var shared$1 = require$$1$1;
var core = core$7;
var dom = dom$8;
var popupManager = popupManager$3;
var loading = loading$1;
let fullscreenInstance = void 0;
const Loading = function(options = {}) {
  if (!core.isClient)
    return void 0;
  const resolved = resolveOptions(options);
  if (resolved.fullscreen && fullscreenInstance) {
    fullscreenInstance.close();
  }
  const instance = loading.createLoadingComponent(__spreadProps(__spreadValues({}, resolved), {
    closed: () => {
      var _a;
      (_a = resolved.closed) == null ? void 0 : _a.call(resolved);
      if (resolved.fullscreen)
        fullscreenInstance = void 0;
    }
  }));
  addStyle(resolved, resolved.parent, instance);
  addClassList(resolved, resolved.parent, instance);
  resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
  let loadingNumber = resolved.parent.getAttribute("loading-number");
  if (!loadingNumber) {
    loadingNumber = "1";
  } else {
    loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
  }
  resolved.parent.setAttribute("loading-number", loadingNumber);
  resolved.parent.appendChild(instance.$el);
  vue$4.nextTick(() => instance.visible.value = resolved.visible);
  if (resolved.fullscreen) {
    fullscreenInstance = instance;
  }
  return instance;
};
const resolveOptions = (options) => {
  var _a, _b, _c, _d;
  let target2;
  if (shared$1.isString(options.target)) {
    target2 = (_a = document.querySelector(options.target)) != null ? _a : document.body;
  } else {
    target2 = options.target || document.body;
  }
  return {
    parent: target2 === document.body || options.body ? document.body : target2,
    background: options.background || "",
    svg: options.svg || "",
    svgViewBox: options.svgViewBox || "",
    spinner: options.spinner || false,
    text: options.text || "",
    fullscreen: target2 === document.body && ((_b = options.fullscreen) != null ? _b : true),
    lock: (_c = options.lock) != null ? _c : false,
    customClass: options.customClass || "",
    visible: (_d = options.visible) != null ? _d : true,
    target: target2
  };
};
const addStyle = async (options, parent, instance) => {
  const maskStyle = {};
  if (options.fullscreen) {
    instance.originalPosition.value = dom.getStyle(document.body, "position");
    instance.originalOverflow.value = dom.getStyle(document.body, "overflow");
    maskStyle.zIndex = popupManager["default"].nextZIndex();
  } else if (options.parent === document.body) {
    instance.originalPosition.value = dom.getStyle(document.body, "position");
    await vue$4.nextTick();
    for (const property of ["top", "left"]) {
      const scroll = property === "top" ? "scrollTop" : "scrollLeft";
      maskStyle[property] = `${options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - parseInt(dom.getStyle(document.body, `margin-${property}`), 10)}px`;
    }
    for (const property of ["height", "width"]) {
      maskStyle[property] = `${options.target.getBoundingClientRect()[property]}px`;
    }
  } else {
    instance.originalPosition.value = dom.getStyle(parent, "position");
  }
  for (const [key2, value] of Object.entries(maskStyle)) {
    instance.$el.style[key2] = value;
  }
};
const addClassList = (options, parent, instance) => {
  if (instance.originalPosition.value !== "absolute" && instance.originalPosition.value !== "fixed") {
    dom.addClass(parent, "el-loading-parent--relative");
  } else {
    dom.removeClass(parent, "el-loading-parent--relative");
  }
  if (options.fullscreen && options.lock) {
    dom.addClass(parent, "el-loading-parent--hidden");
  } else {
    dom.removeClass(parent, "el-loading-parent--hidden");
  }
};
service$1.Loading = Loading;
var directive = {};
Object.defineProperty(directive, "__esModule", { value: true });
var vue$3 = require$$0$1;
var shared = require$$1$1;
var service = service$1;
const INSTANCE_KEY = Symbol("ElLoading");
const createInstance$1 = (el, binding) => {
  var _a, _b, _c, _d;
  const vm = binding.instance;
  const getBindingProp = (key2) => shared.isObject(binding.value) ? binding.value[key2] : void 0;
  const resolveExpression = (key2) => {
    const data2 = shared.isString(key2) && (vm == null ? void 0 : vm[key2]) || key2;
    if (data2)
      return vue$3.ref(data2);
    else
      return data2;
  };
  const getProp = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${shared.hyphenate(name)}`));
  const fullscreen = (_a = getBindingProp("fullscreen")) != null ? _a : binding.modifiers.fullscreen;
  const options = {
    text: getProp("text"),
    svg: getProp("svg"),
    svgViewBox: getProp("svgViewBox"),
    spinner: getProp("spinner"),
    background: getProp("background"),
    customClass: getProp("customClass"),
    fullscreen,
    target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
    body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
    lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
  };
  el[INSTANCE_KEY] = {
    options,
    instance: service.Loading(options)
  };
};
const updateOptions = (newOptions, originalOptions) => {
  for (const key2 of Object.keys(originalOptions)) {
    if (vue$3.isRef(originalOptions[key2]))
      originalOptions[key2].value = newOptions[key2];
  }
};
const vLoading = {
  mounted(el, binding) {
    if (binding.value) {
      createInstance$1(el, binding);
    }
  },
  updated(el, binding) {
    const instance = el[INSTANCE_KEY];
    if (binding.oldValue !== binding.value) {
      if (binding.value && !binding.oldValue) {
        createInstance$1(el, binding);
      } else if (binding.value && binding.oldValue) {
        if (shared.isObject(binding.value))
          updateOptions(binding.value, instance.options);
      } else {
        instance == null ? void 0 : instance.instance.close();
      }
    }
  },
  unmounted(el) {
    var _a;
    (_a = el[INSTANCE_KEY]) == null ? void 0 : _a.instance.close();
  }
};
directive.vLoading = vLoading;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var service2 = service$1;
  var directive$12 = directive;
  const ElLoading = {
    install(app) {
      app.directive("loading", directive$12.vLoading);
      app.config.globalProperties.$loading = service2.Loading;
    },
    directive: directive$12.vLoading,
    service: service2.Loading
  };
  const ElLoadingDirective = directive$12.vLoading;
  const ElLoadingService = service2.Loading;
  exports.ElLoading = ElLoading;
  exports.ElLoadingDirective = ElLoadingDirective;
  exports.ElLoadingService = ElLoadingService;
  exports["default"] = ElLoading;
})(loading$2);
var message$2 = {};
var messageMethod = {};
var message2 = {};
var message_vue_vue_type_script_lang = {};
var message$1 = {};
Object.defineProperty(message$1, "__esModule", { value: true });
var props$3 = props$N;
const messageTypes = ["success", "info", "warning", "error"];
const messageProps = props$3.buildProps({
  customClass: {
    type: String,
    default: ""
  },
  center: {
    type: Boolean,
    default: false
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 3e3
  },
  icon: {
    type: props$3.definePropType([String, Object]),
    default: ""
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: props$3.definePropType([String, Object]),
    default: ""
  },
  onClose: {
    type: props$3.definePropType(Function),
    required: false
  },
  showClose: {
    type: Boolean,
    default: false
  },
  type: {
    type: String,
    values: messageTypes,
    default: "info"
  },
  offset: {
    type: Number,
    default: 20
  },
  zIndex: {
    type: Number,
    default: 0
  },
  grouping: {
    type: Boolean,
    default: false
  },
  repeatNum: {
    type: Number,
    default: 1
  }
});
const messageEmits = {
  destroy: () => true
};
message$1.messageEmits = messageEmits;
message$1.messageProps = messageProps;
message$1.messageTypes = messageTypes;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var aria2 = aria$5;
  var index2 = badge$2;
  var index$110 = icon$4;
  var icon3 = icon$2;
  var message3 = message$1;
  var script2 = vue2.defineComponent({
    name: "ElMessage",
    components: __spreadValues({
      ElBadge: index2.ElBadge,
      ElIcon: index$110.ElIcon
    }, icon3.TypeComponents),
    props: message3.messageProps,
    emits: message3.messageEmits,
    setup(props2) {
      const visible = vue2.ref(false);
      const badgeType = vue2.ref(props2.type ? props2.type === "error" ? "danger" : props2.type : "info");
      let stopTimer = void 0;
      const typeClass = vue2.computed(() => {
        const type4 = props2.type;
        return type4 && icon3.TypeComponentsMap[type4] ? `el-message-icon--${type4}` : "";
      });
      const iconComponent = vue2.computed(() => {
        return props2.icon || icon3.TypeComponentsMap[props2.type] || "";
      });
      const customStyle = vue2.computed(() => ({
        top: `${props2.offset}px`,
        zIndex: props2.zIndex
      }));
      function startTimer() {
        if (props2.duration > 0) {
          ({ stop: stopTimer } = core2.useTimeoutFn(() => {
            if (visible.value)
              close2();
          }, props2.duration));
        }
      }
      function clearTimer() {
        stopTimer == null ? void 0 : stopTimer();
      }
      function close2() {
        visible.value = false;
      }
      function keydown({ code: code2 }) {
        if (code2 === aria2.EVENT_CODE.esc) {
          if (visible.value) {
            close2();
          }
        } else {
          startTimer();
        }
      }
      vue2.onMounted(() => {
        startTimer();
        visible.value = true;
      });
      vue2.watch(() => props2.repeatNum, () => {
        clearTimer();
        startTimer();
      });
      core2.useEventListener(document, "keydown", keydown);
      return {
        typeClass,
        iconComponent,
        customStyle,
        visible,
        badgeType,
        close: close2,
        clearTimer,
        startTimer
      };
    }
  });
  exports["default"] = script2;
})(message_vue_vue_type_script_lang);
var message_vue_vue_type_template_id_031967c2_lang = {};
Object.defineProperty(message_vue_vue_type_template_id_031967c2_lang, "__esModule", { value: true });
var vue$2 = require$$0$1;
const _hoisted_1$2 = ["id"];
const _hoisted_2$2 = {
  key: 0,
  class: "el-message__content"
};
const _hoisted_3$2 = ["innerHTML"];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_badge = vue$2.resolveComponent("el-badge");
  const _component_el_icon = vue$2.resolveComponent("el-icon");
  const _component_close = vue$2.resolveComponent("close");
  return vue$2.openBlock(), vue$2.createBlock(vue$2.Transition, {
    name: "el-message-fade",
    onBeforeLeave: _ctx.onClose,
    onAfterLeave: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("destroy"))
  }, {
    default: vue$2.withCtx(() => [
      vue$2.withDirectives(vue$2.createElementVNode("div", {
        id: _ctx.id,
        class: vue$2.normalizeClass([
          "el-message",
          _ctx.type && !_ctx.icon ? `el-message--${_ctx.type}` : "",
          _ctx.center ? "is-center" : "",
          _ctx.showClose ? "is-closable" : "",
          _ctx.customClass
        ]),
        style: vue$2.normalizeStyle(_ctx.customStyle),
        role: "alert",
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args))
      }, [
        _ctx.repeatNum > 1 ? (vue$2.openBlock(), vue$2.createBlock(_component_el_badge, {
          key: 0,
          value: _ctx.repeatNum,
          type: _ctx.badgeType,
          class: "el-message__badge"
        }, null, 8, ["value", "type"])) : vue$2.createCommentVNode("v-if", true),
        _ctx.iconComponent ? (vue$2.openBlock(), vue$2.createBlock(_component_el_icon, {
          key: 1,
          class: vue$2.normalizeClass(["el-message__icon", _ctx.typeClass])
        }, {
          default: vue$2.withCtx(() => [
            (vue$2.openBlock(), vue$2.createBlock(vue$2.resolveDynamicComponent(_ctx.iconComponent)))
          ]),
          _: 1
        }, 8, ["class"])) : vue$2.createCommentVNode("v-if", true),
        vue$2.renderSlot(_ctx.$slots, "default", {}, () => [
          !_ctx.dangerouslyUseHTMLString ? (vue$2.openBlock(), vue$2.createElementBlock("p", _hoisted_2$2, vue$2.toDisplayString(_ctx.message), 1)) : (vue$2.openBlock(), vue$2.createElementBlock(vue$2.Fragment, { key: 1 }, [
            vue$2.createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
            vue$2.createElementVNode("p", {
              class: "el-message__content",
              innerHTML: _ctx.message
            }, null, 8, _hoisted_3$2)
          ], 2112))
        ]),
        _ctx.showClose ? (vue$2.openBlock(), vue$2.createBlock(_component_el_icon, {
          key: 2,
          class: "el-message__closeBtn",
          onClick: vue$2.withModifiers(_ctx.close, ["stop"])
        }, {
          default: vue$2.withCtx(() => [
            vue$2.createVNode(_component_close)
          ]),
          _: 1
        }, 8, ["onClick"])) : vue$2.createCommentVNode("v-if", true)
      ], 46, _hoisted_1$2), [
        [vue$2.vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }, 8, ["onBeforeLeave"]);
}
message_vue_vue_type_template_id_031967c2_lang.render = render$2;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var message_vue_vue_type_script_lang$1 = message_vue_vue_type_script_lang;
  var message_vue_vue_type_template_id_031967c2_lang$1 = message_vue_vue_type_template_id_031967c2_lang;
  message_vue_vue_type_script_lang$1["default"].render = message_vue_vue_type_template_id_031967c2_lang$1.render;
  message_vue_vue_type_script_lang$1["default"].__file = "packages/components/message/src/message.vue";
  exports["default"] = message_vue_vue_type_script_lang$1["default"];
})(message2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var popupManager2 = popupManager$3;
  var isServer2 = isServer$8;
  var error2 = error$5;
  var message$1$1 = message$1;
  var message_vue_vue_type_script_lang$1 = message_vue_vue_type_script_lang;
  const instances2 = [];
  let seed = 1;
  const message3 = function(options = {}) {
    if (isServer2["default"])
      return { close: () => void 0 };
    if (!vue2.isVNode(options) && typeof options === "object" && options.grouping && !vue2.isVNode(options.message) && instances2.length) {
      const tempVm = instances2.find((item2) => {
        var _a, _b, _c;
        return `${(_b = (_a = item2.vm.props) == null ? void 0 : _a.message) != null ? _b : ""}` === `${(_c = options.message) != null ? _c : ""}`;
      });
      if (tempVm) {
        tempVm.vm.component.props.repeatNum += 1;
        tempVm.vm.component.props.type = options == null ? void 0 : options.type;
        return {
          close: () => vm.component.proxy.visible = false
        };
      }
    }
    if (typeof options === "string" || vue2.isVNode(options)) {
      options = { message: options };
    }
    let verticalOffset = options.offset || 20;
    instances2.forEach(({ vm: vm2 }) => {
      var _a;
      verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + 16;
    });
    verticalOffset += 16;
    const id = `message_${seed++}`;
    const userOnClose = options.onClose;
    const props2 = __spreadProps(__spreadValues({
      zIndex: popupManager2["default"].nextZIndex(),
      offset: verticalOffset
    }, options), {
      id,
      onClose: () => {
        close2(id, userOnClose);
      }
    });
    let appendTo = document.body;
    if (options.appendTo instanceof HTMLElement) {
      appendTo = options.appendTo;
    } else if (typeof options.appendTo === "string") {
      appendTo = document.querySelector(options.appendTo);
    }
    if (!(appendTo instanceof HTMLElement)) {
      error2.debugWarn("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body.");
      appendTo = document.body;
    }
    const container2 = document.createElement("div");
    container2.className = `container_${id}`;
    const message22 = props2.message;
    const vm = vue2.createVNode(message_vue_vue_type_script_lang$1["default"], props2, vue2.isVNode(props2.message) ? { default: () => message22 } : null);
    vm.props.onDestroy = () => {
      vue2.render(null, container2);
    };
    vue2.render(vm, container2);
    instances2.push({ vm });
    appendTo.appendChild(container2.firstElementChild);
    return {
      close: () => vm.component.proxy.visible = false
    };
  };
  message$1$1.messageTypes.forEach((type4) => {
    message3[type4] = (options = {}) => {
      if (typeof options === "string" || vue2.isVNode(options)) {
        options = {
          message: options
        };
      }
      return message3(__spreadProps(__spreadValues({}, options), {
        type: type4
      }));
    };
  });
  function close2(id, userOnClose) {
    const idx = instances2.findIndex(({ vm: vm2 }) => id === vm2.component.props.id);
    if (idx === -1)
      return;
    const { vm } = instances2[idx];
    if (!vm)
      return;
    userOnClose == null ? void 0 : userOnClose(vm);
    const removedHeight = vm.el.offsetHeight;
    instances2.splice(idx, 1);
    const len = instances2.length;
    if (len < 1)
      return;
    for (let i = idx; i < len; i++) {
      const pos = parseInt(instances2[i].vm.el.style["top"], 10) - removedHeight - 16;
      instances2[i].vm.component.props.offset = pos;
    }
  }
  function closeAll() {
    var _a;
    for (let i = instances2.length - 1; i >= 0; i--) {
      const instance = instances2[i].vm.component;
      (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.close();
    }
  }
  message3.closeAll = closeAll;
  exports.close = close2;
  exports.closeAll = closeAll;
  exports["default"] = message3;
})(messageMethod);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var messageMethod$1 = messageMethod;
  var message3 = message$1;
  const ElMessage = withInstall2.withInstallFunction(messageMethod$1["default"], "$message");
  exports.messageEmits = message3.messageEmits;
  exports.messageProps = message3.messageProps;
  exports.messageTypes = message3.messageTypes;
  exports.ElMessage = ElMessage;
  exports["default"] = ElMessage;
})(message$2);
var messageBox$1 = {};
var messageBox = {};
var src = {};
var index_vue_vue_type_script_lang = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var index$110 = button$5;
  var index$22 = input$2;
  var index$32 = overlay$2;
  var popupManager2 = popupManager$3;
  var dom2 = dom$8;
  var aria2 = aria$5;
  var validators2 = validators$6;
  var index$42 = icon$4;
  var icon3 = icon$2;
  var index2 = trapFocus;
  var index$52 = useLocale$1;
  var index$62 = useModal$1;
  var index$72 = usePreventGlobal$1;
  var index$82 = useLockscreen$1;
  var index$92 = useRestoreActive$1;
  var script2 = vue2.defineComponent({
    name: "ElMessageBox",
    directives: {
      TrapFocus: index2["default"]
    },
    components: __spreadValues({
      ElButton: index$110.ElButton,
      ElInput: index$22.ElInput,
      ElOverlay: index$32.ElOverlay,
      ElIcon: index$42.ElIcon
    }, icon3.TypeComponents),
    inheritAttrs: false,
    props: {
      buttonSize: {
        type: String,
        validator: validators2.isValidComponentSize
      },
      modal: {
        type: Boolean,
        default: true
      },
      lockScroll: {
        type: Boolean,
        default: true
      },
      showClose: {
        type: Boolean,
        default: true
      },
      closeOnClickModal: {
        type: Boolean,
        default: true
      },
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },
      closeOnHashChange: {
        type: Boolean,
        default: true
      },
      center: Boolean,
      roundButton: {
        default: false,
        type: Boolean
      },
      container: {
        type: String,
        default: "body"
      },
      boxType: {
        type: String,
        default: ""
      }
    },
    emits: ["vanish", "action"],
    setup(props2, { emit }) {
      const { t } = index$52.useLocale();
      const visible = vue2.ref(false);
      const state = vue2.reactive({
        beforeClose: null,
        callback: null,
        cancelButtonText: "",
        cancelButtonClass: "",
        confirmButtonText: "",
        confirmButtonClass: "",
        customClass: "",
        customStyle: {},
        dangerouslyUseHTMLString: false,
        distinguishCancelAndClose: false,
        icon: "",
        inputPattern: null,
        inputPlaceholder: "",
        inputType: "text",
        inputValue: null,
        inputValidator: null,
        inputErrorMessage: "",
        message: null,
        modalFade: true,
        modalClass: "",
        showCancelButton: false,
        showConfirmButton: true,
        type: "",
        title: void 0,
        showInput: false,
        action: "",
        confirmButtonLoading: false,
        cancelButtonLoading: false,
        confirmButtonDisabled: false,
        editorErrorMessage: "",
        validateError: false,
        zIndex: popupManager2["default"].nextZIndex()
      });
      const typeClass = vue2.computed(() => {
        const type4 = state.type;
        return type4 && icon3.TypeComponentsMap[type4] ? `el-message-box-icon--${type4}` : "";
      });
      const iconComponent = vue2.computed(() => state.icon || icon3.TypeComponentsMap[state.type] || "");
      const hasMessage = vue2.computed(() => !!state.message);
      const inputRef = vue2.ref(null);
      const confirmRef = vue2.ref(null);
      const confirmButtonClasses = vue2.computed(() => state.confirmButtonClass);
      vue2.watch(() => state.inputValue, async (val) => {
        await vue2.nextTick();
        if (props2.boxType === "prompt" && val !== null) {
          validate();
        }
      }, { immediate: true });
      vue2.watch(() => visible.value, (val) => {
        if (val) {
          if (props2.boxType === "alert" || props2.boxType === "confirm") {
            vue2.nextTick().then(() => {
              var _a, _b, _c;
              (_c = (_b = (_a = confirmRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus) == null ? void 0 : _c.call(_b);
            });
          }
          state.zIndex = popupManager2["default"].nextZIndex();
        }
        if (props2.boxType !== "prompt")
          return;
        if (val) {
          vue2.nextTick().then(() => {
            if (inputRef.value && inputRef.value.$el) {
              getInputElement().focus();
            }
          });
        } else {
          state.editorErrorMessage = "";
          state.validateError = false;
        }
      });
      vue2.onMounted(async () => {
        await vue2.nextTick();
        if (props2.closeOnHashChange) {
          dom2.on(window, "hashchange", doClose);
        }
      });
      vue2.onBeforeUnmount(() => {
        if (props2.closeOnHashChange) {
          dom2.off(window, "hashchange", doClose);
        }
      });
      function doClose() {
        if (!visible.value)
          return;
        visible.value = false;
        vue2.nextTick(() => {
          if (state.action)
            emit("action", state.action);
        });
      }
      const handleWrapperClick = () => {
        if (props2.closeOnClickModal) {
          handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
        }
      };
      const handleInputEnter = () => {
        if (state.inputType !== "textarea") {
          return handleAction("confirm");
        }
      };
      const handleAction = (action) => {
        var _a;
        if (props2.boxType === "prompt" && action === "confirm" && !validate()) {
          return;
        }
        state.action = action;
        if (state.beforeClose) {
          (_a = state.beforeClose) == null ? void 0 : _a.call(state, action, state, doClose);
        } else {
          doClose();
        }
      };
      const validate = () => {
        if (props2.boxType === "prompt") {
          const inputPattern = state.inputPattern;
          if (inputPattern && !inputPattern.test(state.inputValue || "")) {
            state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
            state.validateError = true;
            return false;
          }
          const inputValidator = state.inputValidator;
          if (typeof inputValidator === "function") {
            const validateResult = inputValidator(state.inputValue);
            if (validateResult === false) {
              state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
              state.validateError = true;
              return false;
            }
            if (typeof validateResult === "string") {
              state.editorErrorMessage = validateResult;
              state.validateError = true;
              return false;
            }
          }
        }
        state.editorErrorMessage = "";
        state.validateError = false;
        return true;
      };
      const getInputElement = () => {
        const inputRefs = inputRef.value.$refs;
        return inputRefs.input || inputRefs.textarea;
      };
      const handleClose = () => {
        handleAction("close");
      };
      if (props2.closeOnPressEscape) {
        index$62.useModal({
          handleClose
        }, visible);
      } else {
        index$72.usePreventGlobal(visible, "keydown", (e) => e.code === aria2.EVENT_CODE.esc);
      }
      if (props2.lockScroll) {
        index$82.useLockscreen(visible);
      }
      index$92.useRestoreActive(visible);
      return __spreadProps(__spreadValues({}, vue2.toRefs(state)), {
        visible,
        hasMessage,
        typeClass,
        iconComponent,
        confirmButtonClasses,
        inputRef,
        confirmRef,
        doClose,
        handleClose,
        handleWrapperClick,
        handleInputEnter,
        handleAction,
        t
      });
    }
  });
  exports["default"] = script2;
})(index_vue_vue_type_script_lang);
var index_vue_vue_type_template_id_7035e868_lang = {};
Object.defineProperty(index_vue_vue_type_template_id_7035e868_lang, "__esModule", { value: true });
var vue$1 = require$$0$1;
const _hoisted_1$1 = ["aria-label"];
const _hoisted_2$1 = {
  key: 0,
  class: "el-message-box__header"
};
const _hoisted_3$1 = { class: "el-message-box__title" };
const _hoisted_4$1 = { class: "el-message-box__content" };
const _hoisted_5$1 = { class: "el-message-box__container" };
const _hoisted_6 = {
  key: 1,
  class: "el-message-box__message"
};
const _hoisted_7 = { key: 0 };
const _hoisted_8 = ["innerHTML"];
const _hoisted_9 = { class: "el-message-box__input" };
const _hoisted_10 = { class: "el-message-box__btns" };
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue$1.resolveComponent("el-icon");
  const _component_close = vue$1.resolveComponent("close");
  const _component_el_input = vue$1.resolveComponent("el-input");
  const _component_el_button = vue$1.resolveComponent("el-button");
  const _component_el_overlay = vue$1.resolveComponent("el-overlay");
  const _directive_trap_focus = vue$1.resolveDirective("trap-focus");
  return vue$1.openBlock(), vue$1.createBlock(vue$1.Transition, {
    name: "fade-in-linear",
    onAfterLeave: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("vanish"))
  }, {
    default: vue$1.withCtx(() => [
      vue$1.withDirectives(vue$1.createVNode(_component_el_overlay, {
        "z-index": _ctx.zIndex,
        "overlay-class": ["is-message-box", _ctx.modalClass],
        mask: _ctx.modal,
        onClick: vue$1.withModifiers(_ctx.handleWrapperClick, ["self"])
      }, {
        default: vue$1.withCtx(() => [
          vue$1.withDirectives(vue$1.createElementVNode("div", {
            ref: "root",
            "aria-label": _ctx.title || "dialog",
            "aria-modal": "true",
            class: vue$1.normalizeClass([
              "el-message-box",
              _ctx.customClass,
              { "el-message-box--center": _ctx.center }
            ]),
            style: vue$1.normalizeStyle(_ctx.customStyle)
          }, [
            _ctx.title !== null && _ctx.title !== void 0 ? (vue$1.openBlock(), vue$1.createElementBlock("div", _hoisted_2$1, [
              vue$1.createElementVNode("div", _hoisted_3$1, [
                _ctx.iconComponent && _ctx.center ? (vue$1.openBlock(), vue$1.createBlock(_component_el_icon, {
                  key: 0,
                  class: vue$1.normalizeClass(["el-message-box__status", _ctx.typeClass])
                }, {
                  default: vue$1.withCtx(() => [
                    (vue$1.openBlock(), vue$1.createBlock(vue$1.resolveDynamicComponent(_ctx.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : vue$1.createCommentVNode("v-if", true),
                vue$1.createElementVNode("span", null, vue$1.toDisplayString(_ctx.title), 1)
              ]),
              _ctx.showClose ? (vue$1.openBlock(), vue$1.createElementBlock("button", {
                key: 0,
                type: "button",
                class: "el-message-box__headerbtn",
                "aria-label": "Close",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                onKeydown: _cache[1] || (_cache[1] = vue$1.withKeys(vue$1.withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
              }, [
                vue$1.createVNode(_component_el_icon, { class: "el-message-box__close" }, {
                  default: vue$1.withCtx(() => [
                    vue$1.createVNode(_component_close)
                  ]),
                  _: 1
                })
              ], 32)) : vue$1.createCommentVNode("v-if", true)
            ])) : vue$1.createCommentVNode("v-if", true),
            vue$1.createElementVNode("div", _hoisted_4$1, [
              vue$1.createElementVNode("div", _hoisted_5$1, [
                _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (vue$1.openBlock(), vue$1.createBlock(_component_el_icon, {
                  key: 0,
                  class: vue$1.normalizeClass(["el-message-box__status", _ctx.typeClass])
                }, {
                  default: vue$1.withCtx(() => [
                    (vue$1.openBlock(), vue$1.createBlock(vue$1.resolveDynamicComponent(_ctx.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : vue$1.createCommentVNode("v-if", true),
                _ctx.hasMessage ? (vue$1.openBlock(), vue$1.createElementBlock("div", _hoisted_6, [
                  vue$1.renderSlot(_ctx.$slots, "default", {}, () => [
                    !_ctx.dangerouslyUseHTMLString ? (vue$1.openBlock(), vue$1.createElementBlock("p", _hoisted_7, vue$1.toDisplayString(_ctx.message), 1)) : (vue$1.openBlock(), vue$1.createElementBlock("p", {
                      key: 1,
                      innerHTML: _ctx.message
                    }, null, 8, _hoisted_8))
                  ])
                ])) : vue$1.createCommentVNode("v-if", true)
              ]),
              vue$1.withDirectives(vue$1.createElementVNode("div", _hoisted_9, [
                vue$1.createVNode(_component_el_input, {
                  ref: "inputRef",
                  modelValue: _ctx.inputValue,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                  type: _ctx.inputType,
                  placeholder: _ctx.inputPlaceholder,
                  class: vue$1.normalizeClass({ invalid: _ctx.validateError }),
                  onKeydown: vue$1.withKeys(vue$1.withModifiers(_ctx.handleInputEnter, ["prevent"]), ["enter"])
                }, null, 8, ["modelValue", "type", "placeholder", "class", "onKeydown"]),
                vue$1.createElementVNode("div", {
                  class: "el-message-box__errormsg",
                  style: vue$1.normalizeStyle({
                    visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                  })
                }, vue$1.toDisplayString(_ctx.editorErrorMessage), 5)
              ], 512), [
                [vue$1.vShow, _ctx.showInput]
              ])
            ]),
            vue$1.createElementVNode("div", _hoisted_10, [
              _ctx.showCancelButton ? (vue$1.openBlock(), vue$1.createBlock(_component_el_button, {
                key: 0,
                loading: _ctx.cancelButtonLoading,
                class: vue$1.normalizeClass([_ctx.cancelButtonClass]),
                round: _ctx.roundButton,
                size: _ctx.buttonSize || "small",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                onKeydown: _cache[4] || (_cache[4] = vue$1.withKeys(vue$1.withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
              }, {
                default: vue$1.withCtx(() => [
                  vue$1.createTextVNode(vue$1.toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                ]),
                _: 1
              }, 8, ["loading", "class", "round", "size"])) : vue$1.createCommentVNode("v-if", true),
              vue$1.withDirectives(vue$1.createVNode(_component_el_button, {
                ref: "confirmRef",
                type: "primary",
                plain: "",
                loading: _ctx.confirmButtonLoading,
                class: vue$1.normalizeClass([_ctx.confirmButtonClasses]),
                round: _ctx.roundButton,
                disabled: _ctx.confirmButtonDisabled,
                size: _ctx.buttonSize || "small",
                onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                onKeydown: _cache[6] || (_cache[6] = vue$1.withKeys(vue$1.withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
              }, {
                default: vue$1.withCtx(() => [
                  vue$1.createTextVNode(vue$1.toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                ]),
                _: 1
              }, 8, ["loading", "class", "round", "disabled", "size"]), [
                [vue$1.vShow, _ctx.showConfirmButton]
              ])
            ])
          ], 14, _hoisted_1$1), [
            [_directive_trap_focus]
          ])
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask", "onClick"]), [
        [vue$1.vShow, _ctx.visible]
      ])
    ]),
    _: 3
  });
}
index_vue_vue_type_template_id_7035e868_lang.render = render$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_vue_vue_type_script_lang$12 = index_vue_vue_type_script_lang;
  var index_vue_vue_type_template_id_7035e868_lang$1 = index_vue_vue_type_template_id_7035e868_lang;
  index_vue_vue_type_script_lang$12["default"].render = index_vue_vue_type_template_id_7035e868_lang$1.render;
  index_vue_vue_type_script_lang$12["default"].__file = "packages/components/message-box/src/index.vue";
  exports["default"] = index_vue_vue_type_script_lang$12["default"];
})(src);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var shared2 = require$$1$1;
  var isServer2 = isServer$8;
  var index_vue_vue_type_script_lang$12 = index_vue_vue_type_script_lang;
  const messageInstance = /* @__PURE__ */ new Map();
  const initInstance = (props2, container2) => {
    const vnode2 = vue2.h(index_vue_vue_type_script_lang$12["default"], props2);
    vue2.render(vnode2, container2);
    document.body.appendChild(container2.firstElementChild);
    return vnode2.component;
  };
  const genContainer = () => {
    return document.createElement("div");
  };
  const showMessage = (options) => {
    const container2 = genContainer();
    options.onVanish = () => {
      vue2.render(null, container2);
      messageInstance.delete(vm);
    };
    options.onAction = (action) => {
      const currentMsg = messageInstance.get(vm);
      let resolve2;
      if (options.showInput) {
        resolve2 = { value: vm.inputValue, action };
      } else {
        resolve2 = action;
      }
      if (options.callback) {
        options.callback(resolve2, instance.proxy);
      } else {
        if (action === "cancel" || action === "close") {
          if (options.distinguishCancelAndClose && action !== "cancel") {
            currentMsg.reject("close");
          } else {
            currentMsg.reject("cancel");
          }
        } else {
          currentMsg.resolve(resolve2);
        }
      }
    };
    const instance = initInstance(options, container2);
    const vm = instance.proxy;
    for (const prop in options) {
      if (shared2.hasOwn(options, prop) && !shared2.hasOwn(vm.$props, prop)) {
        vm[prop] = options[prop];
      }
    }
    vue2.watch(() => vm.message, (newVal, oldVal) => {
      if (vue2.isVNode(newVal)) {
        instance.slots.default = () => [newVal];
      } else if (vue2.isVNode(oldVal) && !vue2.isVNode(newVal)) {
        delete instance.slots.default;
      }
    }, {
      immediate: true
    });
    vm.visible = true;
    return vm;
  };
  function MessageBox(options) {
    if (isServer2["default"])
      return;
    let callback;
    if (shared2.isString(options) || vue2.isVNode(options)) {
      options = {
        message: options
      };
    } else {
      callback = options.callback;
    }
    return new Promise((resolve2, reject) => {
      const vm = showMessage(options);
      messageInstance.set(vm, {
        options,
        callback,
        resolve: resolve2,
        reject
      });
    });
  }
  MessageBox.alert = (message3, title, options) => {
    if (typeof title === "object") {
      options = title;
      title = "";
    } else if (title === void 0) {
      title = "";
    }
    return MessageBox(Object.assign({
      title,
      message: message3,
      type: "",
      closeOnPressEscape: false,
      closeOnClickModal: false
    }, options, {
      boxType: "alert"
    }));
  };
  MessageBox.confirm = (message3, title, options) => {
    if (typeof title === "object") {
      options = title;
      title = "";
    } else if (title === void 0) {
      title = "";
    }
    return MessageBox(Object.assign({
      title,
      message: message3,
      type: "",
      showCancelButton: true
    }, options, {
      boxType: "confirm"
    }));
  };
  MessageBox.prompt = (message3, title, options) => {
    if (typeof title === "object") {
      options = title;
      title = "";
    } else if (title === void 0) {
      title = "";
    }
    return MessageBox(Object.assign({
      title,
      message: message3,
      showCancelButton: true,
      showInput: true,
      type: ""
    }, options, {
      boxType: "prompt"
    }));
  };
  MessageBox.close = () => {
    messageInstance.forEach((_2, vm) => {
      vm.doClose();
    });
    messageInstance.clear();
  };
  exports["default"] = MessageBox;
})(messageBox);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var messageBox$12 = messageBox;
  const _MessageBox = messageBox$12["default"];
  _MessageBox.install = (app) => {
    app.config.globalProperties.$msgbox = _MessageBox;
    app.config.globalProperties.$messageBox = _MessageBox;
    app.config.globalProperties.$alert = _MessageBox.alert;
    app.config.globalProperties.$confirm = _MessageBox.confirm;
    app.config.globalProperties.$prompt = _MessageBox.prompt;
  };
  const ElMessageBox = _MessageBox;
  exports.ElMessageBox = ElMessageBox;
  exports["default"] = _MessageBox;
})(messageBox$1);
var notification$2 = {};
var notify = {};
var notification2 = {};
var notification_vue_vue_type_script_lang = {};
var notification$1 = {};
Object.defineProperty(notification$1, "__esModule", { value: true });
var props$2 = props$N;
const notificationTypes = [
  "success",
  "info",
  "warning",
  "error"
];
const notificationProps = props$2.buildProps({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: props$2.definePropType([String, Object]),
    default: ""
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: props$2.definePropType([String, Object]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: props$2.definePropType(Function),
    default: () => void 0
  },
  onClose: {
    type: props$2.definePropType(Function),
    required: true
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...notificationTypes, ""],
    default: ""
  },
  zIndex: {
    type: Number,
    default: 0
  }
});
const notificationEmits = {
  destroy: () => true
};
notification$1.notificationEmits = notificationEmits;
notification$1.notificationProps = notificationProps;
notification$1.notificationTypes = notificationTypes;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var core2 = core$7;
  var aria2 = aria$5;
  var index2 = icon$4;
  var icon3 = icon$2;
  var notification3 = notification$1;
  var script2 = vue2.defineComponent({
    name: "ElNotification",
    components: __spreadValues({
      ElIcon: index2.ElIcon
    }, icon3.TypeComponents),
    props: notification3.notificationProps,
    emits: notification3.notificationEmits,
    setup(props2) {
      const visible = vue2.ref(false);
      let timer2 = void 0;
      const typeClass = vue2.computed(() => {
        const type4 = props2.type;
        return type4 && icon3.TypeComponentsMap[props2.type] ? `el-notification--${type4}` : "";
      });
      const iconComponent = vue2.computed(() => {
        return icon3.TypeComponentsMap[props2.type] || props2.icon || "";
      });
      const horizontalClass = vue2.computed(() => props2.position.endsWith("right") ? "right" : "left");
      const verticalProperty = vue2.computed(() => props2.position.startsWith("top") ? "top" : "bottom");
      const positionStyle = vue2.computed(() => {
        return {
          [verticalProperty.value]: `${props2.offset}px`,
          zIndex: props2.zIndex
        };
      });
      function startTimer() {
        if (props2.duration > 0) {
          ({ stop: timer2 } = core2.useTimeoutFn(() => {
            if (visible.value)
              close2();
          }, props2.duration));
        }
      }
      function clearTimer() {
        timer2 == null ? void 0 : timer2();
      }
      function close2() {
        visible.value = false;
      }
      function onKeydown({ code: code2 }) {
        if (code2 === aria2.EVENT_CODE.delete || code2 === aria2.EVENT_CODE.backspace) {
          clearTimer();
        } else if (code2 === aria2.EVENT_CODE.esc) {
          if (visible.value) {
            close2();
          }
        } else {
          startTimer();
        }
      }
      vue2.onMounted(() => {
        startTimer();
        visible.value = true;
      });
      core2.useEventListener(document, "keydown", onKeydown);
      return {
        horizontalClass,
        typeClass,
        iconComponent,
        positionStyle,
        visible,
        close: close2,
        clearTimer,
        startTimer
      };
    }
  });
  exports["default"] = script2;
})(notification_vue_vue_type_script_lang);
var notification_vue_vue_type_template_id_d6b81f36_lang = {};
Object.defineProperty(notification_vue_vue_type_template_id_d6b81f36_lang, "__esModule", { value: true });
var vue = require$$0$1;
const _hoisted_1 = ["id"];
const _hoisted_2 = { class: "el-notification__group" };
const _hoisted_3 = ["textContent"];
const _hoisted_4 = { key: 0 };
const _hoisted_5 = ["innerHTML"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = vue.resolveComponent("el-icon");
  const _component_close = vue.resolveComponent("close");
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "el-notification-fade",
    onBeforeLeave: _ctx.onClose,
    onAfterLeave: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("destroy"))
  }, {
    default: vue.withCtx(() => [
      vue.withDirectives(vue.createElementVNode("div", {
        id: _ctx.id,
        class: vue.normalizeClass(["el-notification", _ctx.customClass, _ctx.horizontalClass]),
        style: vue.normalizeStyle(_ctx.positionStyle),
        role: "alert",
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args)),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onClick && _ctx.onClick(...args))
      }, [
        _ctx.iconComponent ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
          key: 0,
          class: vue.normalizeClass(["el-notification__icon", _ctx.typeClass])
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.iconComponent)))
          ]),
          _: 1
        }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("div", _hoisted_2, [
          vue.createElementVNode("h2", {
            class: "el-notification__title",
            textContent: vue.toDisplayString(_ctx.title)
          }, null, 8, _hoisted_3),
          vue.withDirectives(vue.createElementVNode("div", {
            class: "el-notification__content",
            style: vue.normalizeStyle(!!_ctx.title ? void 0 : { margin: 0 })
          }, [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              !_ctx.dangerouslyUseHTMLString ? (vue.openBlock(), vue.createElementBlock("p", _hoisted_4, vue.toDisplayString(_ctx.message), 1)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                vue.createCommentVNode(" Caution here, message could've been compromized, nerver use user's input as message "),
                vue.createCommentVNode(" eslint-disable-next-line "),
                vue.createElementVNode("p", { innerHTML: _ctx.message }, null, 8, _hoisted_5)
              ], 2112))
            ])
          ], 4), [
            [vue.vShow, _ctx.message]
          ]),
          _ctx.showClose ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
            key: 0,
            class: "el-notification__closeBtn",
            onClick: vue.withModifiers(_ctx.close, ["stop"])
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(_component_close)
            ]),
            _: 1
          }, 8, ["onClick"])) : vue.createCommentVNode("v-if", true)
        ])
      ], 46, _hoisted_1), [
        [vue.vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }, 8, ["onBeforeLeave"]);
}
notification_vue_vue_type_template_id_d6b81f36_lang.render = render;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var notification_vue_vue_type_script_lang$1 = notification_vue_vue_type_script_lang;
  var notification_vue_vue_type_template_id_d6b81f36_lang$1 = notification_vue_vue_type_template_id_d6b81f36_lang;
  notification_vue_vue_type_script_lang$1["default"].render = notification_vue_vue_type_template_id_d6b81f36_lang$1.render;
  notification_vue_vue_type_script_lang$1["default"].__file = "packages/components/notification/src/notification.vue";
  exports["default"] = notification_vue_vue_type_script_lang$1["default"];
})(notification2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var vue2 = require$$0$1;
  var isServer2 = isServer$8;
  var popupManager2 = popupManager$3;
  var error2 = error$5;
  var notification3 = notification$1;
  var notification_vue_vue_type_script_lang$1 = notification_vue_vue_type_script_lang;
  const notifications = {
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    "bottom-right": []
  };
  const GAP_SIZE = 16;
  let seed = 1;
  const notify2 = function(options = {}) {
    if (isServer2["default"])
      return { close: () => void 0 };
    if (typeof options === "string" || vue2.isVNode(options)) {
      options = { message: options };
    }
    const position2 = options.position || "top-right";
    let verticalOffset = options.offset || 0;
    notifications[position2].forEach(({ vm: vm2 }) => {
      var _a;
      verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + GAP_SIZE;
    });
    verticalOffset += GAP_SIZE;
    const id = `notification_${seed++}`;
    const userOnClose = options.onClose;
    const props2 = __spreadProps(__spreadValues({
      zIndex: popupManager2["default"].nextZIndex(),
      offset: verticalOffset
    }, options), {
      id,
      onClose: () => {
        close2(id, position2, userOnClose);
      }
    });
    let appendTo = document.body;
    if (options.appendTo instanceof HTMLElement) {
      appendTo = options.appendTo;
    } else if (typeof options.appendTo === "string") {
      appendTo = document.querySelector(options.appendTo);
    }
    if (!(appendTo instanceof HTMLElement)) {
      error2.debugWarn("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body.");
      appendTo = document.body;
    }
    const container2 = document.createElement("div");
    const vm = vue2.createVNode(notification_vue_vue_type_script_lang$1["default"], props2, vue2.isVNode(props2.message) ? {
      default: () => props2.message
    } : null);
    vm.props.onDestroy = () => {
      vue2.render(null, container2);
    };
    vue2.render(vm, container2);
    notifications[position2].push({ vm });
    appendTo.appendChild(container2.firstElementChild);
    return {
      close: () => {
        vm.component.proxy.visible = false;
      }
    };
  };
  notification3.notificationTypes.forEach((type4) => {
    notify2[type4] = (options = {}) => {
      if (typeof options === "string" || vue2.isVNode(options)) {
        options = {
          message: options
        };
      }
      return notify2(__spreadProps(__spreadValues({}, options), {
        type: type4
      }));
    };
  });
  function close2(id, position2, userOnClose) {
    const orientedNotifications = notifications[position2];
    const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
      var _a;
      return ((_a = vm2.component) == null ? void 0 : _a.props.id) === id;
    });
    if (idx === -1)
      return;
    const { vm } = orientedNotifications[idx];
    if (!vm)
      return;
    userOnClose == null ? void 0 : userOnClose(vm);
    const removedHeight = vm.el.offsetHeight;
    const verticalPos = position2.split("-")[0];
    orientedNotifications.splice(idx, 1);
    const len = orientedNotifications.length;
    if (len < 1)
      return;
    for (let i = idx; i < len; i++) {
      const { el, component: component2 } = orientedNotifications[i].vm;
      const pos = parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
      component2.props.offset = pos;
    }
  }
  function closeAll() {
    for (const orientedNotifications of Object.values(notifications)) {
      orientedNotifications.forEach(({ vm }) => {
        vm.component.proxy.visible = false;
      });
    }
  }
  notify2.closeAll = closeAll;
  exports.close = close2;
  exports.closeAll = closeAll;
  exports["default"] = notify2;
})(notify);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var withInstall2 = withInstall$1;
  var notify$1 = notify;
  var notification3 = notification$1;
  const ElNotification = withInstall2.withInstallFunction(notify$1["default"], "$notify");
  exports.notificationEmits = notification3.notificationEmits;
  exports.notificationProps = notification3.notificationProps;
  exports.notificationTypes = notification3.notificationTypes;
  exports.ElNotification = ElNotification;
  exports["default"] = ElNotification;
})(notification$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index2 = infiniteScroll;
  var index$110 = loading$2;
  var index$22 = message$2;
  var index$32 = messageBox$1;
  var index$42 = notification$2;
  var index$52 = popover;
  var Plugins = [
    index2.ElInfiniteScroll,
    index$110.ElLoading,
    index$22.ElMessage,
    index$32.ElMessageBox,
    index$42.ElNotification,
    index$52.ElPopoverDirective
  ];
  exports["default"] = Plugins;
})(plugin);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var makeInstaller2 = makeInstaller$1;
  var component$1 = component;
  var plugin$1 = plugin;
  var installer = makeInstaller2.makeInstaller([...component$1["default"], ...plugin$1["default"]]);
  exports["default"] = installer;
})(defaults$e);
var components = {};
Object.defineProperty(components, "__esModule", { value: true });
var index = affix$2;
var index$1 = alert$2;
var index$2 = autocomplete;
var index$3 = avatar$2;
var index$4 = backtop$2;
var index$5 = badge$2;
var index$6 = breadcrumb$2;
var index$7 = button$5;
var index$8 = calendar$2;
var index$9 = card$2;
var index$a = carousel;
var index$b = cascader;
var index$c = cascaderPanel;
var index$d = checkTag;
var index$e = checkbox$1;
var index$f = col$2;
var index$g = collapse$1;
var index$h = collapseTransition$1;
var index$i = colorPicker;
var index$j = configProvider$3;
var index$k = container$1;
var index$l = datePicker$1;
var index$m = descriptions;
var index$n = dialog$3;
var index$o = divider$2;
var index$p = drawer$2;
var index$q = dropdown;
var index$r = empty$2;
var index$s = form$3;
var index$t = icon$4;
var index$u = image$2;
var index$v = imageViewer$2;
var index$w = input$2;
var index$x = inputNumber$2;
var index$y = link$2;
var index$z = menu$2;
var index$A = overlay$2;
var index$B = pageHeader$2;
var index$C = pagination$3;
var index$D = popconfirm$2;
var index$E = popper$3;
var index$G = progress$2;
var index$H = radio$5;
var index$I = rate$2;
var index$J = result$2;
var index$K = row$2;
var index$L = scrollbar$3;
var index$M = select$2;
var index$N = selectV2;
var index$O = skeleton$2;
var index$P = slider;
var index$Q = space$2;
var index$R = steps;
var index$S = _switch$2;
var index$T = table$1;
var index$U = tabs$2;
var index$V = tag$2;
var index$W = timePicker$1;
var index$X = timeSelect$1;
var index$Y = timeline;
var index$Z = tooltip;
var index$_ = transfer$1;
var index$$ = tree$2;
var index$10 = treeV2;
var index$11 = upload$1;
var index$12 = infiniteScroll;
var index$13 = loading$2;
var index$14 = message$2;
var index$15 = messageBox$1;
var index$16 = notification$2;
var index$17 = popover;
var affix = affix$1;
var alert = alert$1;
var avatar = avatar$1;
var backtop = backtop$1;
var badge = badge$1;
var breadcrumb = breadcrumb$1;
var breadcrumbItem = breadcrumbItem$1;
var button = button$4;
var calendar = calendar$1;
var card = card$1;
var types = types$2;
var config = config$2;
var col = col$1;
var configProvider = configProvider$2;
var useDialog = useDialog$2;
var dialog = dialog$2;
var divider = divider$1;
var drawer = drawer$1;
var empty = empty$1;
var icon = icon$3;
var image = image$1;
var imageViewer = imageViewer$1;
var input = input$1;
var inputNumber = inputNumber$1;
var link = link$1;
var menu = menu$1;
var menuItem = menuItem$1;
var menuItemGroup = menuItemGroup$1;
var subMenu = subMenu$1;
var overlay = overlay$1;
var pageHeader = pageHeader$1;
var pagination = pagination$2;
var popconfirm = popconfirm$1;
var defaults$5 = defaults$d;
var index$F = usePopper;
var popper = popper$2;
var trigger = trigger$2;
var arrow = arrow$2;
var progress = progress$1;
var radio = radio$4;
var radioGroup = radioGroup$1;
var radioButton = radioButton$1;
var rate = rate$1;
var result = result$1;
var row = row$1;
var util = util$g;
var scrollbar = scrollbar$2;
var bar = bar$1;
var token = token$4;
var token$1 = token$2;
var skeleton = skeleton$1;
var skeletonItem = skeletonItem$1;
var space = space$1;
var useSpace = useSpace$2;
var _switch = _switch$1;
var tabs = tabs$1;
var tabBar = tabBar$2;
var tabNav = tabNav$1;
var tabPane = tabPane$1;
var tag = tag$1;
var dateUtils = dateUtils$1;
var constant = constant$3;
var props = props$x;
var picker_vue_vue_type_script_lang = picker_vue_vue_type_script_lang$1;
var panelTimePick_vue_vue_type_script_lang = panelTimePick_vue_vue_type_script_lang$1;
var constants = constants$f;
var fixedSizeList = fixedSizeList$2;
var dynamicSizeList = dynamicSizeList$2;
var fixedSizeGrid = fixedSizeGrid$2;
var dynamicSizeGrid = dynamicSizeGrid$2;
var props$1 = props$c;
var message = message$1;
var notification = notification$1;
components.ElAffix = index.ElAffix;
components.ElAlert = index$1.ElAlert;
components.ElAutocomplete = index$2.ElAutocomplete;
components.ElAvatar = index$3.ElAvatar;
components.ElBacktop = index$4.ElBacktop;
components.ElBadge = index$5.ElBadge;
components.ElBreadcrumb = index$6.ElBreadcrumb;
components.ElBreadcrumbItem = index$6.ElBreadcrumbItem;
components.ElButton = index$7.ElButton;
components.ElButtonGroup = index$7.ElButtonGroup;
components.ElCalendar = index$8.ElCalendar;
components.ElCard = index$9.ElCard;
components.ElCarousel = index$a.ElCarousel;
components.ElCarouselItem = index$a.ElCarouselItem;
components.ElCascader = index$b.ElCascader;
components.ElCascaderPanel = index$c.ElCascaderPanel;
components.ElCheckTag = index$d.ElCheckTag;
components.ElCheckbox = index$e.ElCheckbox;
components.ElCheckboxButton = index$e.ElCheckboxButton;
components.ElCheckboxGroup = index$e.ElCheckboxGroup;
components.ElCol = index$f.ElCol;
components.ElCollapse = index$g.ElCollapse;
components.ElCollapseItem = index$g.ElCollapseItem;
components.ElCollapseTransition = index$h.ElCollapseTransition;
components.ElColorPicker = index$i.ElColorPicker;
components.ElConfigProvider = index$j.ElConfigProvider;
components.ElAside = index$k.ElAside;
components.ElContainer = index$k.ElContainer;
components.ElFooter = index$k.ElFooter;
components.ElHeader = index$k.ElHeader;
components.ElMain = index$k.ElMain;
components.ElDatePicker = index$l.ElDatePicker;
components.ElDescriptions = index$m.ElDescriptions;
components.ElDescriptionsItem = index$m.ElDescriptionsItem;
components.ElDialog = index$n.ElDialog;
components.ElDivider = index$o.ElDivider;
components.ElDrawer = index$p.ElDrawer;
components.ElDropdown = index$q.ElDropdown;
components.ElDropdownItem = index$q.ElDropdownItem;
components.ElDropdownMenu = index$q.ElDropdownMenu;
components.ElEmpty = index$r.ElEmpty;
components.ElForm = index$s.ElForm;
components.ElFormItem = index$s.ElFormItem;
components.ElIcon = index$t.ElIcon;
components.ElImage = index$u.ElImage;
components.ElImageViewer = index$v.ElImageViewer;
components.ElInput = index$w.ElInput;
components.ElInputNumber = index$x.ElInputNumber;
components.ElLink = index$y.ElLink;
components.ElMenu = index$z.ElMenu;
components.ElMenuItem = index$z.ElMenuItem;
components.ElMenuItemGroup = index$z.ElMenuItemGroup;
components.ElSubMenu = index$z.ElSubMenu;
components.ElOverlay = index$A.ElOverlay;
components.ElPageHeader = index$B.ElPageHeader;
components.ElPagination = index$C.ElPagination;
components.ElPopconfirm = index$D.ElPopconfirm;
components.ElPopper = index$E.ElPopper;
components.ElProgress = index$G.ElProgress;
components.ElRadio = index$H.ElRadio;
components.ElRadioButton = index$H.ElRadioButton;
components.ElRadioGroup = index$H.ElRadioGroup;
components.ElRate = index$I.ElRate;
components.ElResult = index$J.ElResult;
components.ElRow = index$K.ElRow;
components.ElScrollbar = index$L.ElScrollbar;
components.ElOption = index$M.ElOption;
components.ElOptionGroup = index$M.ElOptionGroup;
components.ElSelect = index$M.ElSelect;
components.ElSelectV2 = index$N.ElSelectV2;
components.ElSkeleton = index$O.ElSkeleton;
components.ElSkeletonItem = index$O.ElSkeletonItem;
components.ElSlider = index$P.ElSlider;
components.ElSpace = index$Q.ElSpace;
components.ElStep = index$R.ElStep;
components.ElSteps = index$R.ElSteps;
components.ElSwitch = index$S.ElSwitch;
components.ElTable = index$T.ElTable;
components.ElTableColumn = index$T.ElTableColumn;
components.ElTabPane = index$U.ElTabPane;
components.ElTabs = index$U.ElTabs;
components.ElTag = index$V.ElTag;
components.ElTimePicker = index$W.ElTimePicker;
components.ElTimeSelect = index$X.ElTimeSelect;
components.ElTimeline = index$Y.ElTimeline;
components.ElTimelineItem = index$Y.ElTimelineItem;
components.ElTooltip = index$Z.ElTooltip;
components.ElTransfer = index$_.ElTransfer;
components.ElTree = index$$.ElTree;
components.ElTreeV2 = index$10.ElTreeV2;
components.ElUpload = index$11.ElUpload;
components.ElInfiniteScroll = index$12.ElInfiniteScroll;
components.ElLoading = index$13.ElLoading;
components.ElLoadingDirective = index$13.ElLoadingDirective;
components.ElLoadingService = index$13.ElLoadingService;
components.ElMessage = index$14.ElMessage;
components.ElMessageBox = index$15.ElMessageBox;
components.ElNotification = index$16.ElNotification;
components.ElPopover = index$17.ElPopover;
components.ElPopoverDirective = index$17.ElPopoverDirective;
components.affixEmits = affix.affixEmits;
components.affixProps = affix.affixProps;
components.alertEmits = alert.alertEmits;
components.alertProps = alert.alertProps;
components.avatarEmits = avatar.avatarEmits;
components.avatarProps = avatar.avatarProps;
components.backtopEmits = backtop.backtopEmits;
components.backtopProps = backtop.backtopProps;
components.badgeProps = badge.badgeProps;
components.breadcrumbProps = breadcrumb.breadcrumbProps;
components.breadcrumbItemProps = breadcrumbItem.breadcrumbItemProps;
components.buttonEmits = button.buttonEmits;
components.buttonNativeType = button.buttonNativeType;
components.buttonProps = button.buttonProps;
components.buttonSize = button.buttonSize;
components.buttonType = button.buttonType;
components.calendarEmits = calendar.calendarEmits;
components.calendarProps = calendar.calendarProps;
components.cardProps = card.cardProps;
components.CASCADER_PANEL_INJECTION_KEY = types.CASCADER_PANEL_INJECTION_KEY;
components.ExpandTrigger = types.ExpandTrigger;
components.CommonProps = config.CommonProps;
components.DefaultProps = config.DefaultProps;
components.useCascaderConfig = config.useCascaderConfig;
components.colProps = col.colProps;
components.configProviderProps = configProvider.configProviderProps;
components.useDialog = useDialog.useDialog;
components.dialogEmits = dialog.dialogEmits;
components.dialogProps = dialog.dialogProps;
components.dividerProps = divider.dividerProps;
components.drawerEmits = drawer.drawerEmits;
components.drawerProps = drawer.drawerProps;
components.emptyProps = empty.emptyProps;
components.iconProps = icon.iconProps;
components.imageEmits = image.imageEmits;
components.imageProps = image.imageProps;
components.imageViewerEmits = imageViewer.imageViewerEmits;
components.imageViewerProps = imageViewer.imageViewerProps;
components.inputEmits = input.inputEmits;
components.inputProps = input.inputProps;
components.inputNumberEmits = inputNumber.inputNumberEmits;
components.inputNumberProps = inputNumber.inputNumberProps;
components.linkEmits = link.linkEmits;
components.linkProps = link.linkProps;
components.menuEmits = menu.menuEmits;
components.menuProps = menu.menuProps;
components.menuItemEmits = menuItem.menuItemEmits;
components.menuItemProps = menuItem.menuItemProps;
components.menuItemGroupProps = menuItemGroup.menuItemGroupProps;
components.subMenuProps = subMenu.subMenuProps;
components.overlayEmits = overlay.overlayEmits;
components.overlayProps = overlay.overlayProps;
components.pageHeaderEmits = pageHeader.pageHeaderEmits;
components.pageHeaderProps = pageHeader.pageHeaderProps;
components.paginationEmits = pagination.paginationEmits;
components.paginationProps = pagination.paginationProps;
components.popconfirmEmits = popconfirm.popconfirmEmits;
components.popconfirmProps = popconfirm.popconfirmProps;
components.Effect = defaults$5.Effect;
components.popperDefaultProps = defaults$5["default"];
components.usePopper = index$F["default"];
components.renderPopper = popper["default"];
components.renderTrigger = trigger["default"];
components.renderArrow = arrow["default"];
components.progressProps = progress.progressProps;
components.radioEmits = radio.radioEmits;
components.radioProps = radio.radioProps;
components.radioPropsBase = radio.radioPropsBase;
components.useRadio = radio.useRadio;
components.radioGroupEmits = radioGroup.radioGroupEmits;
components.radioGroupProps = radioGroup.radioGroupProps;
components.radioButtonProps = radioButton.radioButtonProps;
components.rateEmits = rate.rateEmits;
components.rateProps = rate.rateProps;
components.IconComponentMap = result.IconComponentMap;
components.IconMap = result.IconMap;
components.resultProps = result.resultProps;
components.rowProps = row.rowProps;
components.BAR_MAP = util.BAR_MAP;
components.renderThumbStyle = util.renderThumbStyle;
components.scrollbarEmits = scrollbar.scrollbarEmits;
components.scrollbarProps = scrollbar.scrollbarProps;
components.barProps = bar.barProps;
components.selectGroupKey = token.selectGroupKey;
components.selectKey = token.selectKey;
components.selectV2InjectionKey = token$1.selectV2InjectionKey;
components.skeletonProps = skeleton.skeletonProps;
components.skeletonItemProps = skeletonItem.skeletonItemProps;
components.spaceProps = space.spaceProps;
components.useSpace = useSpace.useSpace;
components.switchEmits = _switch.switchEmits;
components.switchProps = _switch.switchProps;
components.tabsEmits = tabs.tabsEmits;
components.tabsProps = tabs.tabsProps;
components.tabBar = tabBar.tabBar;
components.tabNavProps = tabNav.tabNavProps;
components.tabPaneProps = tabPane.tabPaneProps;
components.tagEmits = tag.tagEmits;
components.tagProps = tag.tagProps;
components.extractDateFormat = dateUtils.extractDateFormat;
components.extractTimeFormat = dateUtils.extractTimeFormat;
components.rangeArr = dateUtils.rangeArr;
components.DEFAULT_FORMATS_DATE = constant.DEFAULT_FORMATS_DATE;
components.DEFAULT_FORMATS_DATEPICKER = constant.DEFAULT_FORMATS_DATEPICKER;
components.DEFAULT_FORMATS_TIME = constant.DEFAULT_FORMATS_TIME;
components.timePickerDefaultProps = props.timePickerDefaultProps;
components.CommonPicker = picker_vue_vue_type_script_lang["default"];
components.TimePickPanel = panelTimePick_vue_vue_type_script_lang["default"];
components.CHANGE_EVENT = constants.CHANGE_EVENT;
components.FixedSizeList = fixedSizeList["default"];
components.DynamicSizeList = dynamicSizeList["default"];
components.FixedSizeGrid = fixedSizeGrid["default"];
components.DynamicSizeGrid = dynamicSizeGrid["default"];
components.virtualizedGridProps = props$1.virtualizedGridProps;
components.virtualizedListProps = props$1.virtualizedListProps;
components.virtualizedProps = props$1.virtualizedProps;
components.virtualizedScrollbarProps = props$1.virtualizedScrollbarProps;
components.messageEmits = message.messageEmits;
components.messageProps = message.messageProps;
components.messageTypes = message.messageTypes;
components.notificationEmits = notification.notificationEmits;
components.notificationProps = notification.notificationProps;
components.notificationTypes = notification.notificationTypes;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var defaults2 = defaults$e;
  var makeInstaller2 = makeInstaller$1;
  var affix3 = affix$1;
  var index2 = affix$2;
  var alert3 = alert$1;
  var index$110 = alert$2;
  var index$22 = autocomplete;
  var avatar3 = avatar$1;
  var index$32 = avatar$2;
  var backtop3 = backtop$1;
  var index$42 = backtop$2;
  var badge3 = badge$1;
  var index$52 = badge$2;
  var breadcrumb3 = breadcrumb$1;
  var breadcrumbItem3 = breadcrumbItem$1;
  var index$62 = breadcrumb$2;
  var button3 = button$4;
  var index$72 = button$5;
  var calendar3 = calendar$1;
  var index$82 = calendar$2;
  var card3 = card$1;
  var index$92 = card$2;
  var index$a2 = carousel;
  var index$b2 = cascader;
  var types2 = types$2;
  var config2 = config$2;
  var index$c2 = cascaderPanel;
  var index$d2 = checkTag;
  var index$e2 = checkbox$1;
  var col2 = col$1;
  var index$f2 = col$2;
  var index$g2 = collapse$1;
  var index$h2 = collapseTransition$1;
  var index$i2 = colorPicker;
  var configProvider2 = configProvider$2;
  var index$j2 = configProvider$3;
  var index$k2 = container$1;
  var index$l2 = datePicker$1;
  var index$m2 = descriptions;
  var useDialog2 = useDialog$2;
  var dialog3 = dialog$2;
  var index$n2 = dialog$3;
  var divider3 = divider$1;
  var index$o2 = divider$2;
  var drawer3 = drawer$1;
  var index$p2 = drawer$2;
  var index$q2 = dropdown;
  var empty3 = empty$1;
  var index$r2 = empty$2;
  var index$s2 = form$3;
  var icon3 = icon$3;
  var index$t2 = icon$4;
  var image3 = image$1;
  var index$u2 = image$2;
  var imageViewer3 = imageViewer$1;
  var index$v2 = imageViewer$2;
  var input3 = input$1;
  var index$w2 = input$2;
  var inputNumber3 = inputNumber$1;
  var index$x2 = inputNumber$2;
  var link3 = link$1;
  var index$y2 = link$2;
  var menu2 = menu$1;
  var menuItem3 = menuItem$1;
  var menuItemGroup3 = menuItemGroup$1;
  var subMenu2 = subMenu$1;
  var index$z2 = menu$2;
  var overlay2 = overlay$1;
  var index$A2 = overlay$2;
  var pageHeader3 = pageHeader$1;
  var index$B2 = pageHeader$2;
  var pagination2 = pagination$2;
  var index$C2 = pagination$3;
  var popconfirm3 = popconfirm$1;
  var index$D2 = popconfirm$2;
  var defaults$12 = defaults$d;
  var index$F2 = usePopper;
  var popper2 = popper$2;
  var trigger2 = trigger$2;
  var arrow2 = arrow$2;
  var index$E2 = popper$3;
  var progress3 = progress$1;
  var index$G2 = progress$2;
  var radio3 = radio$4;
  var radioGroup3 = radioGroup$1;
  var radioButton3 = radioButton$1;
  var index$H2 = radio$5;
  var rate3 = rate$1;
  var index$I2 = rate$2;
  var result3 = result$1;
  var index$J2 = result$2;
  var row2 = row$1;
  var index$K2 = row$2;
  var util2 = util$g;
  var scrollbar3 = scrollbar$2;
  var bar3 = bar$1;
  var index$L2 = scrollbar$3;
  var token2 = token$4;
  var index$M2 = select$2;
  var token$12 = token$2;
  var index$N2 = selectV2;
  var skeleton3 = skeleton$1;
  var skeletonItem3 = skeletonItem$1;
  var index$O2 = skeleton$2;
  var index$P2 = slider;
  var space2 = space$1;
  var useSpace2 = useSpace$2;
  var index$Q2 = space$2;
  var index$R2 = steps;
  var _switch2 = _switch$1;
  var index$S2 = _switch$2;
  var index$T2 = table$1;
  var tabs2 = tabs$1;
  var tabBar3 = tabBar$2;
  var tabNav2 = tabNav$1;
  var tabPane3 = tabPane$1;
  var index$U2 = tabs$2;
  var tag3 = tag$1;
  var index$V2 = tag$2;
  var dateUtils2 = dateUtils$1;
  var constant2 = constant$3;
  var props2 = props$x;
  var picker_vue_vue_type_script_lang2 = picker_vue_vue_type_script_lang$1;
  var panelTimePick_vue_vue_type_script_lang2 = panelTimePick_vue_vue_type_script_lang$1;
  var index$W2 = timePicker$1;
  var index$X2 = timeSelect$1;
  var index$Y2 = timeline;
  var index$Z2 = tooltip;
  var constants2 = constants$f;
  var index$_2 = transfer$1;
  var index$$2 = tree$2;
  var index$102 = treeV2;
  var index$112 = upload$1;
  var fixedSizeList2 = fixedSizeList$2;
  var dynamicSizeList2 = dynamicSizeList$2;
  var fixedSizeGrid2 = fixedSizeGrid$2;
  var dynamicSizeGrid2 = dynamicSizeGrid$2;
  var props$12 = props$c;
  var index$122 = infiniteScroll;
  var index$132 = loading$2;
  var message3 = message$1;
  var index$142 = message$2;
  var index$152 = messageBox$1;
  var notification3 = notification$1;
  var index$162 = notification$2;
  var index$172 = popover;
  var index$182 = clickOutside;
  var index$192 = repeatClick;
  var index$1a2 = trapFocus;
  var index$1b2 = mousewheel;
  var index$1c2 = resize;
  var index$1d2 = useAttrs$1;
  var index$1e2 = useCommonProps;
  var index$1f2 = useFocus$1;
  var index$1g2 = useFormItem$1;
  var index$1h2 = useGlobalConfig$1;
  var index$1i2 = useLocale$1;
  var index$1j2 = useLockscreen$1;
  var index$1k2 = useModal$1;
  var index$1l2 = useModelToggle$1;
  var index$1m2 = usePopper$1;
  var index$1n = usePreventGlobal$1;
  var index$1o = useProp$1;
  var index$1p = useRestoreActive$1;
  var index$1q = useSameTarget$1;
  var index$1r = useTeleport$1;
  var index$1s = useThrottleRender$1;
  var index$1t = useTimeout$1;
  var form2 = form$7;
  var button$12 = button$6;
  var breadcrumb$1$1 = breadcrumb$3;
  var pagination$12 = pagination$4;
  var configProvider$12 = configProvider$5;
  var radio$12 = radio$6;
  var tabs$1$1 = tabs$3;
  var scrollbar$12 = scrollbar$4;
  const install2 = defaults2["default"].install;
  const version2 = defaults2["default"].version;
  exports["default"] = defaults2["default"];
  exports.makeInstaller = makeInstaller2.makeInstaller;
  exports.affixEmits = affix3.affixEmits;
  exports.affixProps = affix3.affixProps;
  exports.ElAffix = index2.ElAffix;
  exports.alertEmits = alert3.alertEmits;
  exports.alertProps = alert3.alertProps;
  exports.ElAlert = index$110.ElAlert;
  exports.ElAutocomplete = index$22.ElAutocomplete;
  exports.avatarEmits = avatar3.avatarEmits;
  exports.avatarProps = avatar3.avatarProps;
  exports.ElAvatar = index$32.ElAvatar;
  exports.backtopEmits = backtop3.backtopEmits;
  exports.backtopProps = backtop3.backtopProps;
  exports.ElBacktop = index$42.ElBacktop;
  exports.badgeProps = badge3.badgeProps;
  exports.ElBadge = index$52.ElBadge;
  exports.breadcrumbProps = breadcrumb3.breadcrumbProps;
  exports.breadcrumbItemProps = breadcrumbItem3.breadcrumbItemProps;
  exports.ElBreadcrumb = index$62.ElBreadcrumb;
  exports.ElBreadcrumbItem = index$62.ElBreadcrumbItem;
  exports.buttonEmits = button3.buttonEmits;
  exports.buttonNativeType = button3.buttonNativeType;
  exports.buttonProps = button3.buttonProps;
  exports.buttonSize = button3.buttonSize;
  exports.buttonType = button3.buttonType;
  exports.ElButton = index$72.ElButton;
  exports.ElButtonGroup = index$72.ElButtonGroup;
  exports.calendarEmits = calendar3.calendarEmits;
  exports.calendarProps = calendar3.calendarProps;
  exports.ElCalendar = index$82.ElCalendar;
  exports.cardProps = card3.cardProps;
  exports.ElCard = index$92.ElCard;
  exports.ElCarousel = index$a2.ElCarousel;
  exports.ElCarouselItem = index$a2.ElCarouselItem;
  exports.ElCascader = index$b2.ElCascader;
  exports.CASCADER_PANEL_INJECTION_KEY = types2.CASCADER_PANEL_INJECTION_KEY;
  exports.ExpandTrigger = types2.ExpandTrigger;
  exports.CommonProps = config2.CommonProps;
  exports.DefaultProps = config2.DefaultProps;
  exports.useCascaderConfig = config2.useCascaderConfig;
  exports.ElCascaderPanel = index$c2.ElCascaderPanel;
  exports.ElCheckTag = index$d2.ElCheckTag;
  exports.ElCheckbox = index$e2.ElCheckbox;
  exports.ElCheckboxButton = index$e2.ElCheckboxButton;
  exports.ElCheckboxGroup = index$e2.ElCheckboxGroup;
  exports.colProps = col2.colProps;
  exports.ElCol = index$f2.ElCol;
  exports.ElCollapse = index$g2.ElCollapse;
  exports.ElCollapseItem = index$g2.ElCollapseItem;
  exports.ElCollapseTransition = index$h2.ElCollapseTransition;
  exports.ElColorPicker = index$i2.ElColorPicker;
  exports.configProviderProps = configProvider2.configProviderProps;
  exports.ElConfigProvider = index$j2.ElConfigProvider;
  exports.ElAside = index$k2.ElAside;
  exports.ElContainer = index$k2.ElContainer;
  exports.ElFooter = index$k2.ElFooter;
  exports.ElHeader = index$k2.ElHeader;
  exports.ElMain = index$k2.ElMain;
  exports.ElDatePicker = index$l2.ElDatePicker;
  exports.ElDescriptions = index$m2.ElDescriptions;
  exports.ElDescriptionsItem = index$m2.ElDescriptionsItem;
  exports.useDialog = useDialog2.useDialog;
  exports.dialogEmits = dialog3.dialogEmits;
  exports.dialogProps = dialog3.dialogProps;
  exports.ElDialog = index$n2.ElDialog;
  exports.dividerProps = divider3.dividerProps;
  exports.ElDivider = index$o2.ElDivider;
  exports.drawerEmits = drawer3.drawerEmits;
  exports.drawerProps = drawer3.drawerProps;
  exports.ElDrawer = index$p2.ElDrawer;
  exports.ElDropdown = index$q2.ElDropdown;
  exports.ElDropdownItem = index$q2.ElDropdownItem;
  exports.ElDropdownMenu = index$q2.ElDropdownMenu;
  exports.emptyProps = empty3.emptyProps;
  exports.ElEmpty = index$r2.ElEmpty;
  exports.ElForm = index$s2.ElForm;
  exports.ElFormItem = index$s2.ElFormItem;
  exports.iconProps = icon3.iconProps;
  exports.ElIcon = index$t2.ElIcon;
  exports.imageEmits = image3.imageEmits;
  exports.imageProps = image3.imageProps;
  exports.ElImage = index$u2.ElImage;
  exports.imageViewerEmits = imageViewer3.imageViewerEmits;
  exports.imageViewerProps = imageViewer3.imageViewerProps;
  exports.ElImageViewer = index$v2.ElImageViewer;
  exports.inputEmits = input3.inputEmits;
  exports.inputProps = input3.inputProps;
  exports.ElInput = index$w2.ElInput;
  exports.inputNumberEmits = inputNumber3.inputNumberEmits;
  exports.inputNumberProps = inputNumber3.inputNumberProps;
  exports.ElInputNumber = index$x2.ElInputNumber;
  exports.linkEmits = link3.linkEmits;
  exports.linkProps = link3.linkProps;
  exports.ElLink = index$y2.ElLink;
  exports.menuEmits = menu2.menuEmits;
  exports.menuProps = menu2.menuProps;
  exports.menuItemEmits = menuItem3.menuItemEmits;
  exports.menuItemProps = menuItem3.menuItemProps;
  exports.menuItemGroupProps = menuItemGroup3.menuItemGroupProps;
  exports.subMenuProps = subMenu2.subMenuProps;
  exports.ElMenu = index$z2.ElMenu;
  exports.ElMenuItem = index$z2.ElMenuItem;
  exports.ElMenuItemGroup = index$z2.ElMenuItemGroup;
  exports.ElSubMenu = index$z2.ElSubMenu;
  exports.overlayEmits = overlay2.overlayEmits;
  exports.overlayProps = overlay2.overlayProps;
  exports.ElOverlay = index$A2.ElOverlay;
  exports.pageHeaderEmits = pageHeader3.pageHeaderEmits;
  exports.pageHeaderProps = pageHeader3.pageHeaderProps;
  exports.ElPageHeader = index$B2.ElPageHeader;
  exports.paginationEmits = pagination2.paginationEmits;
  exports.paginationProps = pagination2.paginationProps;
  exports.ElPagination = index$C2.ElPagination;
  exports.popconfirmEmits = popconfirm3.popconfirmEmits;
  exports.popconfirmProps = popconfirm3.popconfirmProps;
  exports.ElPopconfirm = index$D2.ElPopconfirm;
  exports.Effect = defaults$12.Effect;
  exports.popperDefaultProps = defaults$12["default"];
  exports.usePopper = index$F2["default"];
  exports.renderPopper = popper2["default"];
  exports.renderTrigger = trigger2["default"];
  exports.renderArrow = arrow2["default"];
  exports.ElPopper = index$E2.ElPopper;
  exports.progressProps = progress3.progressProps;
  exports.ElProgress = index$G2.ElProgress;
  exports.radioEmits = radio3.radioEmits;
  exports.radioProps = radio3.radioProps;
  exports.radioPropsBase = radio3.radioPropsBase;
  exports.useRadio = radio3.useRadio;
  exports.radioGroupEmits = radioGroup3.radioGroupEmits;
  exports.radioGroupProps = radioGroup3.radioGroupProps;
  exports.radioButtonProps = radioButton3.radioButtonProps;
  exports.ElRadio = index$H2.ElRadio;
  exports.ElRadioButton = index$H2.ElRadioButton;
  exports.ElRadioGroup = index$H2.ElRadioGroup;
  exports.rateEmits = rate3.rateEmits;
  exports.rateProps = rate3.rateProps;
  exports.ElRate = index$I2.ElRate;
  exports.IconComponentMap = result3.IconComponentMap;
  exports.IconMap = result3.IconMap;
  exports.resultProps = result3.resultProps;
  exports.ElResult = index$J2.ElResult;
  exports.rowProps = row2.rowProps;
  exports.ElRow = index$K2.ElRow;
  exports.BAR_MAP = util2.BAR_MAP;
  exports.renderThumbStyle = util2.renderThumbStyle;
  exports.scrollbarEmits = scrollbar3.scrollbarEmits;
  exports.scrollbarProps = scrollbar3.scrollbarProps;
  exports.barProps = bar3.barProps;
  exports.ElScrollbar = index$L2.ElScrollbar;
  exports.selectGroupKey = token2.selectGroupKey;
  exports.selectKey = token2.selectKey;
  exports.ElOption = index$M2.ElOption;
  exports.ElOptionGroup = index$M2.ElOptionGroup;
  exports.ElSelect = index$M2.ElSelect;
  exports.selectV2InjectionKey = token$12.selectV2InjectionKey;
  exports.ElSelectV2 = index$N2.ElSelectV2;
  exports.skeletonProps = skeleton3.skeletonProps;
  exports.skeletonItemProps = skeletonItem3.skeletonItemProps;
  exports.ElSkeleton = index$O2.ElSkeleton;
  exports.ElSkeletonItem = index$O2.ElSkeletonItem;
  exports.ElSlider = index$P2.ElSlider;
  exports.spaceProps = space2.spaceProps;
  exports.useSpace = useSpace2.useSpace;
  exports.ElSpace = index$Q2.ElSpace;
  exports.ElStep = index$R2.ElStep;
  exports.ElSteps = index$R2.ElSteps;
  exports.switchEmits = _switch2.switchEmits;
  exports.switchProps = _switch2.switchProps;
  exports.ElSwitch = index$S2.ElSwitch;
  exports.ElTable = index$T2.ElTable;
  exports.ElTableColumn = index$T2.ElTableColumn;
  exports.tabsEmits = tabs2.tabsEmits;
  exports.tabsProps = tabs2.tabsProps;
  exports.tabBar = tabBar3.tabBar;
  exports.tabNavProps = tabNav2.tabNavProps;
  exports.tabPaneProps = tabPane3.tabPaneProps;
  exports.ElTabPane = index$U2.ElTabPane;
  exports.ElTabs = index$U2.ElTabs;
  exports.tagEmits = tag3.tagEmits;
  exports.tagProps = tag3.tagProps;
  exports.ElTag = index$V2.ElTag;
  exports.extractDateFormat = dateUtils2.extractDateFormat;
  exports.extractTimeFormat = dateUtils2.extractTimeFormat;
  exports.rangeArr = dateUtils2.rangeArr;
  exports.DEFAULT_FORMATS_DATE = constant2.DEFAULT_FORMATS_DATE;
  exports.DEFAULT_FORMATS_DATEPICKER = constant2.DEFAULT_FORMATS_DATEPICKER;
  exports.DEFAULT_FORMATS_TIME = constant2.DEFAULT_FORMATS_TIME;
  exports.timePickerDefaultProps = props2.timePickerDefaultProps;
  exports.CommonPicker = picker_vue_vue_type_script_lang2["default"];
  exports.TimePickPanel = panelTimePick_vue_vue_type_script_lang2["default"];
  exports.ElTimePicker = index$W2.ElTimePicker;
  exports.ElTimeSelect = index$X2.ElTimeSelect;
  exports.ElTimeline = index$Y2.ElTimeline;
  exports.ElTimelineItem = index$Y2.ElTimelineItem;
  exports.ElTooltip = index$Z2.ElTooltip;
  exports.CHANGE_EVENT = constants2.CHANGE_EVENT;
  exports.ElTransfer = index$_2.ElTransfer;
  exports.ElTree = index$$2.ElTree;
  exports.ElTreeV2 = index$102.ElTreeV2;
  exports.ElUpload = index$112.ElUpload;
  exports.FixedSizeList = fixedSizeList2["default"];
  exports.DynamicSizeList = dynamicSizeList2["default"];
  exports.FixedSizeGrid = fixedSizeGrid2["default"];
  exports.DynamicSizeGrid = dynamicSizeGrid2["default"];
  exports.virtualizedGridProps = props$12.virtualizedGridProps;
  exports.virtualizedListProps = props$12.virtualizedListProps;
  exports.virtualizedProps = props$12.virtualizedProps;
  exports.virtualizedScrollbarProps = props$12.virtualizedScrollbarProps;
  exports.ElInfiniteScroll = index$122.ElInfiniteScroll;
  exports.ElLoading = index$132.ElLoading;
  exports.ElLoadingDirective = index$132.ElLoadingDirective;
  exports.ElLoadingService = index$132.ElLoadingService;
  exports.messageEmits = message3.messageEmits;
  exports.messageProps = message3.messageProps;
  exports.messageTypes = message3.messageTypes;
  exports.ElMessage = index$142.ElMessage;
  exports.ElMessageBox = index$152.ElMessageBox;
  exports.notificationEmits = notification3.notificationEmits;
  exports.notificationProps = notification3.notificationProps;
  exports.notificationTypes = notification3.notificationTypes;
  exports.ElNotification = index$162.ElNotification;
  exports.ElPopover = index$172.ElPopover;
  exports.ElPopoverDirective = index$172.ElPopoverDirective;
  exports.ClickOutside = index$182["default"];
  exports.RepeatClick = index$192["default"];
  exports.TrapFocus = index$1a2["default"];
  exports.Mousewheel = index$1b2["default"];
  exports.Resize = index$1c2["default"];
  exports.useAttrs = index$1d2.useAttrs;
  exports.useDisabled = index$1e2.useDisabled;
  exports.useSize = index$1e2.useSize;
  exports.useSizeProp = index$1e2.useSizeProp;
  exports.useFocus = index$1f2.useFocus;
  exports.useFormItem = index$1g2.useFormItem;
  exports.useGlobalConfig = index$1h2.useGlobalConfig;
  exports.buildTranslator = index$1i2.buildTranslator;
  exports.localeContextKey = index$1i2.localeContextKey;
  exports.localeProviderMaker = index$1i2.localeProviderMaker;
  exports.provideLocale = index$1i2.provideLocale;
  exports.translate = index$1i2.translate;
  exports.useLocale = index$1i2.useLocale;
  exports.useLocaleProps = index$1i2.useLocaleProps;
  exports.useLockscreen = index$1j2.useLockscreen;
  exports.useModal = index$1k2.useModal;
  exports.useModelToggle = index$1l2.useModelToggle;
  exports.useModelToggleEmits = index$1l2.useModelToggleEmits;
  exports.useModelToggleProps = index$1l2.useModelToggleProps;
  exports.DARK_EFFECT = index$1m2.DARK_EFFECT;
  exports.LIGHT_EFFECT = index$1m2.LIGHT_EFFECT;
  exports.usePopperControlProps = index$1m2.usePopperControlProps;
  exports.usePopperHook = index$1m2.usePopperHook;
  exports.usePopperProps = index$1m2.usePopperProps;
  exports.usePreventGlobal = index$1n.usePreventGlobal;
  exports.useProp = index$1o.useProp;
  exports.useRestoreActive = index$1p.useRestoreActive;
  exports.useSameTarget = index$1q.useSameTarget;
  exports.useTeleport = index$1r.useTeleport;
  exports.useThrottleRender = index$1s.useThrottleRender;
  exports.useTimeout = index$1t.useTimeout;
  exports.elFormItemKey = form2.elFormItemKey;
  exports.elFormKey = form2.elFormKey;
  exports.buttonGroupContextKey = button$12.buttonGroupContextKey;
  exports.elBreadcrumbKey = breadcrumb$1$1.elBreadcrumbKey;
  exports.elPaginationKey = pagination$12.elPaginationKey;
  exports.configProviderContextKey = configProvider$12.configProviderContextKey;
  exports.radioGroupKey = radio$12.radioGroupKey;
  exports.tabsRootContextKey = tabs$1$1.tabsRootContextKey;
  exports.scrollbarContextKey = scrollbar$12.scrollbarContextKey;
  exports.install = install2;
  exports.version = version2;
})(lib$2);
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
class ApiProxy {
  constructor(plugin2, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin2;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin2.settings) {
      for (const id in plugin2.settings) {
        const item2 = plugin2.settings[id];
        defaultSettings[id] = item2.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin2.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data2 = JSON.parse(raw);
      Object.assign(currentSettings, data2);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e) {
        }
        currentSettings = value;
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve2) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: resolve2
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target2) {
    this.target = target2;
    for (const item2 of this.onQueue) {
      this.target.on[item2.method](...item2.args);
    }
    for (const item2 of this.targetQueue) {
      item2.resolve(await this.target[item2.method](...item2.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const target2 = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && pluginDescriptor.enableEarlyProxy;
  if (hook && (target2.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(pluginDescriptor, hook) : null;
    const list2 = target2.__VUE_DEVTOOLS_PLUGINS__ = target2.__VUE_DEVTOOLS_PLUGINS__ || [];
    list2.push({
      pluginDescriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */
var storeKey = "store";
function useStore(key2) {
  if (key2 === void 0)
    key2 = null;
  return inject(key2 !== null ? key2 : storeKey);
}
function forEachValue(obj, fn3) {
  Object.keys(obj).forEach(function(key2) {
    return fn3(obj[key2], key2);
  });
}
function isObject$2(obj) {
  return obj !== null && typeof obj === "object";
}
function isPromise(val) {
  return val && typeof val.then === "function";
}
function partial(fn3, arg) {
  return function() {
    return fn3(arg);
  };
}
function genericSubscribe(fn3, subs, options) {
  if (subs.indexOf(fn3) < 0) {
    options && options.prepend ? subs.unshift(fn3) : subs.push(fn3);
  }
  return function() {
    var i = subs.indexOf(fn3);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}
function resetStore(store2, hot) {
  store2._actions = Object.create(null);
  store2._mutations = Object.create(null);
  store2._wrappedGetters = Object.create(null);
  store2._modulesNamespaceMap = Object.create(null);
  var state = store2.state;
  installModule(store2, state, [], store2._modules.root, true);
  resetStoreState(store2, state, hot);
}
function resetStoreState(store2, state, hot) {
  var oldState = store2._state;
  store2.getters = {};
  store2._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store2._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function(fn3, key2) {
    computedObj[key2] = partial(fn3, store2);
    Object.defineProperty(store2.getters, key2, {
      get: function() {
        return computedObj[key2]();
      },
      enumerable: true
    });
  });
  store2._state = reactive({
    data: state
  });
  if (store2.strict) {
    enableStrictMode(store2);
  }
  if (oldState) {
    if (hot) {
      store2._withCommit(function() {
        oldState.data = null;
      });
    }
  }
}
function installModule(store2, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store2._modules.getNamespace(path);
  if (module.namespaced) {
    if (store2._modulesNamespaceMap[namespace] && false) {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
    }
    store2._modulesNamespaceMap[namespace] = module;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store2._withCommit(function() {
      parentState[moduleName] = module.state;
    });
  }
  var local = module.context = makeLocalContext(store2, namespace, path);
  module.forEachMutation(function(mutation, key2) {
    var namespacedType = namespace + key2;
    registerMutation(store2, namespacedType, mutation, local);
  });
  module.forEachAction(function(action, key2) {
    var type4 = action.root ? key2 : namespace + key2;
    var handler = action.handler || action;
    registerAction(store2, type4, handler, local);
  });
  module.forEachGetter(function(getter, key2) {
    var namespacedType = namespace + key2;
    registerGetter(store2, namespacedType, getter, local);
  });
  module.forEachChild(function(child, key2) {
    installModule(store2, rootState, path.concat(key2), child, hot);
  });
}
function makeLocalContext(store2, namespace, path) {
  var noNamespace = namespace === "";
  var local = {
    dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type4 = args.type;
      if (!options || !options.root) {
        type4 = namespace + type4;
      }
      return store2.dispatch(type4, payload);
    },
    commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type4 = args.type;
      if (!options || !options.root) {
        type4 = namespace + type4;
      }
      store2.commit(type4, payload, options);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store2.getters;
      } : function() {
        return makeLocalGetters(store2, namespace);
      }
    },
    state: {
      get: function() {
        return getNestedState(store2.state, path);
      }
    }
  });
  return local;
}
function makeLocalGetters(store2, namespace) {
  if (!store2._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store2.getters).forEach(function(type4) {
      if (type4.slice(0, splitPos) !== namespace) {
        return;
      }
      var localType = type4.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store2.getters[type4];
        },
        enumerable: true
      });
    });
    store2._makeLocalGettersCache[namespace] = gettersProxy;
  }
  return store2._makeLocalGettersCache[namespace];
}
function registerMutation(store2, type4, handler, local) {
  var entry = store2._mutations[type4] || (store2._mutations[type4] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store2, local.state, payload);
  });
}
function registerAction(store2, type4, handler, local) {
  var entry = store2._actions[type4] || (store2._actions[type4] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store2, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store2.getters,
      rootState: store2.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store2._devtoolHook) {
      return res.catch(function(err) {
        store2._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  });
}
function registerGetter(store2, type4, rawGetter, local) {
  if (store2._wrappedGetters[type4]) {
    return;
  }
  store2._wrappedGetters[type4] = function wrappedGetter(store3) {
    return rawGetter(local.state, local.getters, store3.state, store3.getters);
  };
}
function enableStrictMode(store2) {
  watch$1(function() {
    return store2._state.data;
  }, function() {
  }, { deep: true, flush: "sync" });
}
function getNestedState(state, path) {
  return path.reduce(function(state2, key2) {
    return state2[key2];
  }, state);
}
function unifyObjectStyle(type4, payload, options) {
  if (isObject$2(type4) && type4.type) {
    options = payload;
    payload = type4;
    type4 = type4.type;
  }
  return { type: type4, payload, options };
}
var LABEL_VUEX_BINDINGS = "vuex bindings";
var MUTATIONS_LAYER_ID = "vuex:mutations";
var ACTIONS_LAYER_ID = "vuex:actions";
var INSPECTOR_ID = "vuex";
var actionId = 0;
function addDevtools(app, store2) {
  setupDevtoolsPlugin({
    id: "org.vuejs.vuex",
    app,
    label: "Vuex",
    homepage: "https://next.vuex.vuejs.org/",
    logo: "https://vuejs.org/images/icons/favicon-96x96.png",
    packageName: "vuex",
    componentStateTypes: [LABEL_VUEX_BINDINGS]
  }, function(api) {
    api.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: "Vuex Mutations",
      color: COLOR_LIME_500
    });
    api.addTimelineLayer({
      id: ACTIONS_LAYER_ID,
      label: "Vuex Actions",
      color: COLOR_LIME_500
    });
    api.addInspector({
      id: INSPECTOR_ID,
      label: "Vuex",
      icon: "storage",
      treeFilterPlaceholder: "Filter stores..."
    });
    api.on.getInspectorTree(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        if (payload.filter) {
          var nodes = [];
          flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
          payload.rootNodes = nodes;
        } else {
          payload.rootNodes = [
            formatStoreForInspectorTree(store2._modules.root, "")
          ];
        }
      }
    });
    api.on.getInspectorState(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        makeLocalGetters(store2, modulePath);
        payload.state = formatStoreForInspectorState(getStoreModule(store2._modules, modulePath), modulePath === "root" ? store2.getters : store2._makeLocalGettersCache, modulePath);
      }
    });
    api.on.editInspectorState(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        var path = payload.path;
        if (modulePath !== "root") {
          path = modulePath.split("/").filter(Boolean).concat(path);
        }
        store2._withCommit(function() {
          payload.set(store2._state.data, path, payload.state.value);
        });
      }
    });
    store2.subscribe(function(mutation, state) {
      var data2 = {};
      if (mutation.payload) {
        data2.payload = mutation.payload;
      }
      data2.state = state;
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: Date.now(),
          title: mutation.type,
          data: data2
        }
      });
    });
    store2.subscribeAction({
      before: function(action, state) {
        var data2 = {};
        if (action.payload) {
          data2.payload = action.payload;
        }
        action._id = actionId++;
        action._time = Date.now();
        data2.state = state;
        api.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: action._time,
            title: action.type,
            groupId: action._id,
            subtitle: "start",
            data: data2
          }
        });
      },
      after: function(action, state) {
        var data2 = {};
        var duration = Date.now() - action._time;
        data2.duration = {
          _custom: {
            type: "duration",
            display: duration + "ms",
            tooltip: "Action duration",
            value: duration
          }
        };
        if (action.payload) {
          data2.payload = action.payload;
        }
        data2.state = state;
        api.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: action.type,
            groupId: action._id,
            subtitle: "end",
            data: data2
          }
        });
      }
    });
  });
}
var COLOR_LIME_500 = 8702998;
var COLOR_DARK = 6710886;
var COLOR_WHITE = 16777215;
var TAG_NAMESPACED = {
  label: "namespaced",
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};
function extractNameFromPath(path) {
  return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
}
function formatStoreForInspectorTree(module, path) {
  return {
    id: path || "root",
    label: extractNameFromPath(path),
    tags: module.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module._children).map(function(moduleName) {
      return formatStoreForInspectorTree(module._children[moduleName], path + moduleName + "/");
    })
  };
}
function flattenStoreForInspectorTree(result3, module, filter2, path) {
  if (path.includes(filter2)) {
    result3.push({
      id: path || "root",
      label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
      tags: module.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module._children).forEach(function(moduleName) {
    flattenStoreForInspectorTree(result3, module._children[moduleName], filter2, path + moduleName + "/");
  });
}
function formatStoreForInspectorState(module, getters, path) {
  getters = path === "root" ? getters : getters[path];
  var gettersKeys = Object.keys(getters);
  var storeState = {
    state: Object.keys(module.state).map(function(key2) {
      return {
        key: key2,
        editable: true,
        value: module.state[key2]
      };
    })
  };
  if (gettersKeys.length) {
    var tree2 = transformPathsToObjectTree(getters);
    storeState.getters = Object.keys(tree2).map(function(key2) {
      return {
        key: key2.endsWith("/") ? extractNameFromPath(key2) : key2,
        editable: false,
        value: canThrow(function() {
          return tree2[key2];
        })
      };
    });
  }
  return storeState;
}
function transformPathsToObjectTree(getters) {
  var result3 = {};
  Object.keys(getters).forEach(function(key2) {
    var path = key2.split("/");
    if (path.length > 1) {
      var target2 = result3;
      var leafKey = path.pop();
      path.forEach(function(p2) {
        if (!target2[p2]) {
          target2[p2] = {
            _custom: {
              value: {},
              display: p2,
              tooltip: "Module",
              abstract: true
            }
          };
        }
        target2 = target2[p2]._custom.value;
      });
      target2[leafKey] = canThrow(function() {
        return getters[key2];
      });
    } else {
      result3[key2] = canThrow(function() {
        return getters[key2];
      });
    }
  });
  return result3;
}
function getStoreModule(moduleMap, path) {
  var names = path.split("/").filter(function(n) {
    return n;
  });
  return names.reduce(function(module, moduleName, i) {
    var child = module[moduleName];
    if (!child) {
      throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
    }
    return i === names.length - 1 ? child : child._children;
  }, path === "root" ? moduleMap : moduleMap.root._children);
}
function canThrow(cb) {
  try {
    return cb();
  } catch (e) {
    return e;
  }
}
var Module = function Module2(rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
};
var prototypeAccessors$1 = { namespaced: { configurable: true } };
prototypeAccessors$1.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = function addChild(key2, module) {
  this._children[key2] = module;
};
Module.prototype.removeChild = function removeChild(key2) {
  delete this._children[key2];
};
Module.prototype.getChild = function getChild(key2) {
  return this._children[key2];
};
Module.prototype.hasChild = function hasChild(key2) {
  return key2 in this._children;
};
Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};
Module.prototype.forEachChild = function forEachChild(fn3) {
  forEachValue(this._children, fn3);
};
Module.prototype.forEachGetter = function forEachGetter(fn3) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn3);
  }
};
Module.prototype.forEachAction = function forEachAction(fn3) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn3);
  }
};
Module.prototype.forEachMutation = function forEachMutation(fn3) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn3);
  }
};
Object.defineProperties(Module.prototype, prototypeAccessors$1);
var ModuleCollection = function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
};
ModuleCollection.prototype.get = function get2(path) {
  return path.reduce(function(module, key2) {
    return module.getChild(key2);
  }, this.root);
};
ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function(namespace, key2) {
    module = module.getChild(key2);
    return namespace + (module.namespaced ? key2 + "/" : "");
  }, "");
};
ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update2([], this.root, rawRootModule);
};
ModuleCollection.prototype.register = function register2(path, rawModule, runtime) {
  var this$1$1 = this;
  if (runtime === void 0)
    runtime = true;
  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key2) {
      this$1$1.register(path.concat(key2), rawChildModule, runtime);
    });
  }
};
ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key2 = path[path.length - 1];
  var child = parent.getChild(key2);
  if (!child) {
    return;
  }
  if (!child.runtime) {
    return;
  }
  parent.removeChild(key2);
};
ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent = this.get(path.slice(0, -1));
  var key2 = path[path.length - 1];
  if (parent) {
    return parent.hasChild(key2);
  }
  return false;
};
function update2(path, targetModule, newModule) {
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key2 in newModule.modules) {
      if (!targetModule.getChild(key2)) {
        return;
      }
      update2(path.concat(key2), targetModule.getChild(key2), newModule.modules[key2]);
    }
  }
}
function createStore(options) {
  return new Store(options);
}
var Store = function Store2(options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var plugins = options.plugins;
  if (plugins === void 0)
    plugins = [];
  var strict = options.strict;
  if (strict === void 0)
    strict = false;
  var devtools2 = options.devtools;
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = Object.create(null);
  this._devtools = devtools2;
  var store2 = this;
  var ref2 = this;
  var dispatch2 = ref2.dispatch;
  var commit2 = ref2.commit;
  this.dispatch = function boundDispatch(type4, payload) {
    return dispatch2.call(store2, type4, payload);
  };
  this.commit = function boundCommit(type4, payload, options2) {
    return commit2.call(store2, type4, payload, options2);
  };
  this.strict = strict;
  var state = this._modules.root.state;
  installModule(this, state, [], this._modules.root);
  resetStoreState(this, state);
  plugins.forEach(function(plugin2) {
    return plugin2(this$1$1);
  });
};
var prototypeAccessors = { state: { configurable: true } };
Store.prototype.install = function install(app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;
  var useDevtools = this._devtools !== void 0 ? this._devtools : false;
  if (useDevtools) {
    addDevtools(app, this);
  }
};
prototypeAccessors.state.get = function() {
  return this._state.data;
};
prototypeAccessors.state.set = function(v2) {
};
Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload, _options);
  var type4 = ref2.type;
  var payload = ref2.payload;
  var mutation = { type: type4, payload };
  var entry = this._mutations[type4];
  if (!entry) {
    return;
  }
  this._withCommit(function() {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.slice().forEach(function(sub) {
    return sub(mutation, this$1$1.state);
  });
};
Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload);
  var type4 = ref2.type;
  var payload = ref2.payload;
  var action = { type: type4, payload };
  var entry = this._actions[type4];
  if (!entry) {
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub) {
      return sub.before;
    }).forEach(function(sub) {
      return sub.before(action, this$1$1.state);
    });
  } catch (e) {
  }
  var result3 = entry.length > 1 ? Promise.all(entry.map(function(handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve2, reject) {
    result3.then(function(res) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.after;
        }).forEach(function(sub) {
          return sub.after(action, this$1$1.state);
        });
      } catch (e) {
      }
      resolve2(res);
    }, function(error2) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.error;
        }).forEach(function(sub) {
          return sub.error(action, this$1$1.state, error2);
        });
      } catch (e) {
      }
      reject(error2);
    });
  });
};
Store.prototype.subscribe = function subscribe(fn3, options) {
  return genericSubscribe(fn3, this._subscribers, options);
};
Store.prototype.subscribeAction = function subscribeAction(fn3, options) {
  var subs = typeof fn3 === "function" ? { before: fn3 } : fn3;
  return genericSubscribe(subs, this._actionSubscribers, options);
};
Store.prototype.watch = function watch$1$1(getter, cb, options) {
  var this$1$1 = this;
  return watch$1(function() {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb, Object.assign({}, options));
};
Store.prototype.replaceState = function replaceState(state) {
  var this$1$1 = this;
  this._withCommit(function() {
    this$1$1._state.data = state;
  });
};
Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0)
    options = {};
  if (typeof path === "string") {
    path = [path];
  }
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  resetStoreState(this, this.state);
};
Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1$1 = this;
  if (typeof path === "string") {
    path = [path];
  }
  this._modules.unregister(path);
  this._withCommit(function() {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};
Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === "string") {
    path = [path];
  }
  return this._modules.isRegistered(path);
};
Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};
Store.prototype._withCommit = function _withCommit(fn3) {
  var committing = this._committing;
  this._committing = true;
  fn3();
  this._committing = committing;
};
Object.defineProperties(Store.prototype, prototypeAccessors);
/*!
  * vue-router v4.0.12
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
const hasSymbol$1 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
const PolySymbol = (name) => hasSymbol$1 ? Symbol(name) : "_vr_" + name;
const matchedRouteKey = /* @__PURE__ */ PolySymbol("rvlm");
const viewDepthKey = /* @__PURE__ */ PolySymbol("rvd");
const routerKey = /* @__PURE__ */ PolySymbol("r");
const routeLocationKey = /* @__PURE__ */ PolySymbol("rl");
const routerViewLocationKey = /* @__PURE__ */ PolySymbol("rvl");
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || hasSymbol$1 && obj[Symbol.toStringTag] === "Module";
}
const assign$1 = Object.assign;
function applyToParams(fn3, params) {
  const newParams = {};
  for (const key2 in params) {
    const value = params[key2];
    newParams[key2] = Array.isArray(value) ? value.map(fn3) : fn3(value);
  }
  return newParams;
}
const noop = () => {
};
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash2 = "";
  const searchPos = location2.indexOf("?");
  const hashPos = location2.indexOf("#", searchPos > -1 ? searchPos : 0);
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash2 = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash2,
    path,
    query,
    hash: hash2
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a2, b2) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
}
function isSameRouteRecord(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length)
    return false;
  for (const key2 in a2) {
    if (!isSameRouteLocationParamsValue(a2[key2], b2[key2]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a2, b2) {
  return Array.isArray(a2) ? isEquivalentArray(a2, b2) : Array.isArray(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
}
function isEquivalentArray(a2, b2) {
  return Array.isArray(b2) ? a2.length === b2.length && a2.every((value, i) => value === b2[i]) : a2.length === 1 && a2[0] === b2;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  let position2 = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (position2 === 1 || segment === ".")
      continue;
    if (segment === "..")
      position2--;
    else
      break;
  }
  return fromSegments.slice(0, position2).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset2) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset2.behavior,
    left: elRect.left - docRect.left - (offset2.left || 0),
    top: elRect.top - docRect.top - (offset2.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position2) {
  let scrollToOptions;
  if ("el" in position2) {
    const positionEl = position2.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position2);
  } else {
    scrollToOptions = position2;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position2 = history.state ? history.state.position - delta : -1;
  return position2 + path;
}
const scrollPositions = new Map();
function saveScrollPosition(key2, scrollPosition) {
  scrollPositions.set(key2, scrollPosition);
}
function getSavedScrollPosition(key2) {
  const scroll = scrollPositions.get(key2);
  scrollPositions.delete(key2);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search: search2, hash: hash2 } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash2.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash2.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search2 + hash2;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index2 = listeners.indexOf(callback);
      if (index2 > -1)
        listeners.splice(index2, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign$1({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back2, current2, forward, replaced = false, computeScroll = false) {
  return {
    back: back2,
    current: current2,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url2 = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url2);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url2);
    }
  }
  function replace(to, data2) {
    const state = assign$1({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data2, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data2) {
    const currentState = assign$1({}, historyState.value, history2.state, {
      forward: to,
      scroll: computeScrollPosition()
    });
    changeLocation(currentState.current, currentState, true);
    const state = assign$1({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data2);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign$1({
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("nf");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type4, params) {
  {
    return assign$1(new Error(), {
      type: type4,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error2, type4) {
  return error2 instanceof Error && NavigationFailureSymbol in error2 && (type4 == null || !!(error2.type & type4));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign$1({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern4 = options.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern4 += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token2 = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token2.type === 0) {
        if (!tokenIndex)
          pattern4 += "/";
        pattern4 += token2.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token2.type === 1) {
        const { value, repeatable, optional, regexp: regexp4 } = token2;
        keys2.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp4 ? regexp4 : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern4 += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern4 += "/?";
  if (options.end)
    pattern4 += "$";
  else if (options.strict)
    pattern4 += "(?:/|$)";
  const re = new RegExp(pattern4, options.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i = 1; i < match.length; i++) {
      const value = match[i] || "";
      const key2 = keys2[i - 1];
      params[key2.name] = value && key2.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token2 of segment) {
        if (token2.type === 0) {
          path += token2.value;
        } else if (token2.type === 1) {
          const { value, repeatable, optional } = token2;
          const param = value in params ? params[value] : "";
          if (Array.isArray(param) && !repeatable)
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          const text = Array.isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path;
  }
  return {
    re,
    score,
    keys: keys2,
    parse: parse2,
    stringify
  };
}
function compareScoreArray(a2, b2) {
  let i = 0;
  while (i < a2.length && i < b2.length) {
    const diff = b2[i] - a2[i];
    if (diff)
      return diff;
    i++;
  }
  if (a2.length < b2.length) {
    return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
  } else if (a2.length > b2.length) {
    return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a2, b2) {
  let i = 0;
  const aScore = a2.score;
  const bScore = b2.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  return bScore.length - aScore.length;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message3) {
    throw new Error(`ERR (${state})/"${buffer2}": ${message3}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer2 = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer2)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer2
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer2,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer2 = "";
  }
  function addCharToBuffer() {
    buffer2 += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer2) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer2}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign$1(parser, {
    record,
    parent,
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign$1({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if ("children" in mainNormalizedRecord) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index2 = matchers.indexOf(matcherRef);
      if (index2 > -1) {
        matchers.splice(index2, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i = 0;
    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0)
      i++;
    matchers.splice(i, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign$1(paramsFromLocation(currentLocation.params, matcher.keys.filter((k) => !k.optional).map((k) => k.name)), location2.params);
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m2) => m2.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign$1({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key2 of keys2) {
    if (key2 in params)
      newParams[key2] = params[key2];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || {} : { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props2 = record.props || false;
  if ("component" in record) {
    propsObject.default = props2;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props2 === "boolean" ? props2 : props2[name];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign$1(meta, record.meta), {});
}
function mergeOptions(defaults2, partialOptions) {
  const options = {};
  for (const key2 in defaults2) {
    options[key2] = key2 in partialOptions ? partialOptions[key2] : defaults2[key2];
  }
  return options;
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search2) {
  const query = {};
  if (search2 === "" || search2 === "?")
    return query;
  const hasLeadingIM = search2[0] === "?";
  const searchParams = (hasLeadingIM ? search2.slice(1) : search2).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key2 = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key2 in query) {
      let currentValue = query[key2];
      if (!Array.isArray(currentValue)) {
        currentValue = query[key2] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key2] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search2 = "";
  for (let key2 in query) {
    const value = query[key2];
    key2 = encodeQueryKey(key2);
    if (value == null) {
      if (value !== void 0) {
        search2 += (search2.length ? "&" : "") + key2;
      }
      continue;
    }
    const values = Array.isArray(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search2 += (search2.length ? "&" : "") + key2;
        if (value2 != null)
          search2 += "=" + value2;
      }
    });
  }
  return search2;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key2 in query) {
    const value = query[key2];
    if (value !== void 0) {
      normalizedQuery[key2] = Array.isArray(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
function useCallbacks() {
  let handlers = [];
  function add2(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1)
        handlers.splice(i, 1);
    };
  }
  function reset2() {
    handlers = [];
  }
  return {
    add: add2,
    list: () => handlers,
    reset: reset2
  };
}
function guardToPromiseFn(guard, to, from, record, name) {
  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next2 = (valid) => {
      if (valid === false)
        reject(createRouterError(4, {
          from,
          to
        }));
      else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function")
          enterCallbackArray.push(valid);
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to, from, next2);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next2);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component2) {
  return typeof component2 === "object" || "displayName" in component2 || "props" in component2 || "__vccOpts" in component2;
}
function useLink(props2) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router.resolve(unref(props2.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index2 > -1)
      return index2;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router[unref(props2.replace) ? "replace" : "push"](unref(props2.to)).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props2, { slots }) {
    const link3 = reactive(useLink(props2));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props2.activeClass, options.linkActiveClass, "router-link-active")]: link3.isActive,
      [getLinkClass(props2.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link3.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link3);
      return props2.custom ? children : h$1("a", {
        "aria-current": link3.isExactActive ? props2.ariaCurrentValue : null,
        href: link3.href,
        onClick: link3.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target2 = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target2))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key2 in inner) {
    const innerValue = inner[key2];
    const outerValue = outer[key2];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  setup(props2, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props2.route || injectedRoute.value);
    const depth = inject(viewDepthKey, 0);
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);
    provide(viewDepthKey, depth + 1);
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch$1(() => [viewRef.value, matchedRouteRef.value, props2.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[props2.name];
      const currentName = props2.name;
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[props2.name];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode2) => {
        if (vnode2.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component2 = h$1(ViewComponent, assign$1({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return normalizeSlot(slots.default, { Component: component2, route }) || component2;
    };
  }
});
function normalizeSlot(slot, data2) {
  if (!slot)
    return null;
  const slotContent = slot(data2);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode);
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign$1({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign$1(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign$1({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign$1({}, rawLocation.params);
      for (const key2 in targetParams) {
        if (targetParams[key2] == null) {
          delete targetParams[key2];
        }
      }
      matcherLocation = assign$1({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash2 = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign$1({}, rawLocation, {
      hash: encodeHash(hash2),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign$1({
      fullPath,
      hash: hash2,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$1({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign$1(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign$1({
        query: to.query,
        hash: to.hash,
        params: to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from = currentRoute.value;
    const data2 = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(assign$1(locationAsObject(shouldRedirect), {
        state: data2,
        force,
        replace: replace2
      }), redirectedFrom || targetLocation);
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(from, from, true, false);
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error2) => isNavigationFailure(error2) ? error2 : triggerError(error2, toLocation, from)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          return pushWithRedirect(assign$1(locationAsObject(failure2.to), {
            state: data2,
            force,
            replace: replace2
          }), redirectedFrom || toLocation);
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data2);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error2 = checkCanceledNavigation(to, from);
    return error2 ? Promise.reject(error2) : Promise.resolve();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to.matched) {
        if (record.beforeEnter && !from.matched.includes(record)) {
          if (Array.isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    for (const guard of afterGuards.list())
      guard(to, from, failure);
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data2) {
    const error2 = checkCanceledNavigation(toLocation, from);
    if (error2)
      return error2;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign$1({
          scroll: isFirstNavigation && state && state.scroll
        }, data2));
      else
        routerHistory.push(toLocation.fullPath, data2);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign$1(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error2) => {
        if (isNavigationFailure(error2, 4 | 8)) {
          return error2;
        }
        if (isNavigationFailure(error2, 2)) {
          pushWithRedirect(error2.to, toLocation).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta)
          routerHistory.go(-info.delta, false);
        return triggerError(error2, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(toLocation, from, false);
        if (failure) {
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error2, to, from) {
    markAsReady(error2);
    const list2 = errorHandlers.list();
    if (list2.length) {
      list2.forEach((handler) => handler(error2, to, from));
    } else {
      console.error(error2);
    }
    return Promise.reject(error2);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (ready)
      return;
    ready = true;
    setupListeners();
    readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
    readyHandlers.reset();
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position2) => position2 && scrollToPosition(position2)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = new Set();
  const router = {
    currentRoute,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key2 in START_LOCATION_NORMALIZED) {
        reactiveRoute[key2] = computed(() => currentRoute.value[key2]);
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, reactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute() {
  return inject(routeLocationKey);
}
var en = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var defaultLocales2 = {
    name: "en",
    hkust: {
      header: {
        contactUs: "Contact Us",
        hkustGz: "HKUST(GZ)",
        subHeadTitle: "More about HKUST",
        ustNews: "University News",
        department: "Academic Departments A-Z",
        lifeUst: "Life{'@'}HKUST",
        library: "Library",
        map: "Map & Directions",
        career: "Careers at HKUST",
        facultyProfiles: "Faculty Profiles",
        about: "About HKUST",
        searchBtnText: "SEARCH",
        searchPlaceholder: "Enter your search terms"
      },
      footer: {
        privacy: "Privacy",
        copyright: "Copyright \xA9 The Hong Kong University of Science and Technology (Guangzhou). All rights reserved.",
        record: "\u7CA4ICP\u590720065231\u53F7",
        follow: "Follow HKUST(GZ) on"
      }
    }
  };
  exports["default"] = defaultLocales2;
})(en);
var hkustEnLocale = /* @__PURE__ */ getDefaultExportFromCjs(en);
var zhCn = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var zhCn2 = {
    name: "zh-cn",
    hkust: {
      header: {
        contactUs: "\u8054\u7EDC\u6211\u4EEC",
        hkustGz: "\u6E2F\u79D1\u5927(\u5E7F\u5DDE)",
        subHeadTitle: "\u66F4\u591A\u5173\u4E8E\u6E2F\u79D1\u5927\u7684\u8D44\u8BAF",
        ustNews: "\u79D1\u5927\u65B0\u95FB",
        department: "\u5B66\u672F\u90E8\u95E8\u7D22\u5F15",
        lifeUst: "\u751F\u6D3B{'@'}\u79D1\u5927",
        library: "\u56FE\u4E66\u9986",
        map: "\u6821\u56ED\u5730\u56FE\u53CA\u6307\u5357",
        career: "Careers at HKUST",
        facultyProfiles: "\u6559\u6388\u7B80\u5F55",
        about: "\u8BA4\u8BC6\u79D1\u5927",
        searchBtnText: "\u641C\u5BFB",
        searchPlaceholder: "\u8BF7\u8F93\u5165\u641C\u5BFB\u9879\u76EE"
      },
      footer: {
        privacy: "\u79C1\u96B1\u653F\u7B56",
        copyright: "\xA9 \u7248\u6743\u5C5E\u9999\u6E2F\u79D1\u6280\u5927\u5B66\uFF08\u5E7F\u5DDE\uFF09\u6240\u6709 ",
        record: "\u7CA4ICP\u590720065231\u53F7",
        follow: "\u5173\u6CE8\u9999\u6E2F\u79D1\u5927(\u5E7F\u5DDE)"
      }
    }
  };
  exports["default"] = zhCn2;
})(zhCn);
var hkustZhcnLocale = /* @__PURE__ */ getDefaultExportFromCjs(zhCn);
var zhTw = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var zhTw2 = {
    name: "zh-tw",
    hkust: {
      header: {
        contactUs: "\u806F\u7D61\u6211\u5011",
        hkustGz: "\u6E2F\u79D1\u5927(\u5EE3\u5DDE)",
        subHeadTitle: "\u66F4\u591A\u95DC\u65BC\u6E2F\u79D1\u5927\u7684\u8CC7\u8A0A",
        ustNews: "\u79D1\u5927\u65B0\u805E",
        department: "\u5B78\u8853\u90E8\u9580\u7D22\u5F15",
        lifeUst: "\u751F\u6D3B{'@'}\u79D1\u5927",
        library: "\u5716\u66F8\u9928",
        map: "\u6821\u5712\u5730\u5716\u53CA\u6307\u5357",
        career: "Careers at HKUST",
        facultyProfiles: "\u6559\u6388\u7C21\u9304",
        about: "\u8A8D\u8B58\u79D1\u5927",
        searchBtnText: "\u641C\u5C0B",
        searchPlaceholder: "\u8ACB\u8F38\u5165\u641C\u5C0B\u9879\u76EE"
      },
      footer: {
        privacy: "\u79C1\u96B1\u653F\u7B56",
        copyright: "\xA9 \u7248\u6B0A\u5C6C\u9999\u6E2F\u79D1\u6280\u5927\u5B78\uFF08\u5EE3\u5DDE\uFF09\u6240\u6709 ",
        record: "\u7CA4ICP\u590720065231\u53F7",
        follow: "\u95DC\u6CE8\u9999\u6E2F\u79D1\u5927(\u5EE3\u5DDE)"
      }
    }
  };
  exports["default"] = zhTw2;
})(zhTw);
var hkustZhtwLocale = /* @__PURE__ */ getDefaultExportFromCjs(zhTw);
var axios$2 = { exports: {} };
var bind$2 = function bind(fn3, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn3.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString = Object.prototype.toString;
function isArray$1(val) {
  return toString.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result3;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result3 = ArrayBuffer.isView(val);
  } else {
    result3 = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result3;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject$1(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject$1(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate$1(val) {
  return toString.call(val) === "[object Date]";
}
function isFile(val) {
  return toString.call(val) === "[object File]";
}
function isBlob(val) {
  return toString.call(val) === "[object Blob]";
}
function isFunction$1(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$1(val) && isFunction$1(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn3) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (var i = 0, l2 = obj.length; i < l2; i++) {
      fn3.call(null, obj[i], i, obj);
    }
  } else {
    for (var key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        fn3.call(null, obj[key2], key2, obj);
      }
    }
  }
}
function merge() {
  var result3 = {};
  function assignValue2(val, key2) {
    if (isPlainObject$1(result3[key2]) && isPlainObject$1(val)) {
      result3[key2] = merge(result3[key2], val);
    } else if (isPlainObject$1(val)) {
      result3[key2] = merge({}, val);
    } else if (isArray$1(val)) {
      result3[key2] = val.slice();
    } else {
      result3[key2] = val;
    }
  }
  for (var i = 0, l2 = arguments.length; i < l2; i++) {
    forEach(arguments[i], assignValue2);
  }
  return result3;
}
function extend(a2, b2, thisArg) {
  forEach(b2, function assignValue2(val, key2) {
    if (thisArg && typeof val === "function") {
      a2[key2] = bind$1(val, thisArg);
    } else {
      a2[key2] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$d = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$1,
  isObject: isObject$1,
  isPlainObject: isPlainObject$1,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim,
  stripBOM
};
var utils$c = utils$d;
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL(url2, params, paramsSerializer) {
  if (!params) {
    return url2;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$c.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$c.forEach(params, function serialize(val, key2) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$c.isArray(val)) {
        key2 = key2 + "[]";
      } else {
        val = [val];
      }
      utils$c.forEach(val, function parseValue2(v2) {
        if (utils$c.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$c.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode(key2) + "=" + encode(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
};
var utils$b = utils$d;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn3) {
  utils$b.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn3(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$a = utils$d;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$a.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};
var enhanceError$2 = function enhanceError(error2, config2, code2, request2, response) {
  error2.config = config2;
  if (code2) {
    error2.code = code2;
  }
  error2.request = request2;
  error2.response = response;
  error2.isAxiosError = true;
  error2.toJSON = function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error2;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError(message3, config2, code2, request2, response) {
  var error2 = new Error(message3);
  return enhanceError$1(error2, config2, code2, request2, response);
};
var createError$1 = createError$2;
var settle$1 = function settle(resolve2, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
  }
};
var utils$9 = utils$d;
var cookies$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write2(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + "=" + encodeURIComponent(value));
      if (utils$9.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$9.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils$9.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read2(name) {
      var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove2(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write2() {
    },
    read: function read2() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$8 = utils$d;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders(headers) {
  var parsed = {};
  var key2;
  var val;
  var i;
  if (!headers) {
    return parsed;
  }
  utils$8.forEach(headers.split("\n"), function parser(line) {
    i = line.indexOf(":");
    key2 = utils$8.trim(line.substr(0, i)).toLowerCase();
    val = utils$8.trim(line.substr(i + 1));
    if (key2) {
      if (parsed[key2] && ignoreDuplicateOf.indexOf(key2) >= 0) {
        return;
      }
      if (key2 === "set-cookie") {
        parsed[key2] = (parsed[key2] ? parsed[key2] : []).concat([val]);
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var utils$7 = utils$d;
var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url2) {
    var href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
function Cancel$3(message3) {
  this.message = message3;
}
Cancel$3.prototype.toString = function toString2() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$3.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$3;
var utils$6 = utils$d;
var settle2 = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath2 = buildFullPath$1;
var parseHeaders2 = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError2 = createError$2;
var defaults$4 = defaults_1;
var Cancel$2 = Cancel_1;
var xhr = function xhrAdapter(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    var requestData = config2.data;
    var requestHeaders = config2.headers;
    var responseType = config2.responseType;
    var onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils$6.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config2.auth) {
      var username = config2.auth.username || "";
      var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath2(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL$1(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle2(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError2("Request aborted", config2, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError2() {
      reject(createError2("Network Error", config2, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      var transitional2 = config2.transitional || defaults$4.transitional;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(createError2(timeoutErrorMessage, config2, transitional2.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request2));
      request2 = null;
    };
    if (utils$6.isStandardBrowserEnv()) {
      var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config2.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils$6.forEach(requestHeaders, function setRequestHeader(val, key2) {
        if (typeof requestData === "undefined" && key2.toLowerCase() === "content-type") {
          delete requestHeaders[key2];
        } else {
          request2.setRequestHeader(key2, val);
        }
      });
    }
    if (!utils$6.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", config2.onDownloadProgress);
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config2.onUploadProgress);
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = function(cancel) {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel && cancel.type ? new Cancel$2("canceled") : cancel);
        request2.abort();
        request2 = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var utils$5 = utils$d;
var normalizeHeaderName2 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$2;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$5.isFormData(data2) || utils$5.isArrayBuffer(data2) || utils$5.isBuffer(data2) || utils$5.isStream(data2) || utils$5.isFile(data2) || utils$5.isBlob(data2)) {
      return data2;
    }
    if (utils$5.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$5.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    if (utils$5.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional2 = this.transitional || defaults$3.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw enhanceError2(e, this, "E_JSON_PARSE");
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method4) {
  defaults$3.headers[method4] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method4) {
  defaults$3.headers[method4] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$4 = utils$d;
var defaults$2 = defaults_1;
var transformData$1 = function transformData(data2, headers, fns) {
  var context = this || defaults$2;
  utils$4.forEach(fns, function transform2(fn3) {
    data2 = fn3.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1 = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};
var utils$3 = utils$d;
var transformData2 = transformData$1;
var isCancel2 = isCancel$1;
var defaults$1 = defaults_1;
var Cancel$1 = Cancel_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new Cancel$1("canceled");
  }
}
var dispatchRequest$1 = function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData2.call(config2, config2.data, config2.headers, config2.transformRequest);
  config2.headers = utils$3.merge(config2.headers.common || {}, config2.headers[config2.method] || {}, config2.headers);
  utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method4) {
    delete config2.headers[method4];
  });
  var adapter = config2.adapter || defaults$1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData2.call(config2, response.data, response.headers, config2.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel2(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(config2, reason.response.data, reason.response.headers, config2.transformResponse);
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$d;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  function getMergedValue(target2, source2) {
    if (utils$2.isPlainObject(target2) && utils$2.isPlainObject(source2)) {
      return utils$2.merge(target2, source2);
    } else if (utils$2.isPlainObject(source2)) {
      return utils$2.merge({}, source2);
    } else if (utils$2.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
};
var data = {
  "version": "0.24.0"
};
var VERSION$2 = data.version;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type4, i) {
  validators$1[type4] = function validator2(thing) {
    return typeof thing === type4 || "a" + (i < 1 ? "n " : " ") + type4;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message3) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$2 + "] Transitional option '" + opt + "'" + desc + (message3 ? ". " + message3 : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i = keys2.length;
  while (i-- > 0) {
    var opt = keys2[i];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result3 = value === void 0 || validator2(value, opt, options);
      if (result3 !== true) {
        throw new TypeError("option " + opt + " must be " + result3);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$1 = utils$d;
var buildURL2 = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional2 = config2.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error2) {
      onRejected(error2);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error2) {
    return Promise.reject(error2);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL2(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method4) {
  Axios$1.prototype[method4] = function(url2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method: method4,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method4) {
  Axios$1.prototype[method4] = function(url2, data2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method: method4,
      url: url2,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve2) {
    resolvePromise = resolve2;
  });
  var token2 = this;
  this.promise.then(function(cancel) {
    if (!token2._listeners)
      return;
    var i;
    var l2 = token2._listeners.length;
    for (i = 0; i < l2; i++) {
      token2._listeners[i](cancel);
    }
    token2._listeners = null;
  });
  this.promise.then = function(onfulfilled) {
    var _resolve;
    var promise = new Promise(function(resolve2) {
      token2.subscribe(resolve2);
      _resolve = resolve2;
    }).then(onfulfilled);
    promise.cancel = function reject() {
      token2.unsubscribe(_resolve);
    };
    return promise;
  };
  executor(function cancel(message3) {
    if (token2.reason) {
      return;
    }
    token2.reason = new Cancel(message3);
    resolvePromise(token2.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.prototype.subscribe = function subscribe2(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }
  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};
CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index2 = this._listeners.indexOf(listener);
  if (index2 !== -1) {
    this._listeners.splice(index2, 1);
  }
};
CancelToken.source = function source() {
  var cancel;
  var token2 = new CancelToken(function executor(c2) {
    cancel = c2;
  });
  return {
    token: token2,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
var utils = utils$d;
var bind2 = bind$2;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind2(Axios.prototype.request, context);
  utils.extend(instance, Axios.prototype, context);
  utils.extend(instance, context);
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.VERSION = data.version;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
/*!
  * shared v9.2.0-beta.23
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
const makeSymbol = (name) => hasSymbol ? Symbol(name) : name;
const generateFormatCacheKey = (locale, key2, source2) => friendlyJSONstringify({ l: locale, k: key2, s: source2 });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const assign = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key2) {
  return hasOwnProperty.call(obj, key2);
}
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject = (val) => val !== null && typeof val === "object";
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
/*!
  * message-compiler v9.2.0-beta.23
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const CompileErrorCodes = {
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  __EXTEND_POINT__: 15
};
function createCompileError(code2, loc, options = {}) {
  const { domain, messages: messages2, args } = options;
  const msg = code2;
  const error2 = new SyntaxError(String(msg));
  error2.code = code2;
  if (loc) {
    error2.location = loc;
  }
  error2.domain = domain;
  return error2;
}
function defaultOnError(error2) {
  throw error2;
}
function createPosition(line, column, offset2) {
  return { line, column, offset: offset2 };
}
function createLocation(start2, end2, source2) {
  const loc = { start: start2, end: end2 };
  if (source2 != null) {
    loc.source = source2;
  }
  return loc;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
  const isLF = (index3) => _buf[index3] === CHAR_LF;
  const isPS = (index3) => _buf[index3] === CHAR_PS;
  const isLS = (index3) => _buf[index3] === CHAR_LS;
  const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
  const index2 = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset2) => isCRLF(offset2) || isPS(offset2) || isLS(offset2) ? CHAR_LF : _buf[offset2];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next2() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset2() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset2 = 0) {
    _peekOffset = offset2;
  }
  function skipToPeek() {
    const target2 = _index + _peekOffset;
    while (target2 !== _index) {
      next2();
    }
    _peekOffset = 0;
  }
  return {
    index: index2,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next: next2,
    peek,
    reset: reset2,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$1 = "tokenizer";
function createTokenizer(source2, options = {}) {
  const location2 = options.location !== false;
  const _scnr = createScanner(source2);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code2, pos, offset2, ...args) {
    const ctx = context();
    pos.column += offset2;
    pos.offset += offset2;
    if (onError) {
      const loc = createLocation(ctx.startLoc, pos);
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$1,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type4, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type4;
    const token2 = { type: type4 };
    if (location2) {
      token2.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token2.value = value;
    }
    return token2;
  }
  const getEndToken = (context2) => getToken(context2, 14);
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || cc >= 65 && cc <= 90 || cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn3 = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn3();
      } else {
        return isIdentifierStart(ch);
      }
    };
    const ret = fn3();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function isTextStart(scnr, reset2 = true) {
    const fn3 = (hasSpace = false, prev2 = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev2 === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev2 === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn3(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev2 === "%" || detectModulo ? true : !(prev2 === CHAR_SP || prev2 === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn3(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn3(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn3();
    reset2 && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn3) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn3(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function takeIdentifierChar(scnr) {
    const closure = (ch) => {
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || cc >= 65 && cc <= 90 || cc >= 48 && cc <= 57 || cc === 95 || cc === 36;
    };
    return takeChar(scnr, closure);
  }
  function takeDigit(scnr) {
    const closure = (ch) => {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57;
    };
    return takeChar(scnr, closure);
  }
  function takeHexDigit(scnr) {
    const closure = (ch) => {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57 || cc >= 65 && cc <= 70 || cc >= 97 && cc <= 102;
    };
    return takeChar(scnr, closure);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    const fn3 = (x2) => x2 !== LITERAL_DELIMITER && x2 !== CHAR_LF;
    while (ch = takeChar(scnr, fn3)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current2 = scnr.currentChar();
    if (current2 === CHAR_LF || current2 === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current2 === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    const closure = (ch2) => ch2 !== "{" && ch2 !== "}" && ch2 !== CHAR_SP && ch2 !== CHAR_LF;
    while (ch = takeChar(scnr, closure)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn3 = (detect = false, buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF) {
        buf += ch;
        scnr.next();
        return fn3(detect, buf);
      } else {
        buf += ch;
        scnr.next();
        return fn3(true, buf);
      }
    };
    return fn3(false, "");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(scnr, "|");
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token2 = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token2 = getToken(context2, 2, "{");
        skipSpaces(scnr);
        context2.braceNest++;
        return token2;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token2 = getToken(context2, 3, "}");
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token2;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token2 = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token2;
      default:
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token2 = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token2 = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token2 = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token2 = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token2.value);
          skipSpaces(scnr);
          return token2;
        }
        break;
    }
    return token2;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token2 = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token2 = getToken(context2, 8, "@");
        context2.inLinked = true;
        return token2;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(context2, 9, ".");
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(context2, 10, ":");
      default:
        if (isPluralStart(scnr)) {
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token2;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token2 = { type: 14 };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(context2, 3, "}");
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default:
        if (isPluralStart(scnr)) {
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        if (ch === "%") {
          scnr.next();
          return getToken(context2, 4, "%");
        }
        break;
    }
    return token2;
  }
  function nextToken() {
    const { currentType, offset: offset2, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset2;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(_context, 14);
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "\uFFFD";
    }
  }
}
function createParser(options = {}) {
  const location2 = options.location !== false;
  const { onError } = options;
  function emitError(tokenzer, code2, start2, offset2, ...args) {
    const end2 = tokenzer.currentPosition();
    end2.offset += offset2;
    end2.column += offset2;
    if (onError) {
      const loc = createLocation(start2, end2);
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN,
        args
      });
      onError(err);
    }
  }
  function startNode(type4, offset2, loc) {
    const node3 = {
      type: type4,
      start: offset2,
      end: offset2
    };
    if (location2) {
      node3.loc = { start: loc, end: loc };
    }
    return node3;
  }
  function endNode(node3, offset2, pos, type4) {
    node3.end = offset2;
    if (type4) {
      node3.type = type4;
    }
    if (location2 && node3.loc) {
      node3.loc.end = pos;
    }
  }
  function parseText(tokenizer, value) {
    const context = tokenizer.context();
    const node3 = startNode(3, context.offset, context.startLoc);
    node3.value = value;
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseList(tokenizer, index2) {
    const context = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context;
    const node3 = startNode(5, offset2, loc);
    node3.index = parseInt(index2, 10);
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseNamed(tokenizer, key2) {
    const context = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context;
    const node3 = startNode(4, offset2, loc);
    node3.key = key2;
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseLiteral(tokenizer, value) {
    const context = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context;
    const node3 = startNode(9, offset2, loc);
    node3.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseLinkedModifier(tokenizer) {
    const token2 = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context;
    const node3 = startNode(8, offset2, loc);
    if (token2.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node3.value = "";
      endNode(node3, offset2, loc);
      return {
        nextConsumeToken: token2,
        node: node3
      };
    }
    if (token2.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
    }
    node3.value = token2.value || "";
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: node3
    };
  }
  function parseLinkedKey(tokenizer, value) {
    const context = tokenizer.context();
    const node3 = startNode(7, context.offset, context.startLoc);
    node3.value = value;
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token2 = tokenizer.nextToken();
    if (token2.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token2 = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token2.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
    }
    token2 = tokenizer.nextToken();
    if (token2.type === 2) {
      token2 = tokenizer.nextToken();
    }
    switch (token2.type) {
      case 11:
        if (token2.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token2.value || "");
        break;
      case 5:
        if (token2.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseNamed(tokenizer, token2.value || "");
        break;
      case 6:
        if (token2.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseList(tokenizer, token2.value || "");
        break;
      case 7:
        if (token2.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseLiteral(tokenizer, token2.value || "");
        break;
      default:
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token2,
          node: linkedNode
        };
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node3 = startNode(2, startOffset, startLoc);
    node3.items = [];
    let nextToken = null;
    do {
      const token2 = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token2.type) {
        case 0:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node3.items.push(parseText(tokenizer, token2.value || ""));
          break;
        case 6:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node3.items.push(parseList(tokenizer, token2.value || ""));
          break;
        case 5:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node3.items.push(parseNamed(tokenizer, token2.value || ""));
          break;
        case 7:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node3.items.push(parseLiteral(tokenizer, token2.value || ""));
          break;
        case 8:
          const parsed = parseLinked(tokenizer);
          node3.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node3, endOffset, endLoc);
    return node3;
  }
  function parsePlural(tokenizer, offset2, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node3 = startNode(1, offset2, loc);
    node3.cases = [];
    node3.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node3.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset: offset2, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset2, startLoc, msgNode);
    }
  }
  function parse2(source2) {
    const tokenizer = createTokenizer(source2, assign({}, options));
    const context = tokenizer.context();
    const node3 = startNode(0, context.offset, context.startLoc);
    if (location2 && node3.loc) {
      node3.loc.source = source2;
    }
    node3.body = parseResource(tokenizer);
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source2[context.offset] || "");
    }
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  return { parse: parse2 };
}
function getTokenCaption(token2) {
  if (token2.type === 14) {
    return "EOF";
  }
  const name = (token2.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "\u2026" : name;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: new Set()
  };
  const context = () => _context;
  const helper2 = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper: helper2 };
}
function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}
function traverseNode(node3, transformer) {
  switch (node3.type) {
    case 1:
      traverseNodes(node3.cases, transformer);
      transformer.helper("plural");
      break;
    case 2:
      traverseNodes(node3.items, transformer);
      break;
    case 6:
      const linked = node3;
      traverseNode(linked.key, transformer);
      transformer.helper("linked");
      break;
    case 5:
      transformer.helper("interpolate");
      transformer.helper("list");
      break;
    case 4:
      transformer.helper("interpolate");
      transformer.helper("named");
      break;
  }
}
function transform(ast, options = {}) {
  const transformer = createTransformer(ast);
  transformer.helper("normalize");
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function createCodeGenerator(ast, options) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
  const _context = {
    source: ast.loc.source,
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  const context = () => _context;
  function push(code2, node3) {
    _context.code += code2;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper2 = (key2) => `_${key2}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper: helper2,
    needIndent
  };
}
function generateLinkedNode(generator, node3) {
  const { helper: helper2 } = generator;
  generator.push(`${helper2("linked")}(`);
  generateNode(generator, node3.key);
  if (node3.modifier) {
    generator.push(`, `);
    generateNode(generator, node3.modifier);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node3) {
  const { helper: helper2, needIndent } = generator;
  generator.push(`${helper2("normalize")}([`);
  generator.indent(needIndent());
  const length = node3.items.length;
  for (let i = 0; i < length; i++) {
    generateNode(generator, node3.items[i]);
    if (i === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node3) {
  const { helper: helper2, needIndent } = generator;
  if (node3.cases.length > 1) {
    generator.push(`${helper2("plural")}([`);
    generator.indent(needIndent());
    const length = node3.cases.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator, node3.cases[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node3) {
  if (node3.body) {
    generateNode(generator, node3.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node3) {
  const { helper: helper2 } = generator;
  switch (node3.type) {
    case 0:
      generateResource(generator, node3);
      break;
    case 1:
      generatePluralNode(generator, node3);
      break;
    case 2:
      generateMessageNode(generator, node3);
      break;
    case 6:
      generateLinkedNode(generator, node3);
      break;
    case 8:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 7:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 5:
      generator.push(`${helper2("interpolate")}(${helper2("list")}(${node3.index}))`, node3);
      break;
    case 4:
      generator.push(`${helper2("interpolate")}(${helper2("named")}(${JSON.stringify(node3.key)}))`, node3);
      break;
    case 9:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 3:
      generator.push(JSON.stringify(node3.value), node3);
      break;
  }
}
const generate = (ast, options = {}) => {
  const mode = isString(options.mode) ? options.mode : "normal";
  const filename = isString(options.filename) ? options.filename : "message.intl";
  const sourceMap = !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${helpers.map((s2) => `${s2}: _${s2}`).join(", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  const { code: code2, map } = generator.context();
  return {
    ast,
    code: code2,
    map: map ? map.toJSON() : void 0
  };
};
function baseCompile(source2, options = {}) {
  const assignedOptions = assign({}, options);
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source2);
  transform(ast, assignedOptions);
  return generate(ast, assignedOptions);
}
/*!
  * devtools-if v9.2.0-beta.23
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const IntlifyDevToolsHooks = {
  I18nInit: "i18n:init",
  FunctionTranslate: "function:translate"
};
/*!
  * core-base v9.2.0-beta.23
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const pathStateMachine = [];
pathStateMachine[0] = {
  ["w"]: [0],
  ["i"]: [3, 0],
  ["["]: [4],
  ["o"]: [7]
};
pathStateMachine[1] = {
  ["w"]: [1],
  ["."]: [2],
  ["["]: [4],
  ["o"]: [7]
};
pathStateMachine[2] = {
  ["w"]: [2],
  ["i"]: [3, 0],
  ["0"]: [3, 0]
};
pathStateMachine[3] = {
  ["i"]: [3, 0],
  ["0"]: [3, 0],
  ["w"]: [1, 1],
  ["."]: [2, 1],
  ["["]: [4, 1],
  ["o"]: [7, 1]
};
pathStateMachine[4] = {
  ["'"]: [5, 0],
  ['"']: [6, 0],
  ["["]: [
    4,
    2
  ],
  ["]"]: [1, 3],
  ["o"]: 8,
  ["l"]: [4, 0]
};
pathStateMachine[5] = {
  ["'"]: [4, 0],
  ["o"]: 8,
  ["l"]: [5, 0]
};
pathStateMachine[6] = {
  ['"']: [4, 0],
  ["o"]: 8,
  ["l"]: [6, 0]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a2 = str.charCodeAt(0);
  const b2 = str.charCodeAt(str.length - 1);
  return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys2 = [];
  let index2 = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c2;
  let key2;
  let newChar;
  let type4;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[0] = () => {
    if (key2 === void 0) {
      key2 = newChar;
    } else {
      key2 += newChar;
    }
  };
  actions[1] = () => {
    if (key2 !== void 0) {
      keys2.push(key2);
      key2 = void 0;
    }
  };
  actions[2] = () => {
    actions[0]();
    subPathDepth++;
  };
  actions[3] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[0]();
    } else {
      subPathDepth = 0;
      if (key2 === void 0) {
        return false;
      }
      key2 = formatSubPath(key2);
      if (key2 === false) {
        return false;
      } else {
        actions[1]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[0]();
      return true;
    }
  }
  while (mode !== null) {
    index2++;
    c2 = path[index2];
    if (c2 === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type4 = getPathCharType(c2);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type4] || typeMap["l"] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c2;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys2;
    }
  }
}
const cache = new Map();
function resolveWithKeyValue(obj, path) {
  return isObject(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : values.join("");
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
}
function normalizeNamed(pluralIndex, props2) {
  if (!props2.count) {
    props2.count = pluralIndex;
  }
  if (!props2.n) {
    props2.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages2) => messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
  const _list = options.list || [];
  const list2 = (index2) => _list[index2];
  const _named = options.named || {};
  isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key2) => _named[key2];
  function message3(key2) {
    const msg = isFunction(options.messages) ? options.messages(key2) : isObject(options.messages) ? options.messages[key2] : false;
    return !msg ? options.parent ? options.parent.message(key2) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type4 = isPlainObject(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const ctx = {
    ["list"]: list2,
    ["named"]: named,
    ["plural"]: plural,
    ["linked"]: (key2, modifier) => {
      const msg = message3(key2)(ctx);
      return isString(modifier) ? _modifier(modifier)(msg) : msg;
    },
    ["message"]: message3,
    ["type"]: type4,
    ["interpolate"]: interpolate,
    ["normalize"]: normalize
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n, version2, meta) {
  devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {
    timestamp: Date.now(),
    i18n,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const CoreWarnCodes = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  __EXTEND_POINT__: 7
};
function fallbackWithSimple(ctx, fallback, start2) {
  return [...new Set([
    start2,
    ...isArray(fallback) ? fallback : isObject(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start2]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start2) {
  const startLocale = isString(start2) ? start2 : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start2];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults2 = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString(defaults2) ? [defaults2] : defaults2;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target2 = tokens.join("-");
    follow = appendItemToChain(chain, target2, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target2, blocks) {
  let follow = false;
  if (!chain.includes(target2)) {
    follow = true;
    if (target2) {
      follow = target2[target2.length - 1] !== "!";
      const locale = target2.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.2.0-beta.23";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
function getDefaultLinkedModifiers() {
  return {
    upper: (val) => isString(val) ? val.toUpperCase() : val,
    lower: (val) => isString(val) ? val.toLowerCase() : val,
    capitalize: (val) => isString(val) ? `${val.charAt(0).toLocaleUpperCase()}${val.substr(1)}` : val
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = () => _additionalMeta;
let _cid = 0;
function createCoreContext(options = {}) {
  const version2 = isString(options.version) ? options.version : VERSION$1;
  const locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const messages2 = isPlainObject(options.messages) ? options.messages : { [locale]: {} };
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [locale]: {} };
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : { [locale]: {} };
  const modifiers = assign({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const internalOptions = options;
  const __datetimeFormatters = isObject(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : new Map();
  const __numberFormatters = isObject(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : new Map();
  const __meta = isObject(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages: messages2,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function handleMissing(context, key2, locale, missingWarn, type4) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key2, type4);
    return isString(ret) ? ret : key2;
  } else {
    return key2;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
const defaultOnCacheKey = (source2) => source2;
let compileCache = Object.create(null);
function compileToFunction(source2, options = {}) {
  {
    const onCacheKey = options.onCacheKey || defaultOnCacheKey;
    const key2 = onCacheKey(source2);
    const cached = compileCache[key2];
    if (cached) {
      return cached;
    }
    let occurred = false;
    const onError = options.onError || defaultOnError;
    options.onError = (err) => {
      occurred = true;
      onError(err);
    };
    const { code: code2 } = baseCompile(source2, options);
    const msg = new Function(`return ${code2}`)();
    return !occurred ? compileCache[key2] = msg : msg;
  }
}
let code$1 = CompileErrorCodes.__EXTEND_POINT__;
const inc$1 = () => code$1++;
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$1,
  INVALID_DATE_ARGUMENT: inc$1(),
  INVALID_ISO_DATE_ARGUMENT: inc$1(),
  __EXTEND_POINT__: inc$1()
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
  const [key2, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : key2 : fallbackFormat ? !messageCompiler ? () => key2 : key2 : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = isString(options.locale) ? options.locale : context.locale;
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message3] = !resolvedMessage ? resolveMessageFormat(context, key2, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key2,
    locale,
    messages2[locale] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key2;
  if (!resolvedMessage && !(isString(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString(format2) || isMessageFunction(format2)) || !isString(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key2;
  }
  let occurred = false;
  const errorDetector = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key2, targetLocale, format2, cacheBaseKey, errorDetector) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message3, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString(key2) ? key2 : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item2) => isString(item2) ? escapeHtml(item2) : item2);
  } else if (isObject(options.named)) {
    Object.keys(options.named).forEach((key2) => {
      if (isString(options.named[key2])) {
        options.named[key2] = escapeHtml(options.named[key2]);
      }
    });
  }
}
function resolveMessageFormat(context, key2, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message3 = {};
  let targetLocale;
  let format2 = null;
  const type4 = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message3 = messages2[targetLocale] || {};
    if ((format2 = resolveValue2(message3, key2)) === null) {
      format2 = message3[key2];
    }
    if (isString(format2) || isFunction(format2))
      break;
    const missingRet = handleMissing(context, key2, targetLocale, missingWarn, type4);
    if (missingRet !== key2) {
      format2 = missingRet;
    }
  }
  return [format2, targetLocale, message3];
}
function compileMessageFormat(context, key2, targetLocale, format2, cacheBaseKey, errorDetector) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key2;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileOptions(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, errorDetector));
  msg.locale = targetLocale;
  msg.key = key2;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};
  if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key2 = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options.plural = arg2;
  } else if (isString(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber(arg3)) {
    options.plural = arg3;
  } else if (isString(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign(options, arg3);
  }
  return [key2, options];
}
function getCompileOptions(context, locale, key2, source2, warnHtmlMessage, errorDetector) {
  return {
    warnHtmlMessage,
    onError: (err) => {
      errorDetector && errorDetector(err);
      {
        throw err;
      }
    },
    onCacheKey: (source3) => generateFormatCacheKey(locale, key2, source3)
  };
}
function getMessageContextOptions(context, locale, message3, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2 } = context;
  const resolveMessage = (key2) => {
    const val = resolveValue2(message3, key2);
    if (isString(val)) {
      let occurred = false;
      const errorDetector = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key2, locale, val, key2, errorDetector);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key2, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  if (!isString(key2) || key2 === "") {
    return new Intl.DateTimeFormat(locale).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type4 = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key2];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key2, targetLocale, missingWarn, type4);
  }
  if (!isPlainObject(format2) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key2;
  }
  let id = `${targetLocale}__${key2}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign({}, format2, overrides));
    __datetimeFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  let options = {};
  let overrides = {};
  let value;
  if (isString(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    options = arg2;
  }
  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key2 in format2) {
    const id = `${locale}__${key2}`;
    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }
    context.__datetimeFormatters.delete(id);
  }
}
function number3(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key2, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  if (!isString(key2) || key2 === "") {
    return new Intl.NumberFormat(locale).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type4 = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key2];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key2, targetLocale, missingWarn, type4);
  }
  if (!isPlainObject(format2) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key2;
  }
  let id = `${targetLocale}__${key2}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign({}, format2, overrides));
    __numberFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  let options = {};
  let overrides = {};
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    options = arg2;
  }
  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key2 in format2) {
    const id = `${locale}__${key2}`;
    if (!context.__numberFormatters.has(id)) {
      continue;
    }
    context.__numberFormatters.delete(id);
  }
}
{
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
/*!
  * vue-i18n v9.2.0-beta.23
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.2.0-beta.23";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
CoreWarnCodes.__EXTEND_POINT__;
let code = CompileErrorCodes.__EXTEND_POINT__;
const inc = () => code++;
const I18nErrorCodes = {
  UNEXPECTED_RETURN_TYPE: code,
  INVALID_ARGUMENT: inc(),
  MUST_BE_CALL_SETUP_TOP: inc(),
  NOT_INSLALLED: inc(),
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  REQUIRED_VALUE: inc(),
  INVALID_VALUE: inc(),
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  NOT_INSLALLED_WITH_PROVIDE: inc(),
  UNEXPECTED_ERROR: inc(),
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  __EXTEND_POINT__: inc()
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TransrateVNodeSymbol = /* @__PURE__ */ makeSymbol("__transrateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
makeSymbol("__intlifyMeta");
const InejctWithOption = /* @__PURE__ */ makeSymbol("__injectWithOption");
function handleFlatJson(obj) {
  if (!isObject(obj)) {
    return obj;
  }
  for (const key2 in obj) {
    if (!hasOwn(obj, key2)) {
      continue;
    }
    if (!key2.includes(".")) {
      if (isObject(obj[key2])) {
        handleFlatJson(obj[key2]);
      }
    } else {
      const subKeys = key2.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }
        currentObj = currentObj[subKeys[i]];
      }
      currentObj[subKeys[lastIndex]] = obj[key2];
      delete obj[key2];
      if (isObject(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages: messages2, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale]: {} };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key2 in ret) {
      if (hasOwn(ret, key2)) {
        handleFlatJson(ret[key2]);
      }
    }
  }
  return ret;
}
const isNotObjectOrIsArray = (val) => !isObject(val) || isArray(val);
function deepCopy(src2, des) {
  if (isNotObjectOrIsArray(src2) || isNotObjectOrIsArray(des)) {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
  for (const key2 in src2) {
    if (hasOwn(src2, key2)) {
      if (isNotObjectOrIsArray(src2[key2]) || isNotObjectOrIsArray(des[key2])) {
        des[key2] = src2[key2];
      } else {
        deepCopy(src2[key2], des[key2]);
      }
    }
  }
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(global2, options, componentOptions) {
  let messages2 = isObject(options.messages) ? options.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages2 = getLocaleMessages(global2.locale.value, {
      messages: messages2,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages2);
  if (locales.length) {
    locales.forEach((locale) => {
      global2.mergeLocaleMessage(locale, messages2[locale]);
    });
  }
  {
    if (isObject(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          global2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          global2.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key2) {
  return createVNode(Text, null, key2, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key2, type4) => {
    return missing(locale, key2, getCurrentInstance() || void 0, type4);
  };
}
const getMetaInfo = () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root } = options;
  const _isGlobal = __root === void 0;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = ref(__root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE);
  const _fallbackLocale = ref(__root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  function getCoreContext() {
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    return createCoreContext(ctxOptions);
  }
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages2 = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  function wrapWithDeps(fn3, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) {
    trackReactivityValues();
    let ret;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      try {
        setAdditionalMeta(getMetaInfo());
        ret = fn3(_context);
      } finally {
        setAdditionalMeta(null);
      }
    } else {
      ret = fn3(_context);
    }
    if (isNumber(ret) && ret === NOT_REOSLVED) {
      const [key2, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key2);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  }
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key2) => key2, (val) => isString(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign({ resolvedMessage: true }, arg3 || {})]);
  }
  function d2(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number3, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
  }
  function normalize(values) {
    return values.map((val) => isString(val) ? createTextNode(val) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function transrateVNode(...args) {
    return wrapWithDeps((context) => {
      let ret;
      const _context2 = context;
      try {
        _context2.processor = processor;
        ret = Reflect.apply(translate, null, [_context2, ...args]);
      } finally {
        _context2.processor = null;
      }
      return ret;
    }, () => parseTranslateArgs(...args), "translate", (root2) => root2[TransrateVNodeSymbol](...args), (key2) => [createTextNode(key2)], (val) => isArray(val));
  }
  function numberParts(...args) {
    return wrapWithDeps((context) => Reflect.apply(number3, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => root2[NumberPartsSymbol](...args), () => [], (val) => isString(val) || isArray(val));
  }
  function datetimeParts(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => root2[DatetimePartsSymbol](...args), () => [], (val) => isString(val) || isArray(val));
  }
  function setPluralRules(rules2) {
    _pluralRules = rules2;
    _context.pluralRules = _pluralRules;
  }
  function te(key2, locale2) {
    const targetLocale = isString(locale2) ? locale2 : _locale.value;
    const message3 = getLocaleMessage(targetLocale);
    return _context.messageResolver(message3, key2) !== null;
  }
  function resolveMessages(key2) {
    let messages3 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key2);
      if (messageValue != null) {
        messages3 = messageValue;
        break;
      }
    }
    return messages3;
  }
  function tm(key2) {
    const messages3 = resolveMessages(key2);
    return messages3 != null ? messages3 : __root ? __root.tm(key2) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message3) {
    _messages.value[locale2] = message3;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message3) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    deepCopy(message3, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root) {
    watch$1(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch$1(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages: messages2,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d2;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOption] = options.__injectWithOption;
    composer[TransrateVNodeSymbol] = transrateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  let messages2 = options.messages;
  if (isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages2 = locales.reduce((messages3, locale2) => {
      const message3 = messages3[locale2] || (messages3[locale2] = {});
      assign(message3, sharedMessages[locale2]);
      return messages3;
    }, messages2 || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  return {
    locale,
    fallbackLocale,
    messages: messages2,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const vueI18n = {
      id: composer.id,
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      get messages() {
        return composer.messages.value;
      },
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      get numberFormats() {
        return composer.numberFormats.value;
      },
      get availableLocales() {
        return composer.availableLocales;
      },
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      get modifiers() {
        return composer.modifiers;
      },
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      __composer: composer,
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list2 = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key2 = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list2 = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list2 = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key2,
          list2 || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list2 = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key2 = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isNumber(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list2 = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list2 = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key2,
          list2 || named || {},
          options2
        ]);
      },
      te(key2, locale) {
        return composer.te(key2, locale);
      },
      tm(key2) {
        return composer.tm(key2);
      },
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      setLocaleMessage(locale, message3) {
        composer.setLocaleMessage(locale, message3);
      },
      mergeLocaleMessage(locale, message3) {
        composer.mergeLocaleMessage(locale, message3);
      },
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      getChoiceIndex(choice, choicesLength) {
        return -1;
      },
      __onComponentInstanceCreated(target2) {
        const { componentInstanceCreatedListener } = options;
        if (componentInstanceCreatedListener) {
          componentInstanceCreatedListener(target2, vueI18n);
        }
      }
    };
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys2) {
  if (keys2.length === 1 && keys2[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current2) => {
      return slot = [
        ...slot,
        ...isArray(current2.children) ? current2.children : [current2]
      ];
    }, []);
  } else {
    return keys2.reduce((arg, key2) => {
      const slot = slots[key2];
      if (slot) {
        arg[key2] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag3) {
  return Fragment;
}
const Translation = {
  name: "i18n-t",
  props: assign({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  setup(props2, context) {
    const { slots, attrs } = context;
    const i18n = props2.i18n || useI18n({
      useScope: props2.scope,
      __useComponent: true
    });
    const keys2 = Object.keys(slots).filter((key2) => key2 !== "_");
    return () => {
      const options = {};
      if (props2.locale) {
        options.locale = props2.locale;
      }
      if (props2.plural !== void 0) {
        options.plural = isString(props2.plural) ? +props2.plural : props2.plural;
      }
      const arg = getInterpolateArg(context, keys2);
      const children = i18n[TransrateVNodeSymbol](props2.keypath, arg, options);
      const assignedAttrs = assign({}, attrs);
      const tag3 = isString(props2.tag) || isObject(props2.tag) ? props2.tag : getFragmentableTag();
      return h$1(tag3, assignedAttrs, children);
    };
  }
};
function renderFormatter(props2, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = {};
    if (props2.locale) {
      options.locale = props2.locale;
    }
    if (isString(props2.format)) {
      options.key = props2.format;
    } else if (isObject(props2.format)) {
      if (isString(props2.format.key)) {
        options.key = props2.format.key;
      }
      overrides = Object.keys(props2.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign({}, options2, { [prop]: props2.format[prop] }) : options2;
      }, {});
    }
    const parts = partFormatter(...[props2.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index2) => {
        const slot = slots[part.type];
        return slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
      });
    } else if (isString(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign({}, attrs);
    const tag3 = isString(props2.tag) || isObject(props2.tag) ? props2.tag : getFragmentableTag();
    return h$1(tag3, assignedAttrs, children);
  };
}
const NUMBER_FORMAT_KEYS = [
  "localeMatcher",
  "style",
  "unit",
  "unitDisplay",
  "currency",
  "currencyDisplay",
  "useGrouping",
  "numberingSystem",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "notation",
  "formatMatcher"
];
const NumberFormat = {
  name: "i18n-n",
  props: assign({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  setup(props2, context) {
    const i18n = props2.i18n || useI18n({ useScope: "parent", __useComponent: true });
    return renderFormatter(props2, context, NUMBER_FORMAT_KEYS, (...args) => i18n[NumberPartsSymbol](...args));
  }
};
const DATETIME_FORMAT_KEYS = [
  "dateStyle",
  "timeStyle",
  "fractionalSecondDigits",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "localeMatcher",
  "timeZone",
  "hour12",
  "hourCycle",
  "formatMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName"
];
const DatetimeFormat = {
  name: "i18n-d",
  props: assign({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  setup(props2, context) {
    const i18n = props2.i18n || useI18n({ useScope: "parent", __useComponent: true });
    return renderFormatter(props2, context, DATETIME_FORMAT_KEYS, (...args) => i18n[DatetimePartsSymbol](...args));
  }
};
function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const bind3 = (el, { instance, value, modifiers }) => {
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n, instance.$);
    const parsedValue = parseValue(value);
    el.textContent = Reflect.apply(composer.t, composer, [
      ...makeParams(parsedValue)
    ]);
  };
  return {
    beforeMount: bind3,
    beforeUpdate: bind3
  };
}
function parseValue(value) {
  if (isString(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString(locale)) {
    options.locale = locale;
  }
  if (isNumber(choice)) {
    options.plural = choice;
  }
  if (isNumber(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app, i18n, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    app.component(!useI18nComponentName ? Translation.name : "i18n", Translation);
    app.component(NumberFormat.name, NumberFormat);
    app.component(DatetimeFormat.name, DatetimeFormat);
  }
  {
    app.directive("t", vTDirective(i18n));
  }
}
function defineMixin(vuei18n, composer, i18n) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToRoot(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          this.$i18n = createVueI18n(optionsI18n);
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToRoot(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __root: composer
          });
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      vuei18n.__onComponentInstanceCreated(this.$i18n);
      i18n.__setInstance(instance, this.$i18n);
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key2, locale) => this.$i18n.te(key2, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key2) => this.$i18n.tm(key2);
    },
    mounted() {
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      nextTick(() => {
        delete this.$t;
        delete this.$rt;
        delete this.$tc;
        delete this.$te;
        delete this.$d;
        delete this.$n;
        delete this.$tm;
        i18n.__deleteInstance(instance);
        delete this.$i18n;
      });
    }
  };
}
function mergeToRoot(root2, options) {
  root2.locale = options.locale || root2.locale;
  root2.fallbackLocale = options.fallbackLocale || root2.fallbackLocale;
  root2.missing = options.missing || root2.missing;
  root2.silentTranslationWarn = options.silentTranslationWarn || root2.silentFallbackWarn;
  root2.silentFallbackWarn = options.silentFallbackWarn || root2.silentFallbackWarn;
  root2.formatFallbackMessages = options.formatFallbackMessages || root2.formatFallbackMessages;
  root2.postTranslation = options.postTranslation || root2.postTranslation;
  root2.warnHtmlInMessage = options.warnHtmlInMessage || root2.warnHtmlInMessage;
  root2.escapeParameterHtml = options.escapeParameterHtml || root2.escapeParameterHtml;
  root2.sync = options.sync || root2.sync;
  root2.__composer[SetPluralRulesSymbol](options.pluralizationRules || root2.pluralizationRules);
  const messages2 = getLocaleMessages(root2.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages2).forEach((locale) => root2.mergeLocaleMessage(locale, messages2[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => root2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => root2.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return root2;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = !!options.globalInjection;
  const __instances = new Map();
  const __global = createGlobal(options, __legacyMode);
  const symbol = makeSymbol("");
  function __getInstance(component2) {
    return __instances.get(component2) || null;
  }
  function __setInstance(component2, instance) {
    __instances.set(component2, instance);
  }
  function __deleteInstance(component2) {
    __instances.delete(component2);
  }
  {
    const i18n = {
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      async install(app, ...options2) {
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n);
        if (!__legacyMode && __globalInjection) {
          injectGlobalFields(app, i18n.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n));
        }
      },
      get global() {
        return __global;
      },
      __instances,
      __getInstance,
      __setInstance,
      __deleteInstance
    };
    return i18n;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSLALLED);
  }
  const i18n = getI18nInstance(instance);
  const global2 = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (scope === "global") {
    adjustI18nResources(global2, options, componentOptions);
    return global2;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = global2;
    }
    return composer2;
  }
  if (i18n.mode === "legacy") {
    throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (global2) {
      composerOptions.__root = global2;
    }
    composer = createComposer(composerOptions);
    setupLifeCycle(i18nInternal, instance);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  {
    return __VUE_I18N_LEGACY_API__ && legacyMode ? createVueI18n(options) : createComposer(options);
  }
}
function getI18nInstance(instance) {
  {
    const i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSLALLED_WITH_PROVIDE);
    }
    return i18n;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n) {
  return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
}
function getComposer(i18n, target2, useComponent = false) {
  let composer = null;
  const root2 = target2.root;
  let current2 = target2.parent;
  while (current2 != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current2);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current2);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOption]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root2 === current2) {
      break;
    }
    current2 = current2.parent;
  }
  return composer;
}
function setupLifeCycle(i18n, target2, composer) {
  {
    onMounted(() => {
    }, target2);
    onUnmounted(() => {
      i18n.__deleteInstance(target2);
    }, target2);
  }
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm"];
function injectGlobalFields(app, composer) {
  const i18n = Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method4) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method4);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app.config.globalProperties, `$${method4}`, desc);
  });
}
registerMessageCompiler(compileToFunction);
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
{
  initFeatureFlags();
}
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target2 = getGlobalThis();
  target2.__INTLIFY__ = true;
  setDevToolsHook(target2.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
export { pushScopeId as A, popScopeId as B, createI18n as C, nextTick as D, createRouter as E, Fragment as F, createWebHistory as G, createStore as H, createSSRApp as I, index$1m as J, Suspense as S, useRoute as a, hkustZhcnLocale as b, computed as c, hkustZhtwLocale as d, axios as e, defineComponent as f, useStore as g, hkustEnLocale as h, onUpdated as i, resolveComponent as j, openBlock as k, createBlock as l, createVNode as m, createBaseVNode as n, onMounted as o, createElementBlock as p, renderList as q, ref as r, resolveDynamicComponent as s, toDisplayString$1 as t, useRouter as u, createTextVNode as v, withCtx as w, lib$2 as x, defineAsyncComponent as y, reactive as z };
